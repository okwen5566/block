webpackJsonp([0x85aeba75f784],{983:function(e,a){e.exports={data:{content:{content:'<p>首先我們要理解調用函數的方法，最起碼可以用下面兩個方法：</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript">func(arg1, arg2);\nfunc.call(context, arg1, arg2);\n</code></pre></code></pre>\n<p>之前我也沒怎麼見過後者，基本上都是直接call func的。後者<code>func(arg1, arg2)</code> 等於 <code>func.call(undefined, arg1, arg2)</code>。簡單來說，this就是context。如果context沒有定義的話，它會被定義為一個全局對象，比如說global。在MDN的文檔有這一句: <code>if the method is a function in non-strict mode code, null and undefined will be replaced with the global object and primitive values will be converted to objects</code>。</p>\n<p>如果不想要this是global的話，給予context一個對象就可以了：\n<code>func.call(obj, arg1, arg2)</code></p>\n<h2 id=全局上下文>全局上下文</h2>\n<p>在全局中，無論是否在嚴格模式下(Strict mode)，<code>this</code>都是代表全局對象。</p>\n<h3 id=瀏覽器>瀏覽器</h3>\n<ol>\n<li><code>this.document</code>指向<code>document</code></li>\n<li>全局對象為<code>window</code></li>\n</ol>\n<h3 id=Node.js>Node.js</h3>\n<p>全局對象為<code>global</code></p>\n<p>直接運用函數的話，this會指向global。</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>;\n}\n\ntest();\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x); <span class="hljs-comment">// 1</span>\n</code></pre></code></pre>\n<p>如果是生成一個對象的話，this會指向這個對象而不是global。</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">this</span>.color = <span class="hljs-string">\'red\'</span>;\n}\n\n<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Car();\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.color); <span class="hljs-comment">// undefined</span>\n<span class="hljs-built_in">console</span>.log(c.color); <span class="hljs-comment">// red</span>\n</code></pre></code></pre>\n<p>下次遇到問題的話，我還是MDN資料吧，裡面寫得很詳細。</p>\n<h2 id=問題>問題</h2>\n<p>在Node.js中，為什麼this.global === this.global.global的返回值為true？</p>\n<h2 id=延伸思考>延伸思考</h2>\n<ol>\n<li>Function.prototype.apply()和call()方法有什麼不同</li>\n<li>Function.prototype.bind()</li>\n</ol>\n<h2 id=參考資料>參考資料</h2>\n<ol>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this - MDN</a></li>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call - MDN</a></li>\n</ol>\n',title:"深入理解 Javascript 中的 this",createdDate:"2017-03-25T12:44+08:00",headerImgur:null,id:"wgY0NH3sqcyaCCQSSAKG2",toc:["全局上下文","瀏覽器","Node.js","問題","延伸思考","參考資料"],tags:"JavaScript"},latestPosts:{totalCount:60,edges:[{node:{title:"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）",url:"netease-kaola-live",createdDate:"2018-08-01T20:00+08:00"}},{node:{title:"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法",url:"regenerator-runtime-is-not-defined",createdDate:"2018-07-29T20:00+08:00"}},{node:{title:"關於作者",url:"about-calpa-liu",createdDate:"2018-05-01T20:00+08:00"}},{node:{title:"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」",url:"insert-zero-width-characters",createdDate:"2018-04-06T23:00+08:00"}},{node:{title:"知乎無限 live 數據流網站",url:"zhihu-unlimited-lives-website",createdDate:"2018-03-28T20:49+08:00"}},{node:{title:"Gatsbyjs async/await 更新報錯解決方法",url:"gatsybjs-async-await-upgrade-bug-solution",createdDate:"2018-03-21T20:00+08:00"}}]}},pathContext:{id:"wgY0NH3sqcyaCCQSSAKG2"}}}});
//# sourceMappingURL=path---2017-03-25-javascript-this-b780dfd0731af1ffc949.js.map