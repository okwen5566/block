{"version":3,"sources":["webpack:///path---2017-09-27-async-summary-7dbbf6dc65605e367e20.js","webpack:///./.cache/json/2017-09-27-async-summary.json"],"names":["webpackJsonp","1016","module","exports","data","content","title","createdDate","headerImgur","id","toc","tags","latestPosts","totalCount","edges","node","url","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,SAAWA,QAAA,0xQAA45OC,MAAA,UAAAC,YAAA,yBAAAC,YAAA,cAAAC,GAAA,yBAAAC,KAAA,uFAAAC,KAAA,yBAAm0CC,aAAgBC,WAAA,GAAAC,QAA0BC,MAAQT,MAAA,wCAAAU,IAAA,qBAAAT,YAAA,4BAAqHQ,MAAQT,MAAA,kEAAAU,IAAA,qCAAAT,YAAA,4BAA+JQ,MAAQT,MAAA,OAAAU,IAAA,kBAAAT,YAAA,4BAAiFQ,MAAQT,MAAA,yCAAAU,IAAA,+BAAAT,YAAA,4BAAgIQ,MAAQT,MAAA,kBAAAU,IAAA,gCAAAT,YAAA,4BAA0GQ,MAAQT,MAAA,gCAAAU,IAAA,4CAAAT,YAAA,8BAAqIU,aAAgBR,GAAA","file":"path---2017-09-27-async-summary-7dbbf6dc65605e367e20.js","sourcesContent":["webpackJsonp([215186751342441],{\n\n/***/ 1016:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"content\":{\"content\":\"<h2 id=前言>前言</h2>\\n<p>異步操作是非常常見的操作，也是其中一題常見的前端工程師面試題目。在日常開發中，我們會和伺服器交互，或者是和用戶的行動作出反應，比如說監聽某些點擊事件。這個時候，其實我們是執行了異步操作，我們需要等待對方若干時間才能收到返回值，甚至是一個錯誤的值。。。因此，異步操作很容易產生一些誤會。這裡，我會說一下異步操作，及其返回的處理方法。</p>\\n<h2 id=同步與異步的分別>同步與異步的分別</h2>\\n<p>在同步的世界裡面，我們希望執行某些操作之後，就能夠馬上拿到返回的值，然後執行下一步。然而，當我們發出 HTTP 請求的時候，我們可能需要等待世界的另外一端返回信息，這需要時間，便不是同步了。。。</p>\\n<p>如果沒有異步的話，當你發出 HTTP 請求的時候，瀏覽器需要等待伺服器返回才執行下一步。這就是代表瀏覽器會卡住。。。</p>\\n<p>異步處理，簡單來說就是我們發出了一個行動，但是不是馬上得到結果，我們會繼續執行後面的指令，等到函數裡面有一個返回，我們才拿那個返回值來使用。最簡單的說法，就是我們向服務器發出請求，但是服務器需要時間處理，並且返回處理過的內容。</p>\\n<h2 id=異步操作處理方法>異步操作處理方法</h2>\\n<ol>\\n<li>Callback</li>\\n<li>Promise （思想）</li>\\n<li>Generator</li>\\n<li>Async await （推薦）</li>\\n</ol>\\n<h3 id=Callback>Callback</h3>\\n<p>我們看一下維基百科上面對於 Callback 的說明：</p>\\n<blockquote>\\n<p>在電腦程式設計中，回呼函式，或簡稱回呼（Callback 即call then back 被主函數呼叫運算後會返回主函數），是指通過函數參數傳遞到其它代碼的，某一塊可執行代碼的參照。這一設計允許了底層代碼呼叫在高層定義的子程式。</p>\\n</blockquote>\\n<p>這樣好像說得蠻複雜的，但其實很簡單，你把一個函數 cb (Function) 作為參數 (Argument)傳進這個函數 B 裡面，然後在函數 B 使用函數 cb。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title\\\">func</span>(<span class=\\\"hljs-params\\\">x, cb</span>) </span>{\\n  cb(x)\\n}\\n</code></pre></code></pre>\\n<p>舉個例子，比如我們要在 Node.js 裡面讀取一個檔案，我們的代碼會是下面這樣的：</p>\\n<p>hello.txt:</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\">Hello World, I'm Calpa Liu.\\n</code></pre></code></pre>\\n<hr>\\n<p>index.js:</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fs = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">'fs'</span>);\\n\\nfs.readFile(<span class=\\\"hljs-string\\\">'hello.txt'</span>, <span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> (<span class=\\\"hljs-params\\\">err, data</span>) </span>{\\n     <span class=\\\"hljs-keyword\\\">if</span> (err) {\\n          <span class=\\\"hljs-keyword\\\">return</span> <span class=\\\"hljs-built_in\\\">console</span>.error(err);\\n     }\\n\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(data);\\n});\\n\\n<span class=\\\"hljs-built_in\\\">console</span>.log(<span class=\\\"hljs-string\\\">'Finished'</span>);\\n</code></pre></code></pre>\\n<p>我們會在 callback 裡面處理 callback，也就是一個回調裡面做另外一件事情，那可能是另外一個 callback，那麼你可以想象一下，我們越寫越深。。。這樣有兩個問題，第一：代碼的耦合性會很高，不容易去拆分代碼；第二：代碼的維護性很差。</p>\\n<p><a data-fancybox=\\\"gallery\\\" href=\\\"https://i.imgur.com/bjHDvVNh.jpg\\\"><img class=\\\"lozad d-block mx-auto\\\" data-src=https://i.imgur.com/bjHDvVNl.jpg title=\\\"Imgur\\\" /></a></p>\\n<h3 id=Promise>Promise</h3>\\n<p>Promise 是說如果你做了 A 的事情，成功了就做 B，不成功就做 C，你還可以繼續做 D 的事情，然後進行成功和不成功的處理。這樣說可能比較虛，但是你看一下 MDN 上面的圖就會明白了。</p>\\n<p><a data-fancybox=\\\"gallery\\\" href=\\\"https://i.imgur.com/w9BxjmL.png\\\"><img class=\\\"lozad d-block mx-auto\\\" data-src=https://i.imgur.com/w9BxjmL.png title=\\\"Promise - MDN\\\" /></a></p>\\n<p>一個發射子彈的動作可以這樣寫：</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fire = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-built_in\\\">Promise</span>(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">resolve, reject</span>) </span>{\\n     setTimeout(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n          resolve(<span class=\\\"hljs-string\\\">'已命中三千里外的目標'</span>);\\n     }, <span class=\\\"hljs-number\\\">3000</span>)\\n});\\n\\nfire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">result</span>) </span>{\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n});\\n</code></pre></code></pre>\\n<p>你可以在 Windows 平台按 F12 或 Ctrl + Shift + I，或在 Mac 上 按 Cmd + Opt + I，打開 Google Chrome Developer Tools ，然後在 Console 貼上上面的代碼，三秒後就會輸出<code>已命中三千里外的目標</code>。</p>\\n<p>你也可以在 then() 裡面寫 1個到 N個的 Promise。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fire = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-built_in\\\">Promise</span>(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">resolve, reject</span>) </span>{\\n     setTimeout(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n          resolve(<span class=\\\"hljs-string\\\">'已命中三千里外的目標'</span>);\\n     }, <span class=\\\"hljs-number\\\">3000</span>)\\n});\\n\\nfire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">result</span>) </span>{\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(<span class=\\\"hljs-string\\\">'正在返回司令部'</span>);\\n     <span class=\\\"hljs-keyword\\\">return</span> fire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> (<span class=\\\"hljs-params\\\">result</span>) </span>{\\n          <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n     });\\n});\\n</code></pre></code></pre>\\n<h3 id=Generator>Generator</h3>\\n<p>Generator 其實是一個狀態機，內部保存機器的運行狀態。我們透過獲取機器的完成狀態 (done)，我們能夠重複調用機器。我們可以使用 yield 暫停一個函數，並跳出函數。從外面的角度來看，我們可以從上而下去寫代碼，但是代碼會複雜，難以理解。</p>\\n<p>雖然它已經寫進 ECMAScript 2015 的正式規範裡面，但是我不太喜歡使用 Generator。我們簡單看一下 Generator 就好了，因為現在是 2017 年，異步操作的有更加好的處理方法。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>* <span class=\\\"hljs-title\\\">gen</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">1</span>;\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">2</span>;\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">3</span>;\\n}\\n\\n<span class=\\\"hljs-keyword\\\">var</span> g = gen(); <span class=\\\"hljs-comment\\\">// \\\"Generator { }\\\"</span>\\ng; <span class=\\\"hljs-comment\\\">//</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 1, done: false}</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 2, done: false}</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 3, done: false}</span>\\ng.next() <span class=\\\"hljs-comment\\\">// {value: undefined, done: true}</span>\\n</code></pre></code></pre>\\n<h3 id=Async/Await>Async/Await</h3>\\n<p>對於技術的要求，是無止境的。為了寫出更加優美的代碼，你又可以付出什麼的代價呢？</p>\\n<p>如果你沒有試過 Async/Await 的話，那麼你就應該試一下，因為實在是太優雅了。</p>\\n<p>這里我就放出一段現在博客在用的代碼：</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">async</span> <span class=\\\"hljs-keyword\\\">const</span> getPosts = <span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">()</span> =&gt;</span> {\\n  <span class=\\\"hljs-keyword\\\">await</span> res = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/posts'</span>);\\n  <span class=\\\"hljs-keyword\\\">return</span> res.data;\\n}\\n</code></pre></code></pre>\\n<p>我們簡單的讀一下這段代碼：</p>\\n<p>一個異步的不變量 <code>getPosts</code> 是一個箭頭函數，內部操作為等待 axios 的 GET 請求到地址：<a href=\\\"https://calpa.me\\\">http://calpa.me</a>，並返回伺服器返回的資料。</p>\\n<p>這是一個非常簡單的異步操作吧，但是如果是這樣的呢？</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">async</span> <span class=\\\"hljs-keyword\\\">const</span> getUserData = <span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">()</span> =&gt;</span> {\\n  <span class=\\\"hljs-keyword\\\">await</span> posts = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/posts'</span>);\\n  <span class=\\\"hljs-keyword\\\">await</span> accountInfo = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/about'</span>);\\n  <span class=\\\"hljs-comment\\\">/* ... */</span>\\n}\\n</code></pre></code></pre>\\n<p>如果你想要使用 Async / Await 的話，可以使用\\n<a href=\\\"https://www.infoq.com/news/2017/02/node-76-async-await\\\">Node.js 7.6</a> 或以上的版本。例如使用 nvm 安裝 v8: <code>nvm install v8</code>，然後 <code>nvm use v8</code>。</p>\\n<p>另外，如果你不想更新 Node 版本的話，你可以安裝 <a href=\\\"https://caolan.github.io/async/\\\">async 工具庫</a>。</p>\\n<h2 id=感想>感想</h2>\\n<p>異步操作已經成為了前端工程師面試常見的問題之一，感覺是對於前端工程師的技術水平需求越來越提高了。雖然這些都是在 MDN 上面寫好的介紹，但是只有自己用過才會知道什麼比較好。</p>\\n<p>如果公司的 Node 版本可以支持 Async/Await 的話，那就直接用 Async/Await 就好了。不行的話，那就用 Promise 吧，不然 Generator 的設計對於強迫症患者來說很不順眼。。。</p>\\n<h2 id=參考資料>參考資料</h2>\\n<ol>\\n<li><a href=\\\"https://en.wikipedia.org/wiki/Callback\\\">Callback (computer programming) - Wikipedia</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\\\">Promise - MDN</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\\\">Generator</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\\\">async function - JavaScript MDN</a></li>\\n</ol>\\n\",\"title\":\"異步操作見聞錄\",\"createdDate\":\"2017-09-27T20:00+08:00\",\"headerImgur\":\"KMksHxZ.png\",\"id\":\"4FGLjbP8pycoASYuOS4gEa\",\"toc\":[\"前言\",\"同步與異步的分別\",\"異步操作處理方法\",\"Callback\",\"Promise\",\"Generator\",\"Async/Await\",\"感想\",\"參考資料\"],\"tags\":\"Front End, JavaScript\"},\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]}},\"pathContext\":{\"id\":\"4FGLjbP8pycoASYuOS4gEa\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2017-09-27-async-summary-7dbbf6dc65605e367e20.js","module.exports = {\"data\":{\"content\":{\"content\":\"<h2 id=前言>前言</h2>\\n<p>異步操作是非常常見的操作，也是其中一題常見的前端工程師面試題目。在日常開發中，我們會和伺服器交互，或者是和用戶的行動作出反應，比如說監聽某些點擊事件。這個時候，其實我們是執行了異步操作，我們需要等待對方若干時間才能收到返回值，甚至是一個錯誤的值。。。因此，異步操作很容易產生一些誤會。這裡，我會說一下異步操作，及其返回的處理方法。</p>\\n<h2 id=同步與異步的分別>同步與異步的分別</h2>\\n<p>在同步的世界裡面，我們希望執行某些操作之後，就能夠馬上拿到返回的值，然後執行下一步。然而，當我們發出 HTTP 請求的時候，我們可能需要等待世界的另外一端返回信息，這需要時間，便不是同步了。。。</p>\\n<p>如果沒有異步的話，當你發出 HTTP 請求的時候，瀏覽器需要等待伺服器返回才執行下一步。這就是代表瀏覽器會卡住。。。</p>\\n<p>異步處理，簡單來說就是我們發出了一個行動，但是不是馬上得到結果，我們會繼續執行後面的指令，等到函數裡面有一個返回，我們才拿那個返回值來使用。最簡單的說法，就是我們向服務器發出請求，但是服務器需要時間處理，並且返回處理過的內容。</p>\\n<h2 id=異步操作處理方法>異步操作處理方法</h2>\\n<ol>\\n<li>Callback</li>\\n<li>Promise （思想）</li>\\n<li>Generator</li>\\n<li>Async await （推薦）</li>\\n</ol>\\n<h3 id=Callback>Callback</h3>\\n<p>我們看一下維基百科上面對於 Callback 的說明：</p>\\n<blockquote>\\n<p>在電腦程式設計中，回呼函式，或簡稱回呼（Callback 即call then back 被主函數呼叫運算後會返回主函數），是指通過函數參數傳遞到其它代碼的，某一塊可執行代碼的參照。這一設計允許了底層代碼呼叫在高層定義的子程式。</p>\\n</blockquote>\\n<p>這樣好像說得蠻複雜的，但其實很簡單，你把一個函數 cb (Function) 作為參數 (Argument)傳進這個函數 B 裡面，然後在函數 B 使用函數 cb。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title\\\">func</span>(<span class=\\\"hljs-params\\\">x, cb</span>) </span>{\\n  cb(x)\\n}\\n</code></pre></code></pre>\\n<p>舉個例子，比如我們要在 Node.js 裡面讀取一個檔案，我們的代碼會是下面這樣的：</p>\\n<p>hello.txt:</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\">Hello World, I'm Calpa Liu.\\n</code></pre></code></pre>\\n<hr>\\n<p>index.js:</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fs = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">'fs'</span>);\\n\\nfs.readFile(<span class=\\\"hljs-string\\\">'hello.txt'</span>, <span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> (<span class=\\\"hljs-params\\\">err, data</span>) </span>{\\n     <span class=\\\"hljs-keyword\\\">if</span> (err) {\\n          <span class=\\\"hljs-keyword\\\">return</span> <span class=\\\"hljs-built_in\\\">console</span>.error(err);\\n     }\\n\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(data);\\n});\\n\\n<span class=\\\"hljs-built_in\\\">console</span>.log(<span class=\\\"hljs-string\\\">'Finished'</span>);\\n</code></pre></code></pre>\\n<p>我們會在 callback 裡面處理 callback，也就是一個回調裡面做另外一件事情，那可能是另外一個 callback，那麼你可以想象一下，我們越寫越深。。。這樣有兩個問題，第一：代碼的耦合性會很高，不容易去拆分代碼；第二：代碼的維護性很差。</p>\\n<p><a data-fancybox=\\\"gallery\\\" href=\\\"https://i.imgur.com/bjHDvVNh.jpg\\\"><img class=\\\"lozad d-block mx-auto\\\" data-src=https://i.imgur.com/bjHDvVNl.jpg title=\\\"Imgur\\\" /></a></p>\\n<h3 id=Promise>Promise</h3>\\n<p>Promise 是說如果你做了 A 的事情，成功了就做 B，不成功就做 C，你還可以繼續做 D 的事情，然後進行成功和不成功的處理。這樣說可能比較虛，但是你看一下 MDN 上面的圖就會明白了。</p>\\n<p><a data-fancybox=\\\"gallery\\\" href=\\\"https://i.imgur.com/w9BxjmL.png\\\"><img class=\\\"lozad d-block mx-auto\\\" data-src=https://i.imgur.com/w9BxjmL.png title=\\\"Promise - MDN\\\" /></a></p>\\n<p>一個發射子彈的動作可以這樣寫：</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fire = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-built_in\\\">Promise</span>(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">resolve, reject</span>) </span>{\\n     setTimeout(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n          resolve(<span class=\\\"hljs-string\\\">'已命中三千里外的目標'</span>);\\n     }, <span class=\\\"hljs-number\\\">3000</span>)\\n});\\n\\nfire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">result</span>) </span>{\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n});\\n</code></pre></code></pre>\\n<p>你可以在 Windows 平台按 F12 或 Ctrl + Shift + I，或在 Mac 上 按 Cmd + Opt + I，打開 Google Chrome Developer Tools ，然後在 Console 貼上上面的代碼，三秒後就會輸出<code>已命中三千里外的目標</code>。</p>\\n<p>你也可以在 then() 裡面寫 1個到 N個的 Promise。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">var</span> fire = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-built_in\\\">Promise</span>(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">resolve, reject</span>) </span>{\\n     setTimeout(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n          resolve(<span class=\\\"hljs-string\\\">'已命中三千里外的目標'</span>);\\n     }, <span class=\\\"hljs-number\\\">3000</span>)\\n});\\n\\nfire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">result</span>) </span>{\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n     <span class=\\\"hljs-built_in\\\">console</span>.log(<span class=\\\"hljs-string\\\">'正在返回司令部'</span>);\\n     <span class=\\\"hljs-keyword\\\">return</span> fire.then(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span> (<span class=\\\"hljs-params\\\">result</span>) </span>{\\n          <span class=\\\"hljs-built_in\\\">console</span>.log(result);\\n     });\\n});\\n</code></pre></code></pre>\\n<h3 id=Generator>Generator</h3>\\n<p>Generator 其實是一個狀態機，內部保存機器的運行狀態。我們透過獲取機器的完成狀態 (done)，我們能夠重複調用機器。我們可以使用 yield 暫停一個函數，並跳出函數。從外面的角度來看，我們可以從上而下去寫代碼，但是代碼會複雜，難以理解。</p>\\n<p>雖然它已經寫進 ECMAScript 2015 的正式規範裡面，但是我不太喜歡使用 Generator。我們簡單看一下 Generator 就好了，因為現在是 2017 年，異步操作的有更加好的處理方法。</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">function</span>* <span class=\\\"hljs-title\\\">gen</span>(<span class=\\\"hljs-params\\\"></span>) </span>{\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">1</span>;\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">2</span>;\\n  <span class=\\\"hljs-keyword\\\">yield</span> <span class=\\\"hljs-number\\\">3</span>;\\n}\\n\\n<span class=\\\"hljs-keyword\\\">var</span> g = gen(); <span class=\\\"hljs-comment\\\">// \\\"Generator { }\\\"</span>\\ng; <span class=\\\"hljs-comment\\\">//</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 1, done: false}</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 2, done: false}</span>\\ng.next(); <span class=\\\"hljs-comment\\\">// {value: 3, done: false}</span>\\ng.next() <span class=\\\"hljs-comment\\\">// {value: undefined, done: true}</span>\\n</code></pre></code></pre>\\n<h3 id=Async/Await>Async/Await</h3>\\n<p>對於技術的要求，是無止境的。為了寫出更加優美的代碼，你又可以付出什麼的代價呢？</p>\\n<p>如果你沒有試過 Async/Await 的話，那麼你就應該試一下，因為實在是太優雅了。</p>\\n<p>這里我就放出一段現在博客在用的代碼：</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">async</span> <span class=\\\"hljs-keyword\\\">const</span> getPosts = <span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">()</span> =&gt;</span> {\\n  <span class=\\\"hljs-keyword\\\">await</span> res = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/posts'</span>);\\n  <span class=\\\"hljs-keyword\\\">return</span> res.data;\\n}\\n</code></pre></code></pre>\\n<p>我們簡單的讀一下這段代碼：</p>\\n<p>一個異步的不變量 <code>getPosts</code> 是一個箭頭函數，內部操作為等待 axios 的 GET 請求到地址：<a href=\\\"https://calpa.me\\\">http://calpa.me</a>，並返回伺服器返回的資料。</p>\\n<p>這是一個非常簡單的異步操作吧，但是如果是這樣的呢？</p>\\n<pre><code><pre><code class=\\\"hljs javascript\\\"><span class=\\\"hljs-keyword\\\">async</span> <span class=\\\"hljs-keyword\\\">const</span> getUserData = <span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">()</span> =&gt;</span> {\\n  <span class=\\\"hljs-keyword\\\">await</span> posts = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/posts'</span>);\\n  <span class=\\\"hljs-keyword\\\">await</span> accountInfo = axios.get(<span class=\\\"hljs-string\\\">'https://calpa.me/about'</span>);\\n  <span class=\\\"hljs-comment\\\">/* ... */</span>\\n}\\n</code></pre></code></pre>\\n<p>如果你想要使用 Async / Await 的話，可以使用\\n<a href=\\\"https://www.infoq.com/news/2017/02/node-76-async-await\\\">Node.js 7.6</a> 或以上的版本。例如使用 nvm 安裝 v8: <code>nvm install v8</code>，然後 <code>nvm use v8</code>。</p>\\n<p>另外，如果你不想更新 Node 版本的話，你可以安裝 <a href=\\\"https://caolan.github.io/async/\\\">async 工具庫</a>。</p>\\n<h2 id=感想>感想</h2>\\n<p>異步操作已經成為了前端工程師面試常見的問題之一，感覺是對於前端工程師的技術水平需求越來越提高了。雖然這些都是在 MDN 上面寫好的介紹，但是只有自己用過才會知道什麼比較好。</p>\\n<p>如果公司的 Node 版本可以支持 Async/Await 的話，那就直接用 Async/Await 就好了。不行的話，那就用 Promise 吧，不然 Generator 的設計對於強迫症患者來說很不順眼。。。</p>\\n<h2 id=參考資料>參考資料</h2>\\n<ol>\\n<li><a href=\\\"https://en.wikipedia.org/wiki/Callback\\\">Callback (computer programming) - Wikipedia</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\\\">Promise - MDN</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\\\">Generator</a></li>\\n<li><a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\\\">async function - JavaScript MDN</a></li>\\n</ol>\\n\",\"title\":\"異步操作見聞錄\",\"createdDate\":\"2017-09-27T20:00+08:00\",\"headerImgur\":\"KMksHxZ.png\",\"id\":\"4FGLjbP8pycoASYuOS4gEa\",\"toc\":[\"前言\",\"同步與異步的分別\",\"異步操作處理方法\",\"Callback\",\"Promise\",\"Generator\",\"Async/Await\",\"感想\",\"參考資料\"],\"tags\":\"Front End, JavaScript\"},\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]}},\"pathContext\":{\"id\":\"4FGLjbP8pycoASYuOS4gEa\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2017-09-27-async-summary.json\n// module id = 1016\n// module chunks = 215186751342441"],"sourceRoot":""}