webpackJsonp([0x7a463142a0ef],{1002:function(t,e){t.exports={data:{content:{content:'<p>每一種編程語言都有數據結構，但他們各有不同之處。JavaScript 是一種動態語言，變數的類型不用提前聲明，你可以使用同一個變數來保存不同的數據類型。</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">\'apple\'</span>; <span class="hljs-comment">// String type</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>; <span class="hljs-comment">// Number type</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Boolean type</span>\n</code></pre></code></pre>\n<p>這就和Python的寫法差不多:</p>\n<pre><code class="language-python"><pre><code class="hljs python">a = \'apple\' // String type\na = 42 // Number type\na = True // Boolean type\n</code></pre></code></pre>\n<h2 id=數據類型>數據類型</h2>\n<p><a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ECMAScript 標準</a>明確定義了7種數據類型：6種原始類型 (Primitive value) 和Object。</p>\n<p>{% img /img/javascript-data-structures.svg 300 auto JavaScript Data Structure %}</p>\n<p>原始數據類型：</p>\n<ol>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Symbol (ECMAScript 2015)</li>\n</ol>\n<h2 id=判斷方法>判斷方法</h2>\n<p>我們可以透過使用<code>typeof</code>和<code>Object.prototype.toString()</code>來判斷數據類型。</p>\n<h3 id=typeof>typeof</h3>\n<p>在 JavaScript 誕生之時，數值是由一個標籤以及實際數據值表示的。基本類型的標籤是 1，而對象類型的標籤是 0。</p>\n<p>由於null代表的是空指針(全部都是 0)，null的類型標籤會是0。如果你在 console 直接輸入<code>typeof null</code>的話，就會得到 &quot;object&quot; 的結果，雖然這不是我們想要的值。。。</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// "undefined"</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Boolean</span>;   <span class="hljs-comment">// "function"</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>;      <span class="hljs-comment">// "boolean"</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>;        <span class="hljs-comment">// "number"</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-string">"42"</span>;      <span class="hljs-comment">// "string"</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>();  <span class="hljs-comment">// "symbol"</span>\n</code></pre></code></pre>\n<p>我們可以看一下ECMAScript是怎樣定義typeof的：</p>\n<ol>\n<li>Let val be the result of evaluating UnaryExpression.</li>\n<li>If Type(val) is Reference, then\na. If IsUnresolvableReference(val) is true, return &quot;undefined&quot;.</li>\n<li>Set val to ? GetValue(val).</li>\n<li>Return a String according to Table 35.</li>\n</ol>\n<p>Table 35: typeof Operator Results</p>\n<table>\n<thead>\n<tr><th style="text-align:left">val 的類型</th><th style="text-align:left">結果</th></tr>\n</thead>\n<tbody>\n<tr><td style="text-align:left">Item One</td><td style="text-align:left">Item Two</td></tr>\n<tr><td style="text-align:left">Type of val</td><td style="text-align:left">Result</td></tr>\n<tr><td style="text-align:left">Undefined</td><td style="text-align:left">&quot;undefined&quot;</td></tr>\n<tr><td style="text-align:left">Null</td><td style="text-align:left">&quot;object&quot;</td></tr>\n<tr><td style="text-align:left">Boolean</td><td style="text-align:left">&quot;boolean&quot;</td></tr>\n<tr><td style="text-align:left">Number</td><td style="text-align:left">&quot;number&quot;</td></tr>\n<tr><td style="text-align:left">String</td><td style="text-align:left">&quot;string&quot;</td></tr>\n<tr><td style="text-align:left">Symbol</td><td style="text-align:left">&quot;symbol&quot;</td></tr>\n<tr><td style="text-align:left">Object (ordinary and does not implement [[Call]])</td><td style="text-align:left">&quot;object&quot;</td></tr>\n<tr><td style="text-align:left">Object (standard exotic and does not implement [[Call]])</td><td style="text-align:left">&quot;object&quot;</td></tr>\n<tr><td style="text-align:left">Object (implements [[Call]])</td><td style="text-align:left">&quot;function&quot;</td></tr>\n<tr><td style="text-align:left">Object (non-standard exotic and does not implement [[Call]])</td><td style="text-align:left">Implementation-defined. Must not be &quot;undefined&quot;, &quot;boolean&quot;,  &quot;function&quot;, &quot;number&quot;, &quot;symbol&quot;, or &quot;string&quot;.</td></tr>\n</tbody>\n</table>\n<p>另外，如果直接用<code>typeof</code>來判斷 NaN 的話，它會返回<code>&quot;number&quot;</code>，對於 NaN 我們可以用<code>isNaN</code>方法來判斷是否一個數字。</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// "number"</span>\n<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// true</span>\n</code></pre></code></pre>\n<h3 id=Object.prototype.toString()>Object.prototype.toString()</h3>\n<p>我們可以利用<code>Object.prototype.toString.call()</code>或者<code>Object.prototype.toString.apply()</code>這兩個方法判斷 Object 的類型，以及 null：</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>);   <span class="hljs-comment">// "[object Undefined]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>);    <span class="hljs-comment">// "[object Date]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>);  <span class="hljs-comment">// "[object String]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Math</span>);        <span class="hljs-comment">// "[object Math]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>);        <span class="hljs-comment">// "[object Null]"</span>\n</code></pre></code></pre>\n<p>ECMAScript 19.1.3.6 明確定義 Object.prototype.toString()：</p>\n<ol>\n<li>If the <code>this</code> value is <code>undefined</code>, return <code>&quot;[object Undefined]&quot;</code>.</li>\n<li>If the <code>this</code> value is <code>null</code>, return <code>&quot;[object Null]&quot;</code>.</li>\n<li>Let <code>O</code> be ! <a href="https://tc39.github.io/ecma262/#sec-toobject">ToObject</a>(<code>this</code> value).</li>\n<li>Let <code>isArray</code> be ? <a href="https://tc39.github.io/ecma262/#sec-isarray">IsArray</a>(<code>O</code>).</li>\n<li>If <code>isArray</code> is <code>true</code>, let <code>builtinTag</code> be <code>&quot;Array&quot;</code>.</li>\n<li>Else if <code>O</code> is a String exotic object, let <code>builtinTag</code> be <code>&quot;String&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[ParameterMap]] internal slot, let <code>builtinTag</code> be <code>&quot;Arguments&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[Call]] internal method, let <code>builtinTag</code> be <code>&quot;Function&quot;</code>.</li>\n<li>Else if <code>O</code> has an [[ErrorData]] internal slot, let <code>builtinTag</code> be <code>&quot;Error&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[BooleanData]] internal slot, let <code>builtinTag</code> be <code>&quot;Boolean&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[NumberData]] internal slot, let <code>builtinTag</code> be <code>&quot;Number&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[DateValue]] internal slot, let <code>builtinTag</code> be <code>&quot;Date&quot;</code>.</li>\n<li>Else if <code>O</code> has a [[RegExpMatcher]] internal slot, let <code>builtinTag</code> be <code>&quot;RegExp&quot;</code>.</li>\n<li>Else, let <code>builtinTag</code> be <code>&quot;Object&quot;</code>.</li>\n<li>Let <code>tag</code> be ? <a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a>(<code>O</code>, @@toStringTag).</li>\n<li>If <a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a>(<code>tag</code>) is not String, let <code>tag</code> be <code>builtinTag</code>.</li>\n<li>Return the String that is the result of concatenating <code>&quot;[object &quot;</code>, <code>tag</code>, and <code>&quot;]&quot;</code>.</li>\n</ol>\n<h2 id=參考資料>參考資料</h2>\n<ol>\n<li><a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ECMAScript® 2018 Language Specification</a></li>\n</ol>\n',title:"深入 ECMAScript 的數據類型",createdDate:"2017-05-18T14:00+08:00",headerImgur:null,id:"1LrOZ7yQ44oYYKcimMKw4A",toc:["數據類型","判斷方法","typeof","Object.prototype.toString()","參考資料"],tags:"JavaScript"},latestPosts:{totalCount:60,edges:[{node:{title:"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）",url:"netease-kaola-live",createdDate:"2018-08-01T20:00+08:00"}},{node:{title:"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法",url:"regenerator-runtime-is-not-defined",createdDate:"2018-07-29T20:00+08:00"}},{node:{title:"關於作者",url:"about-calpa-liu",createdDate:"2018-05-01T20:00+08:00"}},{node:{title:"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」",url:"insert-zero-width-characters",createdDate:"2018-04-06T23:00+08:00"}},{node:{title:"知乎無限 live 數據流網站",url:"zhihu-unlimited-lives-website",createdDate:"2018-03-28T20:49+08:00"}},{node:{title:"Gatsbyjs async/await 更新報錯解決方法",url:"gatsybjs-async-await-upgrade-bug-solution",createdDate:"2018-03-21T20:00+08:00"}}]}},pathContext:{id:"1LrOZ7yQ44oYYKcimMKw4A"}}}});
//# sourceMappingURL=path---2017-05-18-javascript-data-structures-in-deep-4b1dafd69356b855ad3a.js.map