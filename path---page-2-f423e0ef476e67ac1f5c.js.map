{"version":3,"sources":["webpack:///path---page-2-f423e0ef476e67ac1f5c.js","webpack:///./.cache/json/page-2.json"],"names":["webpackJsonp","1047","module","exports","data","latestPosts","totalCount","edges","node","title","url","createdDate","pagePosts","headerImgur","content","tags","pathContext","limit","skip"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,WAAA,GAAAC,QAA0BC,MAAQC,MAAA,wCAAAC,IAAA,qBAAAC,YAAA,4BAAqHH,MAAQC,MAAA,kEAAAC,IAAA,qCAAAC,YAAA,4BAA+JH,MAAQC,MAAA,OAAAC,IAAA,kBAAAC,YAAA,4BAAiFH,MAAQC,MAAA,yCAAAC,IAAA,+BAAAC,YAAA,4BAAgIH,MAAQC,MAAA,kBAAAC,IAAA,gCAAAC,YAAA,4BAA0GH,MAAQC,MAAA,gCAAAC,IAAA,4CAAAC,YAAA,6BAAoIC,WAAcL,QAAUC,MAAQC,MAAA,oBAAAE,YAAA,yBAAAD,IAAA,oBAAAG,YAAA,cAAAC,QAAA,0sCAAAC,KAAA,uBAA22CP,MAAQC,MAAA,sBAAAE,YAAA,yBAAAD,IAAA,oCAAAG,YAAA,cAAAC,QAAA,24HAAAC,KAAA,sBAA6jIP,MAAQC,MAAA,iCAAAE,YAAA,yBAAAD,IAAA,8BAAAG,YAAA,cAAAC,QAAA,6vHAAAC,KAAA,4CAA08HP,MAAQC,MAAA,UAAAE,YAAA,yBAAAD,IAAA,gBAAAG,YAAA,cAAAC,QAAA,kqIAA84GC,KAAA,2BAA26BP,MAAQC,MAAA,6CAAAE,YAAA,yBAAAD,IAAA,8CAAAG,YAAA,cAAAC,QAAA,2jGAA0zDC,KAAA,yBAAu9CP,MAAQC,MAAA,2BAAAE,YAAA,yBAAAD,IAAA,sCAAAG,YAAA,cAAAC,QAAA,4zCAAAC,KAAA,iBAA++CC,aAAgBC,MAAA,EAAAC,KAAA","file":"path---page-2-f423e0ef476e67ac1f5c.js","sourcesContent":["webpackJsonp([135728916539164],{\n\n/***/ 1047:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"參加八次黑客馬拉松的個人體會與總結\",\"createdDate\":\"2017-11-06T19:32+08:00\",\"url\":\"hackathon-summary\",\"headerImgur\":\"qNs8pq4.jpg\",\"content\":\"## 前言\\n\\n與其說黑客馬拉松是一場比賽，不如說它是一場程序員的盛會。作為一個前端開發者，也是蠻喜歡參加這樣的比賽。畢竟可以把自己的想法，在 24 小時之內把自己的想法，或是按著比賽主題做個原型出來。無論你是什麼技術背景的人，都歡迎你來參與這些盛會。\\n\\n## 為什麼我會開始參加黑客馬拉松？\\n\\n一開始，我沒有想那麼多。無論是取得勝利，或者是獲取經驗，都能夠幫助我成長。如果是取得名次的話，那就可以跟人家分享一下喜悅。如果是取得經驗的話，那也能從一個短時間試驗自己對於不同技術的掌握程度。無論如何，有好吃的東西是少不了www\\n\\n另外一個我喜歡黑客松的的地方，就是比賽的獎品也是非常豐富的。ImagineHack 為我帶來的除了第三名的名次之外，還有 FitBit 這一個智能手環。而深圳 TechCrunch 2017 黑客松，則是為我帶來現在我寫代碼，或者是寫文章必備的 HHKB，詳見[《神兵利器 -- HHKB Pro 2 開箱文》][1]一文。現在無論是寫代碼還是寫文章，我都不需要看著鍵盤，就可以自由地輸入。\\n\\n## 比賽內容\\n\\n![hackUST 2017][2]\\n\\n比賽通常都是持續 24 小時，甚至更加長的時間的。比如說第一天的早上開始，到第二天的下午結束。如果那次比賽舉辦單位有名氣的話，或者是比較願意投放資源到福利上面，那麼我們吃的食物也是比較豪華的。當中不乏自助餐，要兩個人伸手才能圍著的超級大 Pizza，還有很多零食，飲料。\\n\\n## 報名方法\\n\\n這些比賽大部分都是免費的，有一些舉辦單位可能會收取幾十塊錢，但你依然可以從不同途徑獲取免費門票。所以如果你沒有參加過的話，你也可以選擇參加一些免費的黑客馬拉松，體驗一下。\\n\\n要找到這些黑客馬拉松，一點也不難。你只需要留意不同社群的信息，就會發現幾乎每個月都有黑客松。這些舉辦單位大多鼓勵不同的參賽者參加，也就是不同的人也能夠參加比賽。比如說程序員，設計師，還有一些商業背景的人也會參加。無論你是否一個程序員，你都可以發揮你的想象力，可能你就是下一個贏家。\\n\\n## 感想\\n\\n這麼有趣的活動，能夠和不同人交流一下，也能驗證自己的技術水平。一舉兩得的事情，何樂而不為呢？ **Just do IT**。有興趣的話，可以看一下我寫的兩篇後記：[hackUST 2017 後記][3]，[SuperCharger Hackathon 後記][4]。希望在下一次比賽可以有合作的機會。\\n\\n\\n[1]: /2017/07/02/introduction-to-hhkb-pro-2/\\n[2]: https://i.imgur.com/IJPUhSJ.jpg\\n[3]: 2017/04/23/hackUST-2017-hackathon-summary/\\n[4]: /2017/02/19/supercharger-hackathon\",\"tags\":\"前端, 閱讀, Hackathon\"}},{\"node\":{\"title\":\"前端程序員的必備工具清單（MacOS）\",\"createdDate\":\"2017-10-02T21:53+08:00\",\"url\":\"frontend-developer-tools-in-macos\",\"headerImgur\":\"Vb56RuU.jpg\",\"content\":\"## 前言\\n\\n工欲善其事，必先利其器。一套完善的工具可以幫助我們事半功倍。而作為前端程序員的我，也是花了點時間為自己配置了一套工具。如果你也是使用 MacOS 作為你的開發系統的話，那麼你可以看一下這篇文章。\\n\\n\\n## 日常\\n\\n### [Alfred 3](https://www.alfredapp.com/)\\n\\n![Alfred Search](https://i.imgur.com/5yaDRiv.jpg)\\n\\nAlfred 是一個強大的效率工具，而且它更加是一個全面的自動化工具平台。你可以從下圖感受一下：\\n\\n![Alfred 的功能](https://i.imgur.com/RK1OiPq.png)\\n\\n你只要在 Alfred 的輸入框，寫下你想要的東西前幾個字，它便會顯示你所希望的命令。不過最強大的是可以和 MacOS 內置的全文搜尋一起用，也就是你輸入`in` 命令，它就可以全局全文搜尋。\\n\\n![全局搜尋](https://i.imgur.com/925QlWY.png)\\n\\n另外，它也可以記錄你所 Copy 過的歷史，如果你使用 Emacs 的 Kill Ring 的話，他就會自動記錄代碼。我工作的時候就經常應用到 Alfred，因為有很多代碼都需要刪除，然後幾個小時後就有人跟你說那個代碼需要還原。。。\\n\\n![Clipboard 歷史記錄](https://i.imgur.com/SsJkjae.png)\\n\\n另外，它的 Powerpack 和 Workflows 提供 Alfred 一個升級的可能性（腦洞），讓你可以寫出自己的代碼，並快捷執行。\\n\\n### Aria2GUI\\n\\n下載神器，網上有很多不同的前端界面，例如 [Yet Another Aria2 Web FrontEnd](https://github.com/yangshun1029/aria2gui)\\n\\n![Yet Another Aria2 Web FrontEnd](https://i.imgur.com/YT38J2q.png)\\n\\n### [ImageOptim](https://imageoptim.com/mac)\\n\\n![ImageOptim 界面](https://i.imgur.com/tEgTJmb.png)\\n\\n沒有經過優化或壓縮的圖片，直接上傳到伺服器或讓其他用戶下載的話，需要的時間都會很長，所以我的圖片大多都會經過 ImageOptim 優化一下。ImageOptim 是一個開源，免費的無損圖片優化工具。\\n\\n### [Moom](https://manytricks.com/moom/)\\n\\nMac 本身沒有提供類似 Windows 上面移動，放大視窗的功能，因此會經常看到有些人的電腦很多個視窗重疊了。。。\\n\\n![Align Left](https://i.imgur.com/dGOOGRz.jpg)\\n\\n### [TotalSpaces2](https://totalspaces.binaryage.com/)\\n\\n![TotalSpaces2](https://i.imgur.com/cAizggh.png)\\n\\n一個超好用的 Mac 桌面空間管理工具，包含以下六大功能：\\n1. 可以上下左右放置桌面佈局，而不是只有默認的向左向右\\n\\t![上下左右的桌面佈局](https://i.imgur.com/j0xBUi1.png)\\n\\n1. 觸控板可以跳轉上下左右的桌面格子\\n\\t![觸控跳轉格子](https://i.imgur.com/f3uGPqJ.png)\\n\\n1. 桌面格子可以設置默認的應用\\n\\t![設置默認應用](https://i.imgur.com/2KEOJhI.png)\\n\\n1. 全面的桌面概覽\\n\\t![全面的桌面概覽](https://i.imgur.com/8pZTHJc.png)\\n1. 更加炫酷的桌面跳轉效果\\n\\t![跳轉效果](https://i.imgur.com/69cceh0.png)\\n1. 屏幕的四個角落可以觸發各自的動作\\n\\t![屏幕角落觸發動作](https://i.imgur.com/HtnXX4a.png)\\n\\n應用場景：\\n\\n當只有一個屏幕，又要同時運行多個佔用全屏的應用，你可能需要切來切去。透過使用 TotalSpaces2，你就可以輕鬆切換屏幕，比如說下面看伺服器狀態，上面看代碼區域。\\n\\n另外，你也可以設置 Terminal 應用在下方屏幕格子，編輯器在上方屏幕格子。\\n\\n### [Eagle](https://eagle.cool/macOS)\\n\\n![Eagle](https://i.imgur.com/6JGSOld.png)\\n\\nEagle 是一個專門為設計師而打造的圖片收藏及管理工具。雖然我不是設計師，但是我有收藏大量的圖片，尤其是二次元動畫的截圖。對於這麼多的圖片，我曾經都很苦惱，因為截圖之後無法再次調用。。。幸好有這個工具，我就可以輕鬆地收藏網頁圖片，或者截屏到 [Eagle](https://eagle.cool/macOS)。之後可以打上標籤，或者人物的台詞。\\n\\n![感覺圖片太多，需要找個工具管理圖片www](https://i.imgur.com/VnB1ItB.png)\\n\\n## Coding\\n### [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\\n\\n![oh-my-zsh](https://i.imgur.com/otYtqAu.png)\\n\\n為什麼你的 Terminal 使用上來那麼不一樣？是的，**oh-my-zsh** 背後的社區驅動著我（逃。。。\\n\\n有時間可以說說到底為什麼 **oh-my-zsh** 那麼強大，以及它的配件。\\n\\n### [Solarized 配色方案](http://ethanschoonover.com/solarized)\\n\\n![兩種配色方案](https://i.imgur.com/mf5wi85.png)\\n\\n![清晰易見](https://i.imgur.com/Vtm0vIa.png)\\n\\n![包含的顏色](https://i.imgur.com/7O38J5g.png)\\n\\n### [SourceTree](https://www.sourcetreeapp.com/)\\n\\n![SourceTree 界面](https://i.imgur.com/7vtlS8m.png)\\n\\n以前沒有習慣命令行的時候，我是用 SourceTree 來看 Git 歷史的。雖然我現在喜歡使用命令行來操作 Git，但是比較複雜的 Git 操作還是需要專門的工具的，例如 SourceTree 就是一個不錯的選擇。\\n\\n## 高能區域（編輯器）\\n\\n無論是什麼神的編輯器，還是編輯器的神，取其精華去其糟粕才是最好的。\\n\\n### [Atom](https://atom.io/)\\n\\n![Atom](https://i.imgur.com/B47vleN.png)\\n\\nAtom 是一個基於 Electron 的現代開源文本編輯器，你可以直接黑掉它的核心，甚至改得完全不一樣。你可以使用 HTML，CSS/Less 及 JavaScript 修改 Atom的功能，它的功能包括但不限於：\\n\\n1. 支持跨平台\\n  1. 內置的 Package 管理系統\\n\\n\\t你可以在 Atom 直接搜尋 Package，並且安裝 Package。\\n\\n  1. 自動補全\\n  1. 瀏覽檔案系統\\n  1. 全局搜尋\\n\\n![編輯器 with Git Diff](https://i.imgur.com/IDDanXB.png)\\n\\n![Atom 設置面板](https://i.imgur.com/03wyXY4.png)\\n\\n![內置的 Package 管理系統](https://i.imgur.com/RTMhhex.png)\\n\\n### Emacs\\n\\n> Emacs = Escape + Meta + Alt + Control + Shift\\n\\n![Emacs Hello World](https://i.imgur.com/HmiuWMz.png)\\n\\n其實我是蠻喜歡 Emacs 的思想，以及它的按鍵。因為寫代碼就好像輸入打遊戲需要的特殊命令，一種寫代碼就是玩遊戲的概念。我養成盲打的習慣，好像也是因為 Emacs 而開始的。。。\\n\\n### Vim\\n\\n如果我要簡單的 Git Commit，我就可以直接寫 Git Commit 記錄，然後輸入`:wq`，並不需要那麼複雜的工具。\\n\\n## 瀏覽器\\n\\n1. [Google Chrome](https://www.google.com/chrome/index.html)\\n\\n這個是個必需品吧。。。\\n\\n1. [Postman](https://www.getpostman.com/)\\n\\n一個超級好用的 HTTP 請求工具，誰用誰知道。\\n\\n## 相關文章\\n1. [《神兵利器 -- HHKB Pro 2 開箱文》](https://calpa.me/2017/07/02/introduction-to-hhkb-pro-2/)\\n\",\"tags\":\"Front End, MacOS\"}},{\"node\":{\"title\":\"【圖多】《遠征成功﹣﹣一個香港人北上杭州豬場的前端面試之路》\",\"createdDate\":\"2017-09-30T18:00+08:00\",\"url\":\"hang-zhou-interview-summary\",\"headerImgur\":\"pGiI5On.jpg\",\"content\":\"## 前言\\n\\n首先，我要感謝網易。作為一個香港人，能夠拿到杭州的面試機會，實屬機會難得。這次的兩輪技術面試，考察點廣泛而深入。雖然問題比較深入，但這讓我感覺對於技術要求比較高，這是一件好事，因為可以反映公司對於技術的重視。在大四的這一年裡，我會繼續努力，爭取時間學習一個。本文將會記錄我面試時遇過的問題，以及作為一個香港人在杭州遇到的困難。。。\\n\\n![我想先以升級和畢業為目標努力](https://i.imgur.com/3IAyiiO.png)\\n\\n如果你想看圖的話，直接跳到下方的[杭州之旅](#杭州之旅)章節就行。\\n\\n## 一面\\n### 面試官的問題\\n\\n1. [自我介紹](/about)\\n1. 跨域怎樣處理？\\n1. 如何做模塊化？有什麼好處？\\n1. [你追求的前端是怎樣的一個前端？](/about)\\n\\n\\n### 我的問題\\n\\n前後端分離？\\n\\n## 二面\\n### 面試官的問題\\n\\n1. [自我介紹](/about)\\n1. [請介紹一下你的專業 (Major)](/about)\\n1. [什麼是黑客松？做什麼的？](/2017/04/23/hackUST-2017-hackathon-summary/)\\n1. 最近一次黑客松你做了什麼？\\n1. 說一下 React 實現原理\\n1. 有了解過 React 底部發生什麼事情嗎？\\n1. React 生態圈\\n1. React Router 發生什麼事情？\\n1. Redux 做了什麼事情？\\n1. 如何做多狀態管理\\n1. [異步操作](/2017/09/27/async-summary/)\\n1. 輸入網址之後到瀏覽器渲染完成之間，發生什麼事情\\n\\n### 我的問題\\n\\n1. 前後端分離？\\n1. 前端渲染？服務器渲染？前端下載框架，然後獲取伺服器資料再渲染？\\n\\n\\n我印象最深刻的是下面三條題目：\\n\\n1. 跨域\\n1. 異步操作\\n1. 輸入網址之後到瀏覽器渲染完成之間，發生什麼事情\\n\\n\\n很難？是的，因為我還沒有寫文章，拿著草稿就出去面試。。。如果你有關心社區裡面的文章的話，你會發現那些都是周經（每個星期都提出來的話題）。\\n\\n![但是越強才越有攻略的價值](https://i.imgur.com/SxgiJxK.png)\\n\\n很輕鬆？也不是。因為暑假的時候，我去了實習，沒有那麼多時間去寫博客文章，所以有一種被人家追稿的感覺。所以，在這一次面試裡面，我就把兩個月累積的稿子在兩次面試裡面說出來，你想一想也知道，當天的我是說了多少話。。。\\n\\n對於這三個問題，我會分成三篇文章，因為這三個問題，有很多細節在裡面的。異步操作已經在[《異步操作見聞錄》](/2017/09/27/async-summary/)談及過，有機會的話，我們再討論一下跨域以及輸入網址之後到瀏覽器渲染完成之間，發生什麼事情。\\n\\n好吧，就讓我們從香港出發吧。\\n\\n---\\n\\n## 杭州之旅\\n### 香港\\n\\n![九龍塘車站](https://i.imgur.com/qPTMcjM.jpg)\\n![上車了](https://i.imgur.com/ZkmrV9p.jpg)\\n我沒有選擇從香港國際機場出發，而是選擇去深圳寶安機場出發。我需要在九龍塘坐火車上去落馬洲，過關後在福田口岸坐地鐵 4號線到會展中心，轉乘 1號線到車公廟，然後轉乘 11號線抵達機場站。\\n\\n### 深圳\\n\\n![深圳寶安機場](https://i.imgur.com/l7g4Qdj.jpg)\\n深圳機場和香港機場都是採取了自然採光的設計，盡可能利用太陽光，這樣的設計看上去帶有現代科技感，也有自然的元素在內。那些六角形的位置，有著一種規律的美感。\\n\\n![42 登機口](https://i.imgur.com/WWO2xOy.jpg)\\n\\nThe answer to life, the universe, and everything.\\n\\n![初音 Kindle](https://i.imgur.com/4LGNjjM.jpg)\\n\\n我在過去的暑假定制的初音 Kindle，一種帶著初音去旅行的感覺www\\n\\n### 杭州\\n\\n![抵達杭州](https://i.imgur.com/XbYLcdi.jpg)\\n抵達杭州的時候，風和日麗，一點都不像會有颱風過來的樣子。\\n\\n![電子支付在杭州](https://i.imgur.com/yPPME3s.jpg)\\n\\n杭州是阿里巴巴的總部，可以說是具有中國特色的電子支付，支付寶發源地。只要有支付寶，就可以在便利店購物，坐巴士，完全不用帶現金出街也行。可惜的是，杭州電子公交卡需要實名認證，還需要開通花唄。花唄功能，到本文截稿為止，它依然沒有讓非中國身份證的人使用。也就是說，身為一個香港人，還是需要購買一張公交卡（八達通），或者使用現金。\\n\\n\\n雖然這一次杭州之旅，我不能享受這個服務，我也覺得沒有什麼問題，因為深圳還是需要公交卡來乘坐地鐵或者巴士。然而，這個時候的我，還沒有想到杭州處於一個拒絕沒有中國身份證的狀態。。。\\n\\n即使我預定了賓館，他們依然不能接待我。我打電話問面試官說一下這個問題後，便跑去杭州知名的如家快捷酒店，試試能不能入住。可惜的是，對於沒有中國身份證的人，他們是不能接待的，解釋是沒有開通港澳台居民的服務。。。\\n\\n![我想問個問題](https://i.imgur.com/zdHe4xH.png)\\n\\n對於外國人而言，他們是可以入籍中國，然後獲得中國身份證。然而，香港土生土長的香港人，又怎麼會跟你搞一張中國身份證呢？關於這一點，我不想在這裡展開。但是，對於有心前來杭州工作的香港人，包括我在內，這是一個迫切的問題。不知道 2020 年杭州舉辦的亞洲運動會，杭州的政策會有什麼改變，但我相信這一定會越來越好的。畢竟她想要成為一線城市，這一點可以說是不能忽視的。一線城市其中一個要素是有很多來自不同地方的人。。。你連居住也不能保障，如何叫人留下來。。。對於這一點，面試當日的 HR 面試環節，我明確表示我是香港人，沒有中國身份證的事實，並詢問網易的安排。\\n\\n於是，那一天我就被三連拒了。幸得杭州友人幫忙，我才得以找了一個房間租下來，不至於流落街頭。\\n\\n### 面試當日\\n![網易正門](https://i.imgur.com/cdlkptJ.jpg)\\n\\n網易的門口也是蠻好找的，因為門口一大堆單車。。。\\n\\n面試當日，非常多人。隨便找幾個人談天，他們都是大牛，現在實習於中國的知名互聯網公司，讓我感到要爭取時間，學習一個。如果要問能不能贏 我也沒有底氣，畢竟能夠進去網易的都是大牛www\\n\\n![如果要問能不能贏 我也沒有底氣](https://i.imgur.com/z8B9JbB.png)\\n\\n你問我能不能面試過關，我只能說無可奉告，因為我沒有底氣。因此，選擇困難症的我只好爭取時間吃飯，因為網易餐廳的菜單實在是太多了，很吸引人www\\n\\n![吃飯了](https://i.imgur.com/vfbrXh2.jpg)\\n\\n![網易餐廳午餐](https://i.imgur.com/XGOSYlY.jpg)\\n\\n中午要吃得清淡一點，因為不知道有沒有面試，要是有的話，那就不能破喉嚨了。。。\\n\\n![網易餐廳晚餐](https://i.imgur.com/Ou7RoJ1.jpg)\\n\\n真是的，這麼多面試題目，我要好好吃一頓。。。\\n\\n![真是的，好辛苦呢（一臉幸福](https://i.imgur.com/HvzzHOM.png)\\n\\n### 第三天\\n![醬鴨](https://i.imgur.com/TlVLgIY.jpg)\\n![好吃的杭州菜](https://i.imgur.com/tYSNBmp.jpg)\\n\\n儘管第一天遇到了那些不愉快的事，但是吃過網易餐廳的菜，還有杭州友人和我一起去吃得杭州菜之後，我也忘記那些事情了。\\n\\n![:p](https://i.imgur.com/0gVyruv.png)\\n\\n## 後記\\n最後再一次感謝網易。我感覺杭州是一個好地方，不管是空氣，還是食物，我也覺得很好。\\n\\n對於網易雲音樂，我最喜歡的是每日歌曲推薦和評論區系統。它的算法也是蠻準確的，雖然我不是很懂算法，但是每天能夠聽到不同的歌曲，然後收藏一個，也是覺得蠻開心的。我每天都要利用網易雲音樂，聽日文歌曲。尤其是寫代碼，或者寫博客文章的時候，更加是要不斷聽我喜歡的音樂裡面的歌曲。\\n\\n如果你在 2018 年之後要來杭州的話，可以找一下我。\\n\\n說到這裡，歡迎來到實力至上的世界。\\n\\n![](https://i.imgur.com/4Ltl87d.png)\\n\\n## 備註\\nHexo 框架有問題：當文章長度有一定長度，而且中英文混合的時候，`hexo serve` 會有亂碼問題。原因是 Node.js buffer 問題。。。\\n\\n本文已參加[掘金秋招征文](https://juejin.im/post/59aa744ff265da247c4f145c)。\\n\",\"tags\":\"callback, JavaScript, async, interview\"}},{\"node\":{\"title\":\"異步操作見聞錄\",\"createdDate\":\"2017-09-27T20:00+08:00\",\"url\":\"async-summary\",\"headerImgur\":\"KMksHxZ.png\",\"content\":\"## 前言\\n異步操作是非常常見的操作，也是其中一題常見的前端工程師面試題目。在日常開發中，我們會和伺服器交互，或者是和用戶的行動作出反應，比如說監聽某些點擊事件。這個時候，其實我們是執行了異步操作，我們需要等待對方若干時間才能收到返回值，甚至是一個錯誤的值。。。因此，異步操作很容易產生一些誤會。這裡，我會說一下異步操作，及其返回的處理方法。\\n\\n## 同步與異步的分別\\n\\n在同步的世界裡面，我們希望執行某些操作之後，就能夠馬上拿到返回的值，然後執行下一步。然而，當我們發出 HTTP 請求的時候，我們可能需要等待世界的另外一端返回信息，這需要時間，便不是同步了。。。\\n\\n如果沒有異步的話，當你發出 HTTP 請求的時候，瀏覽器需要等待伺服器返回才執行下一步。這就是代表瀏覽器會卡住。。。\\n\\n異步處理，簡單來說就是我們發出了一個行動，但是不是馬上得到結果，我們會繼續執行後面的指令，等到函數裡面有一個返回，我們才拿那個返回值來使用。最簡單的說法，就是我們向服務器發出請求，但是服務器需要時間處理，並且返回處理過的內容。\\n\\n## 異步操作處理方法\\n1. Callback\\n1. Promise （思想）\\n1. Generator\\n1. Async await （推薦）\\n\\n### Callback\\n\\n我們看一下維基百科上面對於 Callback 的說明：\\n\\n> 在電腦程式設計中，回呼函式，或簡稱回呼（Callback 即call then back 被主函數呼叫運算後會返回主函數），是指通過函數參數傳遞到其它代碼的，某一塊可執行代碼的參照。這一設計允許了底層代碼呼叫在高層定義的子程式。\\n\\n這樣好像說得蠻複雜的，但其實很簡單，你把一個函數 cb (Function) 作為參數 (Argument)傳進這個函數 B 裡面，然後在函數 B 使用函數 cb。\\n\\n```\\nfunction func(x, cb) {\\n  cb(x)\\n}\\n```\\n\\n舉個例子，比如我們要在 Node.js 裡面讀取一個檔案，我們的代碼會是下面這樣的：\\n\\nhello.txt:\\n```\\nHello World, I'm Calpa Liu.\\n```\\n---\\nindex.js:\\n```\\nvar fs = require('fs');\\n\\nfs.readFile('hello.txt', function (err, data) {\\n     if (err) {\\n          return console.error(err);\\n     }\\n\\n     console.log(data);\\n});\\n\\nconsole.log('Finished');\\n```\\n\\n\\n我們會在 callback 裡面處理 callback，也就是一個回調裡面做另外一件事情，那可能是另外一個 callback，那麼你可以想象一下，我們越寫越深。。。這樣有兩個問題，第一：代碼的耦合性會很高，不容易去拆分代碼；第二：代碼的維護性很差。\\n\\n![Imgur](https://i.imgur.com/bjHDvVN.jpg)\\n\\n\\n### Promise\\n\\nPromise 是說如果你做了 A 的事情，成功了就做 B，不成功就做 C，你還可以繼續做 D 的事情，然後進行成功和不成功的處理。這樣說可能比較虛，但是你看一下 MDN 上面的圖就會明白了。\\n\\n![Promise - MDN](https://i.imgur.com/w9BxjmL.png)\\n\\n一個發射子彈的動作可以這樣寫：\\n\\n```\\nvar fire = new Promise(function(resolve, reject) {\\n     setTimeout(function() {\\n          resolve('已命中三千里外的目標');\\n     }, 3000)\\n});\\n\\nfire.then(function(result) {\\n     console.log(result);\\n});\\n```\\n\\n你可以在 Windows 平台按 F12 或 Ctrl + Shift + I，或在 Mac 上 按 Cmd + Opt + I，打開 Google Chrome Developer Tools ，然後在 Console 貼上上面的代碼，三秒後就會輸出`已命中三千里外的目標`。\\n\\n你也可以在 then() 裡面寫 1個到 N個的 Promise。\\n\\n```\\nvar fire = new Promise(function(resolve, reject) {\\n     setTimeout(function() {\\n          resolve('已命中三千里外的目標');\\n     }, 3000)\\n});\\n\\nfire.then(function(result) {\\n     console.log(result);\\n     console.log('正在返回司令部');\\n     return fire.then(function (result) {\\n          console.log(result);\\n     });\\n});\\n```\\n\\n### Generator\\n\\nGenerator 其實是一個狀態機，內部保存機器的運行狀態。我們透過獲取機器的完成狀態 (done)，我們能夠重複調用機器。我們可以使用 yield 暫停一個函數，並跳出函數。從外面的角度來看，我們可以從上而下去寫代碼，但是代碼會複雜，難以理解。\\n\\n雖然它已經寫進 ECMAScript 2015 的正式規範裡面，但是我不太喜歡使用 Generator。我們簡單看一下 Generator 就好了，因為現在是 2017 年，異步操作的有更加好的處理方法。\\n\\n```\\nfunction* gen() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nvar g = gen(); // \\\"Generator { }\\\"\\ng; //\\ng.next(); // {value: 1, done: false}\\ng.next(); // {value: 2, done: false}\\ng.next(); // {value: 3, done: false}\\ng.next() // {value: undefined, done: true}\\n```\\n\\n### Async/Await\\n\\n對於技術的要求，是無止境的。為了寫出更加優美的代碼，你又可以付出什麼的代價呢？\\n\\n如果你沒有試過 Async/Await 的話，那麼你就應該試一下，因為實在是太優雅了。\\n\\n這里我就放出一段現在博客在用的代碼：\\n\\n```\\nasync const getPosts = () => {\\n  await res = axios.get('https://calpa.me/posts');\\n  return res.data;\\n}\\n```\\n\\n我們簡單的讀一下這段代碼：\\n\\n一個異步的不變量 `getPosts` 是一個箭頭函數，內部操作為等待 axios 的 GET 請求到地址：[http://calpa.me](https://calpa.me)，並返回伺服器返回的資料。\\n\\n這是一個非常簡單的異步操作吧，但是如果是這樣的呢？\\n```\\nasync const getUserData = () => {\\n  await posts = axios.get('https://calpa.me/posts');\\n  await accountInfo = axios.get('https://calpa.me/about');\\n  /* ... */\\n}\\n```\\n\\n如果你想要使用 Async / Await 的話，可以使用\\n[Node.js 7.6](https://www.infoq.com/news/2017/02/node-76-async-await) 或以上的版本。例如使用 nvm 安裝 v8: `nvm install v8`，然後 `nvm use v8`。\\n\\n另外，如果你不想更新 Node 版本的話，你可以安裝 [async 工具庫](https://caolan.github.io/async/)。\\n\\n\\n## 感想\\n異步操作已經成為了前端工程師面試常見的問題之一，感覺是對於前端工程師的技術水平需求越來越提高了。雖然這些都是在 MDN 上面寫好的介紹，但是只有自己用過才會知道什麼比較好。\\n\\n如果公司的 Node 版本可以支持 Async/Await 的話，那就直接用 Async/Await 就好了。不行的話，那就用 Promise 吧，不然 Generator 的設計對於強迫症患者來說很不順眼。。。\\n\\n## 參考資料\\n1. [Callback (computer programming) - Wikipedia](https://en.wikipedia.org/wiki/Callback)\\n1. [Promise - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\\n1. [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\\n1. [async function - JavaScript MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\\n\",\"tags\":\"Front End, JavaScript\"}},{\"node\":{\"title\":\"React-markdown -- 實時渲染 Markdown 的 React 工具\",\"createdDate\":\"2017-08-31T20:00+08:00\",\"url\":\"react-markdown-render-markdown-as-component\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"## 前言\\n\\n要寫出優雅的文檔是有難度的，尤其是需要格式規範的文章。而利用 Markdown，則可以專心寫作。Markdown 除了可以直接編譯為 HTML，還能編譯為 PowerPoint, Resume，還有 React 組件。無論是[利用 Markdown 製作 PowerPoint](https://calpa.me/2017/06/01/create-markdown-powerpoint-in-5-mins/)，還是利用 Markdown 製作簡歷，都是非常方便的。如果你不是很熟悉 Markdown 語法的話，你可以在下文看 [Markdown 語法](#Markdown-語法)。但是如果可以接受他人傳進來的 Markdown 文章，然後渲染他們的文章，那就會更加好。所以我就找了一下 React + Markdown 的組合，發現這個 React-markdown 工具下載的人數蠻多的。雖然那個項目還在開發階段，但是你可以在 [Live Demo](http://rexxars.github.io/react-markdown) 測試一下渲染為 React 組件的效果。\\n\\n---\\n\\n![Live Demo](https://i.imgur.com/UFkBeEN.png)\\n\\n![直接渲染為 React 組件](https://i.imgur.com/q2q2RJv.png)\\n\\n## react-markdown\\n\\nGithub: https://github.com/rexxars/react-markdown\\nnpmjs: https://www.npmjs.com/package/react-markdown\\n\\n### 安裝\\n```\\nnpm install --save react-markdown\\n```\\n\\n### 使用方法\\n使用 ES6 Import `ReactMarkdown`，然后使用 <ReactMarkdown />，並傳入 Markdown 到 source。\\n\\n```js\\nimport ReactMarkdown from 'react-markdown';\\n\\nconst input = '# This is a header\\\\n\\\\nAnd this is a paragraph';\\n\\n<ReactMarkdown source={input} />\\n```\\n\\n然後你會看到這樣的：\\n\\n![React Markdown 例子](https://i.imgur.com/zR2Olai.png)\\n\\n官網上是這樣說的：\\n```js\\nvar React = require('react');\\nvar ReactDOM = require('react-dom');\\nvar ReactMarkdown = require('react-markdown');\\n\\nvar input = '# This is a header\\\\n\\\\nAnd this is a paragraph';\\n\\nReactDOM.render(\\n    <ReactMarkdown source={input} />,\\n    document.getElementById('container')\\n);\\n```\\n\\n### Webpack 1 配置\\n\\n如果你是用 Webpack 1 的話，你需要安裝 json-loader：\\n```\\nnpm install --save json-loader\\n```\\n\\n並在你的 webpack 設置裡面加上：\\n\\n```js\\n{\\n  module: {\\n    loaders: [{\\n      test: /\\\\.json$/,\\n      loader: 'json-loader'\\n    }]\\n  }\\n}\\n```\\n\\n如果你設置 `escapeHtml` 或 `skipHtml` 為 `true`，該組件就不會使用`dangerouslySetInnerHTML`。\\n\\n### 選項\\n\\n以下選項除了`source`之外都是可選的，其實這個工具已經配置成開箱即用，這裡就說幾個最底部的選項，更多的選項請去官網看。\\n\\n* `source` - 你的 Markdown 來源（必須）- string\\n* `className` - 容器的 className - string\\n* `containerTagName` - 容器的標籤名字 ，因為 Markdown 會有很多不同層次的 elements，容器需要把它們封裝。默認是`div` - string\\n\\n這個渲染器會渲染的組件有：\\n\\n* `HtmlInline` - 行內 HTML\\n* `HtmlBlock` - HTML 塊\\n* `Text` - 文字 (在段落裡面)\\n* `Paragraph` - 段落 (`<p>`)\\n* `Heading` - 標題 (`<h1>`, `<h2>` etc)\\n* `Softbreak` - 換行\\n* `Hardbreak` - 斷行（強制換行） (`<br>`)\\n* `Link` - 鏈接 (`<a>`)\\n* `Image` - 圖像 (`<img>`)\\n* `Emph` - 強調 (`<em>`)\\n* `Code` - Inline code nodes (`<code>`)\\n* `CodeBlock` - Blocks of code (`<code>`)\\n* `BlockQuote` - 參照 (`<blockquote>`)\\n* `List` - 列表 (`<ol>`, `<ul>`)\\n* `Item` - 列表 (`<li>`)\\n* `Strong` - Strong/bold nodes (`<strong>`)\\n* `ThematicBreak` - 水平分割線 (`<hr>`)\\n\\n## Markdown 語法\\n\\nMarkdown 的目標是易讀易寫，而它能夠幫助程序員專注開發，減少編寫文檔時候遇到的格式問題。Markdown 和 HTML 的寫法差不多，雖然 HTML 已經很容易寫，但是 Markdown 則是更加格式化，如果你直接閱讀 Markdown 文檔，你也可以想象到它渲染後的樣式。\\n\\n### 標題\\n```\\n# H1\\n## H2\\n### H3\\n```\\n\\n### 清單\\n無序清單使用`*`, `+` 或`-`，而我這是常用`-`\\n```\\n*   Red\\n*   Green\\n*   Blue\\n\\n+   Red\\n+   Green\\n+   Blue\\n\\n-   Red\\n-   Green\\n-   Blue\\n```\\n有序清單則使用數字接著一個英文句點：\\n```\\n1.  Apple\\n2.  Banana\\n3.  Watermelon\\n```\\n\\n## 後記\\n\\n順帶說一下，我的博客已經配置好 Service Worker，現在可以離線訪問網站。也就是下次訪問的時候，即使沒有 Wifi 或者連接到網絡，你也能夠瀏覽到文章內容。\\n\\n有機會的話，我會說說如何配置 Service Worker，以及當中的原理。\\n\\n我的簡歷也差不多重構一次了（逃。。。\\n\",\"tags\":\"React, Markdown, 工具\"}},{\"node\":{\"title\":\"React 應用輕量化（一）Source Map\",\"createdDate\":\"2017-08-27T10:03+08:00\",\"url\":\"react-app-optimization-1-source-map\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"\\n`create-react-app` 提供了很方便的創建 React 應用途徑。它已經把 webpack, Babel, Autoprefixer, ESLint, Jest 等常用工具打包進去。可以說是一個非常方便，好用的製造 React 應用工具。當我打算把包裝好的檔案推上去的時候，我卻發現打包之後的檔案大小有點大，因此我就開始優化這個網頁應用了。第一點我優化的地方就是 Source Map。\\n\\n如果你細心看 README.md 的話，你會發現下面這一句，它把 Source Map 也打包進去。。。\\n\\n> A build script to bundle JS, CSS, and images for production, with sourcemaps.\\n\\n在測試環境中，我們可以透過 sourcemap 找到 bundle 過後的對應項目組件，這個是蠻方便的。\\n\\n但是，在生產環境中，如果有 sourcemap 的話，就會直接暴露項目中的架構，以及檔案，同時會增加網站大小。。。\\n\\n## 解決方法\\n### 快速方法\\n排除 `*.map`，避免部署 sourcemap 到上面。。。\\n\\n這個方法並不能從根源解決問題，因為產生 sourcemap 需時較長，另外，也會產生一個不需要的檔案大小略大的 sourcemap 檔案。\\n\\n### 徹底方法\\n\\n1. `npm run eject`，如果你沒有 Eject 過的話。\\n\\nEject 是一個特殊命令，把 `create-react-app` 的懶人包變成自定義的項目。在 Eject 之前，請想清楚你是否需要掌握項目的每一個細節。\\n\\n對應日新月異的產品需求以及開發需求，我選擇 Eject。比如說 SCSS，CSS 模組化。\\n\\n2. 用你喜歡的文字編輯器 或 IDE 打開 `/config/webpack.config.prod.js`\\n\\n3. 刪除或注釋第五十三行 `devtool: 'source-map'`\\n\\n在上面你可以看到這樣的注釋：\\n> // We generate sourcemaps in production. This is slow but gives good results.\\n> // You can exclude the *.map files from the build during deployment.\\n\\n它這裡寫就是說產生 sourcemap 會給出好的結果，雖然產生時間會更加長。。。\\n\\n另外，你可以排除 `*.map`，避免部署 Source Map 到上面。。。\\n\\n## 參考資料\\n1. [create-react-app README](https://github.com/facebookincubator/create-react-app)\\n1. [Disable webpack production sourcemaps](https://github.com/facebookincubator/create-react-app/issues/2005)\\n\",\"tags\":\"React, 前端\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":12}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-2-f423e0ef476e67ac1f5c.js","module.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"參加八次黑客馬拉松的個人體會與總結\",\"createdDate\":\"2017-11-06T19:32+08:00\",\"url\":\"hackathon-summary\",\"headerImgur\":\"qNs8pq4.jpg\",\"content\":\"## 前言\\n\\n與其說黑客馬拉松是一場比賽，不如說它是一場程序員的盛會。作為一個前端開發者，也是蠻喜歡參加這樣的比賽。畢竟可以把自己的想法，在 24 小時之內把自己的想法，或是按著比賽主題做個原型出來。無論你是什麼技術背景的人，都歡迎你來參與這些盛會。\\n\\n## 為什麼我會開始參加黑客馬拉松？\\n\\n一開始，我沒有想那麼多。無論是取得勝利，或者是獲取經驗，都能夠幫助我成長。如果是取得名次的話，那就可以跟人家分享一下喜悅。如果是取得經驗的話，那也能從一個短時間試驗自己對於不同技術的掌握程度。無論如何，有好吃的東西是少不了www\\n\\n另外一個我喜歡黑客松的的地方，就是比賽的獎品也是非常豐富的。ImagineHack 為我帶來的除了第三名的名次之外，還有 FitBit 這一個智能手環。而深圳 TechCrunch 2017 黑客松，則是為我帶來現在我寫代碼，或者是寫文章必備的 HHKB，詳見[《神兵利器 -- HHKB Pro 2 開箱文》][1]一文。現在無論是寫代碼還是寫文章，我都不需要看著鍵盤，就可以自由地輸入。\\n\\n## 比賽內容\\n\\n![hackUST 2017][2]\\n\\n比賽通常都是持續 24 小時，甚至更加長的時間的。比如說第一天的早上開始，到第二天的下午結束。如果那次比賽舉辦單位有名氣的話，或者是比較願意投放資源到福利上面，那麼我們吃的食物也是比較豪華的。當中不乏自助餐，要兩個人伸手才能圍著的超級大 Pizza，還有很多零食，飲料。\\n\\n## 報名方法\\n\\n這些比賽大部分都是免費的，有一些舉辦單位可能會收取幾十塊錢，但你依然可以從不同途徑獲取免費門票。所以如果你沒有參加過的話，你也可以選擇參加一些免費的黑客馬拉松，體驗一下。\\n\\n要找到這些黑客馬拉松，一點也不難。你只需要留意不同社群的信息，就會發現幾乎每個月都有黑客松。這些舉辦單位大多鼓勵不同的參賽者參加，也就是不同的人也能夠參加比賽。比如說程序員，設計師，還有一些商業背景的人也會參加。無論你是否一個程序員，你都可以發揮你的想象力，可能你就是下一個贏家。\\n\\n## 感想\\n\\n這麼有趣的活動，能夠和不同人交流一下，也能驗證自己的技術水平。一舉兩得的事情，何樂而不為呢？ **Just do IT**。有興趣的話，可以看一下我寫的兩篇後記：[hackUST 2017 後記][3]，[SuperCharger Hackathon 後記][4]。希望在下一次比賽可以有合作的機會。\\n\\n\\n[1]: /2017/07/02/introduction-to-hhkb-pro-2/\\n[2]: https://i.imgur.com/IJPUhSJ.jpg\\n[3]: 2017/04/23/hackUST-2017-hackathon-summary/\\n[4]: /2017/02/19/supercharger-hackathon\",\"tags\":\"前端, 閱讀, Hackathon\"}},{\"node\":{\"title\":\"前端程序員的必備工具清單（MacOS）\",\"createdDate\":\"2017-10-02T21:53+08:00\",\"url\":\"frontend-developer-tools-in-macos\",\"headerImgur\":\"Vb56RuU.jpg\",\"content\":\"## 前言\\n\\n工欲善其事，必先利其器。一套完善的工具可以幫助我們事半功倍。而作為前端程序員的我，也是花了點時間為自己配置了一套工具。如果你也是使用 MacOS 作為你的開發系統的話，那麼你可以看一下這篇文章。\\n\\n\\n## 日常\\n\\n### [Alfred 3](https://www.alfredapp.com/)\\n\\n![Alfred Search](https://i.imgur.com/5yaDRiv.jpg)\\n\\nAlfred 是一個強大的效率工具，而且它更加是一個全面的自動化工具平台。你可以從下圖感受一下：\\n\\n![Alfred 的功能](https://i.imgur.com/RK1OiPq.png)\\n\\n你只要在 Alfred 的輸入框，寫下你想要的東西前幾個字，它便會顯示你所希望的命令。不過最強大的是可以和 MacOS 內置的全文搜尋一起用，也就是你輸入`in` 命令，它就可以全局全文搜尋。\\n\\n![全局搜尋](https://i.imgur.com/925QlWY.png)\\n\\n另外，它也可以記錄你所 Copy 過的歷史，如果你使用 Emacs 的 Kill Ring 的話，他就會自動記錄代碼。我工作的時候就經常應用到 Alfred，因為有很多代碼都需要刪除，然後幾個小時後就有人跟你說那個代碼需要還原。。。\\n\\n![Clipboard 歷史記錄](https://i.imgur.com/SsJkjae.png)\\n\\n另外，它的 Powerpack 和 Workflows 提供 Alfred 一個升級的可能性（腦洞），讓你可以寫出自己的代碼，並快捷執行。\\n\\n### Aria2GUI\\n\\n下載神器，網上有很多不同的前端界面，例如 [Yet Another Aria2 Web FrontEnd](https://github.com/yangshun1029/aria2gui)\\n\\n![Yet Another Aria2 Web FrontEnd](https://i.imgur.com/YT38J2q.png)\\n\\n### [ImageOptim](https://imageoptim.com/mac)\\n\\n![ImageOptim 界面](https://i.imgur.com/tEgTJmb.png)\\n\\n沒有經過優化或壓縮的圖片，直接上傳到伺服器或讓其他用戶下載的話，需要的時間都會很長，所以我的圖片大多都會經過 ImageOptim 優化一下。ImageOptim 是一個開源，免費的無損圖片優化工具。\\n\\n### [Moom](https://manytricks.com/moom/)\\n\\nMac 本身沒有提供類似 Windows 上面移動，放大視窗的功能，因此會經常看到有些人的電腦很多個視窗重疊了。。。\\n\\n![Align Left](https://i.imgur.com/dGOOGRz.jpg)\\n\\n### [TotalSpaces2](https://totalspaces.binaryage.com/)\\n\\n![TotalSpaces2](https://i.imgur.com/cAizggh.png)\\n\\n一個超好用的 Mac 桌面空間管理工具，包含以下六大功能：\\n1. 可以上下左右放置桌面佈局，而不是只有默認的向左向右\\n\\t![上下左右的桌面佈局](https://i.imgur.com/j0xBUi1.png)\\n\\n1. 觸控板可以跳轉上下左右的桌面格子\\n\\t![觸控跳轉格子](https://i.imgur.com/f3uGPqJ.png)\\n\\n1. 桌面格子可以設置默認的應用\\n\\t![設置默認應用](https://i.imgur.com/2KEOJhI.png)\\n\\n1. 全面的桌面概覽\\n\\t![全面的桌面概覽](https://i.imgur.com/8pZTHJc.png)\\n1. 更加炫酷的桌面跳轉效果\\n\\t![跳轉效果](https://i.imgur.com/69cceh0.png)\\n1. 屏幕的四個角落可以觸發各自的動作\\n\\t![屏幕角落觸發動作](https://i.imgur.com/HtnXX4a.png)\\n\\n應用場景：\\n\\n當只有一個屏幕，又要同時運行多個佔用全屏的應用，你可能需要切來切去。透過使用 TotalSpaces2，你就可以輕鬆切換屏幕，比如說下面看伺服器狀態，上面看代碼區域。\\n\\n另外，你也可以設置 Terminal 應用在下方屏幕格子，編輯器在上方屏幕格子。\\n\\n### [Eagle](https://eagle.cool/macOS)\\n\\n![Eagle](https://i.imgur.com/6JGSOld.png)\\n\\nEagle 是一個專門為設計師而打造的圖片收藏及管理工具。雖然我不是設計師，但是我有收藏大量的圖片，尤其是二次元動畫的截圖。對於這麼多的圖片，我曾經都很苦惱，因為截圖之後無法再次調用。。。幸好有這個工具，我就可以輕鬆地收藏網頁圖片，或者截屏到 [Eagle](https://eagle.cool/macOS)。之後可以打上標籤，或者人物的台詞。\\n\\n![感覺圖片太多，需要找個工具管理圖片www](https://i.imgur.com/VnB1ItB.png)\\n\\n## Coding\\n### [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\\n\\n![oh-my-zsh](https://i.imgur.com/otYtqAu.png)\\n\\n為什麼你的 Terminal 使用上來那麼不一樣？是的，**oh-my-zsh** 背後的社區驅動著我（逃。。。\\n\\n有時間可以說說到底為什麼 **oh-my-zsh** 那麼強大，以及它的配件。\\n\\n### [Solarized 配色方案](http://ethanschoonover.com/solarized)\\n\\n![兩種配色方案](https://i.imgur.com/mf5wi85.png)\\n\\n![清晰易見](https://i.imgur.com/Vtm0vIa.png)\\n\\n![包含的顏色](https://i.imgur.com/7O38J5g.png)\\n\\n### [SourceTree](https://www.sourcetreeapp.com/)\\n\\n![SourceTree 界面](https://i.imgur.com/7vtlS8m.png)\\n\\n以前沒有習慣命令行的時候，我是用 SourceTree 來看 Git 歷史的。雖然我現在喜歡使用命令行來操作 Git，但是比較複雜的 Git 操作還是需要專門的工具的，例如 SourceTree 就是一個不錯的選擇。\\n\\n## 高能區域（編輯器）\\n\\n無論是什麼神的編輯器，還是編輯器的神，取其精華去其糟粕才是最好的。\\n\\n### [Atom](https://atom.io/)\\n\\n![Atom](https://i.imgur.com/B47vleN.png)\\n\\nAtom 是一個基於 Electron 的現代開源文本編輯器，你可以直接黑掉它的核心，甚至改得完全不一樣。你可以使用 HTML，CSS/Less 及 JavaScript 修改 Atom的功能，它的功能包括但不限於：\\n\\n1. 支持跨平台\\n  1. 內置的 Package 管理系統\\n\\n\\t你可以在 Atom 直接搜尋 Package，並且安裝 Package。\\n\\n  1. 自動補全\\n  1. 瀏覽檔案系統\\n  1. 全局搜尋\\n\\n![編輯器 with Git Diff](https://i.imgur.com/IDDanXB.png)\\n\\n![Atom 設置面板](https://i.imgur.com/03wyXY4.png)\\n\\n![內置的 Package 管理系統](https://i.imgur.com/RTMhhex.png)\\n\\n### Emacs\\n\\n> Emacs = Escape + Meta + Alt + Control + Shift\\n\\n![Emacs Hello World](https://i.imgur.com/HmiuWMz.png)\\n\\n其實我是蠻喜歡 Emacs 的思想，以及它的按鍵。因為寫代碼就好像輸入打遊戲需要的特殊命令，一種寫代碼就是玩遊戲的概念。我養成盲打的習慣，好像也是因為 Emacs 而開始的。。。\\n\\n### Vim\\n\\n如果我要簡單的 Git Commit，我就可以直接寫 Git Commit 記錄，然後輸入`:wq`，並不需要那麼複雜的工具。\\n\\n## 瀏覽器\\n\\n1. [Google Chrome](https://www.google.com/chrome/index.html)\\n\\n這個是個必需品吧。。。\\n\\n1. [Postman](https://www.getpostman.com/)\\n\\n一個超級好用的 HTTP 請求工具，誰用誰知道。\\n\\n## 相關文章\\n1. [《神兵利器 -- HHKB Pro 2 開箱文》](https://calpa.me/2017/07/02/introduction-to-hhkb-pro-2/)\\n\",\"tags\":\"Front End, MacOS\"}},{\"node\":{\"title\":\"【圖多】《遠征成功﹣﹣一個香港人北上杭州豬場的前端面試之路》\",\"createdDate\":\"2017-09-30T18:00+08:00\",\"url\":\"hang-zhou-interview-summary\",\"headerImgur\":\"pGiI5On.jpg\",\"content\":\"## 前言\\n\\n首先，我要感謝網易。作為一個香港人，能夠拿到杭州的面試機會，實屬機會難得。這次的兩輪技術面試，考察點廣泛而深入。雖然問題比較深入，但這讓我感覺對於技術要求比較高，這是一件好事，因為可以反映公司對於技術的重視。在大四的這一年裡，我會繼續努力，爭取時間學習一個。本文將會記錄我面試時遇過的問題，以及作為一個香港人在杭州遇到的困難。。。\\n\\n![我想先以升級和畢業為目標努力](https://i.imgur.com/3IAyiiO.png)\\n\\n如果你想看圖的話，直接跳到下方的[杭州之旅](#杭州之旅)章節就行。\\n\\n## 一面\\n### 面試官的問題\\n\\n1. [自我介紹](/about)\\n1. 跨域怎樣處理？\\n1. 如何做模塊化？有什麼好處？\\n1. [你追求的前端是怎樣的一個前端？](/about)\\n\\n\\n### 我的問題\\n\\n前後端分離？\\n\\n## 二面\\n### 面試官的問題\\n\\n1. [自我介紹](/about)\\n1. [請介紹一下你的專業 (Major)](/about)\\n1. [什麼是黑客松？做什麼的？](/2017/04/23/hackUST-2017-hackathon-summary/)\\n1. 最近一次黑客松你做了什麼？\\n1. 說一下 React 實現原理\\n1. 有了解過 React 底部發生什麼事情嗎？\\n1. React 生態圈\\n1. React Router 發生什麼事情？\\n1. Redux 做了什麼事情？\\n1. 如何做多狀態管理\\n1. [異步操作](/2017/09/27/async-summary/)\\n1. 輸入網址之後到瀏覽器渲染完成之間，發生什麼事情\\n\\n### 我的問題\\n\\n1. 前後端分離？\\n1. 前端渲染？服務器渲染？前端下載框架，然後獲取伺服器資料再渲染？\\n\\n\\n我印象最深刻的是下面三條題目：\\n\\n1. 跨域\\n1. 異步操作\\n1. 輸入網址之後到瀏覽器渲染完成之間，發生什麼事情\\n\\n\\n很難？是的，因為我還沒有寫文章，拿著草稿就出去面試。。。如果你有關心社區裡面的文章的話，你會發現那些都是周經（每個星期都提出來的話題）。\\n\\n![但是越強才越有攻略的價值](https://i.imgur.com/SxgiJxK.png)\\n\\n很輕鬆？也不是。因為暑假的時候，我去了實習，沒有那麼多時間去寫博客文章，所以有一種被人家追稿的感覺。所以，在這一次面試裡面，我就把兩個月累積的稿子在兩次面試裡面說出來，你想一想也知道，當天的我是說了多少話。。。\\n\\n對於這三個問題，我會分成三篇文章，因為這三個問題，有很多細節在裡面的。異步操作已經在[《異步操作見聞錄》](/2017/09/27/async-summary/)談及過，有機會的話，我們再討論一下跨域以及輸入網址之後到瀏覽器渲染完成之間，發生什麼事情。\\n\\n好吧，就讓我們從香港出發吧。\\n\\n---\\n\\n## 杭州之旅\\n### 香港\\n\\n![九龍塘車站](https://i.imgur.com/qPTMcjM.jpg)\\n![上車了](https://i.imgur.com/ZkmrV9p.jpg)\\n我沒有選擇從香港國際機場出發，而是選擇去深圳寶安機場出發。我需要在九龍塘坐火車上去落馬洲，過關後在福田口岸坐地鐵 4號線到會展中心，轉乘 1號線到車公廟，然後轉乘 11號線抵達機場站。\\n\\n### 深圳\\n\\n![深圳寶安機場](https://i.imgur.com/l7g4Qdj.jpg)\\n深圳機場和香港機場都是採取了自然採光的設計，盡可能利用太陽光，這樣的設計看上去帶有現代科技感，也有自然的元素在內。那些六角形的位置，有著一種規律的美感。\\n\\n![42 登機口](https://i.imgur.com/WWO2xOy.jpg)\\n\\nThe answer to life, the universe, and everything.\\n\\n![初音 Kindle](https://i.imgur.com/4LGNjjM.jpg)\\n\\n我在過去的暑假定制的初音 Kindle，一種帶著初音去旅行的感覺www\\n\\n### 杭州\\n\\n![抵達杭州](https://i.imgur.com/XbYLcdi.jpg)\\n抵達杭州的時候，風和日麗，一點都不像會有颱風過來的樣子。\\n\\n![電子支付在杭州](https://i.imgur.com/yPPME3s.jpg)\\n\\n杭州是阿里巴巴的總部，可以說是具有中國特色的電子支付，支付寶發源地。只要有支付寶，就可以在便利店購物，坐巴士，完全不用帶現金出街也行。可惜的是，杭州電子公交卡需要實名認證，還需要開通花唄。花唄功能，到本文截稿為止，它依然沒有讓非中國身份證的人使用。也就是說，身為一個香港人，還是需要購買一張公交卡（八達通），或者使用現金。\\n\\n\\n雖然這一次杭州之旅，我不能享受這個服務，我也覺得沒有什麼問題，因為深圳還是需要公交卡來乘坐地鐵或者巴士。然而，這個時候的我，還沒有想到杭州處於一個拒絕沒有中國身份證的狀態。。。\\n\\n即使我預定了賓館，他們依然不能接待我。我打電話問面試官說一下這個問題後，便跑去杭州知名的如家快捷酒店，試試能不能入住。可惜的是，對於沒有中國身份證的人，他們是不能接待的，解釋是沒有開通港澳台居民的服務。。。\\n\\n![我想問個問題](https://i.imgur.com/zdHe4xH.png)\\n\\n對於外國人而言，他們是可以入籍中國，然後獲得中國身份證。然而，香港土生土長的香港人，又怎麼會跟你搞一張中國身份證呢？關於這一點，我不想在這裡展開。但是，對於有心前來杭州工作的香港人，包括我在內，這是一個迫切的問題。不知道 2020 年杭州舉辦的亞洲運動會，杭州的政策會有什麼改變，但我相信這一定會越來越好的。畢竟她想要成為一線城市，這一點可以說是不能忽視的。一線城市其中一個要素是有很多來自不同地方的人。。。你連居住也不能保障，如何叫人留下來。。。對於這一點，面試當日的 HR 面試環節，我明確表示我是香港人，沒有中國身份證的事實，並詢問網易的安排。\\n\\n於是，那一天我就被三連拒了。幸得杭州友人幫忙，我才得以找了一個房間租下來，不至於流落街頭。\\n\\n### 面試當日\\n![網易正門](https://i.imgur.com/cdlkptJ.jpg)\\n\\n網易的門口也是蠻好找的，因為門口一大堆單車。。。\\n\\n面試當日，非常多人。隨便找幾個人談天，他們都是大牛，現在實習於中國的知名互聯網公司，讓我感到要爭取時間，學習一個。如果要問能不能贏 我也沒有底氣，畢竟能夠進去網易的都是大牛www\\n\\n![如果要問能不能贏 我也沒有底氣](https://i.imgur.com/z8B9JbB.png)\\n\\n你問我能不能面試過關，我只能說無可奉告，因為我沒有底氣。因此，選擇困難症的我只好爭取時間吃飯，因為網易餐廳的菜單實在是太多了，很吸引人www\\n\\n![吃飯了](https://i.imgur.com/vfbrXh2.jpg)\\n\\n![網易餐廳午餐](https://i.imgur.com/XGOSYlY.jpg)\\n\\n中午要吃得清淡一點，因為不知道有沒有面試，要是有的話，那就不能破喉嚨了。。。\\n\\n![網易餐廳晚餐](https://i.imgur.com/Ou7RoJ1.jpg)\\n\\n真是的，這麼多面試題目，我要好好吃一頓。。。\\n\\n![真是的，好辛苦呢（一臉幸福](https://i.imgur.com/HvzzHOM.png)\\n\\n### 第三天\\n![醬鴨](https://i.imgur.com/TlVLgIY.jpg)\\n![好吃的杭州菜](https://i.imgur.com/tYSNBmp.jpg)\\n\\n儘管第一天遇到了那些不愉快的事，但是吃過網易餐廳的菜，還有杭州友人和我一起去吃得杭州菜之後，我也忘記那些事情了。\\n\\n![:p](https://i.imgur.com/0gVyruv.png)\\n\\n## 後記\\n最後再一次感謝網易。我感覺杭州是一個好地方，不管是空氣，還是食物，我也覺得很好。\\n\\n對於網易雲音樂，我最喜歡的是每日歌曲推薦和評論區系統。它的算法也是蠻準確的，雖然我不是很懂算法，但是每天能夠聽到不同的歌曲，然後收藏一個，也是覺得蠻開心的。我每天都要利用網易雲音樂，聽日文歌曲。尤其是寫代碼，或者寫博客文章的時候，更加是要不斷聽我喜歡的音樂裡面的歌曲。\\n\\n如果你在 2018 年之後要來杭州的話，可以找一下我。\\n\\n說到這裡，歡迎來到實力至上的世界。\\n\\n![](https://i.imgur.com/4Ltl87d.png)\\n\\n## 備註\\nHexo 框架有問題：當文章長度有一定長度，而且中英文混合的時候，`hexo serve` 會有亂碼問題。原因是 Node.js buffer 問題。。。\\n\\n本文已參加[掘金秋招征文](https://juejin.im/post/59aa744ff265da247c4f145c)。\\n\",\"tags\":\"callback, JavaScript, async, interview\"}},{\"node\":{\"title\":\"異步操作見聞錄\",\"createdDate\":\"2017-09-27T20:00+08:00\",\"url\":\"async-summary\",\"headerImgur\":\"KMksHxZ.png\",\"content\":\"## 前言\\n異步操作是非常常見的操作，也是其中一題常見的前端工程師面試題目。在日常開發中，我們會和伺服器交互，或者是和用戶的行動作出反應，比如說監聽某些點擊事件。這個時候，其實我們是執行了異步操作，我們需要等待對方若干時間才能收到返回值，甚至是一個錯誤的值。。。因此，異步操作很容易產生一些誤會。這裡，我會說一下異步操作，及其返回的處理方法。\\n\\n## 同步與異步的分別\\n\\n在同步的世界裡面，我們希望執行某些操作之後，就能夠馬上拿到返回的值，然後執行下一步。然而，當我們發出 HTTP 請求的時候，我們可能需要等待世界的另外一端返回信息，這需要時間，便不是同步了。。。\\n\\n如果沒有異步的話，當你發出 HTTP 請求的時候，瀏覽器需要等待伺服器返回才執行下一步。這就是代表瀏覽器會卡住。。。\\n\\n異步處理，簡單來說就是我們發出了一個行動，但是不是馬上得到結果，我們會繼續執行後面的指令，等到函數裡面有一個返回，我們才拿那個返回值來使用。最簡單的說法，就是我們向服務器發出請求，但是服務器需要時間處理，並且返回處理過的內容。\\n\\n## 異步操作處理方法\\n1. Callback\\n1. Promise （思想）\\n1. Generator\\n1. Async await （推薦）\\n\\n### Callback\\n\\n我們看一下維基百科上面對於 Callback 的說明：\\n\\n> 在電腦程式設計中，回呼函式，或簡稱回呼（Callback 即call then back 被主函數呼叫運算後會返回主函數），是指通過函數參數傳遞到其它代碼的，某一塊可執行代碼的參照。這一設計允許了底層代碼呼叫在高層定義的子程式。\\n\\n這樣好像說得蠻複雜的，但其實很簡單，你把一個函數 cb (Function) 作為參數 (Argument)傳進這個函數 B 裡面，然後在函數 B 使用函數 cb。\\n\\n```\\nfunction func(x, cb) {\\n  cb(x)\\n}\\n```\\n\\n舉個例子，比如我們要在 Node.js 裡面讀取一個檔案，我們的代碼會是下面這樣的：\\n\\nhello.txt:\\n```\\nHello World, I'm Calpa Liu.\\n```\\n---\\nindex.js:\\n```\\nvar fs = require('fs');\\n\\nfs.readFile('hello.txt', function (err, data) {\\n     if (err) {\\n          return console.error(err);\\n     }\\n\\n     console.log(data);\\n});\\n\\nconsole.log('Finished');\\n```\\n\\n\\n我們會在 callback 裡面處理 callback，也就是一個回調裡面做另外一件事情，那可能是另外一個 callback，那麼你可以想象一下，我們越寫越深。。。這樣有兩個問題，第一：代碼的耦合性會很高，不容易去拆分代碼；第二：代碼的維護性很差。\\n\\n![Imgur](https://i.imgur.com/bjHDvVN.jpg)\\n\\n\\n### Promise\\n\\nPromise 是說如果你做了 A 的事情，成功了就做 B，不成功就做 C，你還可以繼續做 D 的事情，然後進行成功和不成功的處理。這樣說可能比較虛，但是你看一下 MDN 上面的圖就會明白了。\\n\\n![Promise - MDN](https://i.imgur.com/w9BxjmL.png)\\n\\n一個發射子彈的動作可以這樣寫：\\n\\n```\\nvar fire = new Promise(function(resolve, reject) {\\n     setTimeout(function() {\\n          resolve('已命中三千里外的目標');\\n     }, 3000)\\n});\\n\\nfire.then(function(result) {\\n     console.log(result);\\n});\\n```\\n\\n你可以在 Windows 平台按 F12 或 Ctrl + Shift + I，或在 Mac 上 按 Cmd + Opt + I，打開 Google Chrome Developer Tools ，然後在 Console 貼上上面的代碼，三秒後就會輸出`已命中三千里外的目標`。\\n\\n你也可以在 then() 裡面寫 1個到 N個的 Promise。\\n\\n```\\nvar fire = new Promise(function(resolve, reject) {\\n     setTimeout(function() {\\n          resolve('已命中三千里外的目標');\\n     }, 3000)\\n});\\n\\nfire.then(function(result) {\\n     console.log(result);\\n     console.log('正在返回司令部');\\n     return fire.then(function (result) {\\n          console.log(result);\\n     });\\n});\\n```\\n\\n### Generator\\n\\nGenerator 其實是一個狀態機，內部保存機器的運行狀態。我們透過獲取機器的完成狀態 (done)，我們能夠重複調用機器。我們可以使用 yield 暫停一個函數，並跳出函數。從外面的角度來看，我們可以從上而下去寫代碼，但是代碼會複雜，難以理解。\\n\\n雖然它已經寫進 ECMAScript 2015 的正式規範裡面，但是我不太喜歡使用 Generator。我們簡單看一下 Generator 就好了，因為現在是 2017 年，異步操作的有更加好的處理方法。\\n\\n```\\nfunction* gen() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nvar g = gen(); // \\\"Generator { }\\\"\\ng; //\\ng.next(); // {value: 1, done: false}\\ng.next(); // {value: 2, done: false}\\ng.next(); // {value: 3, done: false}\\ng.next() // {value: undefined, done: true}\\n```\\n\\n### Async/Await\\n\\n對於技術的要求，是無止境的。為了寫出更加優美的代碼，你又可以付出什麼的代價呢？\\n\\n如果你沒有試過 Async/Await 的話，那麼你就應該試一下，因為實在是太優雅了。\\n\\n這里我就放出一段現在博客在用的代碼：\\n\\n```\\nasync const getPosts = () => {\\n  await res = axios.get('https://calpa.me/posts');\\n  return res.data;\\n}\\n```\\n\\n我們簡單的讀一下這段代碼：\\n\\n一個異步的不變量 `getPosts` 是一個箭頭函數，內部操作為等待 axios 的 GET 請求到地址：[http://calpa.me](https://calpa.me)，並返回伺服器返回的資料。\\n\\n這是一個非常簡單的異步操作吧，但是如果是這樣的呢？\\n```\\nasync const getUserData = () => {\\n  await posts = axios.get('https://calpa.me/posts');\\n  await accountInfo = axios.get('https://calpa.me/about');\\n  /* ... */\\n}\\n```\\n\\n如果你想要使用 Async / Await 的話，可以使用\\n[Node.js 7.6](https://www.infoq.com/news/2017/02/node-76-async-await) 或以上的版本。例如使用 nvm 安裝 v8: `nvm install v8`，然後 `nvm use v8`。\\n\\n另外，如果你不想更新 Node 版本的話，你可以安裝 [async 工具庫](https://caolan.github.io/async/)。\\n\\n\\n## 感想\\n異步操作已經成為了前端工程師面試常見的問題之一，感覺是對於前端工程師的技術水平需求越來越提高了。雖然這些都是在 MDN 上面寫好的介紹，但是只有自己用過才會知道什麼比較好。\\n\\n如果公司的 Node 版本可以支持 Async/Await 的話，那就直接用 Async/Await 就好了。不行的話，那就用 Promise 吧，不然 Generator 的設計對於強迫症患者來說很不順眼。。。\\n\\n## 參考資料\\n1. [Callback (computer programming) - Wikipedia](https://en.wikipedia.org/wiki/Callback)\\n1. [Promise - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\\n1. [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\\n1. [async function - JavaScript MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\\n\",\"tags\":\"Front End, JavaScript\"}},{\"node\":{\"title\":\"React-markdown -- 實時渲染 Markdown 的 React 工具\",\"createdDate\":\"2017-08-31T20:00+08:00\",\"url\":\"react-markdown-render-markdown-as-component\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"## 前言\\n\\n要寫出優雅的文檔是有難度的，尤其是需要格式規範的文章。而利用 Markdown，則可以專心寫作。Markdown 除了可以直接編譯為 HTML，還能編譯為 PowerPoint, Resume，還有 React 組件。無論是[利用 Markdown 製作 PowerPoint](https://calpa.me/2017/06/01/create-markdown-powerpoint-in-5-mins/)，還是利用 Markdown 製作簡歷，都是非常方便的。如果你不是很熟悉 Markdown 語法的話，你可以在下文看 [Markdown 語法](#Markdown-語法)。但是如果可以接受他人傳進來的 Markdown 文章，然後渲染他們的文章，那就會更加好。所以我就找了一下 React + Markdown 的組合，發現這個 React-markdown 工具下載的人數蠻多的。雖然那個項目還在開發階段，但是你可以在 [Live Demo](http://rexxars.github.io/react-markdown) 測試一下渲染為 React 組件的效果。\\n\\n---\\n\\n![Live Demo](https://i.imgur.com/UFkBeEN.png)\\n\\n![直接渲染為 React 組件](https://i.imgur.com/q2q2RJv.png)\\n\\n## react-markdown\\n\\nGithub: https://github.com/rexxars/react-markdown\\nnpmjs: https://www.npmjs.com/package/react-markdown\\n\\n### 安裝\\n```\\nnpm install --save react-markdown\\n```\\n\\n### 使用方法\\n使用 ES6 Import `ReactMarkdown`，然后使用 <ReactMarkdown />，並傳入 Markdown 到 source。\\n\\n```js\\nimport ReactMarkdown from 'react-markdown';\\n\\nconst input = '# This is a header\\\\n\\\\nAnd this is a paragraph';\\n\\n<ReactMarkdown source={input} />\\n```\\n\\n然後你會看到這樣的：\\n\\n![React Markdown 例子](https://i.imgur.com/zR2Olai.png)\\n\\n官網上是這樣說的：\\n```js\\nvar React = require('react');\\nvar ReactDOM = require('react-dom');\\nvar ReactMarkdown = require('react-markdown');\\n\\nvar input = '# This is a header\\\\n\\\\nAnd this is a paragraph';\\n\\nReactDOM.render(\\n    <ReactMarkdown source={input} />,\\n    document.getElementById('container')\\n);\\n```\\n\\n### Webpack 1 配置\\n\\n如果你是用 Webpack 1 的話，你需要安裝 json-loader：\\n```\\nnpm install --save json-loader\\n```\\n\\n並在你的 webpack 設置裡面加上：\\n\\n```js\\n{\\n  module: {\\n    loaders: [{\\n      test: /\\\\.json$/,\\n      loader: 'json-loader'\\n    }]\\n  }\\n}\\n```\\n\\n如果你設置 `escapeHtml` 或 `skipHtml` 為 `true`，該組件就不會使用`dangerouslySetInnerHTML`。\\n\\n### 選項\\n\\n以下選項除了`source`之外都是可選的，其實這個工具已經配置成開箱即用，這裡就說幾個最底部的選項，更多的選項請去官網看。\\n\\n* `source` - 你的 Markdown 來源（必須）- string\\n* `className` - 容器的 className - string\\n* `containerTagName` - 容器的標籤名字 ，因為 Markdown 會有很多不同層次的 elements，容器需要把它們封裝。默認是`div` - string\\n\\n這個渲染器會渲染的組件有：\\n\\n* `HtmlInline` - 行內 HTML\\n* `HtmlBlock` - HTML 塊\\n* `Text` - 文字 (在段落裡面)\\n* `Paragraph` - 段落 (`<p>`)\\n* `Heading` - 標題 (`<h1>`, `<h2>` etc)\\n* `Softbreak` - 換行\\n* `Hardbreak` - 斷行（強制換行） (`<br>`)\\n* `Link` - 鏈接 (`<a>`)\\n* `Image` - 圖像 (`<img>`)\\n* `Emph` - 強調 (`<em>`)\\n* `Code` - Inline code nodes (`<code>`)\\n* `CodeBlock` - Blocks of code (`<code>`)\\n* `BlockQuote` - 參照 (`<blockquote>`)\\n* `List` - 列表 (`<ol>`, `<ul>`)\\n* `Item` - 列表 (`<li>`)\\n* `Strong` - Strong/bold nodes (`<strong>`)\\n* `ThematicBreak` - 水平分割線 (`<hr>`)\\n\\n## Markdown 語法\\n\\nMarkdown 的目標是易讀易寫，而它能夠幫助程序員專注開發，減少編寫文檔時候遇到的格式問題。Markdown 和 HTML 的寫法差不多，雖然 HTML 已經很容易寫，但是 Markdown 則是更加格式化，如果你直接閱讀 Markdown 文檔，你也可以想象到它渲染後的樣式。\\n\\n### 標題\\n```\\n# H1\\n## H2\\n### H3\\n```\\n\\n### 清單\\n無序清單使用`*`, `+` 或`-`，而我這是常用`-`\\n```\\n*   Red\\n*   Green\\n*   Blue\\n\\n+   Red\\n+   Green\\n+   Blue\\n\\n-   Red\\n-   Green\\n-   Blue\\n```\\n有序清單則使用數字接著一個英文句點：\\n```\\n1.  Apple\\n2.  Banana\\n3.  Watermelon\\n```\\n\\n## 後記\\n\\n順帶說一下，我的博客已經配置好 Service Worker，現在可以離線訪問網站。也就是下次訪問的時候，即使沒有 Wifi 或者連接到網絡，你也能夠瀏覽到文章內容。\\n\\n有機會的話，我會說說如何配置 Service Worker，以及當中的原理。\\n\\n我的簡歷也差不多重構一次了（逃。。。\\n\",\"tags\":\"React, Markdown, 工具\"}},{\"node\":{\"title\":\"React 應用輕量化（一）Source Map\",\"createdDate\":\"2017-08-27T10:03+08:00\",\"url\":\"react-app-optimization-1-source-map\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"\\n`create-react-app` 提供了很方便的創建 React 應用途徑。它已經把 webpack, Babel, Autoprefixer, ESLint, Jest 等常用工具打包進去。可以說是一個非常方便，好用的製造 React 應用工具。當我打算把包裝好的檔案推上去的時候，我卻發現打包之後的檔案大小有點大，因此我就開始優化這個網頁應用了。第一點我優化的地方就是 Source Map。\\n\\n如果你細心看 README.md 的話，你會發現下面這一句，它把 Source Map 也打包進去。。。\\n\\n> A build script to bundle JS, CSS, and images for production, with sourcemaps.\\n\\n在測試環境中，我們可以透過 sourcemap 找到 bundle 過後的對應項目組件，這個是蠻方便的。\\n\\n但是，在生產環境中，如果有 sourcemap 的話，就會直接暴露項目中的架構，以及檔案，同時會增加網站大小。。。\\n\\n## 解決方法\\n### 快速方法\\n排除 `*.map`，避免部署 sourcemap 到上面。。。\\n\\n這個方法並不能從根源解決問題，因為產生 sourcemap 需時較長，另外，也會產生一個不需要的檔案大小略大的 sourcemap 檔案。\\n\\n### 徹底方法\\n\\n1. `npm run eject`，如果你沒有 Eject 過的話。\\n\\nEject 是一個特殊命令，把 `create-react-app` 的懶人包變成自定義的項目。在 Eject 之前，請想清楚你是否需要掌握項目的每一個細節。\\n\\n對應日新月異的產品需求以及開發需求，我選擇 Eject。比如說 SCSS，CSS 模組化。\\n\\n2. 用你喜歡的文字編輯器 或 IDE 打開 `/config/webpack.config.prod.js`\\n\\n3. 刪除或注釋第五十三行 `devtool: 'source-map'`\\n\\n在上面你可以看到這樣的注釋：\\n> // We generate sourcemaps in production. This is slow but gives good results.\\n> // You can exclude the *.map files from the build during deployment.\\n\\n它這裡寫就是說產生 sourcemap 會給出好的結果，雖然產生時間會更加長。。。\\n\\n另外，你可以排除 `*.map`，避免部署 Source Map 到上面。。。\\n\\n## 參考資料\\n1. [create-react-app README](https://github.com/facebookincubator/create-react-app)\\n1. [Disable webpack production sourcemaps](https://github.com/facebookincubator/create-react-app/issues/2005)\\n\",\"tags\":\"React, 前端\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":12}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-2.json\n// module id = 1047\n// module chunks = 135728916539164"],"sourceRoot":""}