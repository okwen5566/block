{"version":3,"sources":["webpack:///path---page-5-8e89de0fd9a192f36bbd.js","webpack:///./.cache/json/page-5.json"],"names":["webpackJsonp","1050","module","exports","data","latestPosts","totalCount","edges","node","title","url","createdDate","pagePosts","headerImgur","content","tags","pathContext","limit","skip"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,WAAA,GAAAC,QAA0BC,MAAQC,MAAA,wCAAAC,IAAA,qBAAAC,YAAA,4BAAqHH,MAAQC,MAAA,kEAAAC,IAAA,qCAAAC,YAAA,4BAA+JH,MAAQC,MAAA,OAAAC,IAAA,kBAAAC,YAAA,4BAAiFH,MAAQC,MAAA,yCAAAC,IAAA,+BAAAC,YAAA,4BAAgIH,MAAQC,MAAA,kBAAAC,IAAA,gCAAAC,YAAA,4BAA0GH,MAAQC,MAAA,gCAAAC,IAAA,4CAAAC,YAAA,6BAAoIC,WAAcL,QAAUC,MAAQC,MAAA,sBAAAE,YAAA,yBAAAD,IAAA,4BAAAG,YAAA,cAAAC,QAAA,ygHAAg+GC,KAAA,WAA0MP,MAAQC,MAAA,UAAAE,YAAA,yBAAAD,IAAA,qCAAAG,YAAA,KAAAC,QAAA,49BAAAC,KAAA,uBAA2nCP,MAAQC,MAAA,gBAAAE,YAAA,yBAAAD,IAAA,oCAAAG,YAAA,KAAAC,QAAA,68FAA8oFC,KAAA,SAAqdP,MAAQC,MAAA,kBAAAE,YAAA,yBAAAD,IAAA,0BAAAG,YAAA,KAAAC,QAAA,6zCAAk7CC,KAAA,gBAAgCP,MAAQC,MAAA,qBAAAE,YAAA,yBAAAD,IAAA,4BAAAG,YAAA,cAAAC,QAAA,wvBAA8oBC,KAAA,uBAAoRP,MAAQC,MAAA,gBAAAE,YAAA,yBAAAD,IAAA,6BAAAG,YAAA,KAAAC,QAAA,4bAAAC,KAAA,eAAklBC,aAAgBC,MAAA,EAAAC,KAAA","file":"path---page-5-8e89de0fd9a192f36bbd.js","sourcesContent":["webpackJsonp([10891958300999],{\n\n/***/ 1050:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"React 組件生命週期 - 加載組件\",\"createdDate\":\"2017-05-16T22:40+08:00\",\"url\":\"react-component-lifecycle\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"## 組件\\n`React`提供`React.Component`，我們可以透過使用組件，拆分UI為可以重複使用的獨立部分。`React.Component`是一個抽象的base class。我們甚少直接運用`React.Component`，通常是透過創建一個子類，並使用`render()`方法。\\n\\n例子：\\n```JavaScript\\nclass Greeting extends React.Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n}\\n```\\n\\n如果你不選擇使用ES6，你可以使用模組`create-react-class`。你可以參考[React Without ES6](https://facebook.github.io/react/docs/react-without-es6.html)。\\n下面這一段和ES6的寫法效果一樣：\\n```JavaScript\\nvar createReactClass = require('create-react-class');\\nvar Greeting = createReactClass({\\n  render: function() {\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n});\\n```\\n\\n## 組件生命週期\\n\\n每一個組件都會有幾個生命週期的方法，你可以在程序運行的指定時間，透過覆蓋他們來運行特定代碼。對於這些方法，我們會用`will-`來表示它會在某些事情發生之前的一刻被調用，而`did-`則是表示它會在某些事情發生之後的一刻被調用。本文會細說加載組件中發生了什麼事情。\\n\\n### 加載 (Mounting)\\n1. `constructor()`\\n1. `componentWillMount()`\\n1. `render()`\\n1. `componentDidMount()`\\n\\n### 更新 (Updating)\\n當 props 或者 state 更新的時候，下面這些方法會被調用：\\n\\n1. componentWillReceiveProps()\\n1. shouldComponentUpdate()\\n1. componentWillUpdate()\\n1. render()\\n1. componentDidUpdate()\\n\\n### 斷開連接 (Unmounting)\\n當組件脫離DOM的時候，下面這個方法回被調用：\\n\\n1. componentWillUnmount()\\n\\n### 其他內置方法\\n1. setState()\\n1. forceUpdate()\\n\\n我們會在下文討論一下React是如何加載組件。\\n\\n{% img /img/react-mount.svg 300 auto React LifeCycle Mount %}\\n\\n#### constructor()\\n```JavaScript\\nconstructor(props)\\n```\\n\\n在React加載組件之前，它會調用`constructor`。你可以在`constructor`中去賦予組件的初始`state`。如果你使用`props`創造初始`state`的話，這也是可以接受的。這會很有效地`fork`組件的`props`，然後賦予初始`state`的值。\\n\\n有效的`constructor`例子：\\n```JavaScript\\nconstructor(props) {\\n  super(props);\\n  this.state = {\\n    color: props.initialColor\\n  };\\n}\\n```\\n\\n##### 注意事項\\n1. 如果你不需要賦予初始`state`，你不需要在 React 的組件中植入`constructor`。\\n1. 當你使用在`React.Component`的子類中加載`constructor()`方法時，你應該第一時間調用`super(props)`，而不是在任何statement之後。不然，我們獲取`this.props`值的時候，它會是`undefined`。\\n1. 在一些類似上面的例子，`state`未必會及時與任何的`props`更新。如果你需要同步`state`的話，你其實是想要[lift the state up](https://facebook.github.io/react/docs/lifting-state-up.html)。\\n\\n#### componentWillMount()\\n```JavaScript\\ncomponentWillMount()\\n```\\n\\n它會在組件`render()`之前執行一次，然後不能再執行。如果在這裡定義了`setState`方法，頁面只會在加載之前更新一次，不會重複渲染。React 官方推薦使用`constructor()`代替這個方法。\\n\\n#### render()\\n`React.Component`必須有這個方法，即使你返回`null`，或者`false`。當你返回`null`，或者`false`的時候，`ReactDOM.findDOMNode(this)` 會返回`null`。\\n\\n當它被調用的時候，它會檢查`this.props`和`this.state`，然後返回一個單獨的 React 元素。這個元素會是一個純正的`DOM`組件，例如<div />，或者自定義的 composite 組件。\\n\\n##### 注意事項\\n1. `render()`方法應該是`pure`：它不會改寫任何組件的`state`。每一次調用它都會返回同樣的結果。它不會直接接觸到瀏覽器層面。\\n1. 如果你需要接觸到瀏覽器層面，你應該在`componentDidMount()`或者其他生命週期方法中接觸瀏覽器。\\n1. 保持`render()`方法 pure 來讓組件更加容易被人理解。\\n\\n#### componentDidMount()\\n```JavaScript\\ncomponentDidMount()\\n```\\n\\n它會在組件加載之後執行一次。如果你的初始程序需要DOM nodes，你應該在這裡寫。如果你需要從其他地方加載資料，這裡也是一個不錯的地方去執行網絡請求。如果在這裡定義了`setState`方法，會觸發重複渲染。\\n\\n#### 測試代碼\\n```JavaScript\\nclass Greeting extends React.Component {\\n  _log(method, args) {\\n    console.log(method, args);\\n  }\\n\\n  constructor(props) {\\n    super(props);\\n    console.log('constructor', props);\\n  }\\n\\n  render() {\\n    this._log('render', this.props.name);\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n\\n  componentWillMount() {\\n    this._log('componentWillMount');\\n  }\\n\\n  componentDidMount() {\\n    this._log('componentDidMount');\\n  }\\n}\\n\\nReactDOM.render(\\n  <Greeting name=\\\"Calpa\\\" />,\\n  document.getElementById('app')\\n);\\n```\\n\\nConsole Output:\\n```\\n\\\"constructor\\\" Object {\\n  name: \\\"Calpa\\\"\\n}\\n\\\"componentWillMount\\\" undefined\\n\\\"render\\\" \\\"Calpa\\\"\\n\\\"componentDidMount\\\" undefined\\n```\\n\\n你可以在[CodePen](https://codepen.io/calpa/full/xdJrQm/)中獲取，並測試這段代碼。\\n\\n不知道拿哪一張當封面好。。。\\n\",\"tags\":\"React\"}},{\"node\":{\"title\":\"初探正則表達式\",\"createdDate\":\"2017-05-06T20:13+08:00\",\"url\":\"introduction-to-regular-expression\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n正則表達式是一個非常簡單的語法，但它也是神兵利器，可以說是程序員必須要理解的工具之一。它就像一本會不斷成長的寶刀，隨著程序員對它的理解，它的威力也跟著增強。\\n\\n一些當下熱門的編輯器(Atom, Sublime)或者 IDE (WebStorm)都支持正則表達式尋找。如果你有瞭解過JavaScript中的方法 (exec, test, match, search, replace, split)的話，做下面的題目時會更加得心應手。\\n\\n## 任務目的\\n1. 掌握正則表達式編寫規則\\n1. 瞭解正則表達式的特殊字元\\n1. 瞭解JavaScript提供的正則表達式相關方法\\n1. 能用正則表達式做一些簡單文本或者數字校驗\\n\\n## 任務描述\\n1. 編寫一個匹配URL的正則表達式，測試用例參照但不限於：\\n```\\nhttps://calpa.me/2017/05/06/introduction-to-regular-expression/\\nhttps://google.com\\nhttps://github.com/leviding/T-Plan/blob/master/tasks/task0005/README.md\\nhttp://blog.csdn.net/\\n```\\n\\n1. 編寫一個驗證電子郵箱地址的正則表達式，測試用例參照但不限於：\\n```\\nmyEmail@gmail.com\\nsteve.jobs@apple.com\\n```\\n完成任務之後，可以對比別人的實現方案，但不建議未嘗試就直接搜索答案。\\n在正則表達式的世界中，一個問題往往不止一種方案，可以嘗試多種方法。\\n\\n\\n## 提示\\n你可以想利用一些工具，例如在線的正則表達式工具 ([RegExr](http://regexr.com/), [Regex101](https://regex101.com/))來幫助學習、編寫正則表達式。\\n\\n## 參考資料\\n1. [MDN Regular Expressions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions): 瞭解JavaScript中正則表達式的基本知識\\n\",\"tags\":\"Regex, JavaScript\"}},{\"node\":{\"title\":\"CSS 垂直置中的4種方法\",\"createdDate\":\"2017-05-06T12:59+08:00\",\"url\":\"css-vertical-horizontal-alignment\",\"headerImgur\":null,\"content\":\"這是一道送分題，如果想要垂直置中元素的話，起碼會有四種方法：**padding**, **line-height**, **table** 和 **Flexbox**。使用Flexbox的話，日後要更改元素的位置會非常方便。\\n\\n## padding\\n如果你要置中的元素是`inine`或者是`inline-*`的話，比如說文字和鏈接，你可以用**padding**來實現垂直置中：\\n```\\n.vCenter {\\n  padding-top: 30px;\\n  padding-bottom: 30px;\\n  background: #eee;\\n  text-align: center;\\n}\\n```\\n因為`padding-top`和`padding-bottom`的數值是一樣，所以我們可以透過這個方法來實現垂直置中。\\n<iframe height='265' scrolling='no' title='padding 垂直置中' src='//codepen.io/calpa/embed/pPdowv/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/pPdowv/'>padding 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## line-height\\n```\\n.anotherCenter {\\n  height: 100px;\\n  line-height: 100px;\\n  background: #6cf;\\n  text-align: center;\\n}\\n```\\n如果你不想用`padding`來實現垂直置中的話，你可以利用`line-height`等於`height`。\\n\\n<iframe height='265' scrolling='no' title='line-height 垂直置中' src='//codepen.io/calpa/embed/JNOjJJ/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/JNOjJJ/'>line-height 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## table\\n\\n你可以透過`valign`來控制位置。\\n\\n另外，你可以利用`display: table-cell`來改變顯示的方式。\\n```\\n.fakeTable {\\n  height: 200px;\\n  width: 200px;\\n  display: table-cell;\\n  border: 1px solid black;\\n  text-align: center;\\n  vertical-align: middle;\\n}\\n```\\n\\n<iframe height='265' scrolling='no' title='Table 垂直置中' src='//codepen.io/calpa/embed/xdPxLr/?height=265&theme-id=0&default-tab=html,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/calpa/pen/xdPxLr/'>Table 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## Flexbox\\n另外，你也可以使用**Flexbox**來實現垂直置中，只需要寫justify-content和align-items就可以了。\\n```\\n.vertical-center {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n```\\n<iframe height='265' scrolling='no' title='FlexBox 垂直置中' src='//codepen.io/calpa/embed/NjwWjV/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/NjwWjV/'>FlexBox 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## 延伸閱讀\\n1. [A Complete Guide to Flexbox | CSS-Tricks](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\\n1. [Using CSS Flexible Boxes - CSS | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes)\\n\",\"tags\":\"CSS\"}},{\"node\":{\"title\":\"JavaScript 數組去重\",\"createdDate\":\"2017-05-05T22:53+08:00\",\"url\":\"javascript-array-unique\",\"headerImgur\":null,\"content\":\"顧著做化工模擬功課，差點忘記怎樣寫代碼。。。\\n\\n# 內置方法\\n使用JavaScript內置的去重複方法`Set()`，比如說：\\n\\n```\\nlet arr = [1, 2, 3, 3, 4, 5];\\nArray.from(new Set(arr)); // [1, 2, 3, 4, 5]\\n[...new Set(arr)]; // [1, 2, 3, 4, 5]\\n```\\n\\n## 第一時間會想到的方法\\n1. 雙重遍歷\\n1. 使用hash table\\n\\n## Underscore\\n最後來看一下underscore是如何實現unique()方法吧。\\n\\n```\\n_.uniq = _.unique = function(array, isSorted, iteratee, context) {\\n  // 如果數組不是已經排序\\n  if (!_.isBoolean(isSorted)) {\\n    // 將function(array, isSorted, iteratee, context)\\n    // 換成function(array, false, isSorted, iteratee)\\n    context = iteratee;\\n    iteratee = isSorted;\\n    isSorted = false;\\n  }\\n\\n  // 如果存在iteratee\\n  if (iteratee != null) iteratee = cb(iteratee, context);\\n  var result = [];\\n  var seen = [];\\n  for (var i = 0, length = getLength(array); i < length; i++) {\\n    var value = array[i],\\n        computed = iteratee ? iteratee(value, i, array) : value;\\n    // 如果已經排序，就直接增加數值(第一個值)。\\n    // 非0 就是 true\\n    // 或者see不是computed\\n    if (isSorted) {\\n      if (!i || seen !== computed) result.push(value);\\n      seen = computed;\\n    } else if (iteratee) {\\n      // 使用_.contains查詢數組裡面是否擁有這個值\\n      if (!_.contains(seen, computed)) {\\n        seen.push(computed);\\n        result.push(value);\\n      }\\n    } else if (!_.contains(result, value)) {\\n      result.push(value);\\n    }\\n  }\\n  return result;\\n};\\n```\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"Redux push()是怎樣寫的？\",\"createdDate\":\"2017-05-03T23:20+08:00\",\"url\":\"redux-array-push-function\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"本來你可以直接改寫原本的數組，比如利用這個方法：`arr.push(item)`。\\n但在Redux裡面不可以這樣寫，因為會改寫原本數組，違反了immutable的原則。\\n因此，要這樣寫： `arr: [...state.arr, action.newItem]`。\\n\\n例子：\\n```\\nimport { ADD_ITEM } from '../Actions/UserActions'\\nconst initialUserState = {\\n  arr: []\\n}\\n\\nexport default function userState(state = initialUserState, action) {\\n  console.log(arr);\\n  switch (action.type) {\\n    case ADD_ITEM:\\n      return {\\n        ...state,\\n        arr: [...state.arr, action.newItem]\\n      }\\n\\n    default:\\n      return state;\\n  }\\n}\\n```\\n\\n另外，你也可以利用`concat()`方法。\\n\\n## 參考資料\\n1. [How do I add an element to array in reducer of React native redux? - stackoverflow](http://stackoverflow.com/questions/40911194/how-do-i-add-an-element-to-array-in-reducer-of-react-native-redux)\\n\",\"tags\":\"JavaScript, Redux\"}},{\"node\":{\"title\":\"全自動製作 SVG 雪碧圖\",\"createdDate\":\"2017-05-02T16:51+08:00\",\"url\":\"how-to-generate-svg-sprite\",\"headerImgur\":null,\"content\":\"使用 SVG Sprite 的好處是可以減少 HTTP Request。\\n\\n## 製作方法\\n你可以選擇手動把一張一張圖合在一起，也可以使用`gulp-svg-sprite`自動生成雪碧圖。\\n\\n另外，你可以使用[svg-sprite設置](http://jkphl.github.io/svg-sprite/)幫助寫JSON, Node.js, Gruntfile 或者 Gulpfile的設定檔案。\\n\\n## 使用方法\\n其中一種方法是使用`<use>`。我們可以如同平常一樣使用svg，唯一分別是裡面的內容換成`<use>`，然後把鏈接加上id來調用圖像。\\n\\n```\\n<svg>\\n  <use href=\\\"img/sprite.svg#item\\\"></use>\\n</svg>\\n```\\n\\n\\n## 參考資料\\n[Github Repo: gulp-svg-sprite](https://github.com/jkphl/gulp-svg-sprite)\",\"tags\":\"SVG, 雪碧\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":30}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-5-8e89de0fd9a192f36bbd.js","module.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"React 組件生命週期 - 加載組件\",\"createdDate\":\"2017-05-16T22:40+08:00\",\"url\":\"react-component-lifecycle\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"## 組件\\n`React`提供`React.Component`，我們可以透過使用組件，拆分UI為可以重複使用的獨立部分。`React.Component`是一個抽象的base class。我們甚少直接運用`React.Component`，通常是透過創建一個子類，並使用`render()`方法。\\n\\n例子：\\n```JavaScript\\nclass Greeting extends React.Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n}\\n```\\n\\n如果你不選擇使用ES6，你可以使用模組`create-react-class`。你可以參考[React Without ES6](https://facebook.github.io/react/docs/react-without-es6.html)。\\n下面這一段和ES6的寫法效果一樣：\\n```JavaScript\\nvar createReactClass = require('create-react-class');\\nvar Greeting = createReactClass({\\n  render: function() {\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n});\\n```\\n\\n## 組件生命週期\\n\\n每一個組件都會有幾個生命週期的方法，你可以在程序運行的指定時間，透過覆蓋他們來運行特定代碼。對於這些方法，我們會用`will-`來表示它會在某些事情發生之前的一刻被調用，而`did-`則是表示它會在某些事情發生之後的一刻被調用。本文會細說加載組件中發生了什麼事情。\\n\\n### 加載 (Mounting)\\n1. `constructor()`\\n1. `componentWillMount()`\\n1. `render()`\\n1. `componentDidMount()`\\n\\n### 更新 (Updating)\\n當 props 或者 state 更新的時候，下面這些方法會被調用：\\n\\n1. componentWillReceiveProps()\\n1. shouldComponentUpdate()\\n1. componentWillUpdate()\\n1. render()\\n1. componentDidUpdate()\\n\\n### 斷開連接 (Unmounting)\\n當組件脫離DOM的時候，下面這個方法回被調用：\\n\\n1. componentWillUnmount()\\n\\n### 其他內置方法\\n1. setState()\\n1. forceUpdate()\\n\\n我們會在下文討論一下React是如何加載組件。\\n\\n{% img /img/react-mount.svg 300 auto React LifeCycle Mount %}\\n\\n#### constructor()\\n```JavaScript\\nconstructor(props)\\n```\\n\\n在React加載組件之前，它會調用`constructor`。你可以在`constructor`中去賦予組件的初始`state`。如果你使用`props`創造初始`state`的話，這也是可以接受的。這會很有效地`fork`組件的`props`，然後賦予初始`state`的值。\\n\\n有效的`constructor`例子：\\n```JavaScript\\nconstructor(props) {\\n  super(props);\\n  this.state = {\\n    color: props.initialColor\\n  };\\n}\\n```\\n\\n##### 注意事項\\n1. 如果你不需要賦予初始`state`，你不需要在 React 的組件中植入`constructor`。\\n1. 當你使用在`React.Component`的子類中加載`constructor()`方法時，你應該第一時間調用`super(props)`，而不是在任何statement之後。不然，我們獲取`this.props`值的時候，它會是`undefined`。\\n1. 在一些類似上面的例子，`state`未必會及時與任何的`props`更新。如果你需要同步`state`的話，你其實是想要[lift the state up](https://facebook.github.io/react/docs/lifting-state-up.html)。\\n\\n#### componentWillMount()\\n```JavaScript\\ncomponentWillMount()\\n```\\n\\n它會在組件`render()`之前執行一次，然後不能再執行。如果在這裡定義了`setState`方法，頁面只會在加載之前更新一次，不會重複渲染。React 官方推薦使用`constructor()`代替這個方法。\\n\\n#### render()\\n`React.Component`必須有這個方法，即使你返回`null`，或者`false`。當你返回`null`，或者`false`的時候，`ReactDOM.findDOMNode(this)` 會返回`null`。\\n\\n當它被調用的時候，它會檢查`this.props`和`this.state`，然後返回一個單獨的 React 元素。這個元素會是一個純正的`DOM`組件，例如<div />，或者自定義的 composite 組件。\\n\\n##### 注意事項\\n1. `render()`方法應該是`pure`：它不會改寫任何組件的`state`。每一次調用它都會返回同樣的結果。它不會直接接觸到瀏覽器層面。\\n1. 如果你需要接觸到瀏覽器層面，你應該在`componentDidMount()`或者其他生命週期方法中接觸瀏覽器。\\n1. 保持`render()`方法 pure 來讓組件更加容易被人理解。\\n\\n#### componentDidMount()\\n```JavaScript\\ncomponentDidMount()\\n```\\n\\n它會在組件加載之後執行一次。如果你的初始程序需要DOM nodes，你應該在這裡寫。如果你需要從其他地方加載資料，這裡也是一個不錯的地方去執行網絡請求。如果在這裡定義了`setState`方法，會觸發重複渲染。\\n\\n#### 測試代碼\\n```JavaScript\\nclass Greeting extends React.Component {\\n  _log(method, args) {\\n    console.log(method, args);\\n  }\\n\\n  constructor(props) {\\n    super(props);\\n    console.log('constructor', props);\\n  }\\n\\n  render() {\\n    this._log('render', this.props.name);\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n\\n  componentWillMount() {\\n    this._log('componentWillMount');\\n  }\\n\\n  componentDidMount() {\\n    this._log('componentDidMount');\\n  }\\n}\\n\\nReactDOM.render(\\n  <Greeting name=\\\"Calpa\\\" />,\\n  document.getElementById('app')\\n);\\n```\\n\\nConsole Output:\\n```\\n\\\"constructor\\\" Object {\\n  name: \\\"Calpa\\\"\\n}\\n\\\"componentWillMount\\\" undefined\\n\\\"render\\\" \\\"Calpa\\\"\\n\\\"componentDidMount\\\" undefined\\n```\\n\\n你可以在[CodePen](https://codepen.io/calpa/full/xdJrQm/)中獲取，並測試這段代碼。\\n\\n不知道拿哪一張當封面好。。。\\n\",\"tags\":\"React\"}},{\"node\":{\"title\":\"初探正則表達式\",\"createdDate\":\"2017-05-06T20:13+08:00\",\"url\":\"introduction-to-regular-expression\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n正則表達式是一個非常簡單的語法，但它也是神兵利器，可以說是程序員必須要理解的工具之一。它就像一本會不斷成長的寶刀，隨著程序員對它的理解，它的威力也跟著增強。\\n\\n一些當下熱門的編輯器(Atom, Sublime)或者 IDE (WebStorm)都支持正則表達式尋找。如果你有瞭解過JavaScript中的方法 (exec, test, match, search, replace, split)的話，做下面的題目時會更加得心應手。\\n\\n## 任務目的\\n1. 掌握正則表達式編寫規則\\n1. 瞭解正則表達式的特殊字元\\n1. 瞭解JavaScript提供的正則表達式相關方法\\n1. 能用正則表達式做一些簡單文本或者數字校驗\\n\\n## 任務描述\\n1. 編寫一個匹配URL的正則表達式，測試用例參照但不限於：\\n```\\nhttps://calpa.me/2017/05/06/introduction-to-regular-expression/\\nhttps://google.com\\nhttps://github.com/leviding/T-Plan/blob/master/tasks/task0005/README.md\\nhttp://blog.csdn.net/\\n```\\n\\n1. 編寫一個驗證電子郵箱地址的正則表達式，測試用例參照但不限於：\\n```\\nmyEmail@gmail.com\\nsteve.jobs@apple.com\\n```\\n完成任務之後，可以對比別人的實現方案，但不建議未嘗試就直接搜索答案。\\n在正則表達式的世界中，一個問題往往不止一種方案，可以嘗試多種方法。\\n\\n\\n## 提示\\n你可以想利用一些工具，例如在線的正則表達式工具 ([RegExr](http://regexr.com/), [Regex101](https://regex101.com/))來幫助學習、編寫正則表達式。\\n\\n## 參考資料\\n1. [MDN Regular Expressions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions): 瞭解JavaScript中正則表達式的基本知識\\n\",\"tags\":\"Regex, JavaScript\"}},{\"node\":{\"title\":\"CSS 垂直置中的4種方法\",\"createdDate\":\"2017-05-06T12:59+08:00\",\"url\":\"css-vertical-horizontal-alignment\",\"headerImgur\":null,\"content\":\"這是一道送分題，如果想要垂直置中元素的話，起碼會有四種方法：**padding**, **line-height**, **table** 和 **Flexbox**。使用Flexbox的話，日後要更改元素的位置會非常方便。\\n\\n## padding\\n如果你要置中的元素是`inine`或者是`inline-*`的話，比如說文字和鏈接，你可以用**padding**來實現垂直置中：\\n```\\n.vCenter {\\n  padding-top: 30px;\\n  padding-bottom: 30px;\\n  background: #eee;\\n  text-align: center;\\n}\\n```\\n因為`padding-top`和`padding-bottom`的數值是一樣，所以我們可以透過這個方法來實現垂直置中。\\n<iframe height='265' scrolling='no' title='padding 垂直置中' src='//codepen.io/calpa/embed/pPdowv/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/pPdowv/'>padding 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## line-height\\n```\\n.anotherCenter {\\n  height: 100px;\\n  line-height: 100px;\\n  background: #6cf;\\n  text-align: center;\\n}\\n```\\n如果你不想用`padding`來實現垂直置中的話，你可以利用`line-height`等於`height`。\\n\\n<iframe height='265' scrolling='no' title='line-height 垂直置中' src='//codepen.io/calpa/embed/JNOjJJ/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/JNOjJJ/'>line-height 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## table\\n\\n你可以透過`valign`來控制位置。\\n\\n另外，你可以利用`display: table-cell`來改變顯示的方式。\\n```\\n.fakeTable {\\n  height: 200px;\\n  width: 200px;\\n  display: table-cell;\\n  border: 1px solid black;\\n  text-align: center;\\n  vertical-align: middle;\\n}\\n```\\n\\n<iframe height='265' scrolling='no' title='Table 垂直置中' src='//codepen.io/calpa/embed/xdPxLr/?height=265&theme-id=0&default-tab=html,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/calpa/pen/xdPxLr/'>Table 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## Flexbox\\n另外，你也可以使用**Flexbox**來實現垂直置中，只需要寫justify-content和align-items就可以了。\\n```\\n.vertical-center {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n```\\n<iframe height='265' scrolling='no' title='FlexBox 垂直置中' src='//codepen.io/calpa/embed/NjwWjV/?height=265&theme-id=0&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/calpa/pen/NjwWjV/'>FlexBox 垂直置中</a> by Calpa Liu (<a href='http://codepen.io/calpa'>@calpa</a>) on <a href='http://codepen.io'>CodePen</a>.\\n</iframe>\\n\\n## 延伸閱讀\\n1. [A Complete Guide to Flexbox | CSS-Tricks](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\\n1. [Using CSS Flexible Boxes - CSS | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes)\\n\",\"tags\":\"CSS\"}},{\"node\":{\"title\":\"JavaScript 數組去重\",\"createdDate\":\"2017-05-05T22:53+08:00\",\"url\":\"javascript-array-unique\",\"headerImgur\":null,\"content\":\"顧著做化工模擬功課，差點忘記怎樣寫代碼。。。\\n\\n# 內置方法\\n使用JavaScript內置的去重複方法`Set()`，比如說：\\n\\n```\\nlet arr = [1, 2, 3, 3, 4, 5];\\nArray.from(new Set(arr)); // [1, 2, 3, 4, 5]\\n[...new Set(arr)]; // [1, 2, 3, 4, 5]\\n```\\n\\n## 第一時間會想到的方法\\n1. 雙重遍歷\\n1. 使用hash table\\n\\n## Underscore\\n最後來看一下underscore是如何實現unique()方法吧。\\n\\n```\\n_.uniq = _.unique = function(array, isSorted, iteratee, context) {\\n  // 如果數組不是已經排序\\n  if (!_.isBoolean(isSorted)) {\\n    // 將function(array, isSorted, iteratee, context)\\n    // 換成function(array, false, isSorted, iteratee)\\n    context = iteratee;\\n    iteratee = isSorted;\\n    isSorted = false;\\n  }\\n\\n  // 如果存在iteratee\\n  if (iteratee != null) iteratee = cb(iteratee, context);\\n  var result = [];\\n  var seen = [];\\n  for (var i = 0, length = getLength(array); i < length; i++) {\\n    var value = array[i],\\n        computed = iteratee ? iteratee(value, i, array) : value;\\n    // 如果已經排序，就直接增加數值(第一個值)。\\n    // 非0 就是 true\\n    // 或者see不是computed\\n    if (isSorted) {\\n      if (!i || seen !== computed) result.push(value);\\n      seen = computed;\\n    } else if (iteratee) {\\n      // 使用_.contains查詢數組裡面是否擁有這個值\\n      if (!_.contains(seen, computed)) {\\n        seen.push(computed);\\n        result.push(value);\\n      }\\n    } else if (!_.contains(result, value)) {\\n      result.push(value);\\n    }\\n  }\\n  return result;\\n};\\n```\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"Redux push()是怎樣寫的？\",\"createdDate\":\"2017-05-03T23:20+08:00\",\"url\":\"redux-array-push-function\",\"headerImgur\":\"IYhTVXU.png\",\"content\":\"本來你可以直接改寫原本的數組，比如利用這個方法：`arr.push(item)`。\\n但在Redux裡面不可以這樣寫，因為會改寫原本數組，違反了immutable的原則。\\n因此，要這樣寫： `arr: [...state.arr, action.newItem]`。\\n\\n例子：\\n```\\nimport { ADD_ITEM } from '../Actions/UserActions'\\nconst initialUserState = {\\n  arr: []\\n}\\n\\nexport default function userState(state = initialUserState, action) {\\n  console.log(arr);\\n  switch (action.type) {\\n    case ADD_ITEM:\\n      return {\\n        ...state,\\n        arr: [...state.arr, action.newItem]\\n      }\\n\\n    default:\\n      return state;\\n  }\\n}\\n```\\n\\n另外，你也可以利用`concat()`方法。\\n\\n## 參考資料\\n1. [How do I add an element to array in reducer of React native redux? - stackoverflow](http://stackoverflow.com/questions/40911194/how-do-i-add-an-element-to-array-in-reducer-of-react-native-redux)\\n\",\"tags\":\"JavaScript, Redux\"}},{\"node\":{\"title\":\"全自動製作 SVG 雪碧圖\",\"createdDate\":\"2017-05-02T16:51+08:00\",\"url\":\"how-to-generate-svg-sprite\",\"headerImgur\":null,\"content\":\"使用 SVG Sprite 的好處是可以減少 HTTP Request。\\n\\n## 製作方法\\n你可以選擇手動把一張一張圖合在一起，也可以使用`gulp-svg-sprite`自動生成雪碧圖。\\n\\n另外，你可以使用[svg-sprite設置](http://jkphl.github.io/svg-sprite/)幫助寫JSON, Node.js, Gruntfile 或者 Gulpfile的設定檔案。\\n\\n## 使用方法\\n其中一種方法是使用`<use>`。我們可以如同平常一樣使用svg，唯一分別是裡面的內容換成`<use>`，然後把鏈接加上id來調用圖像。\\n\\n```\\n<svg>\\n  <use href=\\\"img/sprite.svg#item\\\"></use>\\n</svg>\\n```\\n\\n\\n## 參考資料\\n[Github Repo: gulp-svg-sprite](https://github.com/jkphl/gulp-svg-sprite)\",\"tags\":\"SVG, 雪碧\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":30}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-5.json\n// module id = 1050\n// module chunks = 10891958300999"],"sourceRoot":""}