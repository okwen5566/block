{"version":3,"sources":["webpack:///path---page-8-adcdcd6ae712ae0ac731.js","webpack:///./.cache/json/page-8.json"],"names":["webpackJsonp","1053","module","exports","data","latestPosts","totalCount","edges","node","title","url","createdDate","pagePosts","headerImgur","content","tags","pathContext","limit","skip"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,WAAA,GAAAC,QAA0BC,MAAQC,MAAA,wCAAAC,IAAA,qBAAAC,YAAA,4BAAqHH,MAAQC,MAAA,kEAAAC,IAAA,qCAAAC,YAAA,4BAA+JH,MAAQC,MAAA,OAAAC,IAAA,kBAAAC,YAAA,4BAAiFH,MAAQC,MAAA,yCAAAC,IAAA,+BAAAC,YAAA,4BAAgIH,MAAQC,MAAA,kBAAAC,IAAA,gCAAAC,YAAA,4BAA0GH,MAAQC,MAAA,gCAAAC,IAAA,4CAAAC,YAAA,6BAAoIC,WAAcL,QAAUC,MAAQC,MAAA,0BAAAE,YAAA,yBAAAD,IAAA,kBAAAG,YAAA,KAAAC,QAAA,o3CAAujCC,KAAA,gBAAkdP,MAAQC,MAAA,wBAAAE,YAAA,yBAAAD,IAAA,0BAAAG,YAAA,KAAAC,QAAA,kQAAAC,KAAA,eAA4ZP,MAAQC,MAAA,uBAAAE,YAAA,yBAAAD,IAAA,oBAAAG,YAAA,KAAAC,QAAA,msBAAAC,KAAA,eAA81BP,MAAQC,MAAA,uBAAAE,YAAA,yBAAAD,IAAA,2BAAAG,YAAA,KAAAC,QAAA,ytDAAAC,KAAA,kBAAy3DP,MAAQC,MAAA,sBAAAE,YAAA,yBAAAD,IAAA,wBAAAG,YAAA,KAAAC,QAAA,q/BAAo+BC,KAAA,SAAqKP,MAAQC,MAAA,4BAAAE,YAAA,yBAAAD,IAAA,yBAAAG,YAAA,cAAAC,QAAA,4pBAAAC,KAAA,yBAA20BC,aAAgBC,MAAA,EAAAC,KAAA","file":"path---page-8-adcdcd6ae712ae0ac731.js","sourcesContent":["webpackJsonp([244335847057972],{\n\n/***/ 1053:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"深入理解 Javascript 中的 this\",\"createdDate\":\"2017-03-25T12:44+08:00\",\"url\":\"javascript-this\",\"headerImgur\":null,\"content\":\"首先我們要理解調用函數的方法，最起碼可以用下面兩個方法：\\n```JavaScript\\nfunc(arg1, arg2);\\nfunc.call(context, arg1, arg2);\\n```\\n之前我也沒怎麼見過後者，基本上都是直接call func的。後者`func(arg1, arg2)` 等於 `func.call(undefined, arg1, arg2)`。簡單來說，this就是context。如果context沒有定義的話，它會被定義為一個全局對象，比如說global。在MDN的文檔有這一句: `if the method is a function in non-strict mode code, null and undefined will be replaced with the global object and primitive values will be converted to objects`。\\n\\n如果不想要this是global的話，給予context一個對象就可以了：\\n`func.call(obj, arg1, arg2)`\\n\\n## 全局上下文\\n在全局中，無論是否在嚴格模式下(Strict mode)，`this`都是代表全局對象。\\n\\n### 瀏覽器\\n1. `this.document`指向`document`\\n1. 全局對象為`window`\\n\\n### Node.js\\n全局對象為`global`\\n\\n直接運用函數的話，this會指向global。\\n```JavaScript\\nfunction test() {\\n  this.x = 1;\\n}\\n\\ntest();\\n\\nconsole.log(this.x); // 1\\n```\\n\\n如果是生成一個對象的話，this會指向這個對象而不是global。\\n```JavaScript\\nfunction Car() {\\n  this.color = 'red';\\n}\\n\\nvar c = new Car();\\n\\nconsole.log(this.color); // undefined\\nconsole.log(c.color); // red\\n```\\n\\n下次遇到問題的話，我還是MDN資料吧，裡面寫得很詳細。\\n\\n## 問題\\n在Node.js中，為什麼this.global === this.global.global的返回值為true？\\n\\n## 延伸思考\\n1. Function.prototype.apply()和call()方法有什麼不同\\n1. Function.prototype.bind()\\n\\n## 參考資料\\n1. [this - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\\n1. [Function.prototype.call - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"Hexo 時代之更改 sitemap 域名\",\"createdDate\":\"2017-02-26T14:45+08:00\",\"url\":\"hexo-change-sitemap-url\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n如果沒有做任何配置的話，`hexo g`的時候會自動輸出一個`sitemap.xml`。\\n但是現在域名不同了，需要一點更改。。。\\n\\n## 方法\\n1. 打開_config.yml\\n1. 修改`url:`就可以了\\n1. `hexo clean`\\n1. `hexo g`\\n\\n## 參考資料\\n1. [hexo-generator-sitemap 生成的sitemap如何配置自定义的域名？](https://segmentfault.com/q/1010000004659915)\",\"tags\":\"Hexo, SEO\"}},{\"node\":{\"title\":\"添加 nofollow 屬性優化 SEO\",\"createdDate\":\"2017-02-25T22:00+08:00\",\"url\":\"hexo-seo-nofollow\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n我們的網頁通常會有很多鏈接，但是在爬蟲的時候可以分開哪一些是外部鏈接，哪一些是內部鏈接來優化搜尋結果。比如說增加`nofollow`標籤。nofollow是一個HTML標籤的屬性值，它可以告訴搜尋引擎不要追蹤這個鏈接。\\n\\n## 手動\\n我們可以手動把每一個鏈接都加上nofollow屬性，比如這樣：\\n```\\n<a href=\\\"https://github.com/calpa\\\" rel=\\\"nofollow\\\">Calpa的Github主頁</a>\\n<a href=\\\"https://github.com/calpa\\\" rel=\\\"external nofollow\\\">Calpa的Github主頁</a>\\n```\\n`external nofollow`是更加專業的寫法，告訴搜尋引擎這是一個外部鏈接。\\n\\n## 自動\\n我們也可以利用`hexo-autonofollow`插件來做這一件事情。\\n只需要輸入`npm install hexo-autonofollow --save`，然後在`_config.yml`裡面寫上下面就可以了：\\n```\\nnofollow:\\n    enable: true\\n    exclude:\\n    - exclude1.com\\n    - exclude2.com\\n```\\nexclude1.com和exclude2都是內部域名。\\n\\n## 參考資料\\n1. [Hexo优化之为外部链接添加nofollow\\n](https://liuzhichao.com/2016/hexo-auto-nofollow.html)\\n\",\"tags\":\"Hexo, SEO\"}},{\"node\":{\"title\":\"【教學】免費獲取 Github 教育禮包\",\"createdDate\":\"2017-02-23T10:00+08:00\",\"url\":\"github-education-package\",\"headerImgur\":null,\"content\":\"![Imgur](https://i.imgur.com/PmOA3IB.png?3)\\n\\n現在如果你看網址列的話，你會發現現在域名改成了`calpa.me`，而且加上了一個綠色的鎖。\\n\\n<img src=\\\"https://dwa5x7aod66zk.cloudfront.net/assets/sdp-backpack-a64038716bf134f45e809ff86b9611fb97e41bbd2ccfa3181da73cf164d3c200.png\\\" width=\\\"200px\\\" />\\n\\n## Github 禮包\\n如果你有學生身份的話，其中一個好處就是可以使用很多免費服務。比如說[Github Education](https://education.github.com/)禮包。它裡面有很多內容，但其中比較實用的有下面這些：\\n1. [AWS Educate](https://aws.amazon.com/?nc1=h_ls): Up to $110 in bonus AWS credits for a total of $75-$150\\n1. [Digital Ocean](https://www.digitalocean.com/): Cloud hosting\\n1. [Github](https://github.com/): Unlimited private repositories (normally $7/month) while you are a student.\\n1. [namecheap](https://www.namecheap.com/): One year domain name registration on the .me TLD (normally $18.99/year)\\n1. [Travis CI](https://travis-ci.org/): Private builds (normally $69/month) while you're a student\\n1. [UDACITY](https://www.udacity.com/): One month free access to any Nanodegree program (normally $199)\\n\\n既然namecheap提供一年免費`.me` 域名，不如我就用`calpa.me`取代之前`calpa.github.io`吧。\\n\\n## namecheap\\n在[namecheap](https://nc.me/)尋找`calpa.me`是否有人註冊，如果沒有的話就可以直接將.me加入購物車。\\n\\n![Imgur](https://i.imgur.com/24oQqGZ.png)\\n之後，在namecheap的dashboard會看到自己域名，然後點擊MANAGE按鈕。\\n\\n在Advanced DNS裡面，我們需要增加兩筆`A`記錄：\\n1. @ 192.30.252.153\\n1. @ 192.30.252.154\\n\\n之後利用`dig +noall +answer username.me`命令就可以看到記錄如上一樣。\\n\\n## HTTPS\\n如果要使用HTTPS，可以利用免費的Cloudflare服務。\\n1. 註冊Cloudflare\\n1. 打開namecheap的domain頁，將nameserver改成Custome DNS，然後加入`bella.ns.cloudflare.com`和`igor.ns.cloudflare.com`。\\n\\n## 感想\\n添加新的域名其實不難，只是需要很多時間去等待服務器修改DNS記錄。。。\\n\\n## 參考資料\\n1. [Configuring A records with your DNS provider - Github](https://help.github.com/articles/setting-up-an-apex-domain/#configuring-a-records-with-your-dns-provider)\",\"tags\":\"Github, Free\"}},{\"node\":{\"title\":\"初探 Web Notification\",\"createdDate\":\"2017-02-22T15:20+08:00\",\"url\":\"push-web-notification\",\"headerImgur\":null,\"content\":\"如果要推送通知的話，我們首先要請求權限：`Notification.requestPermission()`\\n\\n之後檢查`Notification.permission`來查看是否擁有權限。該值會是下面三個其中之一：\\n\\n1. default: 從未詢問用戶\\n1. granted: 用戶授權顯示通知的權限\\n1. denied: 用戶不授權。。。\\n\\n創造一個通知很簡單，`new Notification(text)`可以了。\\n```\\nvar text = \\\"Hello, world\\\";\\nnew Notification(text);\\n```\\n![Imgur](https://i.imgur.com/l1lVFXZ.png)\\n\\n沒有圖片的話會比較空虛，可以加入options。\\n\\n```\\nfunction push() {\\n  var title = \\\"這是一個標題。。。\\\";\\n\\tvar options = {\\n\\t\\tbody: \\\"Calpa 寫了一篇文章XD\\\",\\n\\t\\ticon: \\\"https://calpa.github.io/img/profile.png\\\"\\n\\t}\\n\\tvar n = new Notification(title, options);\\n}\\n\\npush();\\n```\\n![Imgur](https://i.imgur.com/uuNPUoB.png)\\n\\n如果要增加與用戶的互動，可以利用Notification的事件：\\n1. onshow\\n1. onclick\\n1. onclose\\n1. onerror\\n\\n我們可以監聽`onclick`，當用戶點擊通知，瀏覽器就會跳到目標頁面。\\n```\\nn.onclick = (event) => {\\n\\tevent.preventDefault();\\n\\twindow.open('https://calpa.github.io/', '_blank');\\n}\\n```\\n\\n## 參考資料\\n1. [Using the Notification API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API)\\n\",\"tags\":\"Web\"}},{\"node\":{\"title\":\"SuperCharger Hackathon 後記\",\"createdDate\":\"2017-02-19T15:12+08:00\",\"url\":\"supercharger-hackathon\",\"headerImgur\":\"7EMhgpx.jpg\",\"content\":\"![Imgur](https://i.imgur.com/7EMhgpx.jpg)\\n\\n如果計上這次比賽的話，我已經是第五次參加這一類編程比賽。與過往的比賽不同，合作的對象不再是大學生，而是兩間Start-up公司。在這次比賽中，我選擇[KYC-Chain](http://kyc-chain.com/)、[Clare.ai](https://www.clare.ai/)兩間公司組成的隊伍。KYC-Chain透過[Airtable](https://airtable.com/)提供一些常見的用戶問題與答案，而Clare.ai則負責寫code。\\n\\nAirtable有API教學，可以用node.js增加、移除、修改或者獲取資料。\\n\\n## 現有問題\\n如果用戶想了解一些資訊，他需要經過很多過程才能獲取答案。\\n\\n## 目的\\n利用Chatbot，用戶只需要說出自己的問題便能查詢資料，例如Identity Card，Regulatory Law等資訊。\\n\\n## 將來發展\\n1. 獲取申請表格\\n1. 自動填寫各類文件\\n\\n## 感想\\n我本來以為要從零開始架構一個Chatbot，原來可以直接用Api.ai。\\n大多數時間都是和一些在外面工作的人交流。。。\\n\\n## 參考資料\\n1. 我自己 XD\\n1. [SuperCharger FinTech Hackathon - Facebook 活動頁](https://www.facebook.com/events/704583943057523/)\\n\",\"tags\":\"前端, 閱讀, Hackathon\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":48}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-8-adcdcd6ae712ae0ac731.js","module.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"深入理解 Javascript 中的 this\",\"createdDate\":\"2017-03-25T12:44+08:00\",\"url\":\"javascript-this\",\"headerImgur\":null,\"content\":\"首先我們要理解調用函數的方法，最起碼可以用下面兩個方法：\\n```JavaScript\\nfunc(arg1, arg2);\\nfunc.call(context, arg1, arg2);\\n```\\n之前我也沒怎麼見過後者，基本上都是直接call func的。後者`func(arg1, arg2)` 等於 `func.call(undefined, arg1, arg2)`。簡單來說，this就是context。如果context沒有定義的話，它會被定義為一個全局對象，比如說global。在MDN的文檔有這一句: `if the method is a function in non-strict mode code, null and undefined will be replaced with the global object and primitive values will be converted to objects`。\\n\\n如果不想要this是global的話，給予context一個對象就可以了：\\n`func.call(obj, arg1, arg2)`\\n\\n## 全局上下文\\n在全局中，無論是否在嚴格模式下(Strict mode)，`this`都是代表全局對象。\\n\\n### 瀏覽器\\n1. `this.document`指向`document`\\n1. 全局對象為`window`\\n\\n### Node.js\\n全局對象為`global`\\n\\n直接運用函數的話，this會指向global。\\n```JavaScript\\nfunction test() {\\n  this.x = 1;\\n}\\n\\ntest();\\n\\nconsole.log(this.x); // 1\\n```\\n\\n如果是生成一個對象的話，this會指向這個對象而不是global。\\n```JavaScript\\nfunction Car() {\\n  this.color = 'red';\\n}\\n\\nvar c = new Car();\\n\\nconsole.log(this.color); // undefined\\nconsole.log(c.color); // red\\n```\\n\\n下次遇到問題的話，我還是MDN資料吧，裡面寫得很詳細。\\n\\n## 問題\\n在Node.js中，為什麼this.global === this.global.global的返回值為true？\\n\\n## 延伸思考\\n1. Function.prototype.apply()和call()方法有什麼不同\\n1. Function.prototype.bind()\\n\\n## 參考資料\\n1. [this - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\\n1. [Function.prototype.call - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"Hexo 時代之更改 sitemap 域名\",\"createdDate\":\"2017-02-26T14:45+08:00\",\"url\":\"hexo-change-sitemap-url\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n如果沒有做任何配置的話，`hexo g`的時候會自動輸出一個`sitemap.xml`。\\n但是現在域名不同了，需要一點更改。。。\\n\\n## 方法\\n1. 打開_config.yml\\n1. 修改`url:`就可以了\\n1. `hexo clean`\\n1. `hexo g`\\n\\n## 參考資料\\n1. [hexo-generator-sitemap 生成的sitemap如何配置自定义的域名？](https://segmentfault.com/q/1010000004659915)\",\"tags\":\"Hexo, SEO\"}},{\"node\":{\"title\":\"添加 nofollow 屬性優化 SEO\",\"createdDate\":\"2017-02-25T22:00+08:00\",\"url\":\"hexo-seo-nofollow\",\"headerImgur\":null,\"content\":\"## 前言\\n\\n我們的網頁通常會有很多鏈接，但是在爬蟲的時候可以分開哪一些是外部鏈接，哪一些是內部鏈接來優化搜尋結果。比如說增加`nofollow`標籤。nofollow是一個HTML標籤的屬性值，它可以告訴搜尋引擎不要追蹤這個鏈接。\\n\\n## 手動\\n我們可以手動把每一個鏈接都加上nofollow屬性，比如這樣：\\n```\\n<a href=\\\"https://github.com/calpa\\\" rel=\\\"nofollow\\\">Calpa的Github主頁</a>\\n<a href=\\\"https://github.com/calpa\\\" rel=\\\"external nofollow\\\">Calpa的Github主頁</a>\\n```\\n`external nofollow`是更加專業的寫法，告訴搜尋引擎這是一個外部鏈接。\\n\\n## 自動\\n我們也可以利用`hexo-autonofollow`插件來做這一件事情。\\n只需要輸入`npm install hexo-autonofollow --save`，然後在`_config.yml`裡面寫上下面就可以了：\\n```\\nnofollow:\\n    enable: true\\n    exclude:\\n    - exclude1.com\\n    - exclude2.com\\n```\\nexclude1.com和exclude2都是內部域名。\\n\\n## 參考資料\\n1. [Hexo优化之为外部链接添加nofollow\\n](https://liuzhichao.com/2016/hexo-auto-nofollow.html)\\n\",\"tags\":\"Hexo, SEO\"}},{\"node\":{\"title\":\"【教學】免費獲取 Github 教育禮包\",\"createdDate\":\"2017-02-23T10:00+08:00\",\"url\":\"github-education-package\",\"headerImgur\":null,\"content\":\"![Imgur](https://i.imgur.com/PmOA3IB.png?3)\\n\\n現在如果你看網址列的話，你會發現現在域名改成了`calpa.me`，而且加上了一個綠色的鎖。\\n\\n<img src=\\\"https://dwa5x7aod66zk.cloudfront.net/assets/sdp-backpack-a64038716bf134f45e809ff86b9611fb97e41bbd2ccfa3181da73cf164d3c200.png\\\" width=\\\"200px\\\" />\\n\\n## Github 禮包\\n如果你有學生身份的話，其中一個好處就是可以使用很多免費服務。比如說[Github Education](https://education.github.com/)禮包。它裡面有很多內容，但其中比較實用的有下面這些：\\n1. [AWS Educate](https://aws.amazon.com/?nc1=h_ls): Up to $110 in bonus AWS credits for a total of $75-$150\\n1. [Digital Ocean](https://www.digitalocean.com/): Cloud hosting\\n1. [Github](https://github.com/): Unlimited private repositories (normally $7/month) while you are a student.\\n1. [namecheap](https://www.namecheap.com/): One year domain name registration on the .me TLD (normally $18.99/year)\\n1. [Travis CI](https://travis-ci.org/): Private builds (normally $69/month) while you're a student\\n1. [UDACITY](https://www.udacity.com/): One month free access to any Nanodegree program (normally $199)\\n\\n既然namecheap提供一年免費`.me` 域名，不如我就用`calpa.me`取代之前`calpa.github.io`吧。\\n\\n## namecheap\\n在[namecheap](https://nc.me/)尋找`calpa.me`是否有人註冊，如果沒有的話就可以直接將.me加入購物車。\\n\\n![Imgur](https://i.imgur.com/24oQqGZ.png)\\n之後，在namecheap的dashboard會看到自己域名，然後點擊MANAGE按鈕。\\n\\n在Advanced DNS裡面，我們需要增加兩筆`A`記錄：\\n1. @ 192.30.252.153\\n1. @ 192.30.252.154\\n\\n之後利用`dig +noall +answer username.me`命令就可以看到記錄如上一樣。\\n\\n## HTTPS\\n如果要使用HTTPS，可以利用免費的Cloudflare服務。\\n1. 註冊Cloudflare\\n1. 打開namecheap的domain頁，將nameserver改成Custome DNS，然後加入`bella.ns.cloudflare.com`和`igor.ns.cloudflare.com`。\\n\\n## 感想\\n添加新的域名其實不難，只是需要很多時間去等待服務器修改DNS記錄。。。\\n\\n## 參考資料\\n1. [Configuring A records with your DNS provider - Github](https://help.github.com/articles/setting-up-an-apex-domain/#configuring-a-records-with-your-dns-provider)\",\"tags\":\"Github, Free\"}},{\"node\":{\"title\":\"初探 Web Notification\",\"createdDate\":\"2017-02-22T15:20+08:00\",\"url\":\"push-web-notification\",\"headerImgur\":null,\"content\":\"如果要推送通知的話，我們首先要請求權限：`Notification.requestPermission()`\\n\\n之後檢查`Notification.permission`來查看是否擁有權限。該值會是下面三個其中之一：\\n\\n1. default: 從未詢問用戶\\n1. granted: 用戶授權顯示通知的權限\\n1. denied: 用戶不授權。。。\\n\\n創造一個通知很簡單，`new Notification(text)`可以了。\\n```\\nvar text = \\\"Hello, world\\\";\\nnew Notification(text);\\n```\\n![Imgur](https://i.imgur.com/l1lVFXZ.png)\\n\\n沒有圖片的話會比較空虛，可以加入options。\\n\\n```\\nfunction push() {\\n  var title = \\\"這是一個標題。。。\\\";\\n\\tvar options = {\\n\\t\\tbody: \\\"Calpa 寫了一篇文章XD\\\",\\n\\t\\ticon: \\\"https://calpa.github.io/img/profile.png\\\"\\n\\t}\\n\\tvar n = new Notification(title, options);\\n}\\n\\npush();\\n```\\n![Imgur](https://i.imgur.com/uuNPUoB.png)\\n\\n如果要增加與用戶的互動，可以利用Notification的事件：\\n1. onshow\\n1. onclick\\n1. onclose\\n1. onerror\\n\\n我們可以監聽`onclick`，當用戶點擊通知，瀏覽器就會跳到目標頁面。\\n```\\nn.onclick = (event) => {\\n\\tevent.preventDefault();\\n\\twindow.open('https://calpa.github.io/', '_blank');\\n}\\n```\\n\\n## 參考資料\\n1. [Using the Notification API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API)\\n\",\"tags\":\"Web\"}},{\"node\":{\"title\":\"SuperCharger Hackathon 後記\",\"createdDate\":\"2017-02-19T15:12+08:00\",\"url\":\"supercharger-hackathon\",\"headerImgur\":\"7EMhgpx.jpg\",\"content\":\"![Imgur](https://i.imgur.com/7EMhgpx.jpg)\\n\\n如果計上這次比賽的話，我已經是第五次參加這一類編程比賽。與過往的比賽不同，合作的對象不再是大學生，而是兩間Start-up公司。在這次比賽中，我選擇[KYC-Chain](http://kyc-chain.com/)、[Clare.ai](https://www.clare.ai/)兩間公司組成的隊伍。KYC-Chain透過[Airtable](https://airtable.com/)提供一些常見的用戶問題與答案，而Clare.ai則負責寫code。\\n\\nAirtable有API教學，可以用node.js增加、移除、修改或者獲取資料。\\n\\n## 現有問題\\n如果用戶想了解一些資訊，他需要經過很多過程才能獲取答案。\\n\\n## 目的\\n利用Chatbot，用戶只需要說出自己的問題便能查詢資料，例如Identity Card，Regulatory Law等資訊。\\n\\n## 將來發展\\n1. 獲取申請表格\\n1. 自動填寫各類文件\\n\\n## 感想\\n我本來以為要從零開始架構一個Chatbot，原來可以直接用Api.ai。\\n大多數時間都是和一些在外面工作的人交流。。。\\n\\n## 參考資料\\n1. 我自己 XD\\n1. [SuperCharger FinTech Hackathon - Facebook 活動頁](https://www.facebook.com/events/704583943057523/)\\n\",\"tags\":\"前端, 閱讀, Hackathon\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":48}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-8.json\n// module id = 1053\n// module chunks = 244335847057972"],"sourceRoot":""}