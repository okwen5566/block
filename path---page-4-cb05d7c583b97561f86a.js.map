{"version":3,"sources":["webpack:///path---page-4-cb05d7c583b97561f86a.js","webpack:///./.cache/json/page-4.json"],"names":["webpackJsonp","1049","module","exports","data","latestPosts","totalCount","edges","node","title","url","createdDate","pagePosts","headerImgur","content","tags","pathContext","limit","skip"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,WAAA,GAAAC,QAA0BC,MAAQC,MAAA,wCAAAC,IAAA,qBAAAC,YAAA,4BAAqHH,MAAQC,MAAA,kEAAAC,IAAA,qCAAAC,YAAA,4BAA+JH,MAAQC,MAAA,OAAAC,IAAA,kBAAAC,YAAA,4BAAiFH,MAAQC,MAAA,yCAAAC,IAAA,+BAAAC,YAAA,4BAAgIH,MAAQC,MAAA,kBAAAC,IAAA,gCAAAC,YAAA,4BAA0GH,MAAQC,MAAA,gCAAAC,IAAA,4CAAAC,YAAA,6BAAoIC,WAAcL,QAAUC,MAAQC,MAAA,oBAAAE,YAAA,yBAAAD,IAAA,2CAAAG,YAAA,KAAAC,QAAA,i5DAA8tCC,KAAA,cAA+1BP,MAAQC,MAAA,4BAAAE,YAAA,yBAAAD,IAAA,uCAAAG,YAAA,KAAAC,QAAA,8/BAAmjBC,KAAA,cAA6nBP,MAAQC,MAAA,wCAAAE,YAAA,yBAAAD,IAAA,yCAAAG,YAAA,KAAAC,QAAA,g1BAAw+BC,KAAA,gBAAkCP,MAAQC,MAAA,aAAAE,YAAA,yBAAAD,IAAA,wBAAAG,YAAA,KAAAC,QAAA,29BAAAC,KAAA,kBAA2mCP,MAAQC,MAAA,wBAAAE,YAAA,yBAAAD,IAAA,gCAAAG,YAAA,cAAAC,QAAA,2uCAAAC,KAAA,gBAAq5CP,MAAQC,MAAA,sBAAAE,YAAA,yBAAAD,IAAA,qCAAAG,YAAA,KAAAC,QAAA,2nIAA8uFC,KAAA,kBAAwoDC,aAAgBC,MAAA,EAAAC,KAAA","file":"path---page-4-cb05d7c583b97561f86a.js","sourcesContent":["webpackJsonp([192681129940542],{\n\n/***/ 1049:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"香港開放數據平台 - 從入門到放棄\",\"createdDate\":\"2017-06-12T21:36+08:00\",\"url\":\"hong-kong-open-data-from-zero-to-give-up\",\"headerImgur\":null,\"content\":\"## 前言\\n經過 2017 年香港開源年會之後，我都沒有去看香港的開放數據做得怎麼樣。今天香港正懸掛八號風球，正好是一個機會去了解一下。香港政府有一個開放數據平台，[資料一線通](https://data.gov.hk/tc-data/dataset)，以多種檔案格式提供多個政府部門類別，機構的一些查詢資料，比如說天氣預報，中學教育統計資料。值得注意的是，這些檔案並不是 ODF，而是 xls, xml, csv, json, gif, txt, tif。。。\\n\\n## 使用 API\\n\\n第一眼看到的時候，我就想可不可以直接複製貼上測試一下，結果發現是不行的。。。\\n\\n{% img https://i.imgur.com/cwI9gp7.png 600 auto %}\\n\\n\\\"歷史檔案文件列表應用程式界面\\\" 其實這個名字會不會有點長，我在閱讀下文的時候看到這麼長的字也很難聯想到剛才有看過。而且如果直接在瀏覽器輸入第一句的話，只會返回 400 Bad Request。。。\\n```\\n{\\n  \\\"message\\\" : \\\"REQUEST ERROR: start parameter missing\\\"\\n}\\n```\\n\\n## 香港天文台提供的數據\\n\\n如果想要獲取香港天文台在平台上，2016年1月1日到1月2日的開放資料，就可以輸入這一句到命令行里：\\n```\\ncurl https://api.data.gov.hk/v1/historical-archive/list-files?start=20160101&end=20160102&provider=hk-hko\\n```\\n\\n返回的結果太長，prettify 後的檔案更加是高達 362 行。。。\\n\\n有興趣的話，你可以透過[這個鏈接](https://gist.github.com/calpa/11b75ce631d9a3809e17fb6b9ed15d6b)看一下。。。\\n\\n這個看起來不錯，有很多東西在裡面。但是，你可能會發現數據結構有點奇怪，一個數組去儲存所有的資料，這裡我就不展開了。\\n\\n如果看到最後，你就會發現 **file-count** 提供文檔總數，其實直接計算一下 **file** 的長度就可以了，上面的例子共有21份文檔。\\n```javascript\\nfile.length // 21\\nfile-count // 21\\n```\\n\\n{% img https://i.imgur.com/Hik48CC.png 600 auto 香港天文台開放數據 %}\\n<center>香港天文台開放數據網頁</center>\\n\\n你可以進去下載數據，比如說進入[本港地區天氣報告](http://rss.weather.gov.hk/rss/CurrentWeather_uc.xml)，但你會發現它把最重要的資料放了在 description 裡面，用一個 tr, td, td 的形式展現出來，這就不如你用 HTML 展現吧。。。\\n\\n## XML\\n\\n> 與許多HTML元素不同的是，XML元素的基礎是其功能，而非其格式。你不應該根據標記，就假定任何的格式或樣式。相反地， XML把版面配置留給樣規。樣規是獨立的文件，把元素配上樣式。\\n\\n如果寫 XML 的話，最重要是把資料都顯示出來，格式都是其次的。在 XML 中，我們可以自由地定義標籤，充分地表達自己的意思。也許，我應該之後寫一篇關於 XML 的文章。。。\\n\\n本來，我是想繼續寫的，但是看到那些莫名其妙的查詢方法，以及查詢的[香港天文台開放數據網頁](https://data.gov.hk/tc-data/provider/hk-hko)都只有 xml 格式，我就簡短寫一下就算了。\\n\\n如果你好奇為什麼我會提到 ODF 的話，你可以去看一下台灣政府是[如何推動開放數據](https://onepiece.nchu.edu.tw/cofsys/plsql/odf)。\\n\\n## 題外話\\n\\n我也不知道為什麼[特首博客的RSS](http://www.ceo.gov.hk/chi/blog/rss/blog_rss.xml)會報錯。。。\\n\\n## 參考資料\\n1. [ODF 政府文件標準格式宣導​](https://onepiece.nchu.edu.tw/cofsys/plsql/odf)\\n1. [國立交通大學 XML教學](http://yes.nctu.edu.tw/lecture/web/xml/intro/chapter1.html)\\n\",\"tags\":\"API, xml\"}},{\"node\":{\"title\":\"5分鐘製作 Markdown PowerPoint\",\"createdDate\":\"2017-06-01T17:00+08:00\",\"url\":\"create-markdown-powerpoint-in-5-mins\",\"headerImgur\":null,\"content\":\"<iframe width='100%' height='515' src='https://gitpitch.com/calpa/slides/master?grs=github&t=white' frameborder='0' allowfullscreen></iframe>\\n\\n## 關於我\\n\\n- 自學 <span style=\\\" color: #f48024\\\">Web</span> 前端程序員\\n- 香港科技大學化學工程三年級學生\\n- 曾經參加過 6次 Hackathon\\n- 技術博客: https://calpa.me\\n\\n## 以前製作 PowerPoint 的方法\\n\\nMicrosoft PowerPoint\\n\\nApache OpenOffice Impress\\n\\n## <span style=\\\"letter-spacing: 0.1em; color: #e49436; text-transform:none\\\">Git</span> Pitch\\n\\n## 前置技能\\n\\n- Github\\n- Markdown\\n\\n#### Github\\n\\n<img src=\\\"https://i.imgur.com/Riz9ctd.png\\\" height=\\\"200\\\" width=\\\"200\\\" />\\n\\n#### Markdown\\n\\n#### Markdown語法\\n\\n##### 標題\\n\\n```Markdown\\n# h1\\n## h2\\n### h3\\n#### h4\\n##### h5\\n```\\n\\n## 4個步驟\\n\\n![Imgur](https://i.imgur.com/HqSHVOy.png)\\n\\n![Imgur](https://i.imgur.com/ZwDgHFr.png)\\n\\n![Imgur](https://i.imgur.com/RLV4Ut0.png)\\n\\n![Imgur](https://i.imgur.com/uOoSrMa.png)\\n\\n### GitPitch Slideshow URL\\n\\nhttps://gitpitch.com/user/repo\\n\\n<img src=\\\"https://calpa.me/img/qrcode.png\\\" height=\\\"200\\\" width=\\\"200\\\" />\\n\",\"tags\":\"Markdown\"}},{\"node\":{\"title\":\"JavaScript Array.map(parseInt) 錯誤解決方案\",\"createdDate\":\"2017-05-31T11:06+08:00\",\"url\":\"javascript-array-map-parseint-solution\",\"headerImgur\":null,\"content\":\"如果我想轉換數組裡面的字符串為數字的話，很自然就會想到 `map` 和 `parseInt` 這兩個方法。但是用起來的時候卻不是我想要的結果。。。\\n\\n```JavaScript\\nvar a = [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"];\\n\\nvar b = a.map(parseInt);\\n\\nconsole.log(b); // [1, NaN, NaN, NaN, NaN]\\n```\\n\\n## 原因\\n\\n如果我們細看 map 的參數，就會發現它的 callback 會有三個 arguments：`currentValue`, `index` 和 `array`。\\n\\n對於 `parseInt` 來說， 它會接收`currentValue`和 `index`，並用 index 作為 index 進制。。。\\n```JavaScript\\nparseInt('1', 0); // OK => 1\\nparseInt('2', 1); // 不合法的進制。。。\\nparseInt('3', 2); // NaN, 二進制沒有 3\\nparseInt('4', 3); // NaN, 三進制沒有 4\\nparseInt('5', 4); // NaN, 四進制沒有 5\\n```\\n\\n## 解決方法\\n\\n1. 用`.map(parseFloat)`，因為它只接收一個參數。\\n  ```JavaScript\\n  var c = a.map(parseFloat);\\n  ```\\n\\n1. 用`.map(Number)`\\n  ```JavaScript\\n  var d = a.map(Number);\\n  ```\\n\\n1. 用`.map(num => parseInt(num))`\\n  ```JavaScript\\n  var e = a.map(num => parseInt(num));\\n  ```\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"為什麼要寫技術博客？\",\"createdDate\":\"2017-05-30T20:00+08:00\",\"url\":\"why-i-write-blog-post\",\"headerImgur\":null,\"content\":\"從第一篇[《Hello World》](https://calpa.me/2017/01/08/hello-world/)文章，我已經開始寫博客半年了，一共寫三十多篇，平均一個禮拜出一篇文章。其實，我沒有想那麼多，直接就開始寫文章了。可能我的博客沒有其他人寫得那麼好，但是我依然堅持寫博客。每一篇文章是需要一點時間構思、撰寫，但是這點時間是很值得的。\\n\\n## 原因\\n\\n1. 重用問題解決方案\\n  我們在寫代碼的時候，經常會遇到一些問題，不是那麼容易直接去解決，每次都是用同樣，或差不多的解決方法。如果每一次去 Google 這些問題，就會顯得有點浪費時間了。透過博客記錄下來，我們可以很方便地讓自己重用這些方案，同時讓別人避免造同樣的輪子。\\n\\n1. 學習知識\\n\\n  分享是學習知識的其中一種好方法。透過分享知識，我們可以整理碎片化的知識，並把它組合起來成為一篇文章。如果有小夥伴指出那篇文章的問題，大家可以交流一下，互相提升技術水平。\\n\\n1. 整理思維\\n\\n  作為一個 Web 前端程序員，經常會接觸網絡上日新月異的工具，知識。如果可以整理他們出來，就可以更好地讓自己摸清脈絡，對他們有更好的認識。\\n\\n1. 了解自己\\n\\n  就如同寫日記一樣，寫博客是一個不錯的方法去尋找自己的路。我們可能會有很多的興趣，但只有一樣或數樣是真愛。如果把自己的興趣和學習的歷程寫下來，就會知道什麼才是自己持之以恆想做的事情，自己的熱情在哪裡。\\n\\n1. 認識不同的讀者\\n\\n  如果博客可以吸引讀者，這就代表文章的質量開始上升。透過與不同的人交流，學習不同的思想。寫著寫著博客文章，我開始和國內，台灣的程序員打開了溝通的渠道，博客也有開始有來自世界各地，包括日本，美國的讀者。\\n\\n## 最初的動機\\n\\n以前看到一些大牛經常發文，我就想：可不可以有一天我也可以發文呢？一開始我是打算把自己看到的好文章節錄出來，以及記錄自己遇到的坑，然後讓自己日後重用。沒有想到的是，那篇[《打好 JavaScript 的6個步驟》](https://calpa.me/2017/05/21/learn-javascript-in-six-steps/)會為博客在兩日之內帶來 2000 多的流量，讓我感到有點高興。今後應該會繼續寫博客，記錄一下自己學了什麼。\\n\",\"tags\":\"前端, 閱讀, Blog\"}},{\"node\":{\"title\":\"打好 JavaScript 基礎的6個步驟\",\"createdDate\":\"2017-05-21T20:00+08:00\",\"url\":\"learn-javascript-in-six-steps\",\"headerImgur\":\"KMksHxZ.png\",\"content\":\"平日開發的時候，我們會選擇使用一些框架來避免重複製造輪子，減輕我們的工作量。然而，我們卻不能透過使用更好的工具，或者更換框架來解決一些基礎開發問題。因此打好基礎很重要，不但決定前端程序員解決基礎問題的能力，還決定了面對日新月異框架時的掌握能力。當我開發 React 應用的時候，遇到的問題多是我對於 JavaScript 的理解不夠充分。因此，我在這裡寫一下如何打好 JavaScript 基礎，希望拋磚引玉 XD\\n\\n1. 看一些經典的書\\n  JavaScript: 紅寶書 (JavaScript高級程序設計)，犀牛書 (JavaScript: The Definitive Guide)，You Don't Know JS\\n  計算機經典: 算法導論，SICP\\n\\n![JavaScript高級程序設計][1]\\n\\n![JavaScript: The Definitive Guide][2]\\n\\n![You Don't Know JS][3]\\n\\n1. 嘗試用不同的工具，增加自己的視野。\\n  你可以做一些玩具，自己嘗試一下寫 TODO APP 的不同寫法。\\n\\n1. 看工具的源碼：React, Vue, Underscore.js\\n  這些開源項目的代碼都已經放在 Github，網絡上也有對它們的源碼分析，隨便一找就有了。透過閱讀代碼，可以學習一下代碼規範，理解什麼才是好的代碼。\\n\\n1. 自己把這些工具、框架的某些功能做出來。\\n  你可以實現 [Underscore.js][4] 裡面的一些方法，例如`_.uniq(array, [isSorted], [iteratee])` 數組去重方法，然後看一下自己和人家寫得有什麼分別，為什麼人家會這樣寫？它有運用到什麼設計模式？\\n\\n1. 看ECMAScript規範。\\n  你可以閱讀[ECMAScript 規範][5]，人家對於不同的數據類型和函數是怎樣定義的，思考一下為什麼需要這樣定義，為什麼不這樣定義。\\n  為什麼`typeof null`會是`object`？不定義為`null`？\\n\\n1. 記錄你學了什麼知識並分享。\\n  記錄一下自己學習了什麼知識，遇到了什麼坑。透過和其他人交流一下，可以了解到自己有什麼不足之處。其中一個方法是利用 Hexo 建立博客，可以透過修改主題練習 HTML, JavaScript, CSS。我也是這樣寫博客的：https://calpa.me\\n\\n這裡就作為我的一個學習小總結，不繼續展開了。。。\\n\\n[1]: https://i.imgur.com/xm6R14W.jpg\\n[2]: https://i.imgur.com/autEZuV.jpg\\n[3]: https://i.imgur.com/ajLLsUg.gif\\n[4]: http://underscorejs.org/\\n[5]: https://tc39.github.io/ecma262\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"深入 ECMAScript 的數據類型\",\"createdDate\":\"2017-05-18T14:00+08:00\",\"url\":\"javascript-data-structures-in-deep\",\"headerImgur\":null,\"content\":\"\\n每一種編程語言都有數據結構，但他們各有不同之處。JavaScript 是一種動態語言，變數的類型不用提前聲明，你可以使用同一個變數來保存不同的數據類型。\\n```JavaScript\\nvar a = 'apple'; // String type\\nvar a = 42; // Number type\\nvar a = true; // Boolean type\\n```\\n\\n這就和Python的寫法差不多:\\n```python\\na = 'apple' // String type\\na = 42 // Number type\\na = True // Boolean type\\n```\\n## 數據類型\\n[ECMAScript 標準](https://tc39.github.io/ecma262/#sec-ecmascript-overview)明確定義了7種數據類型：6種原始類型 (Primitive value) 和Object。\\n\\n{% img /img/javascript-data-structures.svg 300 auto JavaScript Data Structure %}\\n\\n原始數據類型：\\n1. Undefined\\n1. Null\\n1. Boolean\\n1. Number\\n1. String\\n1. Symbol (ECMAScript 2015)\\n\\n## 判斷方法\\n\\n我們可以透過使用`typeof`和`Object.prototype.toString()`來判斷數據類型。\\n\\n### typeof\\n\\n在 JavaScript 誕生之時，數值是由一個標籤以及實際數據值表示的。基本類型的標籤是 1，而對象類型的標籤是 0。\\n\\n由於null代表的是空指針(全部都是 0)，null的類型標籤會是0。如果你在 console 直接輸入`typeof null`的話，就會得到 \\\"object\\\" 的結果，雖然這不是我們想要的值。。。\\n\\n```JavaScript\\ntypeof undefined; // \\\"undefined\\\"\\ntypeof Boolean;   // \\\"function\\\"\\ntypeof true;      // \\\"boolean\\\"\\ntypeof 42;        // \\\"number\\\"\\ntypeof \\\"42\\\";      // \\\"string\\\"\\ntypeof Symbol();  // \\\"symbol\\\"\\n```\\n\\n我們可以看一下ECMAScript是怎樣定義typeof的：\\n\\n1. Let val be the result of evaluating UnaryExpression.\\n1. If Type(val) is Reference, then\\n  a. If IsUnresolvableReference(val) is true, return \\\"undefined\\\".\\n1. Set val to ? GetValue(val).\\n1. Return a String according to Table 35.\\n\\nTable 35: typeof Operator Results\\n\\n| val 的類型 | 結果     |\\n| :------------- | :------------- |\\n| Item One       | Item Two       |\\n|Type of val\\t|Result|\\n|Undefined\\t|\\\"undefined\\\"|\\n|Null|\\t\\\"object\\\"|\\n|Boolean\\t|\\\"boolean\\\"|\\n|Number|\\t\\\"number\\\"|\\n|String\\t|\\\"string\\\"|\\n|Symbol|\\t\\\"symbol\\\"|\\n|Object (ordinary and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (standard exotic and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (implements [[Call]])\\t|\\\"function\\\"|\\n|Object (non-standard exotic and does not implement [[Call]])\\t|Implementation-defined. Must not be \\\"undefined\\\", \\\"boolean\\\",  \\\"function\\\", \\\"number\\\", \\\"symbol\\\", or \\\"string\\\".|\\n\\n另外，如果直接用`typeof`來判斷 NaN 的話，它會返回`\\\"number\\\"`，對於 NaN 我們可以用`isNaN`方法來判斷是否一個數字。\\n```JavaScript\\ntypeof NaN; // \\\"number\\\"\\nisNaN(NaN); // true\\n```\\n### Object.prototype.toString()\\n\\n我們可以利用`Object.prototype.toString.call()`或者`Object.prototype.toString.apply()`這兩個方法判斷 Object 的類型，以及 null：\\n```JavaScript\\nObject.prototype.toString.call(undefined);   // \\\"[object Undefined]\\\"\\nObject.prototype.toString.call(new Date);    // \\\"[object Date]\\\"\\nObject.prototype.toString.call(new String);  // \\\"[object String]\\\"\\nObject.prototype.toString.call(Math);        // \\\"[object Math]\\\"\\nObject.prototype.toString.call(null);        // \\\"[object Null]\\\"\\n```\\n\\nECMAScript 19.1.3.6 明確定義 Object.prototype.toString()：\\n\\n1.  If the `this` value is `undefined`, return `\\\"[object Undefined]\\\"`.\\n2.  If the `this` value is `null`, return `\\\"[object Null]\\\"`.\\n3.  Let `O` be ! [ToObject](https://tc39.github.io/ecma262/#sec-toobject)(`this` value).\\n4.  Let `isArray` be ? [IsArray](https://tc39.github.io/ecma262/#sec-isarray)(`O`).\\n5.  If `isArray` is `true`, let `builtinTag` be `\\\"Array\\\"`.\\n6.  Else if `O` is a String exotic object, let `builtinTag` be `\\\"String\\\"`.\\n7.  Else if `O` has a [[ParameterMap]] internal slot, let `builtinTag` be `\\\"Arguments\\\"`.\\n8.  Else if `O` has a [[Call]] internal method, let `builtinTag` be `\\\"Function\\\"`.\\n9.  Else if `O` has an [[ErrorData]] internal slot, let `builtinTag` be `\\\"Error\\\"`.\\n10.  Else if `O` has a [[BooleanData]] internal slot, let `builtinTag` be `\\\"Boolean\\\"`.\\n11.  Else if `O` has a [[NumberData]] internal slot, let `builtinTag` be `\\\"Number\\\"`.\\n12.  Else if `O` has a [[DateValue]] internal slot, let `builtinTag` be `\\\"Date\\\"`.\\n13.  Else if `O` has a [[RegExpMatcher]] internal slot, let `builtinTag` be `\\\"RegExp\\\"`.\\n14.  Else, let `builtinTag` be `\\\"Object\\\"`.\\n15.  Let `tag` be ? [Get](https://tc39.github.io/ecma262/#sec-get-o-p)(`O`, @@toStringTag).\\n16.  If [Type](https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values)(`tag`) is not String, let `tag` be `builtinTag`.\\n17.  Return the String that is the result of concatenating `\\\"[object \\\"`, `tag`, and `\\\"]\\\"`.\\n\\n## 參考資料\\n1. [ECMAScript® 2018 Language Specification](https://tc39.github.io/ecma262/#sec-ecmascript-overview)\",\"tags\":\"JavaScript\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":24}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-4-cb05d7c583b97561f86a.js","module.exports = {\"data\":{\"latestPosts\":{\"totalCount\":60,\"edges\":[{\"node\":{\"title\":\"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）\",\"url\":\"netease-kaola-live\",\"createdDate\":\"2018-08-01T20:00+08:00\"}},{\"node\":{\"title\":\"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法\",\"url\":\"regenerator-runtime-is-not-defined\",\"createdDate\":\"2018-07-29T20:00+08:00\"}},{\"node\":{\"title\":\"關於作者\",\"url\":\"about-calpa-liu\",\"createdDate\":\"2018-05-01T20:00+08:00\"}},{\"node\":{\"title\":\"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」\",\"url\":\"insert-zero-width-characters\",\"createdDate\":\"2018-04-06T23:00+08:00\"}},{\"node\":{\"title\":\"知乎無限 live 數據流網站\",\"url\":\"zhihu-unlimited-lives-website\",\"createdDate\":\"2018-03-28T20:49+08:00\"}},{\"node\":{\"title\":\"Gatsbyjs async/await 更新報錯解決方法\",\"url\":\"gatsybjs-async-await-upgrade-bug-solution\",\"createdDate\":\"2018-03-21T20:00+08:00\"}}]},\"pagePosts\":{\"edges\":[{\"node\":{\"title\":\"香港開放數據平台 - 從入門到放棄\",\"createdDate\":\"2017-06-12T21:36+08:00\",\"url\":\"hong-kong-open-data-from-zero-to-give-up\",\"headerImgur\":null,\"content\":\"## 前言\\n經過 2017 年香港開源年會之後，我都沒有去看香港的開放數據做得怎麼樣。今天香港正懸掛八號風球，正好是一個機會去了解一下。香港政府有一個開放數據平台，[資料一線通](https://data.gov.hk/tc-data/dataset)，以多種檔案格式提供多個政府部門類別，機構的一些查詢資料，比如說天氣預報，中學教育統計資料。值得注意的是，這些檔案並不是 ODF，而是 xls, xml, csv, json, gif, txt, tif。。。\\n\\n## 使用 API\\n\\n第一眼看到的時候，我就想可不可以直接複製貼上測試一下，結果發現是不行的。。。\\n\\n{% img https://i.imgur.com/cwI9gp7.png 600 auto %}\\n\\n\\\"歷史檔案文件列表應用程式界面\\\" 其實這個名字會不會有點長，我在閱讀下文的時候看到這麼長的字也很難聯想到剛才有看過。而且如果直接在瀏覽器輸入第一句的話，只會返回 400 Bad Request。。。\\n```\\n{\\n  \\\"message\\\" : \\\"REQUEST ERROR: start parameter missing\\\"\\n}\\n```\\n\\n## 香港天文台提供的數據\\n\\n如果想要獲取香港天文台在平台上，2016年1月1日到1月2日的開放資料，就可以輸入這一句到命令行里：\\n```\\ncurl https://api.data.gov.hk/v1/historical-archive/list-files?start=20160101&end=20160102&provider=hk-hko\\n```\\n\\n返回的結果太長，prettify 後的檔案更加是高達 362 行。。。\\n\\n有興趣的話，你可以透過[這個鏈接](https://gist.github.com/calpa/11b75ce631d9a3809e17fb6b9ed15d6b)看一下。。。\\n\\n這個看起來不錯，有很多東西在裡面。但是，你可能會發現數據結構有點奇怪，一個數組去儲存所有的資料，這裡我就不展開了。\\n\\n如果看到最後，你就會發現 **file-count** 提供文檔總數，其實直接計算一下 **file** 的長度就可以了，上面的例子共有21份文檔。\\n```javascript\\nfile.length // 21\\nfile-count // 21\\n```\\n\\n{% img https://i.imgur.com/Hik48CC.png 600 auto 香港天文台開放數據 %}\\n<center>香港天文台開放數據網頁</center>\\n\\n你可以進去下載數據，比如說進入[本港地區天氣報告](http://rss.weather.gov.hk/rss/CurrentWeather_uc.xml)，但你會發現它把最重要的資料放了在 description 裡面，用一個 tr, td, td 的形式展現出來，這就不如你用 HTML 展現吧。。。\\n\\n## XML\\n\\n> 與許多HTML元素不同的是，XML元素的基礎是其功能，而非其格式。你不應該根據標記，就假定任何的格式或樣式。相反地， XML把版面配置留給樣規。樣規是獨立的文件，把元素配上樣式。\\n\\n如果寫 XML 的話，最重要是把資料都顯示出來，格式都是其次的。在 XML 中，我們可以自由地定義標籤，充分地表達自己的意思。也許，我應該之後寫一篇關於 XML 的文章。。。\\n\\n本來，我是想繼續寫的，但是看到那些莫名其妙的查詢方法，以及查詢的[香港天文台開放數據網頁](https://data.gov.hk/tc-data/provider/hk-hko)都只有 xml 格式，我就簡短寫一下就算了。\\n\\n如果你好奇為什麼我會提到 ODF 的話，你可以去看一下台灣政府是[如何推動開放數據](https://onepiece.nchu.edu.tw/cofsys/plsql/odf)。\\n\\n## 題外話\\n\\n我也不知道為什麼[特首博客的RSS](http://www.ceo.gov.hk/chi/blog/rss/blog_rss.xml)會報錯。。。\\n\\n## 參考資料\\n1. [ODF 政府文件標準格式宣導​](https://onepiece.nchu.edu.tw/cofsys/plsql/odf)\\n1. [國立交通大學 XML教學](http://yes.nctu.edu.tw/lecture/web/xml/intro/chapter1.html)\\n\",\"tags\":\"API, xml\"}},{\"node\":{\"title\":\"5分鐘製作 Markdown PowerPoint\",\"createdDate\":\"2017-06-01T17:00+08:00\",\"url\":\"create-markdown-powerpoint-in-5-mins\",\"headerImgur\":null,\"content\":\"<iframe width='100%' height='515' src='https://gitpitch.com/calpa/slides/master?grs=github&t=white' frameborder='0' allowfullscreen></iframe>\\n\\n## 關於我\\n\\n- 自學 <span style=\\\" color: #f48024\\\">Web</span> 前端程序員\\n- 香港科技大學化學工程三年級學生\\n- 曾經參加過 6次 Hackathon\\n- 技術博客: https://calpa.me\\n\\n## 以前製作 PowerPoint 的方法\\n\\nMicrosoft PowerPoint\\n\\nApache OpenOffice Impress\\n\\n## <span style=\\\"letter-spacing: 0.1em; color: #e49436; text-transform:none\\\">Git</span> Pitch\\n\\n## 前置技能\\n\\n- Github\\n- Markdown\\n\\n#### Github\\n\\n<img src=\\\"https://i.imgur.com/Riz9ctd.png\\\" height=\\\"200\\\" width=\\\"200\\\" />\\n\\n#### Markdown\\n\\n#### Markdown語法\\n\\n##### 標題\\n\\n```Markdown\\n# h1\\n## h2\\n### h3\\n#### h4\\n##### h5\\n```\\n\\n## 4個步驟\\n\\n![Imgur](https://i.imgur.com/HqSHVOy.png)\\n\\n![Imgur](https://i.imgur.com/ZwDgHFr.png)\\n\\n![Imgur](https://i.imgur.com/RLV4Ut0.png)\\n\\n![Imgur](https://i.imgur.com/uOoSrMa.png)\\n\\n### GitPitch Slideshow URL\\n\\nhttps://gitpitch.com/user/repo\\n\\n<img src=\\\"https://calpa.me/img/qrcode.png\\\" height=\\\"200\\\" width=\\\"200\\\" />\\n\",\"tags\":\"Markdown\"}},{\"node\":{\"title\":\"JavaScript Array.map(parseInt) 錯誤解決方案\",\"createdDate\":\"2017-05-31T11:06+08:00\",\"url\":\"javascript-array-map-parseint-solution\",\"headerImgur\":null,\"content\":\"如果我想轉換數組裡面的字符串為數字的話，很自然就會想到 `map` 和 `parseInt` 這兩個方法。但是用起來的時候卻不是我想要的結果。。。\\n\\n```JavaScript\\nvar a = [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"];\\n\\nvar b = a.map(parseInt);\\n\\nconsole.log(b); // [1, NaN, NaN, NaN, NaN]\\n```\\n\\n## 原因\\n\\n如果我們細看 map 的參數，就會發現它的 callback 會有三個 arguments：`currentValue`, `index` 和 `array`。\\n\\n對於 `parseInt` 來說， 它會接收`currentValue`和 `index`，並用 index 作為 index 進制。。。\\n```JavaScript\\nparseInt('1', 0); // OK => 1\\nparseInt('2', 1); // 不合法的進制。。。\\nparseInt('3', 2); // NaN, 二進制沒有 3\\nparseInt('4', 3); // NaN, 三進制沒有 4\\nparseInt('5', 4); // NaN, 四進制沒有 5\\n```\\n\\n## 解決方法\\n\\n1. 用`.map(parseFloat)`，因為它只接收一個參數。\\n  ```JavaScript\\n  var c = a.map(parseFloat);\\n  ```\\n\\n1. 用`.map(Number)`\\n  ```JavaScript\\n  var d = a.map(Number);\\n  ```\\n\\n1. 用`.map(num => parseInt(num))`\\n  ```JavaScript\\n  var e = a.map(num => parseInt(num));\\n  ```\\n\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"為什麼要寫技術博客？\",\"createdDate\":\"2017-05-30T20:00+08:00\",\"url\":\"why-i-write-blog-post\",\"headerImgur\":null,\"content\":\"從第一篇[《Hello World》](https://calpa.me/2017/01/08/hello-world/)文章，我已經開始寫博客半年了，一共寫三十多篇，平均一個禮拜出一篇文章。其實，我沒有想那麼多，直接就開始寫文章了。可能我的博客沒有其他人寫得那麼好，但是我依然堅持寫博客。每一篇文章是需要一點時間構思、撰寫，但是這點時間是很值得的。\\n\\n## 原因\\n\\n1. 重用問題解決方案\\n  我們在寫代碼的時候，經常會遇到一些問題，不是那麼容易直接去解決，每次都是用同樣，或差不多的解決方法。如果每一次去 Google 這些問題，就會顯得有點浪費時間了。透過博客記錄下來，我們可以很方便地讓自己重用這些方案，同時讓別人避免造同樣的輪子。\\n\\n1. 學習知識\\n\\n  分享是學習知識的其中一種好方法。透過分享知識，我們可以整理碎片化的知識，並把它組合起來成為一篇文章。如果有小夥伴指出那篇文章的問題，大家可以交流一下，互相提升技術水平。\\n\\n1. 整理思維\\n\\n  作為一個 Web 前端程序員，經常會接觸網絡上日新月異的工具，知識。如果可以整理他們出來，就可以更好地讓自己摸清脈絡，對他們有更好的認識。\\n\\n1. 了解自己\\n\\n  就如同寫日記一樣，寫博客是一個不錯的方法去尋找自己的路。我們可能會有很多的興趣，但只有一樣或數樣是真愛。如果把自己的興趣和學習的歷程寫下來，就會知道什麼才是自己持之以恆想做的事情，自己的熱情在哪裡。\\n\\n1. 認識不同的讀者\\n\\n  如果博客可以吸引讀者，這就代表文章的質量開始上升。透過與不同的人交流，學習不同的思想。寫著寫著博客文章，我開始和國內，台灣的程序員打開了溝通的渠道，博客也有開始有來自世界各地，包括日本，美國的讀者。\\n\\n## 最初的動機\\n\\n以前看到一些大牛經常發文，我就想：可不可以有一天我也可以發文呢？一開始我是打算把自己看到的好文章節錄出來，以及記錄自己遇到的坑，然後讓自己日後重用。沒有想到的是，那篇[《打好 JavaScript 的6個步驟》](https://calpa.me/2017/05/21/learn-javascript-in-six-steps/)會為博客在兩日之內帶來 2000 多的流量，讓我感到有點高興。今後應該會繼續寫博客，記錄一下自己學了什麼。\\n\",\"tags\":\"前端, 閱讀, Blog\"}},{\"node\":{\"title\":\"打好 JavaScript 基礎的6個步驟\",\"createdDate\":\"2017-05-21T20:00+08:00\",\"url\":\"learn-javascript-in-six-steps\",\"headerImgur\":\"KMksHxZ.png\",\"content\":\"平日開發的時候，我們會選擇使用一些框架來避免重複製造輪子，減輕我們的工作量。然而，我們卻不能透過使用更好的工具，或者更換框架來解決一些基礎開發問題。因此打好基礎很重要，不但決定前端程序員解決基礎問題的能力，還決定了面對日新月異框架時的掌握能力。當我開發 React 應用的時候，遇到的問題多是我對於 JavaScript 的理解不夠充分。因此，我在這裡寫一下如何打好 JavaScript 基礎，希望拋磚引玉 XD\\n\\n1. 看一些經典的書\\n  JavaScript: 紅寶書 (JavaScript高級程序設計)，犀牛書 (JavaScript: The Definitive Guide)，You Don't Know JS\\n  計算機經典: 算法導論，SICP\\n\\n![JavaScript高級程序設計][1]\\n\\n![JavaScript: The Definitive Guide][2]\\n\\n![You Don't Know JS][3]\\n\\n1. 嘗試用不同的工具，增加自己的視野。\\n  你可以做一些玩具，自己嘗試一下寫 TODO APP 的不同寫法。\\n\\n1. 看工具的源碼：React, Vue, Underscore.js\\n  這些開源項目的代碼都已經放在 Github，網絡上也有對它們的源碼分析，隨便一找就有了。透過閱讀代碼，可以學習一下代碼規範，理解什麼才是好的代碼。\\n\\n1. 自己把這些工具、框架的某些功能做出來。\\n  你可以實現 [Underscore.js][4] 裡面的一些方法，例如`_.uniq(array, [isSorted], [iteratee])` 數組去重方法，然後看一下自己和人家寫得有什麼分別，為什麼人家會這樣寫？它有運用到什麼設計模式？\\n\\n1. 看ECMAScript規範。\\n  你可以閱讀[ECMAScript 規範][5]，人家對於不同的數據類型和函數是怎樣定義的，思考一下為什麼需要這樣定義，為什麼不這樣定義。\\n  為什麼`typeof null`會是`object`？不定義為`null`？\\n\\n1. 記錄你學了什麼知識並分享。\\n  記錄一下自己學習了什麼知識，遇到了什麼坑。透過和其他人交流一下，可以了解到自己有什麼不足之處。其中一個方法是利用 Hexo 建立博客，可以透過修改主題練習 HTML, JavaScript, CSS。我也是這樣寫博客的：https://calpa.me\\n\\n這裡就作為我的一個學習小總結，不繼續展開了。。。\\n\\n[1]: https://i.imgur.com/xm6R14W.jpg\\n[2]: https://i.imgur.com/autEZuV.jpg\\n[3]: https://i.imgur.com/ajLLsUg.gif\\n[4]: http://underscorejs.org/\\n[5]: https://tc39.github.io/ecma262\",\"tags\":\"JavaScript\"}},{\"node\":{\"title\":\"深入 ECMAScript 的數據類型\",\"createdDate\":\"2017-05-18T14:00+08:00\",\"url\":\"javascript-data-structures-in-deep\",\"headerImgur\":null,\"content\":\"\\n每一種編程語言都有數據結構，但他們各有不同之處。JavaScript 是一種動態語言，變數的類型不用提前聲明，你可以使用同一個變數來保存不同的數據類型。\\n```JavaScript\\nvar a = 'apple'; // String type\\nvar a = 42; // Number type\\nvar a = true; // Boolean type\\n```\\n\\n這就和Python的寫法差不多:\\n```python\\na = 'apple' // String type\\na = 42 // Number type\\na = True // Boolean type\\n```\\n## 數據類型\\n[ECMAScript 標準](https://tc39.github.io/ecma262/#sec-ecmascript-overview)明確定義了7種數據類型：6種原始類型 (Primitive value) 和Object。\\n\\n{% img /img/javascript-data-structures.svg 300 auto JavaScript Data Structure %}\\n\\n原始數據類型：\\n1. Undefined\\n1. Null\\n1. Boolean\\n1. Number\\n1. String\\n1. Symbol (ECMAScript 2015)\\n\\n## 判斷方法\\n\\n我們可以透過使用`typeof`和`Object.prototype.toString()`來判斷數據類型。\\n\\n### typeof\\n\\n在 JavaScript 誕生之時，數值是由一個標籤以及實際數據值表示的。基本類型的標籤是 1，而對象類型的標籤是 0。\\n\\n由於null代表的是空指針(全部都是 0)，null的類型標籤會是0。如果你在 console 直接輸入`typeof null`的話，就會得到 \\\"object\\\" 的結果，雖然這不是我們想要的值。。。\\n\\n```JavaScript\\ntypeof undefined; // \\\"undefined\\\"\\ntypeof Boolean;   // \\\"function\\\"\\ntypeof true;      // \\\"boolean\\\"\\ntypeof 42;        // \\\"number\\\"\\ntypeof \\\"42\\\";      // \\\"string\\\"\\ntypeof Symbol();  // \\\"symbol\\\"\\n```\\n\\n我們可以看一下ECMAScript是怎樣定義typeof的：\\n\\n1. Let val be the result of evaluating UnaryExpression.\\n1. If Type(val) is Reference, then\\n  a. If IsUnresolvableReference(val) is true, return \\\"undefined\\\".\\n1. Set val to ? GetValue(val).\\n1. Return a String according to Table 35.\\n\\nTable 35: typeof Operator Results\\n\\n| val 的類型 | 結果     |\\n| :------------- | :------------- |\\n| Item One       | Item Two       |\\n|Type of val\\t|Result|\\n|Undefined\\t|\\\"undefined\\\"|\\n|Null|\\t\\\"object\\\"|\\n|Boolean\\t|\\\"boolean\\\"|\\n|Number|\\t\\\"number\\\"|\\n|String\\t|\\\"string\\\"|\\n|Symbol|\\t\\\"symbol\\\"|\\n|Object (ordinary and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (standard exotic and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (implements [[Call]])\\t|\\\"function\\\"|\\n|Object (non-standard exotic and does not implement [[Call]])\\t|Implementation-defined. Must not be \\\"undefined\\\", \\\"boolean\\\",  \\\"function\\\", \\\"number\\\", \\\"symbol\\\", or \\\"string\\\".|\\n\\n另外，如果直接用`typeof`來判斷 NaN 的話，它會返回`\\\"number\\\"`，對於 NaN 我們可以用`isNaN`方法來判斷是否一個數字。\\n```JavaScript\\ntypeof NaN; // \\\"number\\\"\\nisNaN(NaN); // true\\n```\\n### Object.prototype.toString()\\n\\n我們可以利用`Object.prototype.toString.call()`或者`Object.prototype.toString.apply()`這兩個方法判斷 Object 的類型，以及 null：\\n```JavaScript\\nObject.prototype.toString.call(undefined);   // \\\"[object Undefined]\\\"\\nObject.prototype.toString.call(new Date);    // \\\"[object Date]\\\"\\nObject.prototype.toString.call(new String);  // \\\"[object String]\\\"\\nObject.prototype.toString.call(Math);        // \\\"[object Math]\\\"\\nObject.prototype.toString.call(null);        // \\\"[object Null]\\\"\\n```\\n\\nECMAScript 19.1.3.6 明確定義 Object.prototype.toString()：\\n\\n1.  If the `this` value is `undefined`, return `\\\"[object Undefined]\\\"`.\\n2.  If the `this` value is `null`, return `\\\"[object Null]\\\"`.\\n3.  Let `O` be ! [ToObject](https://tc39.github.io/ecma262/#sec-toobject)(`this` value).\\n4.  Let `isArray` be ? [IsArray](https://tc39.github.io/ecma262/#sec-isarray)(`O`).\\n5.  If `isArray` is `true`, let `builtinTag` be `\\\"Array\\\"`.\\n6.  Else if `O` is a String exotic object, let `builtinTag` be `\\\"String\\\"`.\\n7.  Else if `O` has a [[ParameterMap]] internal slot, let `builtinTag` be `\\\"Arguments\\\"`.\\n8.  Else if `O` has a [[Call]] internal method, let `builtinTag` be `\\\"Function\\\"`.\\n9.  Else if `O` has an [[ErrorData]] internal slot, let `builtinTag` be `\\\"Error\\\"`.\\n10.  Else if `O` has a [[BooleanData]] internal slot, let `builtinTag` be `\\\"Boolean\\\"`.\\n11.  Else if `O` has a [[NumberData]] internal slot, let `builtinTag` be `\\\"Number\\\"`.\\n12.  Else if `O` has a [[DateValue]] internal slot, let `builtinTag` be `\\\"Date\\\"`.\\n13.  Else if `O` has a [[RegExpMatcher]] internal slot, let `builtinTag` be `\\\"RegExp\\\"`.\\n14.  Else, let `builtinTag` be `\\\"Object\\\"`.\\n15.  Let `tag` be ? [Get](https://tc39.github.io/ecma262/#sec-get-o-p)(`O`, @@toStringTag).\\n16.  If [Type](https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values)(`tag`) is not String, let `tag` be `builtinTag`.\\n17.  Return the String that is the result of concatenating `\\\"[object \\\"`, `tag`, and `\\\"]\\\"`.\\n\\n## 參考資料\\n1. [ECMAScript® 2018 Language Specification](https://tc39.github.io/ecma262/#sec-ecmascript-overview)\",\"tags\":\"JavaScript\"}}]}},\"pathContext\":{\"limit\":6,\"skip\":24}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-4.json\n// module id = 1049\n// module chunks = 192681129940542"],"sourceRoot":""}