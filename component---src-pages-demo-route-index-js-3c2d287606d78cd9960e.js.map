{"version":3,"sources":["webpack:///component---src-pages-demo-route-index-js-3c2d287606d78cd9960e.js","webpack:///./~/cytoscape/dist/cytoscape.cjs.js","webpack:///./~/heap/index.js","webpack:///./~/heap/lib/heap.js","webpack:///./~/lodash.debounce/index.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/timers-browserify/main.js","webpack:///./src/pages/demo/route/index.js"],"names":["webpackJsonp","743","module","exports","__webpack_require__","setImmediate","clearImmediate","root","factory","this","__WEBPACK_EXTERNAL_MODULE_140__","__WEBPACK_EXTERNAL_MODULE_141__","modules","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_typeof","Symbol","iterator","obj","constructor","window","navigator","document","typeofstr","typeofobj","typeoffn","typeofhtmlele","HTMLElement","instanceStr","instanceString","is","fn","defined","string","array","Array","isArray","plainObject","number","isNaN","integer","Math","floor","bool","htmlElement","elementOrCollection","element","collection","_private","single","core","style","stylesheet","event","thread","fabric","emptyString","undefined","match","nonemptyString","domElement","boundingBox","x1","x2","y1","y2","promise","then","touch","DocumentTouch","gecko","InstallTrigger","documentElement","webkit","webkitURL","chromium","chrome","khtml","vendor","khtmlEtc","ms","userAgent","windows","appVersion","mac","linux","unix","math","util","MAX_INT","Number","MAX_SAFE_INTEGER","trueify","falsify","zeroify","noop","error","msg","console","apply","arguments","trace","log","clone","extend","copy","slice","copyArray","arr","clonePosition","pos","x","y","uuid","a","b","random","toString","makeBoundingBox","bind","_staticEmptyObject","staticEmptyObject","assign","tgt","args","length","keys","j","k","default","val","def","removeFromArray","ele","manyCopies","splice","clearArray","push","otherArr","el","getPrefixedProperty","propName","prefix","prependCamel","setPrefixedProperty","memoize","forEach","req","arePositionsSame","p1","p2","copyPosition","modelToRenderedPosition","zoom","pan","renderedToModelPosition","array2point","deg2rad","deg","PI","getAngleFromDisp","dispX","dispY","atan2","log2","signum","dist","sqrt","sqdist","dx","dy","qbezierAt","p0","t","qbezierPtAt","lineAt","vec","vecDist","normVec","lineAtDist","triangleAngle","A","B","C","acos","bound","min","max","bb","Infinity","w","h","updateBoundingBox","bb1","bb2","expandBoundingBoxByPoint","expandBoundingBox","padding","boundingBoxesIntersect","inBoundingBox","pointInBoundingBox","pt","boundingBoxInBoundingBox","roundRectangleIntersectLine","nodeX","nodeY","width","height","cornerRadius","getRoundRectangleRadius","halfWidth","halfHeight","straightLineIntersections","topStartX","topStartY","topEndX","topEndY","finiteLinesIntersect","rightStartX","rightStartY","rightEndX","rightEndY","bottomStartX","bottomStartY","bottomEndX","bottomEndY","leftStartX","leftStartY","leftEndX","leftEndY","arcIntersections","topLeftCenterX","topLeftCenterY","intersectLineCircle","topRightCenterX","topRightCenterY","bottomRightCenterX","bottomRightCenterY","bottomLeftCenterX","bottomLeftCenterY","inLineVicinity","lx1","ly1","lx2","ly2","tolerance","inBezierVicinity","x3","y3","solveQuadratic","r","sqrtR","denom","root1","root2","solveCubic","result","discriminant","q","dum1","term1","r13","pow","cos","sqdistToQuadraticBezier","roots","zeroThreshold","params","index","abs","minDistanceSquared","curX","curY","distSquared","sqdistToFiniteLine","offset","line","lineSq","hypSq","dotProduct","adjSq","pointInsidePolygonPoints","points","up","pointInsidePolygon","basePoints","centerX","centerY","direction","transformedPoints","angle","atan","sin","expandedLineSet","expandPolygon","joinLines","lineSet","vertices","currentLineStartX","currentLineStartY","currentLineEndX","currentLineEndY","nextLineStartX","nextLineStartY","nextLineEndX","nextLineEndY","intersection","pad","currentPointX","currentPointY","nextPointX","nextPointY","offsetX","offsetY","offsetLength","normalizedOffsetX","normalizedOffsetY","intersectLineEllipse","ellipseWradius","ellipseHradius","len","newLength","lenProportion","checkInEllipse","radius","f","t1","t2","tMin","tMax","inRangeParams","nearIntersectionX","nearIntersectionY","farIntersectionX","farIntersectionY","findCircleNearPoint","farX","farY","displacementX","displacementY","distance","unitDisplacementX","unitDisplacementY","findMaxSqDistanceToOrigin","maxSqDistance","sqDistance","midOfThree","x4","y4","infiniteLines","dx13","dx21","dx43","dy13","dy21","dy43","ua_t","ub_t","u_b","ua","ub","flptThreshold","polygonIntersectLine","intersections","doTransform","currentX","currentY","nextX","nextY","_i","shortenIntersection","amount","disp","lenRatio","generateUnitNgonPointsFitToSquare","sides","rotationRadians","generateUnitNgonPoints","fitPolygonToSquare","minX","minY","maxX","maxY","sx","sy","_i2","_i3","increment","startAngle","currentAngle","getCutRectangleCornerLength","bezierPtsToQuadCoeff","getBarrelCurveConstants","heightOffset","widthOffset","ctrlPtOffsetPct","define","STATE_PENDING","STATE_FULFILLED","STATE_REJECTED","api","executor","id","state","fulfillValue","rejectReason","onFulfilled","onRejected","proxy","fulfill","reject","deliver","curr","next","resolver","execute","execute_handlers","handlers","func","setTimeout","cb","method","e","resolve","TypeError","resolved","all","ps","resolveAll","rejectAll","vals","doneCount","isPromise","err","Promise","newQuery","Selector","selector","self","selectorText","invalid","group","groupOnly","filter","parse","selfn","valid","text","size","eq","sameText","otherSel","toStringCache","str","clean","cleanVal","space","queryToString","query","sel","subject","substring","data","field","operator","meta","colonSelectors","ids","classes","source","target","connectedNodes","parent","ancestor","child","descendant","Map","Set","Element","idFactory","generate","cy","tryThisId","hasElementWithId","Collection","elements","options","map","createdElements","eles","elesIds","json","has","add","_l","unique","set","restore","elesfn","spawn","opts","spawnSelf","renderer","getElementById","entry","$id","poolIndex","startBatch","position","checkSwitch","trueFnName","falseFnName","obj_k","endBatch","removed","selected","selectable","locked","grabbable","cls","jsons","elesArr","notifyRenderer","cy_p","nodes","edges","isNode","concat","removeFromElements","_ele","clearTraversalCache","isEdge","edge","fields","fieldsLength","badSourceOrTarget","src","addToPool","node","_data","parentId","specifiedParent","empty","selfAsParent","same","children","hasCompoundNodes","restored","_i4","_ele2","parallelEdges","toUpdateStyle","merge","dirtyCompoundBoundsCache","updateStyle","emitAndNotify","emit","inside","remove","addConnectedEdges","addChildren","alreadyAdded","elesToRemoveIds","elesToRemove","unshift","removeEdgeRef","connectedEdges","removeParallelRefs","removeChildRef","pid","alteredParents","removeFromPool","_i5","_ele3","elesStillInside","_i6","_ele4","isParent","removedElements","notify","type","_i7","_ele5","move","struct","srcId","tgtId","srcExists","tgtExists","scratch","parentExists","_jsons","descs","descendants","descsEtcJsons","union","_i8","_json","_ele6","props","_classCallCheck","instance","Constructor","_createClass","defineProperties","descriptor","writable","key","protoProps","staticProps","ObjectSet","arrayOrObjectSet","_obj","create","toArray","_this","callback","thisArg","Emitter","defaults","listeners","emitting","Event","eventRegex","universalNamespace","qualifierCompare","q1","q2","eventMatches","eventFields","callbackContext","context","beforeEmit","afterEmit","bubble","forEachEvent","handler","events","qualifier","conf","confOverrides","eventList","split","evt","namespace","ret","makeEventObj","forEachEventObj","eventObj","on","addListener","one","removeListener","off","_loop","listener","trigger","extraParams","manualCallback","numListenersBeforeEmit","_loop2","stopPropagation","preventDefault","isPropagationStopped","Core","container","reg","_cyreg","destroy","readies","head","headless","layout","defVal","altVal","_p","ready","aniEles","destroyed","notificationsEnabled","minZoom","maxZoom","zoomingEnabled","userZoomingEnabled","panningEnabled","userPanningEnabled","boxSelectionEnabled","autolock","autolockNodes","autoungrabify","autoungrabifyNodes","autounselectify","styleEnabled","animation","current","queue","createEmitter","selType","selectionType","loadExtData","extData","anyIsPromise","some","setStyle","initRenderer","hideEdgesOnViewport","textureOnViewport","wheelSensitivity","motionBlur","motionBlurOpacity","pixelRatio","desktopTapThreshold","touchTapThreshold","setElesAndLayout","onload","ondone","notifications","oldEles","mutableElements","layoutOpts","run","thens","initStyle","initEles","append","startAnimationLoop","done","corefn","isReady","isDestroyed","emitter","stopAnimationLoop","destroyRenderer","unmerge","idInJson","updateEles","gr","grs","stdFilter","bindingEvent","allowBinding","allowSetting","settingEvent","settingTriggersEvent","triggerFnName","allowGetting","removeScratch","removeData","triggerEvent","autoWidth","autoHeight","autoPadding","compoundBoundsClean","rstyle","styleCxts","grabbed","active","rscratch","traversalCache","renderedPosition","rpos","css","applyBypass","zIndexSort","getDepth","pstyle","zDepth","getEleDepth","depthDiff","eleDiff","zDiff","returnFalse","returnTrue","recycle","isImmediatePropagationStopped","isDefaultPrevented","defaultPrevented","originalEvent","timeStamp","Date","now","stopImmediatePropagation","fullFpsTime","setupDequeueing","dequeueingSetup","queueRedraw","debounce","redrawHint","redraw","deqRedrawThreshold","dequeue","willDraw","frameStartTime","startTime","performanceNow","avgRenderTime","averageRedrawTime","renderTime","lastRedrawTime","deqd","extent","getPixelRatio","duration","frameDuration","timeAvailable","deqFastCost","deqCost","deqAvgCost","deqNoDrawCost","thisDeqd","deq","onDeqd","shouldRedraw","priority","beforeRender","stateSelectors","matches","visible","transparent","animated","isChildless","isChild","isOrphan","isLoop","isSimple","backgrounding","sort","descending","stateSelectorMatches","lookup","selToFn","stateSelectorRegex","join","Style","coreStyle","resetToDefault","styfn","clear","newStyle","addDefaultStylesheet","selectorStr","properties","mappedProperties","prop","mapVal","dash2camel","cssRule","hasPie","mapped","currentSelectorIsCore","appendToStyle","appendFromJson","appendFromString","fromJson","fromString","types","keyFn","memoizedFn","cache","setExtension","registrant","ext","overrideErr","Layout","layoutProto","optLayoutFns","fnName","start","regStop","stop","animate","anis","animations","getCy","once","eventAliasesOn","BaseRenderer","getExtension","bProto","RegistrantRenderer","rProto","Renderer","proto","pName","pVal","existsInR","_pName","clientFunctions","setMap","extensions","getMap","setModule","moduleType","moduleName","getModule","incExts","extension","impl","Stylesheet","sheetfn","_name","_value","generateStyle","Animation","opts2","started","playing","hooked","applying","progress","completes","frames","complete","anifn","hook","tAni","addToAnimationPool","play","stopped","pause","rewind","fastforward","time","wasPlaying","completed","reverse","swap","_pa","startStyleProp","startStyle","aStar","reconstructPath","end","cameFromMap","pathAcum","previous","previousEdge","cameFromEdge","findMin","openSet","fScore","minPos","tempScore","goal","heuristic","weight","weightFn","directed","sid","tid","closedSet","cameFrom","gScore","steps","cMin","cMinId","rPath","found","path","vwEdges","wSrc","wTgt","wid","indexOf","bellmanFord","numNodes","id2position","cost","predecessor","predEdge","flag","sourceIndex","targetIndex","temp","pathTo","distanceTo","hasNegativeWeightCycle","position2id","res","to","toId","reconstructPathAux","fromPos","toPos","acumPath","predPos","Heap","betweennessCentrality","weighted","V","_C","v","vid","outgoers","openNeighborhood","S","P","g","Q","pop","vEle","edgesTo","edgeWeight","updateItem","betweenness","betweennessNormalized","betweennessNormalised","bc","defineSearch","bfs","dfs","visit","connectedBy","id2depth","shift","depth","prevEdge","prevNode","not","intersect","connectedEles","breadthFirstSearch","depthFirstSearch","closenessCentralityNormalized","harmonic","closenesses","maxCloseness","fw","floydWarshall","currCloseness","closeness","closenessCentrality","dijkstra","totalDistance","cc","ccn","closenessCentralityNormalised","degreeCentralityNormalized","indegrees","outdegrees","maxIndegree","maxOutdegree","currDegree","degreeCentrality","indegree","outdegree","degrees","maxDegree","degree","callingEles","alpha","incoming","outgoing","k_in","k_out","s_in","s_out","connEdges","dc","dcn","degreeCentralityNormalised","prev","knownDist","getDist","setDist","distBetween","u","smallestEdge","uvs","edgesWith","smallestDistance","smalletsDist","uid","neighbors","neighborhood","vDist","alt","newRow","edgeNext","initMatrix","from","fromId","pathArr","kargerStein","colapse","edgeIndex","nodeMap","remainingEdges","edgeInfo","sourceIn","targetIn","partition1","partition2","newEdges","contractUntil","metaNodeMap","sizeLimit","numEdges","numIter","ceil","LN2","stopSize","edgeIndexes","minCut","minCutSize","originalMetaNode","iter","edgesState","metaNodeMap2","res1","res2","resEdges","witnessNodePartition","partitionId","cut","kruskal","findSet","forest","anySame","weightA","weightB","setU","setV","pageRank","normalizeVector","vector","total","dampingFactor","precision","epsilon","iterations","matrix","columnSum","additionalProb","eigenvector","nullVector","diff","rank","nodeId","clearQueue","delay","delayAnimation","_classes","changed","classesMap","eleClasses","changedEle","eleHasClass","eleCls","specdClass","addClass","toggleClass","hasClass","className","classesStr","toggle","il","_changedEle","_eleClasses","shouldAdd","delete","removeClass","flashClass","allAre","selObj","every","allAreNeighbors","nhood","contains","allAreNeighbours","forEachCompound","includeSelf","recursiveStep","did","hasCompounds","addParent","addParentAndChildren","parents","_parent","nonempty","commonAncestors","ancestors","orphans","nonorphans","siblings","forEachDown","forEachUp","forEachUpAndDown","immutableKeys","removeRscratch","attr","removeAttr","defineDegreeFunction","includeLoops","defineDegreeBoundsFunction","degreeFn","minDegree","minIndegree","minOutdegree","totalDegree","filledBbOpts","includeNodes","defBbOpts","includeEdges","includeLabels","includeOverlays","useCache","renderedBoundingBox","updateCompoundBounds","update","computeBiasValues","propDiff","propBias","propBiasComplement","biasDiff","biasComplementDiff","biasTotal","computePaddingValues","paddingObject","relativeTo","units","pfValue","left","right","top","bottom","leftVal","rightVal","topVal","bottomVal","widthBiasDiffs","diffLeft","diffRight","heightBiasDiffs","diffTop","diffBottom","updated","batching","batchingStyle","noninf","updateBounds","updateBoundsFromBox","b2","prefixedProperty","updateBoundsFromArrow","bounds","halfArW","arrowWidth","arrowType","srcX","srcY","tgtX","tgtY","midX","midY","updateBoundsFromLabel","prefixDash","label","strValue","halign","valign","labelWidth","labelHeight","labelX","labelY","marginX","marginY","rotation","outlineWidth","borderWidth","halfBorderWidth","lh","lw","lw_2","lh_2","isAutorotate","isPfValue","theta","rotate","px1y1","px1y2","px2y1","px2y2","boundingBoxImpl","display","ex1","ex2","ey1","ey2","displayed","overlayOpacity","overlayPadding","wHalf","_w","outerWidth","halfW","outerHeight","halfH","hpts","haystackPts","_temp","pts","bezierPts","linePts","n1","n1pos","n2","n2pos","_temp2","_temp3","ghost","gx","gy","tf","getKey","incudeNodes","cachedBoundingBoxImpl","defBbOptsKey","bbCache","recalculateRenderedStyle","updatedEdge","boundingBoxAt","newPos","bbAtOldPos","_n","_p2","_pos","old","boundingbox","renderedBoundingbox","ifEdge","controlPoints","getControlPoints","segmentPoints","_this2","getSegmentPoints","sourceEndpoint","_this3","getSourceEndpoint","targetEndpoint","_this4","getTargetEndpoint","midpoint","_this5","getEdgeMidpoint","widthHeight","edgePoints","beforePositionSet","oldPos","delta","validKeys","beforeGet","beforeSet","onSet","canSet","silentPosition","positions","silent","_fn","silentPositions","dim","setting","relativePosition","ppos","_hasParent","_relativeToParent","_origin","hasParent","relativeToParent","origin","modelPosition","point","modelPositions","renderedPoint","relativePoint","defineDimFns","uppercaseName","capitalize","autoName","labelName","outerName","uppercaseOuterName","border","od","emitterOptions","selector1","selector2","onceCollection","argSelector","arg","_filter","filterEles","include","toRemove","rMap","absoluteComplement","other","col1","col2","col1Smaller","map2","col","xor","$","inOther","both","retEles","toAdd","toAddEle","_index","unmergeOne","unmergedLastEle","lastEleI","lastEle","lastEleId","mapFn","reduce","initialValue","valFn","maxEle","minEle","or","difference","relativeComplement","subtract","and","symmetricDifference","symdiff","fnFilter","filterFn","complement","abscomp","thisSize","first","last","sortFn","sorted","sortByZIndex","srcDepth","tgtDepth","each","layoutDimensions","nodeDimensionsIncludeLabels","bbDim","layoutPositions","layoutEles","getMemoizeKey","fnMem","calculateSpacing","spacing","nodesBb","center","spacingVector","useSpacingFactor","spacingFactor","spacingBb","getFinalPos","transform","animateNode","animateFilter","ani","animationDuration","easing","animationEasing","fit","fitAni","zoomPanAni","makeLayout","createLayout","styleCache","cacheStyleFunction","cachePrototypeStyleFunction","selfFn","checkCompound","parentOk","defineDerivedStateFunction","specs","ok","edgeOkViaNode","dirtyStyleCache","dirty","bEles","batchStyleEles","updatedEles","changedEles","updateMappers","parsedStyle","getDefaultProperty","numericStyle","numericStyleUnits","renderedStyle","getRenderedStyle","updateTransitions","getStylePropertyValue","getRawStyle","removeStyle","names","removeAllBypasses","removeBypasses","show","hide","effectiveOpacity","parentOpacity","opacity","eleTakesUpSpace","takesUpSpace","eleInteractive","parentInteractive","interactive","noninteractive","eleVisible","edgeVisibleViaNode","hidden","bypass","renderedCss","removeBypass","removeCss","defineSwitchFunction","_handler","able","ableField","overrideAble","changedColl","defineSwitchSet","overrideField","deselect","unselect","inactive","defineSourceFunction","sources","defineEdgesWithFunction","otherNodes","edgeData","thisToOther","otherToThis","edgeConnectsThisAndOther","thisIsSrc","thisIsTgt","defineParallelEdgesFunction","codirected","edge1","edge1_p","src1","srcid1","tgtid1","srcEdges1","edge2","edge2data","tgtid2","srcid2","oppdirected","arg1","arg2","arg3","arg4","selectorOrEles","tch","ch","cacheHit","defineDagExtremity","disqualified","noIncomingEdges","noOutgoingEdges","defineDagOneHop","oEles","defineDagAllHops","sEles","sElesIds","incomers","newNext","nid","leaves","successors","predecessors","otherNode","closedNeighborhood","neighbourhood","closedNeighbourhood","openNeighbourhood","targets","codirectedEdges","components","visited","unvisited","visitInComponent","component","elesByGroup","_jsons2","elesArray","jl","generateCubicBezier","mX1","mY1","mX2","mY2","aA1","aA2","calcBezier","aT","getSlope","newtonRaphsonIterate","aX","aGuessT","NEWTON_ITERATIONS","currentSlope","calcSampleValues","kSplineTableSize","mSampleValues","kSampleStepSize","binarySubdivide","aA","aB","currentT","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","getTForX","intervalStart","currentSample","lastSample","guessForT","initialSlope","NEWTON_MIN_SLOPE","precompute","_precomputed","float32ArraySupported","Float32Array","isFinite","getEasedValue","percent","easingFn","roundValue","color","round","ease","startProp","endProp","propSpec","easedArr","si","ei","generateSpringRK4","cubicBezier","bezier","easings","linear","ease-in","ease-out","ease-in-out","ease-in-sine","ease-out-sine","ease-in-out-sine","ease-in-quad","ease-out-quad","ease-in-out-quad","ease-in-cubic","ease-out-cubic","ease-in-out-cubic","ease-in-quart","ease-out-quart","ease-in-out-quart","ease-in-quint","ease-out-quint","ease-in-out-quint","ease-in-expo","ease-out-expo","ease-in-out-expo","ease-in-circ","ease-out-circ","ease-in-out-circ","spring","tension","friction","cubic-bezier","stepAll","animationsRunning","headlessStep","requestAnimationFrame","beforeRenderPriorities","springAccelerationForState","springEvaluateStateWithDerivative","initialState","dt","derivative","dv","springIntegrateState","dxdt","dvdt","springRK4Factory","initState","time_lapsed","DT","have_duration","last_state","parseFloat","percentComplete","startAnimation","isCore","isEles","ani_p","startPosition","getAnimationStartStyle","startPan","startZoom","stepOne","ranAnis","callbacks","_callbacks","step","doneEles","ranEleAni","handledThisEle","ranCoreAni","pEasing","easingImpl","easingVals","easingProp","startPos","endPos","endPan","animatingPan","endZoom","animatingZoom","easedVal","overrideBypass","png","jpg","bg","jpeg","batchingNotify","batchNotifyEles","bTypes","batchNotifyTypes","noNotifications","batchCount","batch","batchData","renderTo","pxRatio","forceRender","resize","invalidateSize","RendererProto","domEle","childNodes","removeChild","onRender","offRender","invalidateDimensions","dims","panBy","arg0","viewportState","getFitViewport","bbe","getZoomedViewport","currentPan","currentZoom","bail","level","pan1","zoom1","zoom2","pan2","zoomed","panned","vp","viewport","zoomDefd","panDefd","zoomFailed","panFailed","z","cancelOnFailedZoom","getCenterPan","reset","sizeCache","getComputedStyle","getPropertyValue","clientWidth","clientHeight","rb","renderedExtent","centre","selfIsArrayLike","propertiesEmpty","getPropsList","cyPan","centerPan","fitVp","jumpToEnd","_defineProperty","change","_valid","_ret","i_a","l_a","_i_a","_l_a","_privateFields","_keys","_key","validKeyToDelete","listen","unlisten","unbind","pon","promiseOn","offArgs","onArgs","BreadthFirstLayout","circle","avoidOverlap","maximalAdjustments","graph","rootsArray","unhandledNodes","currComp","pNode","comp","compRoots","depths","foundByBfs","prevId","succ","orphanNodes","maxChecks","checks","assignedDepth","_node","_assignedDepth","assignDepthsToEles","_eles","breadthfirst","intersectsDepth","thisInfo","highestDepthOfOther","highestOther","otherInfo","adj","nDepths","elesToMove","_depth","nDepth","info","intEle","_info","_intEle","intInfo","newDepth","minDistance","nbb","cachedWeightedPercent","getWeightedPercent","eleDepth","samples","_i9","neighbor","bf","_depth2","_nDepth","apct","bpct","times","_i10","biggestDepthSize","_i11","getPosition","isBottomDepth","depthSize","distanceX","distanceY","radiusStepSize","epos","_i12","_depth3","_j","_node2","CircleLayout","sweep","clockwise","counterclockwise","dTheta","dcos","dsin","rMin","getPos","rx","ry","ConcentricLayout","equidistant","minNodeSpacing","concentric","levelWidth","nodeValues","maxNodeSize","levels","currentLevel","minDist","firstLvlHasMulti","maxR","rStep","rDeltaMax","_r","_level","rDelta","_level2","_level3","_dTheta","_r2","_val","_theta","CoseLayout","DEBUG","animationThreshold","refresh","randomize","componentSpacing","nodeRepulsion","nodeOverlap","idealEdgeLength","edgeElasticity","nestingFactor","gravity","initialTemp","coolingFactor","minTemp","weaver","broadcast","message","falseThread","Thread","matchesEvent","pass","debug","layoutInfo","createLayoutInfo","printLayoutInfo","randomizePositions","refreshRequested","rOpts","force","refreshPositions","layoutNodes","loopRet","_step","calculateNodeForces","calculateEdgeForces","calculateGravityForces","propagateForces","updatePositions","graphSet","node1","idToIndex","node2","randomDistance","cmptId1","cmptId","cmptId2","isCompound","directionX","positionX","directionY","positionY","maxRandDist","overlap","nodesOverlap","forceX","forceY","point1","findClippingPoint","point2","distanceSqr","isLocked","dX","dY","overlapX","overlapY","X","Y","H","W","dirSlope","nodeSlope","edgeSize","layoutEdges","sourceIx","sourceId","targetIx","targetId","lx","ly","idealLength","elasticity","distThreshold","fx","fy","nodeIndex","offX","offY","childNode","nodeSize","tempForce","limitForce","temperature","updateAncestryBoundaries","padRight","padLeft","padBottom","padTop","separateComponents","layutInfo","cid","totalA","c1","c2","usedW","rowH","maxRowW","mainLoop","layoutInfoUpdated","lnode","indexToGraph","id2cmptId","tempNode","tempGraph","p_id","node_id","node_ix","tempEdge","sourceGraph","targetGraph","lca","findLCA","lcaGraph","findLCA_aux","count","graphIx","nodeIx","childGraphIx","coseBB","pctX","pctY","GridLayout","avoidOverlapPadding","condense","rows","cols","cells","splits","small","large","oRows","oCols","columns","sm","lg","_sm","_lg","cellWidth","cellHeight","cellUsed","used","row","use","moveToNextCell","id2manPos","rcPos","NullLayout","PresetLayout","posIsFn","RandomLayout","BRp","arrowShapeWidth","registerArrowShapes","arrowShapes","bbCollide","translation","edgeWidth","xRotated","yRotated","xScaled","yScaled","xTranslated","yTranslated","transformPoints","retPts","pointsToArr","standardGap","defineArrowShape","defn","collide","roughCollide","draw","arrowShapeImpl","gap","controlPoint","ptsTrans","ctrlPt","ctrlPtTrans","pointsTee","triPts","teePts","baseCrossLinePts","crossLinePts","shiftFactor","y0","getArrowWidth","projectIntoViewport","clientX","clientY","offsets","findContainerClientCoords","offsetLeft","offsetTop","scale","containerBB","rect","getBoundingClientRect","styleValue","paddingHor","paddingVer","borderHor","borderVer","unscaledW","unscaledH","invalidateContainerClientCoordsCache","findNearestElement","interactiveElementsOnly","isTouch","findNearestElements","addEle","sqDist","nearNode","near","minSqDist","nearEdge","checkNode","nodeThreshold","hw","hh","shape","nodeShapes","getNodeShape","checkPoint","checkEdge","rs","styleWidth","edgeThreshold","widthSq","width2","inEdgeBB","edgeType","allpts","arSize","arrows","arrowStartX","arrowStartY","srcArrowAngle","arrowEndX","arrowEndY","tgtArrowAngle","midsrcArrowAngle","midtgtArrowAngle","ar","preprop","pre","checkLabel","th","labelThreshold","eventsEnabled","bw","pw","getCachedZSortedEles","getAllInBox","box","x1c","x2c","y1c","y2c","boxBb","nodeBb","startX","startY","endX","endY","allInside","calculateArrowAngles","isHaystack","isBezier","isMultibezier","isSegments","isSelf","segpts","bX","bY","i2","i1","i3","bp0x","bp0y","bp1x","bp1y","cpts","ctrlpts","ic","midDispX","midDispY","getArrowHeight","arrowWidthCache","cachedVal","getPts","findEdgeControlPoints","pairId","hashTable","pairIds","haystackEdges","curveStyle","edgeIsUnbundled","edgeIsBezier","tableEntry","hasUnbundled","hasBezier","srcPos","tgtPos","srcW","srcH","tgtW","tgtH","srcShape","tgtShape","vectorNormInverse","badBezier","pairEdges","edge_p","dirCounts","north","west","south","east","northwest","southwest","northeast","southeast","srcX2","srcY2","srcW2","srcH2","tgtX2","tgtY2","tgtW2","tgtH2","numEdges2","edgeIndex1","lastEdgeIndex","edgeIndex2","numEdges1","lastNumEdges","edgeIsSwapped","ctrlptDists","loopDir","loopSwp","ctrlptWs","bezierN","stepSize","ctrlptDist","ctrlptWeight","edgeDistances","segmentWs","segmentDs","segmentsN","srcEndpt","tgtEndpt","srcArrShape","tgtArrShape","arrowScale","lineWidth","srcX1","lastSrcCtlPtX","srcY1","lastSrcCtlPtY","srcW1","lastSrcCtlPtW","srcH1","lastSrcCtlPtH","tgtX1","lastTgtCtlPtX","tgtY1","lastTgtCtlPtY","tgtW1","lastTgtCtlPtW","tgtH1","lastTgtCtlPtH","curveStyle1","lastCurveStyle","curveStyle2","ctrlptDists1","lastCtrlptDists","ctrlptDists2","ctrlptWs1","lastCtrlptWs","ctrlptWs2","segmentWs1","lastSegmentWs","segmentWs2","segmentDs1","lastSegmentDs","segmentDs2","stepSize1","lastStepSize","stepSize2","loopDir1","lastLoopDir","loopDir2","loopSwp1","lastLoopSwp","loopSwp2","edgeDistances1","lastEdgeDistances","edgeDistances2","srcEndpt1","lastSrcEndpt","srcEndpt2","tgtEndpt1","lastTgtEndpt","tgtEndpt2","srcArr1","lastSrcArr","srcArr2","tgtArr1","lastTgtArr","tgtArr2","lineW1","lastLineW","lineW2","arrScl1","lastArrScl","arrScl2","ptCacheHit","calculatedIntersection","srcOutside","intersectLine","srcIntn","tgtOutside","tgtIntn","midptSrcPts","posPts","vectorNorm","loopDist","loopAngle","outAngle","inAngle","String","loopW","loopaPos","loopbPos","loopPos","minCompoundStretch","compoundStretchA","compoundStretchB","w1","w2","midptPts","adjustedMidpt","multi","manctrlptDist","normctrlptDist","sign","distanceFromMidpoint","findEndpoints","badStart","badAStart","badEnd","badAEnd","minCpADistFactor","arrowW","minCpADist","startACpDist","closeStartACp","endACpDist","closeEndACp","overlapping","cpD","cpL","cpM","cpProj","srcCtrlPtIntn","tgtCtrlPtIntn","mt","storeEdgeProjections","recalculateEdgeLabelProjections","calculateLabelAngles","haystack","halfRadius","manualEndptToPx","npos","tgtArShape","srcArShape","tgtDist","srcDist","et","lines","segments","hasEndpts","srcManEndpt","srcManEndptVal","tgtManEndpt","tgtManEndptVal","p1_i","p2_i","cpStart","cpEnd","srcArrowFromPt","tgtArrowFromPt","arrowEnd","edgeEnd","arrowStart","edgeStart","badLine","pushBezierPts","p3","bpts","bezierProjPcts","lpts","recalculateEdgeProjections","recalculateNodeLabelProjection","content","textX","textY","nodeWidth","nodeHeight","nodePos","textHalign","textValign","applyLabelDimensions","mid","setRs","createControlPointInfo","addSegment","cp","t0","prevSegment","segment","startDist","nProjs","prevCp","calculateEndProjection","isSrc","lineAngle","bezierAngle","lp0","lp1","cps","totalDist","seg","lastSeg","tSegment","segDt","di","d0","pD","applyPrefixedLabelDimensions","getLabelText","labelDims","calculateLabelDimensions","pfd","textTransform","toUpperCase","toLowerCase","wrapStyle","labelKey","maxW","wrappedLines","lineDims","lineW","words","subline","word","testLine","testDims","testW","ellipsized","ellipsis","incLastCh","widthWithNextCh","extraKey","cacheKey","labelStyleKey","labelDimCache","sizeMult","fStyle","family","div","labelCalcDiv","createElement","body","appendChild","ds","fontFamily","fontStyle","fontSize","fontWeight","zIndex","visibility","pointerEvents","lineHeight","whiteSpace","textContent","rot","rotStr","labelAngle","sourceLabelAngle","targetLabelAngle","sourceLabelAutoAngle","targetLabelAutoAngle","makePolygon","registerCalculationListeners","elesToUpdate","enqueue","dirtyStyleCaches","evts","dirtyEvents","binder","pEdges","pEdge","updateEleCalcs","fns","onUpdateEleCalcsFns","eleCalcs","onUpdateEleCalcs","nodeW","nodeH","updateCachedGrabbedEles","cachedZSortedEles","drag","nondrag","grabTargets","inDragLayer","invalidateCachedZSortedEles","forceRecalc","getCachedImage","url","crossOrigin","onLoad","imageCache","image","addEventListener","Image","dataUriPrefix","isDataUri","init","BR","ctr","stylesheetId","stylesheetAlreadyExists","innerHTML","insertBefore","computedStyle","selection","hoverData","down","downTime","triggerMode","dragging","initialPan","capture","dragData","possibleDragElements","touchData","singleTouchStartTime","singleTouchMoved","earlier","redraws","showFps","hideLabelsOnViewport","motionBlurEnabled","forcedPixelRatio","motionBlurTransparency","motionBlurPxRatio","mbPxRBlurry","minMbLowQualFrames","fullQualityMb","clearedForMotionBlur","desktopTapThreshold2","touchTapThreshold2","tapholdDuration","bindings","beforeRenderCallbacks","eleTxrDeq","lyrTxrDeq","registerNodeShapes","load","matchCanvasSize","startRenderLoop","binding","removeEventListener","removeObserver","disconnect","styleObserver","registerBinding","useCapture","tgtIsDom","supportsPassiveEvents","supportsPassive","passive","nodeIsDraggable","nodeIsGrabbable","triggerEvents","isMultSelKeyDown","shiftKey","metaKey","ctrlKey","allowPanningPassthrough","downs","allowPassthrough","getDragListIds","listHasId","addToList","hasId","setGrabbed","setFreed","setInDragLayer","setOutDragLayer","setGrabTarget","isGrabTarget","removeGrabTarget","addToDragList","addDescendantsToDrag","innerNodes","addNodesToDrag","updateAncestorsInDragLayer","addNodeToDrag","freeDraggedElements","grabbedEles","haveMutationsApi","MutationObserver","mutns","mutn","rNodes","removedNodes","rNode","parentNode","observe","childList","onResize","attributes","invalidateCoords","inBoxSelection","eventInContainer","containerPageCoords","touches","atLeastOnePosInside","tParent","containerIsTarget","which","gpos","select","nears","draggedElements","mdownPos","mdownGPos","checkForTaphold","tapholdCancelled","clearTimeout","tapholdTimeout","cxtStarted","cxtEvt","activate","getTime","cxtDragged","makeEvent","triggerGrab","selectedNodes","bgActivePosistion","draggingEles","selecting","isOverThresholdDrag","dx2","dy2","dist2","multSelKeyDown","updateDragDelta","dragDelta","goIntoBoxMode","cxtOver","deltaP","justStartedPan","mdPos","dragged","unactivate","justStartedDrag","didDrag","toTrigger","dEle","dPos","tcol","cxtTap","eleWouldBeSelected","downWasGrabbed","wheelHandler","scrollingPage","wheelZooming","wheelTimeout","deltaY","wheelDeltaY","wheelDelta","needsWheelFix","deltaMode","scrollingPageTimeout","f1x1","f1y1","f2x1","f2y1","distance1","distance1Sq","center1","modelCenter1","containerWidth","containerHeight","twoFingersStartInside","touchstartHandler","distanceSq","touchDragEles","cxtDistThreshold","cxtDistThresholdSq","near1","near2","cxt","starts","draggedEles","pinching","sPos","touch0","startGPosition","touchmoveHandler","startGPos","f1x2","f1y2","f2x2","f2y2","distance2Sq","factorSq","distThresholdSq","factorThreshold","factorThresholdSq","lastThreeTouch","de_p","distance2","factor","df1x","df1y","df2x","df2y","tx","ty","ctrx","ctry","swipePanning","draggedEle","touchcancelHandler","touchendHandler","ctxTapend","ctxTap","startWasGrabbed","rdist2","TouchEvent","pointers","makeTouch","identifier","pointerId","pageX","pageY","radiusX","radiusY","screenX","screenY","makePointer","addPointer","removePointer","updatePointer","addTouchesToEvent","pointerIsMouse","pointerType","generatePolygon","nodeShapeImpl","generateEllipse","generateRoundRectangle","diam","generateCutRectangle","cornerLength","generateCutTrianglePts","cl","xBegin","xEnd","yBegin","yEnd","topLeft","topRight","bottomRight","bottomLeft","cPts","cutTrianglePts","generateBarrel","bPts","generateBarrelBezierPts","curveConstants","hOffset","wOffset","ctrlPtXOffset","isTop","isBottom","barrelCurvePts","getCurveT","curvePts","x0","xMin","xMax","yMin","yMax","coeff","validRoots","curveRegions","corner","cornerPts","bezY","generateBottomRoundrectangle","topIntersections","star5Points","outerPoints","innerPoints","innerRadius","timeToRender","redrawTotalTime","redrawCount","lastDrawTime","requestedFrame","renderOptions","cbs","renderLoopStarted","renderFn","requestTime","skipFrame","render","endTime","CRp","polygon","lineTo","triangle-backcurve","firstPt","quadraticCurveTo","triangle-tee","trianglePoints","teePoints","beginPath","closePath","firstTeePt","moveTo","triangle-cross","crossLinePoints","arc","drawEdge","shiftToOriginWithBb","drawLabel","usePaths","translate","overlayWidth","overlayColor","lineColor","lineStyle","drawLine","strokeOpacity","lineCap","strokeStyle","drawEdgePath","drawOverlay","drawArrows","arrowOpacity","drawArrowheads","drawText","drawElementText","lineJoin","ghostOpacity","effectiveGhostOpacity","canvasCxt","pathCacheHit","pathCacheKey","keyMatches","pathCache","Path2D","setLineDash","stroke","drawArrowhead","arrowShape","arrowClearFill","arrowFill","edgeOpacity","gco","globalCompositeOperation","fillStyle","drawArrowShape","fill","canvasContext","shapeImpl","arrowPathCacheKey","arrowPathCache","alreadyCached","leavePathOpen","matchEdgeWidth","drawElement","showLabel","drawNode","drawCachedElement","eleTxrCache","getElement","drawImage","texture","canvas","drawElements","drawCachedElements","drawCachedNodes","drawLayeredElements","layers","lyrTxrCache","getLayers","layer","drawDebugPoints","fillRect","safeDrawImage","img","ix","iy","iw","ih","drawInscribedImage","nodeOpacity","styleObj","getIndexedStyle","repeat","paddingX2","nodeTW","nodeTH","clip","shouldClip","imgOpacity","imgW","cachedW","imgH","cachedH","offsetWidth","offsetHeight","gAlpha","globalAlpha","save","pattern","createPattern","roundRect","ctx","eleTextBiggerThanMin","lvl","computedSize","minSize","textAlign","textBaseline","srcLabel","tgtLabel","drawNodeText","drawEdgeText","getFontCache","fontCaches","setupTextStyle","labelStyle","labelSize","labelFamily","labelWeight","outlineOpacity","outlineColor","fontCacheKey","fontKey","font","pdash","textW","textH","textAngle","orgTextX","orgTextY","backgroundOpacity","borderOpacity","textBorderWidth","backgroundPadding","bgX","bgY","bgW","bgH","textFill","textBackgroundColor","styleShape","textStroke","textLineWidth","textBorderColor","textBorderStyle","strokeRect","whiteWidth","strokeText","fillText","bgImgProp","urls","urlDefined","numImages","bgImgCrossOrigin","darkness","bgColor","bgOpacity","borderColor","borderStyle","setupShapeColor","bgOpy","setupBorderColor","bdrOpy","shapePts","drawShape","drawImages","prevBging","totalCompleted","drawPie","redrawShape","pieOpacity","darken","darkenOpacity","drawBorder","effGhostOpacity","cyStyle","pieSize","lastPercent","pieBackgroundN","angleStart","angleDelta","angleEnd","motionBlurDelay","contexts","backingStore","backingStorePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","devicePixelRatio","paintCache","caches","paintCaches","needToCreateCache","mbPxRatio","bufferCanvases","MOTIONBLUR_BUFFER_NODE","MOTIONBLUR_BUFFER_DRAG","canvasWidth","canvasHeight","canvasContainer","CANVAS_LAYERS","canvases","BUFFER_COUNT","textureMult","TEXTURE_BUFFER","forcedContext","forcedZoom","forcedPan","drawAllLayers","forcedPxRatio","mbclear","setContextTransform","ePan","eZoom","clearingMotionBlur","bufferContexts","effectivePan","effectiveZoom","setTransform","clearRect","drawOnlyNodeLayer","needDraw","canvasNeedsRedraw","textureDraw","inNodeDragGesture","motionBlurFadeEffect","prevPxRatio","motionBlurTimeout","mbFrames","textureDrawLastFrame","NODE","SELECT_BOX","prevVp","prevViewport","viewportIsDiff","textureCache","mpan","DRAG","outsideBgColor","outsideBgOpacity","vpManip","hideEdges","needMbClear","useBuffer","fps","maxFps","cxtNode","txtNode","cxtDrag","txtDrag","drawMotionBlur","txt","needClear","pxr","motionBlurCleared","drawPolygonPath","drawRoundRectanglePath","arcTo","drawBottomRoundRectanglePath","drawCutRectanglePath","drawBarrelPath","barrelCurveConstants","sin0","cos0","ellipseStepSize","drawEllipsePath","ellipse","xPos","yPos","rw","rh","defs","minTxrH","txrStepH","minLvl","maxLvl","eleTxrSpacing","defTxrWidth","maxTxrW","maxTxrH","minUtility","maxFullness","maxFullnessChecks","allowEdgeTxrCaching","allowParentTxrCaching","maxDeqSize","getTxrReasons","downscale","highQuality","ElementTextureCache","onDequeues","ETCp","reasons","getTextureQueue","txrH","eleImgCaches","getRetiredTextureQueue","rtxtrQs","retired","rtxtrQ","getElementQueue","eleCacheQueue","reqs","getElementIdToQueue","id2q","eleIdToCacheQueue","reason","eleScaledH","eleScaledW","imgCaches","eleCache","txrQ","txr","addNewTxr","recycleTexture","addTexture","usedWidth","higherCache","scaledLabelShown","scalableFrom","otherCache","deqing","highQualityReq","downscaleReq","oneUpCache","queueElement","lowerCache","eleCaches","checkTextureFullness","invalidateElement","invalidatedWidth","checkTextureUtility","retireTexture","fullnessChecks","minW","getContext","existingReq","dequeued","onDequeue","offDequeue","b64ToBlob","b64","mimeType","bytes","atob","buff","ArrayBuffer","buffUint8","Uint8Array","charCodeAt","Blob","b64UriToB64","b64uri","substr","output","b64Uri","toDataURL","quality","createBuffer","buffer","bufferCanvasImage","ctrRect","full","specdMaxDims","maxWidth","maxHeight","maxScaleW","maxScaleH","buffCanvas","buffCxt","zsortedEles","CanvasRenderer","tapHlOff","containerStyle","setAttribute","overflow","getAttribute","topCanvas","pathsEnabled","LayeredTextureCache","de","invalidateElements","CR","pathsImpld","path2dEnabled","imgSmoothing","imageSmoothingEnabled","webkitImageSmoothingEnabled","mozImageSmoothingEnabled","msImageSmoothingEnabled","defNumLayers","refineEleDebounceTime","disableEleImgSmoothing","invalidThreshold","maxLayerArea","alwaysQueue","useHighQualityEleTxrReqs","useEleTxrCaching","layersByLevel","firstGet","lastInvalidationTime","skipping","qSort","layersQueue","setupEleCacheInvalidation","LTCp","layerIdPool","makeLayer","elesQueue","validateLayersElesOrdering","tmpLayers","layersByLvl","lvlComplete","levelIsComplete","checkTempLevels","canUseAsTmpLvl","checkLvls","dir","getBb","after","area","insert","maxElesPerLayer","allowLazyQueueing","imgLayerCaches","existingLayer","queueLayer","drawEleInLayer","getEleLevelForLayerLevel","numElesInLayers","invalidateLayer","updateElementsInLayers","haveLayers","replacement","refineElementTextures","rLyr","replaces","eleDeqs","updatedElesInLayers","elesQ","peek","applyLayerReplacement","requestRedraw","layersInLevel","replaced","NullRenderer","cytoscape","version","ObjectMap","_slicedToArray","sliceIterator","_arr","_d","_e","_s","_require","tokens","cleanMetaChars","replace","RegExp","metaChar","$1","replaceLastQuery","examiningQuery","replacementQuery","exprs","regex","populate","_ref","_ref2","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","variable","_ref9","_ref10","comparatorOp","_ref11","_ref12","valueIsString","exec","boolOp","_ref13","_ref14","_ref15","_ref16","separator","nextQuery","currentSubject","directedEdge","edgeQuery","undirectedEdge","childQuery","descendantQuery","modifier","regexObj","operandsMatch","allDataMatches","_matches","fieldVal","fieldValue","fieldStr","valStr","caseInsensitive","notExpr","isIneqCmp","confirmRelations","isNecessary","_matches2","queryMatches","allColonSelectorsMatch","allIdsMatch","actualId","allClassesMatch","allMetaMatches","matchesAny","getSource","getTarget","q0","selectorFunction","filteredCollection","consumeExpr","remaining","expr","consumed","consumeWhitespace","currentQuery","check","ops","op","contextStyles","propDiffs","cleanElements","ie","cxtMeta","getContextMeta","cxtStyle","getContextStyle","app","applyContextStyle","diffProps","updateStyleHints","getPropertiesDiff","oldCxtKey","newCxtKey","dualCxtKey","addedProp","oldHasCxt","newHasCxt","cxtHasDiffed","cxtHasMappedProps","laterCxtOverrides","laterCxt","hasLaterCxt","cxtKey","prevKey","styleCxtKey","contextSelectorMatches","diffPropNames","cxtStyles","hasCxt","retDiffProps","diffPropName","cxtProp","eleProp","deleteBypassed","retDiffProp","applyParsedProperty","bypassed","_size","srcContent","tgtContent","oWidth","wrap","wrapW","sourceLabelKey","targetLabelKey","styleKey","parsedProp","flatProp","propIsBypass","origProp","origPropIsBypass","flatPropMapping","checkZOrder","checkZOrderTrigger","deleteBypass","printMappingErr","mapData","_fieldVal","fieldMin","fieldMax","r1","valueMin","r2","valueMax","g1","g2","b1","a1","a2","clr","calcValue","mapping","_fields","_fieldVal2","_field","flatPropVal","fnRetVal","keepBypasses","updatedEle","propInStyle","isBypass","anyPrev","styProp","diffProp","prevProp","fromProp","toProp","initVal","initDt","transitioning","fromValue","toValue","triggersZOrder","_parsedProp","specifiedProps","_name2","_parsedProp2","_prop2","camel2dash","isColor","isMulti","mutiple","oldValue","propertyNames","getEmSizeInPixels","px","containerCss","isRenderedVal","subproperty","alias","pointsTo","styleProp","implicitUnits","aniProps","aniProp","propsObj","defaultLength","propIsFlat","parseImplWarn","flatKey","argHash","propCache","parseImpl","passedValue","trim","multiple","_mapped","evenMultiple","valArr","unitsArr","pfValArr","hasEnum","validate","singleEnum","checkEnums","enums","en","unitless","unitsRegex","allowPercent","strictMin","strictMax","propList","propsStr","propsSplit","tuple","color2tuple","regexes","enumProp","singleRegexMatchValue","rgba","rgbaNoBackRefs","hsla","hslaNoBackRefs","hex3","hex6","mapArg","urlRegexes","zeroOneNumber","zeroOneNumbers","nOneOneNumber","nonNegativeInt","numbers","positiveNumber","bidirectionalSize","bidirectionalSizes","sizeMaybePercent","paddingRelativeTo","bgWH","bgPos","bgRelativeTo","bgRepeat","bgFit","bgCrossOrigin","bgClip","fontletiant","textDecoration","textWrap","textBackgroundShape","nodeShape","compoundIncludeLabels","zCompoundDepth","zIndexCompare","layoutData","mapLayoutData","mapScratch","textRotation","polygonPointList","edgeEndpoint","zOrderDiff","zeroNonZero","val1","val2","anyDiff","zd","aliases","arrowPrefixes","pointsToProp","aliasProp","getDefaultProperties","rawProps","text-events","text-valign","text-halign","text-outline-color","text-outline-width","text-outline-opacity","text-opacity","text-decoration","text-transform","text-wrap","text-max-width","text-background-color","text-background-opacity","text-background-shape","text-background-padding","text-border-opacity","text-border-width","text-border-style","text-border-color","font-family","font-style","font-weight","font-size","min-zoomed-font-size","text-rotation","source-text-rotation","target-text-rotation","z-compound-depth","z-index-compare","z-index","text-margin-x","text-margin-y","source-label","source-text-offset","source-text-margin-x","source-text-margin-y","target-label","target-text-offset","target-text-margin-x","target-text-margin-y","overlay-opacity","overlay-color","overlay-padding","transition-property","transition-duration","transition-delay","transition-timing-function","background-blacken","background-color","background-opacity","background-image","background-image-crossorigin","background-image-opacity","background-position-x","background-position-y","background-width-relative-to","background-height-relative-to","background-repeat","background-fit","background-clip","background-width","background-height","border-color","border-opacity","border-width","border-style","shape-polygon-points","ghost-offset-y","ghost-offset-x","ghost-opacity","padding-relative-to","compound-sizing-wrt-labels","min-width","min-width-bias-left","min-width-bias-right","min-height","min-height-bias-top","min-height-bias-bottom","pie-size","line-style","line-color","control-point-step-size","control-point-weights","segment-weights","segment-distances","edge-distances","curve-style","haystack-radius","arrow-scale","loop-direction","loop-sweep","source-distance-from-node","target-distance-from-node","source-endpoint","target-endpoint","parsedProps","source-arrow-color","target-arrow-color","mid-source-arrow-color","mid-target-arrow-color","selection-box-color","selection-box-opacity","selection-box-border-color","selection-box-border-width","active-bg-color","active-bg-opacity","active-bg-size","outside-texture-bg-color","outside-texture-bg-opacity","removeSelAndBlockFromRemaining","selAndBlockStr","removePropAndValFromRem","blockRem","propAndValStr","nothingLeftToParse","selAndBlock","blockStr","invalidBlock","_nothingLeftToParse","propAndVal","propStr","_prop","hex2tuple","hex","shortHex","base","parseInt","hsl2tuple","hsl","hue2rgb","rgb2tuple","rgb","isPct","channel","atLeastOneIsPct","allArePct","colorname2tuple","colors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","mapEmpty","pushMap","deleteMap","keepChildren","lastKey","ascending","charAt","performance","pnow","raf","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","Item","process","nextTick","title","browser","env","argv","versions","removeAllListeners","prependListener","prependOnceListener","cwd","chdir","umask","global","Function","task","tasksByHandle","nextHandle","registerImmediate","handle","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","attachEvent","installMessageChannelImplementation","MessageChannel","port1","port2","installReadyStateChangeImplementation","html","doc","script","onreadystatechange","installSetTimeoutImplementation","attachTo","getPrototypeOf","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","eval","961","962","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","_siftdown","_siftup","lo","hi","cmp","lastelt","returnitem","_len","_ref1","_results","_results1","elem","los","startpos","newitem","parentpos","childpos","endpos","rightpos","pushpop","heap","front","1060","wait","invokeFunc","lastArgs","lastThis","lastInvokeTime","leadingEdge","timerId","timerExpired","leading","remainingWait","timeSinceLastCall","lastCallTime","timeSinceLastInvoke","maxing","nativeMin","maxWait","shouldInvoke","trailingEdge","trailing","cancel","flush","debounced","isInvoking","FUNC_ERROR_TEXT","toNumber","isObject","nativeMax","isObjectLike","isSymbol","objectToString","symbolTag","NAN","valueOf","reTrim","isBinary","reIsBinary","test","reIsOctal","freeParseInt","reIsBadHex","freeGlobal","freeSelf","objectProto","1477","557","scope","645","_interopRequireDefault","_classCallCheck2","_classCallCheck3","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_react","_react2","_cytoscape","_cytoscape2","Cytoscape","_Component","componentDidMount","Component","1218"],"mappings":"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","file":"component---src-pages-demo-route-index-js-3c2d287606d78cd9960e.js","sourcesContent":["webpackJsonp([174189240362290],{\n\n/***/ 743:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(961), __webpack_require__(1060));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"heap\", \"lodash.debounce\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"cytoscape\"] = factory(require(\"heap\"), require(\"lodash.debounce\"));\n\t\telse\n\t\t\troot[\"cytoscape\"] = factory(root[\"heap\"], root[\"lodash.debounce\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_140__, __WEBPACK_EXTERNAL_MODULE_141__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId]) {\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/ \t\t}\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\ti: moduleId,\n\t/******/ \t\t\tl: false,\n\t/******/ \t\t\texports: {}\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.l = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// identity function for calling harmony imports with the correct context\n\t/******/ \t__webpack_require__.i = function(value) { return value; };\n\t/******/\n\t/******/ \t// define getter function for harmony exports\n\t/******/ \t__webpack_require__.d = function(exports, name, getter) {\n\t/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n\t/******/ \t\t\tObject.defineProperty(exports, name, {\n\t/******/ \t\t\t\tconfigurable: false,\n\t/******/ \t\t\t\tenumerable: true,\n\t/******/ \t\t\t\tget: getter\n\t/******/ \t\t\t});\n\t/******/ \t\t}\n\t/******/ \t};\n\t/******/\n\t/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n\t/******/ \t__webpack_require__.n = function(module) {\n\t/******/ \t\tvar getter = module && module.__esModule ?\n\t/******/ \t\t\tfunction getDefault() { return module['default']; } :\n\t/******/ \t\t\tfunction getModuleExports() { return module; };\n\t/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n\t/******/ \t\treturn getter;\n\t/******/ \t};\n\t/******/\n\t/******/ \t// Object.prototype.hasOwnProperty.call\n\t/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(__webpack_require__.s = 116);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*global HTMLElement DocumentTouch */\n\t\n\tvar window = __webpack_require__(4);\n\tvar navigator = window ? window.navigator : null;\n\tvar document = window ? window.document : null;\n\t\n\tvar typeofstr = _typeof('');\n\tvar typeofobj = _typeof({});\n\tvar typeoffn = _typeof(function () {});\n\tvar typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);\n\t\n\tvar instanceStr = function instanceStr(obj) {\n\t  return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;\n\t};\n\t\n\tvar is = {\n\t  defined: function defined(obj) {\n\t    return obj != null; // not undefined or null\n\t  },\n\t\n\t  string: function string(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;\n\t  },\n\t\n\t  fn: function fn(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;\n\t  },\n\t\n\t  array: function array(obj) {\n\t    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n\t  },\n\t\n\t  plainObject: function plainObject(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;\n\t  },\n\t\n\t  object: function object(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;\n\t  },\n\t\n\t  number: function number(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);\n\t  },\n\t\n\t  integer: function integer(obj) {\n\t    return is.number(obj) && Math.floor(obj) === obj;\n\t  },\n\t\n\t  bool: function bool(obj) {\n\t    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);\n\t  },\n\t\n\t  htmlElement: function htmlElement(obj) {\n\t    if ('undefined' === typeofhtmlele) {\n\t      return undefined;\n\t    } else {\n\t      return null != obj && obj instanceof HTMLElement;\n\t    }\n\t  },\n\t\n\t  elementOrCollection: function elementOrCollection(obj) {\n\t    return is.element(obj) || is.collection(obj);\n\t  },\n\t\n\t  element: function element(obj) {\n\t    return instanceStr(obj) === 'collection' && obj._private.single;\n\t  },\n\t\n\t  collection: function collection(obj) {\n\t    return instanceStr(obj) === 'collection' && !obj._private.single;\n\t  },\n\t\n\t  core: function core(obj) {\n\t    return instanceStr(obj) === 'core';\n\t  },\n\t\n\t  style: function style(obj) {\n\t    return instanceStr(obj) === 'style';\n\t  },\n\t\n\t  stylesheet: function stylesheet(obj) {\n\t    return instanceStr(obj) === 'stylesheet';\n\t  },\n\t\n\t  event: function event(obj) {\n\t    return instanceStr(obj) === 'event';\n\t  },\n\t\n\t  thread: function thread(obj) {\n\t    return instanceStr(obj) === 'thread';\n\t  },\n\t\n\t  fabric: function fabric(obj) {\n\t    return instanceStr(obj) === 'fabric';\n\t  },\n\t\n\t  emptyString: function emptyString(obj) {\n\t    if (obj === undefined || obj === null) {\n\t      // null is empty\n\t      return true;\n\t    } else if (obj === '' || obj.match(/^\\s+$/)) {\n\t      return true; // empty string is empty\n\t    }\n\t\n\t    return false; // otherwise, we don't know what we've got\n\t  },\n\t\n\t  nonemptyString: function nonemptyString(obj) {\n\t    if (obj && is.string(obj) && obj !== '' && !obj.match(/^\\s+$/)) {\n\t      return true;\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  domElement: function domElement(obj) {\n\t    if (typeof HTMLElement === 'undefined') {\n\t      return false; // we're not in a browser so it doesn't matter\n\t    } else {\n\t      return obj instanceof HTMLElement;\n\t    }\n\t  },\n\t\n\t  boundingBox: function boundingBox(obj) {\n\t    return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);\n\t  },\n\t\n\t  promise: function promise(obj) {\n\t    return is.object(obj) && is.fn(obj.then);\n\t  },\n\t\n\t  touch: function touch() {\n\t    return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);\n\t  },\n\t\n\t  gecko: function gecko() {\n\t    return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);\n\t  },\n\t\n\t  webkit: function webkit() {\n\t    return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);\n\t  },\n\t\n\t  chromium: function chromium() {\n\t    return window && typeof chrome !== 'undefined';\n\t  },\n\t\n\t  khtml: function khtml() {\n\t    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...\n\t  },\n\t\n\t  khtmlEtc: function khtmlEtc() {\n\t    return is.khtml() || is.webkit() || is.chromium();\n\t  },\n\t\n\t  ms: function ms() {\n\t    return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...\n\t  },\n\t\n\t  windows: function windows() {\n\t    return navigator && navigator.appVersion.match(/Win/i);\n\t  },\n\t\n\t  mac: function mac() {\n\t    return navigator && navigator.appVersion.match(/Mac/i);\n\t  },\n\t\n\t  linux: function linux() {\n\t    return navigator && navigator.appVersion.match(/Linux/i);\n\t  },\n\t\n\t  unix: function unix() {\n\t    return navigator && navigator.appVersion.match(/X11/i);\n\t  }\n\t};\n\t\n\tmodule.exports = is;\n\t\n\t/***/ }),\n\t/* 1 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/*global console */\n\t\n\tvar is = __webpack_require__(0);\n\tvar math = __webpack_require__(2);\n\t\n\tvar util = {\n\t\n\t  MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,\n\t\n\t  trueify: function trueify() {\n\t    return true;\n\t  },\n\t\n\t  falsify: function falsify() {\n\t    return false;\n\t  },\n\t\n\t  zeroify: function zeroify() {\n\t    return 0;\n\t  },\n\t\n\t  noop: function noop() {},\n\t\n\t  error: function error(msg) {\n\t    /* eslint-disable */\n\t    if (console.error) {\n\t      console.error.apply(console, arguments);\n\t\n\t      if (console.trace) {\n\t        console.trace();\n\t      }\n\t    } else {\n\t      console.log.apply(console, arguments);\n\t\n\t      if (console.trace) {\n\t        console.trace();\n\t      }\n\t    }\n\t    /* eslint-enable */\n\t  },\n\t\n\t  clone: function clone(obj) {\n\t    return this.extend({}, obj);\n\t  },\n\t\n\t  // gets a shallow copy of the argument\n\t  copy: function copy(obj) {\n\t    if (obj == null) {\n\t      return obj;\n\t    }if (is.array(obj)) {\n\t      return obj.slice();\n\t    } else if (is.plainObject(obj)) {\n\t      return this.clone(obj);\n\t    } else {\n\t      return obj;\n\t    }\n\t  },\n\t\n\t  copyArray: function copyArray(arr) {\n\t    return arr.slice();\n\t  },\n\t\n\t  clonePosition: function clonePosition(pos) {\n\t    return { x: pos.x, y: pos.y };\n\t  },\n\t\n\t  uuid: function uuid(a, b // placeholders\n\t  ) {\n\t    for ( // loop :)\n\t    b = a = ''; // b - result , a - numeric letiable\n\t    a++ < 36; //\n\t    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n\t    ? //  return a random number or 4\n\t    (a ^ 15 // if \"a\" is not 15\n\t    ? // genetate a random number from 0 to 15\n\t    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n\t    : 4 //  otherwise 4\n\t    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n\t    ) {}\n\t    return b;\n\t  }\n\t\n\t};\n\t\n\tutil.makeBoundingBox = math.makeBoundingBox.bind(math);\n\t\n\tutil._staticEmptyObject = {};\n\t\n\tutil.staticEmptyObject = function () {\n\t  return util._staticEmptyObject;\n\t};\n\t\n\tutil.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n\t  var args = arguments;\n\t\n\t  for (var i = 1; i < args.length; i++) {\n\t    var obj = args[i];\n\t\n\t    if (obj == null) {\n\t      continue;\n\t    }\n\t\n\t    var keys = Object.keys(obj);\n\t\n\t    for (var j = 0; j < keys.length; j++) {\n\t      var k = keys[j];\n\t\n\t      tgt[k] = obj[k];\n\t    }\n\t  }\n\t\n\t  return tgt;\n\t};\n\t\n\tutil.assign = util.extend;\n\t\n\tutil.default = function (val, def) {\n\t  if (val === undefined) {\n\t    return def;\n\t  } else {\n\t    return val;\n\t  }\n\t};\n\t\n\tutil.removeFromArray = function (arr, ele, manyCopies) {\n\t  for (var i = arr.length; i >= 0; i--) {\n\t    if (arr[i] === ele) {\n\t      arr.splice(i, 1);\n\t\n\t      if (!manyCopies) {\n\t        break;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tutil.clearArray = function (arr) {\n\t  arr.splice(0, arr.length);\n\t};\n\t\n\tutil.push = function (arr, otherArr) {\n\t  for (var i = 0; i < otherArr.length; i++) {\n\t    var el = otherArr[i];\n\t\n\t    arr.push(el);\n\t  }\n\t};\n\t\n\tutil.getPrefixedProperty = function (obj, propName, prefix) {\n\t  if (prefix) {\n\t    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n\t  }\n\t\n\t  return obj[propName];\n\t};\n\t\n\tutil.setPrefixedProperty = function (obj, propName, prefix, value) {\n\t  if (prefix) {\n\t    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n\t  }\n\t\n\t  obj[propName] = value;\n\t};\n\t\n\t[__webpack_require__(130), __webpack_require__(131), { memoize: __webpack_require__(19) }, __webpack_require__(132), __webpack_require__(134), __webpack_require__(135), __webpack_require__(133)].forEach(function (req) {\n\t  util.extend(util, req);\n\t});\n\t\n\tmodule.exports = util;\n\t\n\t/***/ }),\n\t/* 2 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = {};\n\t\n\tmath.arePositionsSame = function (p1, p2) {\n\t  return p1.x === p2.x && p1.y === p2.y;\n\t};\n\t\n\tmath.copyPosition = function (p) {\n\t  return { x: p.x, y: p.y };\n\t};\n\t\n\tmath.modelToRenderedPosition = function (p, zoom, pan) {\n\t  return {\n\t    x: p.x * zoom + pan.x,\n\t    y: p.y * zoom + pan.y\n\t  };\n\t};\n\t\n\tmath.renderedToModelPosition = function (p, zoom, pan) {\n\t  return {\n\t    x: (p.x - pan.x) / zoom,\n\t    y: (p.y - pan.y) / zoom\n\t  };\n\t};\n\t\n\tmath.array2point = function (arr) {\n\t  return {\n\t    x: arr[0],\n\t    y: arr[1]\n\t  };\n\t};\n\t\n\tmath.deg2rad = function (deg) {\n\t  return Math.PI * deg / 180;\n\t};\n\t\n\tmath.getAngleFromDisp = function (dispX, dispY) {\n\t  return Math.atan2(dispY, dispX) - Math.PI / 2;\n\t};\n\t\n\tmath.log2 = Math.log2 || function (n) {\n\t  return Math.log(n) / Math.log(2);\n\t};\n\t\n\tmath.signum = function (x) {\n\t  if (x > 0) {\n\t    return 1;\n\t  } else if (x < 0) {\n\t    return -1;\n\t  } else {\n\t    return 0;\n\t  }\n\t};\n\t\n\tmath.dist = function (p1, p2) {\n\t  return Math.sqrt(math.sqdist(p1, p2));\n\t};\n\t\n\tmath.sqdist = function (p1, p2) {\n\t  var dx = p2.x - p1.x;\n\t  var dy = p2.y - p1.y;\n\t\n\t  return dx * dx + dy * dy;\n\t};\n\t\n\t// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves\n\tmath.qbezierAt = function (p0, p1, p2, t) {\n\t  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n\t};\n\t\n\tmath.qbezierPtAt = function (p0, p1, p2, t) {\n\t  return {\n\t    x: math.qbezierAt(p0.x, p1.x, p2.x, t),\n\t    y: math.qbezierAt(p0.y, p1.y, p2.y, t)\n\t  };\n\t};\n\t\n\tmath.lineAt = function (p0, p1, t, d) {\n\t  var vec = {\n\t    x: p1.x - p0.x,\n\t    y: p1.y - p0.y\n\t  };\n\t\n\t  var vecDist = math.dist(p0, p1);\n\t\n\t  var normVec = {\n\t    x: vec.x / vecDist,\n\t    y: vec.y / vecDist\n\t  };\n\t\n\t  t = t == null ? 0 : t;\n\t\n\t  d = d != null ? d : t * vecDist;\n\t\n\t  return {\n\t    x: p0.x + normVec.x * d,\n\t    y: p0.y + normVec.y * d\n\t  };\n\t};\n\t\n\tmath.lineAtDist = function (p0, p1, d) {\n\t  return math.lineAt(p0, p1, undefined, d);\n\t};\n\t\n\t// get angle at A via cosine law\n\tmath.triangleAngle = function (A, B, C) {\n\t  var a = math.dist(B, C);\n\t  var b = math.dist(A, C);\n\t  var c = math.dist(A, B);\n\t\n\t  return Math.acos((a * a + b * b - c * c) / (2 * a * b));\n\t};\n\t\n\tmath.bound = function (min, val, max) {\n\t  return Math.max(min, Math.min(max, val));\n\t};\n\t\n\t// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n\tmath.makeBoundingBox = function (bb) {\n\t  if (bb == null) {\n\t    return {\n\t      x1: Infinity,\n\t      y1: Infinity,\n\t      x2: -Infinity,\n\t      y2: -Infinity,\n\t      w: 0,\n\t      h: 0\n\t    };\n\t  } else if (bb.x1 != null && bb.y1 != null) {\n\t    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n\t      return {\n\t        x1: bb.x1,\n\t        y1: bb.y1,\n\t        x2: bb.x2,\n\t        y2: bb.y2,\n\t        w: bb.x2 - bb.x1,\n\t        h: bb.y2 - bb.y1\n\t      };\n\t    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n\t      return {\n\t        x1: bb.x1,\n\t        y1: bb.y1,\n\t        x2: bb.x1 + bb.w,\n\t        y2: bb.y1 + bb.h,\n\t        w: bb.w,\n\t        h: bb.h\n\t      };\n\t    }\n\t  }\n\t};\n\t\n\tmath.updateBoundingBox = function (bb1, bb2) {\n\t  // update bb1 with bb2 bounds\n\t\n\t  bb1.x1 = Math.min(bb1.x1, bb2.x1);\n\t  bb1.x2 = Math.max(bb1.x2, bb2.x2);\n\t  bb1.w = bb1.x2 - bb1.x1;\n\t\n\t  bb1.y1 = Math.min(bb1.y1, bb2.y1);\n\t  bb1.y2 = Math.max(bb1.y2, bb2.y2);\n\t  bb1.h = bb1.y2 - bb1.y1;\n\t};\n\t\n\tmath.expandBoundingBoxByPoint = function (bb, x, y) {\n\t  bb.x1 = Math.min(bb.x1, x);\n\t  bb.x2 = Math.max(bb.x2, x);\n\t  bb.w = bb.x2 - bb.x1;\n\t\n\t  bb.y1 = Math.min(bb.y1, y);\n\t  bb.y2 = Math.max(bb.y2, y);\n\t  bb.h = bb.y2 - bb.y1;\n\t};\n\t\n\tmath.expandBoundingBox = function (bb, padding) {\n\t  bb.x1 -= padding;\n\t  bb.x2 += padding;\n\t  bb.y1 -= padding;\n\t  bb.y2 += padding;\n\t  bb.w = bb.x2 - bb.x1;\n\t  bb.h = bb.y2 - bb.y1;\n\t\n\t  return bb;\n\t};\n\t\n\tmath.boundingBoxesIntersect = function (bb1, bb2) {\n\t  // case: one bb to right of other\n\t  if (bb1.x1 > bb2.x2) {\n\t    return false;\n\t  }\n\t  if (bb2.x1 > bb1.x2) {\n\t    return false;\n\t  }\n\t\n\t  // case: one bb to left of other\n\t  if (bb1.x2 < bb2.x1) {\n\t    return false;\n\t  }\n\t  if (bb2.x2 < bb1.x1) {\n\t    return false;\n\t  }\n\t\n\t  // case: one bb above other\n\t  if (bb1.y2 < bb2.y1) {\n\t    return false;\n\t  }\n\t  if (bb2.y2 < bb1.y1) {\n\t    return false;\n\t  }\n\t\n\t  // case: one bb below other\n\t  if (bb1.y1 > bb2.y2) {\n\t    return false;\n\t  }\n\t  if (bb2.y1 > bb1.y2) {\n\t    return false;\n\t  }\n\t\n\t  // otherwise, must have some overlap\n\t  return true;\n\t};\n\t\n\tmath.inBoundingBox = function (bb, x, y) {\n\t  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n\t};\n\t\n\tmath.pointInBoundingBox = function (bb, pt) {\n\t  return this.inBoundingBox(bb, pt.x, pt.y);\n\t};\n\t\n\tmath.boundingBoxInBoundingBox = function (bb1, bb2) {\n\t  return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);\n\t};\n\t\n\tmath.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {\n\t\n\t  var cornerRadius = this.getRoundRectangleRadius(width, height);\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t\n\t  // Check intersections with straight line segments\n\t  var straightLineIntersections = void 0;\n\t\n\t  // Top segment, left to right\n\t  {\n\t    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n\t    var topStartY = nodeY - halfHeight - padding;\n\t    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n\t    var topEndY = topStartY;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\t\n\t    if (straightLineIntersections.length > 0) {\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Right segment, top to bottom\n\t  {\n\t    var rightStartX = nodeX + halfWidth + padding;\n\t    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n\t    var rightEndX = rightStartX;\n\t    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n\t\n\t    if (straightLineIntersections.length > 0) {\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Bottom segment, left to right\n\t  {\n\t    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n\t    var bottomStartY = nodeY + halfHeight + padding;\n\t    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n\t    var bottomEndY = bottomStartY;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n\t\n\t    if (straightLineIntersections.length > 0) {\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Left segment, top to bottom\n\t  {\n\t    var leftStartX = nodeX - halfWidth - padding;\n\t    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n\t    var leftEndX = leftStartX;\n\t    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n\t\n\t    if (straightLineIntersections.length > 0) {\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Check intersections with arc segments\n\t  var arcIntersections = void 0;\n\t\n\t  // Top Left\n\t  {\n\t    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n\t    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n\t      return [arcIntersections[0], arcIntersections[1]];\n\t    }\n\t  }\n\t\n\t  // Top Right\n\t  {\n\t    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n\t    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n\t      return [arcIntersections[0], arcIntersections[1]];\n\t    }\n\t  }\n\t\n\t  // Bottom Right\n\t  {\n\t    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n\t    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n\t      return [arcIntersections[0], arcIntersections[1]];\n\t    }\n\t  }\n\t\n\t  // Bottom Left\n\t  {\n\t    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n\t    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n\t      return [arcIntersections[0], arcIntersections[1]];\n\t    }\n\t  }\n\t\n\t  return []; // if nothing\n\t};\n\t\n\tmath.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {\n\t  var t = tolerance;\n\t\n\t  var x1 = Math.min(lx1, lx2);\n\t  var x2 = Math.max(lx1, lx2);\n\t  var y1 = Math.min(ly1, ly2);\n\t  var y2 = Math.max(ly1, ly2);\n\t\n\t  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n\t};\n\t\n\tmath.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n\t\n\t  var bb = {\n\t    x1: Math.min(x1, x3, x2) - tolerance,\n\t    x2: Math.max(x1, x3, x2) + tolerance,\n\t    y1: Math.min(y1, y3, y2) - tolerance,\n\t    y2: Math.max(y1, y3, y2) + tolerance\n\t  };\n\t\n\t  // if outside the rough bounding box for the bezier, then it can't be a hit\n\t  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n\t    // console.log('bezier out of rough bb')\n\t    return false;\n\t  } else {\n\t    // console.log('do more expensive check');\n\t    return true;\n\t  }\n\t};\n\tmath.solveQuadratic = function (a, b, c, val) {\n\t  c -= val;\n\t\n\t  var r = b * b - 4 * a * c;\n\t\n\t  if (r < 0) {\n\t    return [];\n\t  }\n\t\n\t  var sqrtR = Math.sqrt(r);\n\t  var denom = 2 * a;\n\t  var root1 = (-b + sqrtR) / denom;\n\t  var root2 = (-b - sqrtR) / denom;\n\t\n\t  return [root1, root2];\n\t};\n\t\n\tmath.solveCubic = function (a, b, c, d, result) {\n\t\n\t  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n\t  // r is the real component, i is the imaginary component\n\t\n\t  // An implementation of the Cardano method from the year 1545\n\t  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\t\n\t  b /= a;\n\t  c /= a;\n\t  d /= a;\n\t\n\t  var discriminant = void 0,\n\t      q = void 0,\n\t      r = void 0,\n\t      dum1 = void 0,\n\t      s = void 0,\n\t      t = void 0,\n\t      term1 = void 0,\n\t      r13 = void 0;\n\t\n\t  q = (3.0 * c - b * b) / 9.0;\n\t  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n\t  r /= 54.0;\n\t\n\t  discriminant = q * q * q + r * r;\n\t  result[1] = 0;\n\t  term1 = b / 3.0;\n\t\n\t  if (discriminant > 0) {\n\t    s = r + Math.sqrt(discriminant);\n\t    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n\t    t = r - Math.sqrt(discriminant);\n\t    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n\t    result[0] = -term1 + s + t;\n\t    term1 += (s + t) / 2.0;\n\t    result[4] = result[2] = -term1;\n\t    term1 = Math.sqrt(3.0) * (-t + s) / 2;\n\t    result[3] = term1;\n\t    result[5] = -term1;\n\t    return;\n\t  }\n\t\n\t  result[5] = result[3] = 0;\n\t\n\t  if (discriminant === 0) {\n\t    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n\t    result[0] = -term1 + 2.0 * r13;\n\t    result[4] = result[2] = -(r13 + term1);\n\t    return;\n\t  }\n\t\n\t  q = -q;\n\t  dum1 = q * q * q;\n\t  dum1 = Math.acos(r / Math.sqrt(dum1));\n\t  r13 = 2.0 * Math.sqrt(q);\n\t  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n\t  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n\t  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n\t\n\t  return;\n\t};\n\t\n\tmath.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {\n\t\n\t  // Find minimum distance by using the minimum of the distance\n\t  // function between the given point and the curve\n\t\n\t  // This gives the coefficients of the resulting cubic equation\n\t  // whose roots tell us where a possible minimum is\n\t  // (Coefficients are divided by 4)\n\t\n\t  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n\t\n\t  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n\t\n\t  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n\t\n\t  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n\t\n\t  // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\t\n\t  var roots = [];\n\t\n\t  // Use the cubic solving algorithm\n\t  this.solveCubic(a, b, c, d, roots);\n\t\n\t  var zeroThreshold = 0.0000001;\n\t\n\t  var params = [];\n\t\n\t  for (var index = 0; index < 6; index += 2) {\n\t    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n\t      params.push(roots[index]);\n\t    }\n\t  }\n\t\n\t  params.push(1.0);\n\t  params.push(0.0);\n\t\n\t  var minDistanceSquared = -1;\n\t\n\t  var curX = void 0,\n\t      curY = void 0,\n\t      distSquared = void 0;\n\t  for (var i = 0; i < params.length; i++) {\n\t    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n\t\n\t    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n\t\n\t    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n\t    // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n\t    if (minDistanceSquared >= 0) {\n\t      if (distSquared < minDistanceSquared) {\n\t        minDistanceSquared = distSquared;\n\t      }\n\t    } else {\n\t      minDistanceSquared = distSquared;\n\t    }\n\t  }\n\t\n\t  return minDistanceSquared;\n\t};\n\t\n\tmath.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {\n\t  var offset = [x - x1, y - y1];\n\t  var line = [x2 - x1, y2 - y1];\n\t\n\t  var lineSq = line[0] * line[0] + line[1] * line[1];\n\t  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n\t\n\t  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n\t  var adjSq = dotProduct * dotProduct / lineSq;\n\t\n\t  if (dotProduct < 0) {\n\t    return hypSq;\n\t  }\n\t\n\t  if (adjSq > lineSq) {\n\t    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n\t  }\n\t\n\t  return hypSq - adjSq;\n\t};\n\t\n\tmath.pointInsidePolygonPoints = function (x, y, points) {\n\t  var x1 = void 0,\n\t      y1 = void 0,\n\t      x2 = void 0,\n\t      y2 = void 0;\n\t  var y3 = void 0;\n\t\n\t  // Intersect with vertical line through (x, y)\n\t  var up = 0;\n\t  // let down = 0;\n\t  for (var i = 0; i < points.length / 2; i++) {\n\t    x1 = points[i * 2];\n\t    y1 = points[i * 2 + 1];\n\t\n\t    if (i + 1 < points.length / 2) {\n\t      x2 = points[(i + 1) * 2];\n\t      y2 = points[(i + 1) * 2 + 1];\n\t    } else {\n\t      x2 = points[(i + 1 - points.length / 2) * 2];\n\t      y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n\t    }\n\t\n\t    if (x1 == x && x2 == x) {\n\t      // then ignore\n\t    } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n\t\n\t      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\t\n\t      if (y3 > y) {\n\t        up++;\n\t      }\n\t\n\t      // if( y3 < y ){\n\t      // down++;\n\t      // }\n\t    } else {\n\t      continue;\n\t    }\n\t  }\n\t\n\t  if (up % 2 === 0) {\n\t    return false;\n\t  } else {\n\t    return true;\n\t  }\n\t};\n\t\n\tmath.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n\t\n\t  //let direction = arguments[6];\n\t  var transformedPoints = new Array(basePoints.length);\n\t\n\t  // Gives negative angle\n\t  var angle = void 0;\n\t\n\t  if (direction[0] != null) {\n\t    angle = Math.atan(direction[1] / direction[0]);\n\t\n\t    if (direction[0] < 0) {\n\t      angle = angle + Math.PI / 2;\n\t    } else {\n\t      angle = -angle - Math.PI / 2;\n\t    }\n\t  } else {\n\t    angle = direction;\n\t  }\n\t\n\t  var cos = Math.cos(-angle);\n\t  var sin = Math.sin(-angle);\n\t\n\t  //    console.log(\"base: \" + basePoints);\n\t  for (var i = 0; i < transformedPoints.length / 2; i++) {\n\t    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n\t\n\t    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n\t\n\t    transformedPoints[i * 2] += centerX;\n\t    transformedPoints[i * 2 + 1] += centerY;\n\t  }\n\t\n\t  var points = void 0;\n\t\n\t  if (padding > 0) {\n\t    var expandedLineSet = this.expandPolygon(transformedPoints, -padding);\n\t\n\t    points = this.joinLines(expandedLineSet);\n\t  } else {\n\t    points = transformedPoints;\n\t  }\n\t\n\t  return math.pointInsidePolygonPoints(x, y, points);\n\t};\n\t\n\tmath.joinLines = function (lineSet) {\n\t\n\t  var vertices = new Array(lineSet.length / 2);\n\t\n\t  var currentLineStartX = void 0,\n\t      currentLineStartY = void 0,\n\t      currentLineEndX = void 0,\n\t      currentLineEndY = void 0;\n\t  var nextLineStartX = void 0,\n\t      nextLineStartY = void 0,\n\t      nextLineEndX = void 0,\n\t      nextLineEndY = void 0;\n\t\n\t  for (var i = 0; i < lineSet.length / 4; i++) {\n\t    currentLineStartX = lineSet[i * 4];\n\t    currentLineStartY = lineSet[i * 4 + 1];\n\t    currentLineEndX = lineSet[i * 4 + 2];\n\t    currentLineEndY = lineSet[i * 4 + 3];\n\t\n\t    if (i < lineSet.length / 4 - 1) {\n\t      nextLineStartX = lineSet[(i + 1) * 4];\n\t      nextLineStartY = lineSet[(i + 1) * 4 + 1];\n\t      nextLineEndX = lineSet[(i + 1) * 4 + 2];\n\t      nextLineEndY = lineSet[(i + 1) * 4 + 3];\n\t    } else {\n\t      nextLineStartX = lineSet[0];\n\t      nextLineStartY = lineSet[1];\n\t      nextLineEndX = lineSet[2];\n\t      nextLineEndY = lineSet[3];\n\t    }\n\t\n\t    var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n\t\n\t    vertices[i * 2] = intersection[0];\n\t    vertices[i * 2 + 1] = intersection[1];\n\t  }\n\t\n\t  return vertices;\n\t};\n\t\n\tmath.expandPolygon = function (points, pad) {\n\t\n\t  var expandedLineSet = new Array(points.length * 2);\n\t\n\t  var currentPointX = void 0,\n\t      currentPointY = void 0,\n\t      nextPointX = void 0,\n\t      nextPointY = void 0;\n\t\n\t  for (var i = 0; i < points.length / 2; i++) {\n\t    currentPointX = points[i * 2];\n\t    currentPointY = points[i * 2 + 1];\n\t\n\t    if (i < points.length / 2 - 1) {\n\t      nextPointX = points[(i + 1) * 2];\n\t      nextPointY = points[(i + 1) * 2 + 1];\n\t    } else {\n\t      nextPointX = points[0];\n\t      nextPointY = points[1];\n\t    }\n\t\n\t    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n\t\n\t    // Assume CCW polygon winding\n\t\n\t    var offsetX = nextPointY - currentPointY;\n\t    var offsetY = -(nextPointX - currentPointX);\n\t\n\t    // Normalize\n\t    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n\t    var normalizedOffsetX = offsetX / offsetLength;\n\t    var normalizedOffsetY = offsetY / offsetLength;\n\t\n\t    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n\t    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n\t    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n\t    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n\t  }\n\t\n\t  return expandedLineSet;\n\t};\n\t\n\tmath.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n\t\n\t  var dispX = centerX - x;\n\t  var dispY = centerY - y;\n\t\n\t  dispX /= ellipseWradius;\n\t  dispY /= ellipseHradius;\n\t\n\t  var len = Math.sqrt(dispX * dispX + dispY * dispY);\n\t\n\t  var newLength = len - 1;\n\t\n\t  if (newLength < 0) {\n\t    return [];\n\t  }\n\t\n\t  var lenProportion = newLength / len;\n\t\n\t  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n\t};\n\t\n\tmath.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {\n\t  x -= centerX;\n\t  y -= centerY;\n\t\n\t  x /= width / 2 + padding;\n\t  y /= height / 2 + padding;\n\t\n\t  return x * x + y * y <= 1;\n\t};\n\t\n\t// Returns intersections of increasing distance from line's start point\n\tmath.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {\n\t\n\t  // Calculate d, direction vector of line\n\t  var d = [x2 - x1, y2 - y1]; // Direction vector of line\n\t  var f = [x1 - centerX, y1 - centerY];\n\t\n\t  var a = d[0] * d[0] + d[1] * d[1];\n\t  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n\t  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n\t\n\t  var discriminant = b * b - 4 * a * c;\n\t\n\t  if (discriminant < 0) {\n\t    return [];\n\t  }\n\t\n\t  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n\t  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n\t\n\t  var tMin = Math.min(t1, t2);\n\t  var tMax = Math.max(t1, t2);\n\t  var inRangeParams = [];\n\t\n\t  if (tMin >= 0 && tMin <= 1) {\n\t    inRangeParams.push(tMin);\n\t  }\n\t\n\t  if (tMax >= 0 && tMax <= 1) {\n\t    inRangeParams.push(tMax);\n\t  }\n\t\n\t  if (inRangeParams.length === 0) {\n\t    return [];\n\t  }\n\t\n\t  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n\t  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\t\n\t  if (inRangeParams.length > 1) {\n\t\n\t    if (inRangeParams[0] == inRangeParams[1]) {\n\t      return [nearIntersectionX, nearIntersectionY];\n\t    } else {\n\t\n\t      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n\t      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n\t\n\t      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n\t    }\n\t  } else {\n\t    return [nearIntersectionX, nearIntersectionY];\n\t  }\n\t};\n\t\n\tmath.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {\n\t\n\t  var displacementX = farX - centerX;\n\t  var displacementY = farY - centerY;\n\t  var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);\n\t\n\t  var unitDisplacementX = displacementX / distance;\n\t  var unitDisplacementY = displacementY / distance;\n\t\n\t  return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];\n\t};\n\t\n\tmath.findMaxSqDistanceToOrigin = function (points) {\n\t  var maxSqDistance = 0.000001;\n\t  var sqDistance = void 0;\n\t\n\t  for (var i = 0; i < points.length / 2; i++) {\n\t\n\t    sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];\n\t\n\t    if (sqDistance > maxSqDistance) {\n\t      maxSqDistance = sqDistance;\n\t    }\n\t  }\n\t\n\t  return maxSqDistance;\n\t};\n\t\n\tmath.midOfThree = function (a, b, c) {\n\t  if (b <= a && a <= c || c <= a && a <= b) {\n\t    return a;\n\t  } else if (a <= b && b <= c || c <= b && b <= a) {\n\t    return b;\n\t  } else {\n\t    return c;\n\t  }\n\t};\n\t\n\t// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\n\tmath.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n\t\n\t  var dx13 = x1 - x3;\n\t  var dx21 = x2 - x1;\n\t  var dx43 = x4 - x3;\n\t\n\t  var dy13 = y1 - y3;\n\t  var dy21 = y2 - y1;\n\t  var dy43 = y4 - y3;\n\t\n\t  var ua_t = dx43 * dy13 - dy43 * dx13;\n\t  var ub_t = dx21 * dy13 - dy21 * dx13;\n\t  var u_b = dy43 * dx21 - dx43 * dy21;\n\t\n\t  if (u_b !== 0) {\n\t    var ua = ua_t / u_b;\n\t    var ub = ub_t / u_b;\n\t\n\t    var flptThreshold = 0.001;\n\t    var min = 0 - flptThreshold;\n\t    var max = 1 + flptThreshold;\n\t\n\t    if (min <= ua && ua <= max && min <= ub && ub <= max) {\n\t      return [x1 + ua * dx21, y1 + ua * dy21];\n\t    } else {\n\t      if (!infiniteLines) {\n\t        return [];\n\t      } else {\n\t        return [x1 + ua * dx21, y1 + ua * dy21];\n\t      }\n\t    }\n\t  } else {\n\t    if (ua_t === 0 || ub_t === 0) {\n\t\n\t      // Parallel, coincident lines. Check if overlap\n\t\n\t      // Check endpoint of second line\n\t      if (this.midOfThree(x1, x2, x4) === x4) {\n\t        return [x4, y4];\n\t      }\n\t\n\t      // Check start point of second line\n\t      if (this.midOfThree(x1, x2, x3) === x3) {\n\t        return [x3, y3];\n\t      }\n\t\n\t      // Endpoint of first line\n\t      if (this.midOfThree(x3, x4, x2) === x2) {\n\t        return [x2, y2];\n\t      }\n\t\n\t      return [];\n\t    } else {\n\t\n\t      // Parallel, non-coincident\n\t      return [];\n\t    }\n\t  }\n\t};\n\t\n\t// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n\t// intersect a node polygon (pts transformed)\n\t//\n\t// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n\t// intersect the points (no transform)\n\tmath.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {\n\t\n\t  var intersections = [];\n\t  var intersection = void 0;\n\t\n\t  var transformedPoints = new Array(basePoints.length);\n\t\n\t  var doTransform = true;\n\t  if (arguments.length === 5) {\n\t    doTransform = false;\n\t  }\n\t\n\t  var points = void 0;\n\t\n\t  if (doTransform) {\n\t    for (var i = 0; i < transformedPoints.length / 2; i++) {\n\t      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n\t      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n\t    }\n\t\n\t    if (padding > 0) {\n\t      var expandedLineSet = math.expandPolygon(transformedPoints, -padding);\n\t\n\t      points = math.joinLines(expandedLineSet);\n\t    } else {\n\t      points = transformedPoints;\n\t    }\n\t  } else {\n\t    points = basePoints;\n\t  }\n\t\n\t  var currentX = void 0,\n\t      currentY = void 0,\n\t      nextX = void 0,\n\t      nextY = void 0;\n\t\n\t  for (var _i = 0; _i < points.length / 2; _i++) {\n\t\n\t    currentX = points[_i * 2];\n\t    currentY = points[_i * 2 + 1];\n\t\n\t    if (_i < points.length / 2 - 1) {\n\t      nextX = points[(_i + 1) * 2];\n\t      nextY = points[(_i + 1) * 2 + 1];\n\t    } else {\n\t      nextX = points[0];\n\t      nextY = points[1];\n\t    }\n\t\n\t    intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n\t\n\t    if (intersection.length !== 0) {\n\t      intersections.push(intersection[0], intersection[1]);\n\t    }\n\t  }\n\t\n\t  return intersections;\n\t};\n\t\n\tmath.shortenIntersection = function (intersection, offset, amount) {\n\t\n\t  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n\t\n\t  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n\t\n\t  var lenRatio = (length - amount) / length;\n\t\n\t  if (lenRatio < 0) {\n\t    lenRatio = 0.00001;\n\t  }\n\t\n\t  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n\t};\n\t\n\tmath.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {\n\t  var points = math.generateUnitNgonPoints(sides, rotationRadians);\n\t  points = math.fitPolygonToSquare(points);\n\t\n\t  return points;\n\t};\n\t\n\tmath.fitPolygonToSquare = function (points) {\n\t  var x = void 0,\n\t      y = void 0;\n\t  var sides = points.length / 2;\n\t  var minX = Infinity,\n\t      minY = Infinity,\n\t      maxX = -Infinity,\n\t      maxY = -Infinity;\n\t\n\t  for (var i = 0; i < sides; i++) {\n\t    x = points[2 * i];\n\t    y = points[2 * i + 1];\n\t\n\t    minX = Math.min(minX, x);\n\t    maxX = Math.max(maxX, x);\n\t    minY = Math.min(minY, y);\n\t    maxY = Math.max(maxY, y);\n\t  }\n\t\n\t  // stretch factors\n\t  var sx = 2 / (maxX - minX);\n\t  var sy = 2 / (maxY - minY);\n\t\n\t  for (var _i2 = 0; _i2 < sides; _i2++) {\n\t    x = points[2 * _i2] = points[2 * _i2] * sx;\n\t    y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;\n\t\n\t    minX = Math.min(minX, x);\n\t    maxX = Math.max(maxX, x);\n\t    minY = Math.min(minY, y);\n\t    maxY = Math.max(maxY, y);\n\t  }\n\t\n\t  if (minY < -1) {\n\t    for (var _i3 = 0; _i3 < sides; _i3++) {\n\t      y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);\n\t    }\n\t  }\n\t\n\t  return points;\n\t};\n\t\n\tmath.generateUnitNgonPoints = function (sides, rotationRadians) {\n\t\n\t  var increment = 1.0 / sides * 2 * Math.PI;\n\t  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n\t\n\t  startAngle += rotationRadians;\n\t\n\t  var points = new Array(sides * 2);\n\t\n\t  var currentAngle = void 0;\n\t  for (var i = 0; i < sides; i++) {\n\t    currentAngle = i * increment + startAngle;\n\t\n\t    points[2 * i] = Math.cos(currentAngle); // x\n\t    points[2 * i + 1] = Math.sin(-currentAngle); // y\n\t  }\n\t\n\t  return points;\n\t};\n\t\n\tmath.getRoundRectangleRadius = function (width, height) {\n\t\n\t  // Set the default radius, unless half of width or height is smaller than default\n\t  return Math.min(width / 4, height / 4, 8);\n\t};\n\t\n\tmath.getCutRectangleCornerLength = function () {\n\t  return 8;\n\t};\n\t\n\tmath.bezierPtsToQuadCoeff = function (p0, p1, p2) {\n\t  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n\t};\n\t\n\tmath.getBarrelCurveConstants = function (width, height) {\n\t  // get curve width, height, and control point position offsets as a percentage of node height / width\n\t  return {\n\t    heightOffset: Math.min(15, 0.05 * height),\n\t    widthOffset: Math.min(100, 0.25 * width),\n\t    ctrlPtOffsetPct: 0.05\n\t  };\n\t};\n\t\n\tmodule.exports = math;\n\t\n\t/***/ }),\n\t/* 3 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t// use this module to cherry pick functions into your prototype\n\t// (useful for functions shared between the core and collections, for example)\n\t\n\t// e.g.\n\t// let foo = define.foo({ /* params... */ })\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar define = {};\n\t\n\t[__webpack_require__(72), __webpack_require__(73), __webpack_require__(74)].forEach(function (m) {\n\t  util.assign(define, m);\n\t});\n\t\n\tmodule.exports = define;\n\t\n\t/***/ }),\n\t/* 4 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\t\n\t/***/ }),\n\t/* 5 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\tEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\n\tCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\n\tLicensed under The MIT License (http://opensource.org/licenses/MIT)\n\t*/\n\t\n\t/*  promise states [Promises/A+ 2.1]  */\n\tvar STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */\n\tvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */\n\tvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */\n\t\n\t/*  promise object constructor  */\n\tvar api = function api(executor) {\n\t  /*  optionally support non-constructor/plain-function call  */\n\t  if (!(this instanceof api)) return new api(executor);\n\t\n\t  /*  initialize object  */\n\t  this.id = 'Thenable/1.0.7';\n\t  this.state = STATE_PENDING; /*  initial state  */\n\t  this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\t  this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\t  this.onFulfilled = []; /*  initial handlers  */\n\t  this.onRejected = []; /*  initial handlers  */\n\t\n\t  /*  provide optional information-hiding proxy  */\n\t  this.proxy = {\n\t    then: this.then.bind(this)\n\t  };\n\t\n\t  /*  support optional executor function  */\n\t  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n\t};\n\t\n\t/*  promise API methods  */\n\tapi.prototype = {\n\t  /*  promise resolving methods  */\n\t  fulfill: function fulfill(value) {\n\t    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n\t  },\n\t  reject: function reject(value) {\n\t    return deliver(this, STATE_REJECTED, 'rejectReason', value);\n\t  },\n\t\n\t  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n\t  then: function then(onFulfilled, onRejected) {\n\t    var curr = this;\n\t    var next = new api(); /*  [Promises/A+ 2.2.7]  */\n\t    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */\n\t    curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */\n\t    execute(curr);\n\t    return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */\n\t  }\n\t};\n\t\n\t/*  deliver an action  */\n\tvar deliver = function deliver(curr, state, name, value) {\n\t  if (curr.state === STATE_PENDING) {\n\t    curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\t    curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\t    execute(curr);\n\t  }\n\t  return curr;\n\t};\n\t\n\t/*  execute all handlers  */\n\tvar execute = function execute(curr) {\n\t  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n\t};\n\t\n\t/*  execute particular set of handlers  */\n\tvar execute_handlers = function execute_handlers(curr, name, value) {\n\t  /* global setImmediate: true */\n\t  /* global setTimeout: true */\n\t\n\t  /*  short-circuit processing  */\n\t  if (curr[name].length === 0) return;\n\t\n\t  /*  iterate over all handlers, exactly once  */\n\t  var handlers = curr[name];\n\t  curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\t  var func = function func() {\n\t    for (var i = 0; i < handlers.length; i++) {\n\t      handlers[i](value);\n\t    } /*  [Promises/A+ 2.2.5]  */\n\t  };\n\t\n\t  /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */\n\t  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n\t};\n\t\n\t/*  generate a resolver function  */\n\tvar resolver = function resolver(cb, next, method) {\n\t  return function (value) {\n\t    if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n\t      next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n\t    else {\n\t        var result;\n\t        try {\n\t          result = cb(value);\n\t        } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n\t        catch (e) {\n\t          next.reject(e); /*  [Promises/A+ 2.2.7.2]  */\n\t          return;\n\t        }\n\t        resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */\n\t      }\n\t  };\n\t};\n\t\n\t/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */\n\tvar resolve = function resolve(promise, x) {\n\t  /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */\n\t  if (promise === x || promise.proxy === x) {\n\t    promise.reject(new TypeError('cannot resolve promise with itself'));\n\t    return;\n\t  }\n\t\n\t  /*  surgically check for a \"then\" method\n\t    (mainly to just call the \"getter\" of \"then\" only once)  */\n\t  var then;\n\t  if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {\n\t    try {\n\t      then = x.then;\n\t    } /*  [Promises/A+ 2.3.3.1, 3.5]  */\n\t    catch (e) {\n\t      promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */\n\t      return;\n\t    }\n\t  }\n\t\n\t  /*  handle own Thenables    [Promises/A+ 2.3.2]\n\t    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\t  if (typeof then === 'function') {\n\t    var resolved = false;\n\t    try {\n\t      /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */\n\t      then.call(x,\n\t      /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */\n\t      function (y) {\n\t        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n\t        if (y === x) /*  [Promises/A+ 3.6]  */\n\t          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n\t      },\n\t\n\t      /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */\n\t      function (r) {\n\t        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n\t        promise.reject(r);\n\t      });\n\t    } catch (e) {\n\t      if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */\n\t        promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */\n\t    }\n\t    return;\n\t  }\n\t\n\t  /*  handle other values  */\n\t  promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n\t};\n\t\n\t// so we always have Promise.all()\n\tapi.all = function (ps) {\n\t  return new api(function (resolveAll, rejectAll) {\n\t    var vals = new Array(ps.length);\n\t    var doneCount = 0;\n\t\n\t    var fulfill = function fulfill(i, val) {\n\t      vals[i] = val;\n\t      doneCount++;\n\t\n\t      if (doneCount === ps.length) {\n\t        resolveAll(vals);\n\t      }\n\t    };\n\t\n\t    for (var i = 0; i < ps.length; i++) {\n\t      (function (i) {\n\t        var p = ps[i];\n\t        var isPromise = p != null && p.then != null;\n\t\n\t        if (isPromise) {\n\t          p.then(function (val) {\n\t            fulfill(i, val);\n\t          }, function (err) {\n\t            rejectAll(err);\n\t          });\n\t        } else {\n\t          var val = p;\n\t          fulfill(i, val);\n\t        }\n\t      })(i);\n\t    }\n\t  });\n\t};\n\t\n\tapi.resolve = function (val) {\n\t  return new api(function (resolve, reject) {\n\t    resolve(val);\n\t  });\n\t};\n\t\n\tapi.reject = function (val) {\n\t  return new api(function (resolve, reject) {\n\t    reject(val);\n\t  });\n\t};\n\t\n\tmodule.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(138).setImmediate))\n\t\n\t/***/ }),\n\t/* 6 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar newQuery = __webpack_require__(11);\n\t\n\tvar Selector = function Selector(selector) {\n\t  var self = this;\n\t\n\t  self._private = {\n\t    selectorText: selector,\n\t    invalid: true\n\t  };\n\t\n\t  if (selector == null || is.string(selector) && selector.match(/^\\s*$/)) {\n\t\n\t    self.length = 0;\n\t  } else if (selector === '*' || selector === 'edge' || selector === 'node') {\n\t\n\t    // make single, group-only selectors cheap to make and cheap to filter\n\t\n\t    self[0] = newQuery();\n\t    self[0].group = selector === '*' ? selector : selector + 's';\n\t    self[0].groupOnly = true;\n\t    self[0].length = 1;\n\t    self._private.invalid = false;\n\t    self.length = 1;\n\t  } else if (is.elementOrCollection(selector)) {\n\t\n\t    var collection = selector.collection();\n\t\n\t    self[0] = newQuery();\n\t    self[0].collection = collection;\n\t    self[0].length = 1;\n\t    self.length = 1;\n\t  } else if (is.fn(selector)) {\n\t\n\t    self[0] = newQuery();\n\t    self[0].filter = selector;\n\t    self[0].length = 1;\n\t    self.length = 1;\n\t  } else if (is.string(selector)) {\n\t    if (!self.parse(selector)) {\n\t      return;\n\t    }\n\t  } else {\n\t    util.error('A selector must be created from a string; found ', selector);\n\t    return;\n\t  }\n\t\n\t  self._private.invalid = false;\n\t};\n\t\n\tvar selfn = Selector.prototype;\n\t\n\tselfn.valid = function () {\n\t  return !this._private.invalid;\n\t};\n\t\n\tselfn.invalid = function () {\n\t  return this._private.invalid;\n\t};\n\t\n\tselfn.text = function () {\n\t  return this._private.selectorText;\n\t};\n\t\n\tselfn.size = function () {\n\t  return this.length;\n\t};\n\t\n\tselfn.eq = function (i) {\n\t  return this[i];\n\t};\n\t\n\tselfn.sameText = function (otherSel) {\n\t  return this.text() === otherSel.text();\n\t};\n\t\n\tselfn.toString = selfn.selector = function () {\n\t\n\t  if (this._private.toStringCache != null) {\n\t    return this._private.toStringCache;\n\t  }\n\t\n\t  var i = void 0;\n\t  var str = '';\n\t\n\t  var clean = function clean(obj) {\n\t    if (obj == null) {\n\t      return '';\n\t    } else {\n\t      return obj;\n\t    }\n\t  };\n\t\n\t  var cleanVal = function cleanVal(val) {\n\t    if (is.string(val)) {\n\t      return '\"' + val + '\"';\n\t    } else {\n\t      return clean(val);\n\t    }\n\t  };\n\t\n\t  var space = function space(val) {\n\t    return ' ' + val + ' ';\n\t  };\n\t\n\t  var queryToString = function queryToString(query) {\n\t    var str = '';\n\t    var j = void 0,\n\t        sel = void 0;\n\t\n\t    if (query.subject === query) {\n\t      str += '$';\n\t    }\n\t\n\t    var group = clean(query.group);\n\t    str += group.substring(0, group.length - 1);\n\t\n\t    for (j = 0; j < query.data.length; j++) {\n\t      var data = query.data[j];\n\t\n\t      if (data.value) {\n\t        str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';\n\t      } else {\n\t        str += '[' + clean(data.operator) + data.field + ']';\n\t      }\n\t    }\n\t\n\t    for (j = 0; j < query.meta.length; j++) {\n\t      var meta = query.meta[j];\n\t      str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';\n\t    }\n\t\n\t    for (j = 0; j < query.colonSelectors.length; j++) {\n\t      sel = query.colonSelectors[i];\n\t      str += sel;\n\t    }\n\t\n\t    for (j = 0; j < query.ids.length; j++) {\n\t      sel = '#' + query.ids[i];\n\t      str += sel;\n\t    }\n\t\n\t    for (j = 0; j < query.classes.length; j++) {\n\t      sel = '.' + query.classes[j];\n\t      str += sel;\n\t    }\n\t\n\t    if (query.source != null && query.target != null) {\n\t      str = queryToString(query.source) + ' -> ' + queryToString(query.target);\n\t    }\n\t\n\t    if (query.connectedNodes != null) {\n\t      var n = query.connectedNodes;\n\t\n\t      str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);\n\t    }\n\t\n\t    if (query.parent != null) {\n\t      str = queryToString(query.parent) + ' > ' + str;\n\t    }\n\t\n\t    if (query.ancestor != null) {\n\t      str = queryToString(query.ancestor) + ' ' + str;\n\t    }\n\t\n\t    if (query.child != null) {\n\t      str += ' > ' + queryToString(query.child);\n\t    }\n\t\n\t    if (query.descendant != null) {\n\t      str += ' ' + queryToString(query.descendant);\n\t    }\n\t\n\t    return str;\n\t  };\n\t\n\t  for (i = 0; i < this.length; i++) {\n\t    var query = this[i];\n\t\n\t    str += queryToString(query);\n\t\n\t    if (this.length > 1 && i < this.length - 1) {\n\t      str += ', ';\n\t    }\n\t  }\n\t\n\t  this._private.toStringCache = str;\n\t\n\t  return str;\n\t};\n\t\n\t[__webpack_require__(120), __webpack_require__(119)].forEach(function (p) {\n\t  return util.assign(selfn, p);\n\t});\n\t\n\tmodule.exports = Selector;\n\t\n\t/***/ }),\n\t/* 7 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar Map = __webpack_require__(117);\n\tvar Set = __webpack_require__(9);\n\t\n\tvar Element = __webpack_require__(13);\n\t\n\t// factory for generating edge ids when no id is specified for a new element\n\tvar idFactory = {\n\t  generate: function generate(cy, element, tryThisId) {\n\t    var id = tryThisId != null ? tryThisId : util.uuid();\n\t\n\t    while (cy.hasElementWithId(id)) {\n\t      id = util.uuid();\n\t    }\n\t\n\t    return id;\n\t  }\n\t};\n\t\n\t// represents a set of nodes, edges, or both together\n\tvar Collection = function Collection(cy, elements, options) {\n\t  if (cy === undefined || !is.core(cy)) {\n\t    util.error('A collection must have a reference to the core');\n\t    return;\n\t  }\n\t\n\t  var map = new Map();\n\t  var createdElements = false;\n\t\n\t  if (!elements) {\n\t    elements = [];\n\t  } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {\n\t    createdElements = true;\n\t\n\t    // make elements from json and restore all at once later\n\t    var eles = [];\n\t    var elesIds = new Set();\n\t\n\t    for (var i = 0, l = elements.length; i < l; i++) {\n\t      var json = elements[i];\n\t\n\t      if (json.data == null) {\n\t        json.data = {};\n\t      }\n\t\n\t      var data = json.data;\n\t\n\t      // make sure newly created elements have valid ids\n\t      if (data.id == null) {\n\t        data.id = idFactory.generate(cy, json);\n\t      } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {\n\t        continue; // can't create element if prior id already exists\n\t      }\n\t\n\t      var ele = new Element(cy, json, false);\n\t      eles.push(ele);\n\t      elesIds.add(data.id);\n\t    }\n\t\n\t    elements = eles;\n\t  }\n\t\n\t  this.length = 0;\n\t\n\t  for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n\t    var element = elements[_i];\n\t    if (element == null) {\n\t      continue;\n\t    }\n\t\n\t    var id = element._private.data.id;\n\t\n\t    if (options == null || options.unique && !map.has(id)) {\n\t      map.set(id, {\n\t        index: this.length,\n\t        ele: element\n\t      });\n\t\n\t      this[this.length] = element;\n\t      this.length++;\n\t    }\n\t  }\n\t\n\t  this._private = {\n\t    cy: cy,\n\t    map: map\n\t  };\n\t\n\t  // restore the elements if we created them from json\n\t  if (createdElements) {\n\t    this.restore();\n\t  }\n\t};\n\t\n\t// Functions\n\t////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\t// keep the prototypes in sync (an element has the same functions as a collection)\n\t// and use elefn and elesfn as shorthands to the prototypes\n\tvar elesfn = Element.prototype = Collection.prototype;\n\t\n\telesfn.instanceString = function () {\n\t  return 'collection';\n\t};\n\t\n\telesfn.spawn = function (cy, eles, opts) {\n\t  if (!is.core(cy)) {\n\t    // cy is optional\n\t    opts = eles;\n\t    eles = cy;\n\t    cy = this.cy();\n\t  }\n\t\n\t  return new Collection(cy, eles, opts);\n\t};\n\t\n\telesfn.spawnSelf = function () {\n\t  return this.spawn(this);\n\t};\n\t\n\telesfn.cy = function () {\n\t  return this._private.cy;\n\t};\n\t\n\telesfn.renderer = function () {\n\t  return this._private.cy.renderer();\n\t};\n\t\n\telesfn.element = function () {\n\t  return this[0];\n\t};\n\t\n\telesfn.collection = function () {\n\t  if (is.collection(this)) {\n\t    return this;\n\t  } else {\n\t    // an element\n\t    return new Collection(this._private.cy, [this]);\n\t  }\n\t};\n\t\n\telesfn.unique = function () {\n\t  return new Collection(this._private.cy, this, { unique: true });\n\t};\n\t\n\telesfn.hasElementWithId = function (id) {\n\t  return this._private.map.has(id);\n\t};\n\t\n\telesfn.getElementById = function (id) {\n\t  var cy = this._private.cy;\n\t  var entry = this._private.map.get(id);\n\t\n\t  return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n\t};\n\t\n\telesfn.$id = elesfn.getElementById;\n\t\n\telesfn.poolIndex = function () {\n\t  var cy = this._private.cy;\n\t  var eles = cy._private.elements;\n\t  var id = this._private.data.id;\n\t\n\t  return eles._private.map.get(id).index;\n\t};\n\t\n\telesfn.json = function (obj) {\n\t  var ele = this.element();\n\t  var cy = this.cy();\n\t\n\t  if (ele == null && obj) {\n\t    return this;\n\t  } // can't set to no eles\n\t\n\t  if (ele == null) {\n\t    return undefined;\n\t  } // can't get from no eles\n\t\n\t  var p = ele._private;\n\t\n\t  if (is.plainObject(obj)) {\n\t    // set\n\t\n\t    cy.startBatch();\n\t\n\t    if (obj.data) {\n\t      ele.data(obj.data);\n\t    }\n\t\n\t    if (obj.position) {\n\t      ele.position(obj.position);\n\t    }\n\t\n\t    // ignore group -- immutable\n\t\n\t    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n\t      var obj_k = obj[k];\n\t\n\t      if (obj_k != null && obj_k !== p[k]) {\n\t        if (obj_k) {\n\t          ele[trueFnName]();\n\t        } else {\n\t          ele[falseFnName]();\n\t        }\n\t      }\n\t    };\n\t\n\t    checkSwitch('removed', 'remove', 'restore');\n\t\n\t    checkSwitch('selected', 'select', 'unselect');\n\t\n\t    checkSwitch('selectable', 'selectify', 'unselectify');\n\t\n\t    checkSwitch('locked', 'lock', 'unlock');\n\t\n\t    checkSwitch('grabbable', 'grabify', 'ungrabify');\n\t\n\t    if (obj.classes != null) {\n\t      ele.classes(obj.classes);\n\t    }\n\t\n\t    cy.endBatch();\n\t\n\t    return this;\n\t  } else if (obj === undefined) {\n\t    // get\n\t\n\t    var json = {\n\t      data: util.copy(p.data),\n\t      position: util.copy(p.position),\n\t      group: p.group,\n\t      removed: p.removed,\n\t      selected: p.selected,\n\t      selectable: p.selectable,\n\t      locked: p.locked,\n\t      grabbable: p.grabbable,\n\t      classes: null\n\t    };\n\t\n\t    json.classes = '';\n\t\n\t    var i = 0;\n\t    p.classes.forEach(function (cls) {\n\t      return json.classes += i++ === 0 ? cls : ' ' + cls;\n\t    });\n\t\n\t    return json;\n\t  }\n\t};\n\t\n\telesfn.jsons = function () {\n\t  var jsons = [];\n\t\n\t  for (var i = 0; i < this.length; i++) {\n\t    var ele = this[i];\n\t    var json = ele.json();\n\t\n\t    jsons.push(json);\n\t  }\n\t\n\t  return jsons;\n\t};\n\t\n\telesfn.clone = function () {\n\t  var cy = this.cy();\n\t  var elesArr = [];\n\t\n\t  for (var i = 0; i < this.length; i++) {\n\t    var ele = this[i];\n\t    var json = ele.json();\n\t    var clone = new Element(cy, json, false); // NB no restore\n\t\n\t    elesArr.push(clone);\n\t  }\n\t\n\t  return new Collection(cy, elesArr);\n\t};\n\telesfn.copy = elesfn.clone;\n\t\n\telesfn.restore = function (notifyRenderer) {\n\t  var self = this;\n\t  var cy = self.cy();\n\t  var cy_p = cy._private;\n\t\n\t  if (notifyRenderer === undefined) {\n\t    notifyRenderer = true;\n\t  }\n\t\n\t  // create arrays of nodes and edges, since we need to\n\t  // restore the nodes first\n\t  var nodes = [];\n\t  var edges = [];\n\t  var elements = void 0;\n\t  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {\n\t    var ele = self[_i2];\n\t\n\t    if (!ele.removed()) {\n\t      // don't need to handle this ele\n\t      continue;\n\t    }\n\t\n\t    // keep nodes first in the array and edges after\n\t    if (ele.isNode()) {\n\t      // put to front of array if node\n\t      nodes.push(ele);\n\t    } else {\n\t      // put to end of array if edge\n\t      edges.push(ele);\n\t    }\n\t  }\n\t\n\t  elements = nodes.concat(edges);\n\t\n\t  var i = void 0;\n\t  var removeFromElements = function removeFromElements() {\n\t    elements.splice(i, 1);\n\t    i--;\n\t  };\n\t\n\t  // now, restore each element\n\t  for (i = 0; i < elements.length; i++) {\n\t    var _ele = elements[i];\n\t\n\t    var _private = _ele._private;\n\t    var data = _private.data;\n\t\n\t    // the traversal cache should start fresh when ele is added\n\t    _ele.clearTraversalCache();\n\t\n\t    // set id and validate\n\t    if (data.id === undefined) {\n\t      data.id = idFactory.generate(cy, _ele);\n\t    } else if (is.number(data.id)) {\n\t      data.id = '' + data.id; // now it's a string\n\t    } else if (is.emptyString(data.id) || !is.string(data.id)) {\n\t      util.error('Can not create element with invalid string ID `' + data.id + '`');\n\t\n\t      // can't create element if it has empty string as id or non-string id\n\t      removeFromElements();\n\t      continue;\n\t    } else if (cy.hasElementWithId(data.id)) {\n\t      util.error('Can not create second element with ID `' + data.id + '`');\n\t\n\t      // can't create element if one already has that id\n\t      removeFromElements();\n\t      continue;\n\t    }\n\t\n\t    var id = data.id; // id is finalised, now let's keep a ref\n\t\n\t    if (_ele.isNode()) {\n\t      // extra checks for nodes\n\t      var pos = _private.position;\n\t\n\t      // make sure the nodes have a defined position\n\t\n\t      if (pos.x == null) {\n\t        pos.x = 0;\n\t      }\n\t\n\t      if (pos.y == null) {\n\t        pos.y = 0;\n\t      }\n\t    }\n\t\n\t    if (_ele.isEdge()) {\n\t      // extra checks for edges\n\t\n\t      var edge = _ele;\n\t      var fields = ['source', 'target'];\n\t      var fieldsLength = fields.length;\n\t      var badSourceOrTarget = false;\n\t      for (var j = 0; j < fieldsLength; j++) {\n\t\n\t        var field = fields[j];\n\t        var val = data[field];\n\t\n\t        if (is.number(val)) {\n\t          val = data[field] = '' + data[field]; // now string\n\t        }\n\t\n\t        if (val == null || val === '') {\n\t          // can't create if source or target is not defined properly\n\t          util.error('Can not create edge `' + id + '` with unspecified ' + field);\n\t          badSourceOrTarget = true;\n\t        } else if (!cy.hasElementWithId(val)) {\n\t          // can't create edge if one of its nodes doesn't exist\n\t          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n\t          badSourceOrTarget = true;\n\t        }\n\t      }\n\t\n\t      if (badSourceOrTarget) {\n\t        removeFromElements();continue;\n\t      } // can't create this\n\t\n\t      var src = cy.getElementById(data.source);\n\t      var tgt = cy.getElementById(data.target);\n\t\n\t      src._private.edges.push(edge);\n\t      tgt._private.edges.push(edge);\n\t\n\t      edge._private.source = src;\n\t      edge._private.target = tgt;\n\t    } // if is edge\n\t\n\t    // create mock ids / indexes maps for element so it can be used like collections\n\t    _private.map = new Map();\n\t    _private.map.set(id, { ele: _ele, index: 0 });\n\t\n\t    _private.removed = false;\n\t    cy.addToPool(_ele);\n\t  } // for each element\n\t\n\t  // do compound node sanity checks\n\t  for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n\t    // each node\n\t    var node = nodes[_i3];\n\t    var _data = node._private.data;\n\t\n\t    if (is.number(_data.parent)) {\n\t      // then automake string\n\t      _data.parent = '' + _data.parent;\n\t    }\n\t\n\t    var parentId = _data.parent;\n\t\n\t    var specifiedParent = parentId != null;\n\t\n\t    if (specifiedParent) {\n\t      var parent = cy.getElementById(parentId);\n\t\n\t      if (parent.empty()) {\n\t        // non-existant parent; just remove it\n\t        _data.parent = undefined;\n\t      } else {\n\t        var selfAsParent = false;\n\t        var ancestor = parent;\n\t        while (!ancestor.empty()) {\n\t          if (node.same(ancestor)) {\n\t            // mark self as parent and remove from data\n\t            selfAsParent = true;\n\t            _data.parent = undefined; // remove parent reference\n\t\n\t            // exit or we loop forever\n\t            break;\n\t          }\n\t\n\t          ancestor = ancestor.parent();\n\t        }\n\t\n\t        if (!selfAsParent) {\n\t          // connect with children\n\t          parent[0]._private.children.push(node);\n\t          node._private.parent = parent[0];\n\t\n\t          // let the core know we have a compound graph\n\t          cy_p.hasCompoundNodes = true;\n\t        }\n\t      } // else\n\t    } // if specified parent\n\t  } // for each node\n\t\n\t  if (elements.length > 0) {\n\t    var restored = new Collection(cy, elements);\n\t\n\t    for (var _i4 = 0; _i4 < restored.length; _i4++) {\n\t      var _ele2 = restored[_i4];\n\t\n\t      if (_ele2.isNode()) {\n\t        continue;\n\t      }\n\t\n\t      // adding an edge invalidates the traversal caches for the parallel edges\n\t      _ele2.parallelEdges().clearTraversalCache();\n\t\n\t      // adding an edge invalidates the traversal cache for the connected nodes\n\t      _ele2.source().clearTraversalCache();\n\t      _ele2.target().clearTraversalCache();\n\t    }\n\t\n\t    var toUpdateStyle = void 0;\n\t\n\t    if (cy_p.hasCompoundNodes) {\n\t      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n\t    } else {\n\t      toUpdateStyle = restored;\n\t    }\n\t\n\t    toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);\n\t\n\t    if (notifyRenderer) {\n\t      restored.emitAndNotify('add');\n\t    } else {\n\t      restored.emit('add');\n\t    }\n\t  }\n\t\n\t  return self; // chainability\n\t};\n\t\n\telesfn.removed = function () {\n\t  var ele = this[0];\n\t  return ele && ele._private.removed;\n\t};\n\t\n\telesfn.inside = function () {\n\t  var ele = this[0];\n\t  return ele && !ele._private.removed;\n\t};\n\t\n\telesfn.remove = function (notifyRenderer) {\n\t  var self = this;\n\t  var removed = [];\n\t  var elesToRemove = [];\n\t  var elesToRemoveIds = {};\n\t  var cy = self._private.cy;\n\t\n\t  if (notifyRenderer === undefined) {\n\t    notifyRenderer = true;\n\t  }\n\t\n\t  // add connected edges\n\t  function addConnectedEdges(node) {\n\t    var edges = node._private.edges;\n\t    for (var i = 0; i < edges.length; i++) {\n\t      add(edges[i]);\n\t    }\n\t  }\n\t\n\t  // add descendant nodes\n\t  function addChildren(node) {\n\t    var children = node._private.children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      add(children[i]);\n\t    }\n\t  }\n\t\n\t  function add(ele) {\n\t    var alreadyAdded = elesToRemoveIds[ele.id()];\n\t    if (alreadyAdded) {\n\t      return;\n\t    } else {\n\t      elesToRemoveIds[ele.id()] = true;\n\t    }\n\t\n\t    if (ele.isNode()) {\n\t      elesToRemove.push(ele); // nodes are removed last\n\t\n\t      addConnectedEdges(ele);\n\t      addChildren(ele);\n\t    } else {\n\t      elesToRemove.unshift(ele); // edges are removed first\n\t    }\n\t  }\n\t\n\t  // make the list of elements to remove\n\t  // (may be removing more than specified due to connected edges etc)\n\t\n\t  for (var i = 0, l = self.length; i < l; i++) {\n\t    var ele = self[i];\n\t\n\t    add(ele);\n\t  }\n\t\n\t  function removeEdgeRef(node, edge) {\n\t    var connectedEdges = node._private.edges;\n\t\n\t    util.removeFromArray(connectedEdges, edge);\n\t\n\t    // removing an edges invalidates the traversal cache for its nodes\n\t    node.clearTraversalCache();\n\t  }\n\t\n\t  function removeParallelRefs(edge) {\n\t    // removing an edge invalidates the traversal caches for the parallel edges\n\t    edge.parallelEdges().clearTraversalCache();\n\t  }\n\t\n\t  var alteredParents = [];\n\t  alteredParents.ids = {};\n\t\n\t  function removeChildRef(parent, ele) {\n\t    ele = ele[0];\n\t    parent = parent[0];\n\t\n\t    var children = parent._private.children;\n\t    var pid = parent.id();\n\t\n\t    util.removeFromArray(children, ele);\n\t\n\t    if (!alteredParents.ids[pid]) {\n\t      alteredParents.ids[pid] = true;\n\t      alteredParents.push(parent);\n\t    }\n\t  }\n\t\n\t  self.dirtyCompoundBoundsCache();\n\t\n\t  cy.removeFromPool(elesToRemove); // remove from core pool\n\t\n\t  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {\n\t    var _ele3 = elesToRemove[_i5];\n\t\n\t    // mark as removed\n\t    _ele3._private.removed = true;\n\t\n\t    // add to list of removed elements\n\t    removed.push(_ele3);\n\t\n\t    if (_ele3.isEdge()) {\n\t      // remove references to this edge in its connected nodes\n\t      var src = _ele3.source()[0];\n\t      var tgt = _ele3.target()[0];\n\t\n\t      removeEdgeRef(src, _ele3);\n\t      removeEdgeRef(tgt, _ele3);\n\t      removeParallelRefs(_ele3);\n\t    } else {\n\t      // remove reference to parent\n\t      var parent = _ele3.parent();\n\t\n\t      if (parent.length !== 0) {\n\t        removeChildRef(parent, _ele3);\n\t      }\n\t    }\n\t  }\n\t\n\t  // check to see if we have a compound graph or not\n\t  var elesStillInside = cy._private.elements;\n\t  cy._private.hasCompoundNodes = false;\n\t  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {\n\t    var _ele4 = elesStillInside[_i6];\n\t\n\t    if (_ele4.isParent()) {\n\t      cy._private.hasCompoundNodes = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var removedElements = new Collection(this.cy(), removed);\n\t  if (removedElements.size() > 0) {\n\t    // must manually notify since trigger won't do this automatically once removed\n\t\n\t    if (notifyRenderer) {\n\t      this.cy().notify({\n\t        type: 'remove',\n\t        eles: removedElements\n\t      });\n\t    }\n\t\n\t    removedElements.emit('remove');\n\t  }\n\t\n\t  // the parents who were modified by the removal need their style updated\n\t  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {\n\t    var _ele5 = alteredParents[_i7];\n\t\n\t    if (!_ele5.removed()) {\n\t      _ele5.updateStyle();\n\t    }\n\t  }\n\t\n\t  return new Collection(cy, removed);\n\t};\n\t\n\telesfn.move = function (struct) {\n\t  var cy = this._private.cy;\n\t\n\t  if (struct.source !== undefined || struct.target !== undefined) {\n\t    var srcId = struct.source;\n\t    var tgtId = struct.target;\n\t    var srcExists = cy.hasElementWithId(srcId);\n\t    var tgtExists = cy.hasElementWithId(tgtId);\n\t\n\t    if (srcExists || tgtExists) {\n\t      var jsons = this.jsons();\n\t\n\t      this.remove();\n\t\n\t      for (var i = 0; i < jsons.length; i++) {\n\t        var json = jsons[i];\n\t        var ele = this[i];\n\t\n\t        if (json.group === 'edges') {\n\t          if (srcExists) {\n\t            json.data.source = srcId;\n\t          }\n\t\n\t          if (tgtExists) {\n\t            json.data.target = tgtId;\n\t          }\n\t\n\t          json.scratch = ele._private.scratch;\n\t        }\n\t      }\n\t\n\t      return cy.add(jsons);\n\t    }\n\t  } else if (struct.parent !== undefined) {\n\t    // move node to new parent\n\t    var parentId = struct.parent;\n\t    var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\t\n\t    if (parentExists) {\n\t      var _jsons = this.jsons();\n\t      var descs = this.descendants();\n\t      var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();\n\t\n\t      this.remove(); // NB: also removes descendants and their connected edges\n\t\n\t      for (var _i8 = 0; _i8 < _jsons.length; _i8++) {\n\t        var _json = _jsons[_i8];\n\t        var _ele6 = this[_i8];\n\t\n\t        if (_json.group === 'nodes') {\n\t          _json.data.parent = parentId === null ? undefined : parentId;\n\t\n\t          _json.scratch = _ele6._private.scratch;\n\t        }\n\t      }\n\t\n\t      return cy.add(_jsons.concat(descsEtcJsons));\n\t    }\n\t  }\n\t\n\t  return this; // if nothing done\n\t};\n\t\n\t[__webpack_require__(32), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(44), __webpack_require__(47), __webpack_require__(48), __webpack_require__(49), __webpack_require__(7), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54)].forEach(function (props) {\n\t  util.extend(elesfn, props);\n\t});\n\t\n\tmodule.exports = Collection;\n\t\n\t/***/ }),\n\t/* 8 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = __webpack_require__(140);\n\t\n\t/***/ }),\n\t/* 9 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* global Set */\n\t\n\tvar undef =  true ? 'undefined' : _typeof(undefined);\n\t\n\tvar ObjectSet = function () {\n\t  function ObjectSet(arrayOrObjectSet) {\n\t    _classCallCheck(this, ObjectSet);\n\t\n\t    this._obj = Object.create(null);\n\t\n\t    if (arrayOrObjectSet != null) {\n\t      var arr = void 0;\n\t\n\t      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n\t        arr = arrayOrObjectSet.toArray();\n\t      } else {\n\t        arr = arrayOrObjectSet;\n\t      }\n\t\n\t      for (var i = 0; i < arr.length; i++) {\n\t        this.add(arr[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  _createClass(ObjectSet, [{\n\t    key: 'instanceString',\n\t    value: function instanceString() {\n\t      return 'set';\n\t    }\n\t  }, {\n\t    key: 'add',\n\t    value: function add(val) {\n\t      this._obj[val] = 1;\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(val) {\n\t      this._obj[val] = 0;\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this._obj = Object.create(null);\n\t    }\n\t  }, {\n\t    key: 'has',\n\t    value: function has(val) {\n\t      return this._obj[val] === 1;\n\t    }\n\t  }, {\n\t    key: 'toArray',\n\t    value: function toArray() {\n\t      var _this = this;\n\t\n\t      return Object.keys(this._obj).filter(function (key) {\n\t        return _this.has(key);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'forEach',\n\t    value: function forEach(callback, thisArg) {\n\t      return this.toArray().forEach(callback, thisArg);\n\t    }\n\t  }, {\n\t    key: 'size',\n\t    get: function get() {\n\t      return this.toArray().length;\n\t    }\n\t  }]);\n\t\n\t  return ObjectSet;\n\t}();\n\t\n\t// TODO use the stdlib Set in future...\n\t// module.exports = typeof Set !== undef ? Set : ObjectSet;\n\t\n\t\n\tmodule.exports = ObjectSet;\n\t\n\t/***/ }),\n\t/* 10 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar Event = __webpack_require__(15);\n\t\n\tvar eventRegex = /(\\w+)(\\.(?:\\w+|\\*))?/; // regex for matching event strings (e.g. \"click.namespace\")\n\tvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\t\n\tvar defaults = {\n\t  qualifierCompare: function qualifierCompare(q1, q2) {\n\t    return q1 === q2;\n\t  },\n\t  eventMatches: function eventMatches() /*context, listener, eventObj*/{\n\t    return true;\n\t  },\n\t  eventFields: function eventFields() /*context*/{\n\t    return {};\n\t  },\n\t  callbackContext: function callbackContext(context /*, listener, eventObj*/) {\n\t    return context;\n\t  },\n\t  beforeEmit: function beforeEmit() /* context, listener, eventObj */{},\n\t  afterEmit: function afterEmit() /* context, listener, eventObj */{},\n\t  bubble: function bubble() /*context*/{\n\t    return false;\n\t  },\n\t  parent: function parent() /*context*/{\n\t    return null;\n\t  },\n\t  context: undefined\n\t};\n\t\n\tfunction Emitter(opts) {\n\t  util.assign(this, defaults, opts);\n\t\n\t  this.listeners = [];\n\t  this.emitting = 0;\n\t}\n\t\n\tvar p = Emitter.prototype;\n\t\n\tvar forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n\t  if (is.fn(qualifier)) {\n\t    callback = qualifier;\n\t    qualifier = null;\n\t  }\n\t\n\t  if (confOverrides) {\n\t    if (conf == null) {\n\t      conf = confOverrides;\n\t    } else {\n\t      conf = util.assign({}, conf, confOverrides);\n\t    }\n\t  }\n\t\n\t  var eventList = events.split(/\\s+/);\n\t\n\t  for (var i = 0; i < eventList.length; i++) {\n\t    var evt = eventList[i];\n\t\n\t    if (is.emptyString(evt)) {\n\t      continue;\n\t    }\n\t\n\t    var match = evt.match(eventRegex); // type[.namespace]\n\t\n\t    if (match) {\n\t      var type = match[1];\n\t      var namespace = match[2] ? match[2] : null;\n\t      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n\t\n\t      if (ret === false) {\n\t        break;\n\t      } // allow exiting early\n\t    }\n\t  }\n\t};\n\t\n\tvar makeEventObj = function makeEventObj(self, obj) {\n\t  return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));\n\t};\n\t\n\tvar forEachEventObj = function forEachEventObj(self, handler, events) {\n\t  if (is.event(events)) {\n\t    handler(self, events);\n\t\n\t    return;\n\t  } else if (is.plainObject(events)) {\n\t    handler(self, makeEventObj(self, events));\n\t\n\t    return;\n\t  }\n\t\n\t  var eventList = events.split(/\\s+/);\n\t\n\t  for (var i = 0; i < eventList.length; i++) {\n\t    var evt = eventList[i];\n\t\n\t    if (is.emptyString(evt)) {\n\t      continue;\n\t    }\n\t\n\t    var match = evt.match(eventRegex); // type[.namespace]\n\t\n\t    if (match) {\n\t      var type = match[1];\n\t      var namespace = match[2] ? match[2] : null;\n\t      var eventObj = makeEventObj(self, {\n\t        type: type,\n\t        namespace: namespace,\n\t        target: self.context\n\t      });\n\t\n\t      handler(self, eventObj);\n\t    }\n\t  }\n\t};\n\t\n\tp.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n\t  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n\t    if (is.fn(callback)) {\n\t      self.listeners.push({\n\t        event: event, // full event string\n\t        callback: callback, // callback to run\n\t        type: type, // the event type (e.g. 'click')\n\t        namespace: namespace, // the event namespace (e.g. \".foo\")\n\t        qualifier: qualifier, // a restriction on whether to match this emitter\n\t        conf: conf // additional configuration\n\t      });\n\t    }\n\t  }, events, qualifier, callback, conf, confOverrides);\n\t\n\t  return this;\n\t};\n\t\n\tp.one = function (events, qualifier, callback, conf) {\n\t  return this.on(events, qualifier, callback, conf, { one: true });\n\t};\n\t\n\tp.removeListener = p.off = function (events, qualifier, callback, conf) {\n\t  var _this = this;\n\t\n\t  if (this.emitting !== 0) {\n\t    this.listeners = util.copyArray(this.listeners);\n\t  }\n\t\n\t  var listeners = this.listeners;\n\t\n\t  var _loop = function _loop(i) {\n\t    var listener = listeners[i];\n\t\n\t    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {\n\t      if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n\t        listeners.splice(i, 1);\n\t\n\t        return false;\n\t      }\n\t    }, events, qualifier, callback, conf);\n\t  };\n\t\n\t  for (var i = listeners.length - 1; i >= 0; i--) {\n\t    _loop(i);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tp.emit = p.trigger = function (events, extraParams, manualCallback) {\n\t  var listeners = this.listeners;\n\t  var numListenersBeforeEmit = listeners.length;\n\t\n\t  this.emitting++;\n\t\n\t  if (!is.array(extraParams)) {\n\t    extraParams = [extraParams];\n\t  }\n\t\n\t  forEachEventObj(this, function (self, eventObj) {\n\t    if (manualCallback != null) {\n\t      listeners = [{\n\t        event: eventObj.event,\n\t        type: eventObj.type,\n\t        namespace: eventObj.namespace,\n\t        callback: manualCallback\n\t      }];\n\t\n\t      numListenersBeforeEmit = listeners.length;\n\t    }\n\t\n\t    var _loop2 = function _loop2(i) {\n\t      var listener = listeners[i];\n\t\n\t      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n\t        var args = [eventObj];\n\t\n\t        if (extraParams != null) {\n\t          util.push(args, extraParams);\n\t        }\n\t\n\t        self.beforeEmit(self.context, listener, eventObj);\n\t\n\t        if (listener.conf && listener.conf.one) {\n\t          self.listeners = self.listeners.filter(function (l) {\n\t            return l !== listener;\n\t          });\n\t        }\n\t\n\t        var context = self.callbackContext(self.context, listener, eventObj);\n\t        var ret = listener.callback.apply(context, args);\n\t\n\t        self.afterEmit(self.context, listener, eventObj);\n\t\n\t        if (ret === false) {\n\t          eventObj.stopPropagation();\n\t          eventObj.preventDefault();\n\t        }\n\t      } // if listener matches\n\t    };\n\t\n\t    for (var i = 0; i < numListenersBeforeEmit; i++) {\n\t      _loop2(i);\n\t    } // for listener\n\t\n\t    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n\t      self.parent(self.context).emit(eventObj, extraParams);\n\t    }\n\t  }, events);\n\t\n\t  this.emitting--;\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Emitter;\n\t\n\t/***/ }),\n\t/* 11 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t// storage for parsed queries\n\tvar newQuery = function newQuery() {\n\t  return {\n\t    classes: [],\n\t    colonSelectors: [],\n\t    data: [],\n\t    group: null,\n\t    ids: [],\n\t    meta: [],\n\t\n\t    // fake selectors\n\t    collection: null, // a collection to match against\n\t    filter: null, // filter function\n\t\n\t    // these are defined in the upward direction rather than down (e.g. child)\n\t    // because we need to go up in Selector.filter()\n\t    parent: null, // parent query obj\n\t    ancestor: null, // ancestor query obj\n\t    subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\t\n\t    // use these only when subject has been defined\n\t    child: null,\n\t    descendant: null\n\t  };\n\t};\n\t\n\tmodule.exports = newQuery;\n\t\n\t/***/ }),\n\t/* 12 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar window = __webpack_require__(4);\n\tvar util = __webpack_require__(1);\n\tvar Collection = __webpack_require__(7);\n\tvar is = __webpack_require__(0);\n\tvar Promise = __webpack_require__(5);\n\tvar define = __webpack_require__(3);\n\t\n\tvar Core = function Core(opts) {\n\t  var cy = this;\n\t\n\t  opts = util.extend({}, opts);\n\t\n\t  var container = opts.container;\n\t\n\t  // allow for passing a wrapped jquery object\n\t  // e.g. cytoscape({ container: $('#cy') })\n\t  if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {\n\t    container = container[0];\n\t  }\n\t\n\t  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\t  reg = reg || {};\n\t\n\t  if (reg && reg.cy) {\n\t    reg.cy.destroy();\n\t\n\t    reg = {}; // old instance => replace reg completely\n\t  }\n\t\n\t  var readies = reg.readies = reg.readies || [];\n\t\n\t  if (container) {\n\t    container._cyreg = reg;\n\t  } // make sure container assoc'd reg points to this cy\n\t  reg.cy = cy;\n\t\n\t  var head = window !== undefined && container !== undefined && !opts.headless;\n\t  var options = opts;\n\t  options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);\n\t  options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);\n\t\n\t  var defVal = function defVal(def, val, altVal) {\n\t    if (val !== undefined) {\n\t      return val;\n\t    } else if (altVal !== undefined) {\n\t      return altVal;\n\t    } else {\n\t      return def;\n\t    }\n\t  };\n\t\n\t  var _p = this._private = {\n\t    container: container, // html dom ele container\n\t    ready: false, // whether ready has been triggered\n\t    options: options, // cached options\n\t    elements: new Collection(this), // elements in the graph\n\t    listeners: [], // list of listeners\n\t    aniEles: new Collection(this), // elements being animated\n\t    scratch: {}, // scratch object for core\n\t    layout: null,\n\t    renderer: null,\n\t    destroyed: false, // whether destroy was called\n\t    notificationsEnabled: true, // whether notifications are sent to the renderer\n\t    minZoom: 1e-50,\n\t    maxZoom: 1e50,\n\t    zoomingEnabled: defVal(true, options.zoomingEnabled),\n\t    userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n\t    panningEnabled: defVal(true, options.panningEnabled),\n\t    userPanningEnabled: defVal(true, options.userPanningEnabled),\n\t    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n\t    autolock: defVal(false, options.autolock, options.autolockNodes),\n\t    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n\t    autounselectify: defVal(false, options.autounselectify),\n\t    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n\t    zoom: is.number(options.zoom) ? options.zoom : 1,\n\t    pan: {\n\t      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,\n\t      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0\n\t    },\n\t    animation: { // object for currently-running animations\n\t      current: [],\n\t      queue: []\n\t    },\n\t    hasCompoundNodes: false\n\t  };\n\t\n\t  this.createEmitter();\n\t\n\t  // set selection type\n\t  var selType = options.selectionType;\n\t  if (selType === undefined || selType !== 'additive' && selType !== 'single') {\n\t    // then set default\n\t\n\t    _p.selectionType = 'single';\n\t  } else {\n\t    _p.selectionType = selType;\n\t  }\n\t\n\t  // init zoom bounds\n\t  if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {\n\t    _p.minZoom = options.minZoom;\n\t    _p.maxZoom = options.maxZoom;\n\t  } else if (is.number(options.minZoom) && options.maxZoom === undefined) {\n\t    _p.minZoom = options.minZoom;\n\t  } else if (is.number(options.maxZoom) && options.minZoom === undefined) {\n\t    _p.maxZoom = options.maxZoom;\n\t  }\n\t\n\t  var loadExtData = function loadExtData(extData, next) {\n\t    var anyIsPromise = extData.some(is.promise);\n\t\n\t    if (anyIsPromise) {\n\t      return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init\n\t    } else {\n\t      next(extData); // exec synchronously for convenience\n\t    }\n\t  };\n\t\n\t  // start with the default stylesheet so we have something before loading an external stylesheet\n\t  if (_p.styleEnabled) {\n\t    cy.setStyle([]);\n\t  }\n\t\n\t  // create the renderer\n\t  cy.initRenderer(util.extend({\n\t    hideEdgesOnViewport: options.hideEdgesOnViewport,\n\t    textureOnViewport: options.textureOnViewport,\n\t    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n\t    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default\n\t    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,\n\t    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,\n\t    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,\n\t    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold\n\t  }, options.renderer));\n\t\n\t  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n\t    cy.notifications(false);\n\t\n\t    // remove old elements\n\t    var oldEles = cy.mutableElements();\n\t    if (oldEles.length > 0) {\n\t      oldEles.remove();\n\t    }\n\t\n\t    if (elements != null) {\n\t      if (is.plainObject(elements) || is.array(elements)) {\n\t        cy.add(elements);\n\t      }\n\t    }\n\t\n\t    cy.one('layoutready', function (e) {\n\t      cy.notifications(true);\n\t      cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\t\n\t      cy.notify({\n\t        type: 'load',\n\t        eles: cy.mutableElements()\n\t      });\n\t\n\t      cy.one('load', onload);\n\t      cy.emit('load');\n\t    }).one('layoutstop', function () {\n\t      cy.one('done', ondone);\n\t      cy.emit('done');\n\t    });\n\t\n\t    var layoutOpts = util.extend({}, cy._private.options.layout);\n\t    layoutOpts.eles = cy.elements();\n\t\n\t    cy.layout(layoutOpts).run();\n\t  };\n\t\n\t  loadExtData([options.style, options.elements], function (thens) {\n\t    var initStyle = thens[0];\n\t    var initEles = thens[1];\n\t\n\t    // init style\n\t    if (_p.styleEnabled) {\n\t      cy.style().append(initStyle);\n\t    }\n\t\n\t    // initial load\n\t    setElesAndLayout(initEles, function () {\n\t      // onready\n\t      cy.startAnimationLoop();\n\t      _p.ready = true;\n\t\n\t      // if a ready callback is specified as an option, the bind it\n\t      if (is.fn(options.ready)) {\n\t        cy.on('ready', options.ready);\n\t      }\n\t\n\t      // bind all the ready handlers registered before creating this instance\n\t      for (var i = 0; i < readies.length; i++) {\n\t        var fn = readies[i];\n\t        cy.on('ready', fn);\n\t      }\n\t      if (reg) {\n\t        reg.readies = [];\n\t      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\t\n\t      cy.emit('ready');\n\t    }, options.done);\n\t  });\n\t};\n\t\n\tvar corefn = Core.prototype; // short alias\n\t\n\tutil.extend(corefn, {\n\t  instanceString: function instanceString() {\n\t    return 'core';\n\t  },\n\t\n\t  isReady: function isReady() {\n\t    return this._private.ready;\n\t  },\n\t\n\t  isDestroyed: function isDestroyed() {\n\t    return this._private.destroyed;\n\t  },\n\t\n\t  ready: function ready(fn) {\n\t    if (this.isReady()) {\n\t      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n\t    } else {\n\t      this.on('ready', fn);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  destroy: function destroy() {\n\t    var cy = this;\n\t    if (cy.isDestroyed()) return;\n\t\n\t    cy.stopAnimationLoop();\n\t\n\t    cy.destroyRenderer();\n\t\n\t    this.emit('destroy');\n\t\n\t    cy._private.destroyed = true;\n\t\n\t    return cy;\n\t  },\n\t\n\t  hasElementWithId: function hasElementWithId(id) {\n\t    return this._private.elements.hasElementWithId(id);\n\t  },\n\t\n\t  getElementById: function getElementById(id) {\n\t    return this._private.elements.getElementById(id);\n\t  },\n\t\n\t  selectionType: function selectionType() {\n\t    return this._private.selectionType;\n\t  },\n\t\n\t  hasCompoundNodes: function hasCompoundNodes() {\n\t    return this._private.hasCompoundNodes;\n\t  },\n\t\n\t  headless: function headless() {\n\t    return this._private.options.renderer.name === 'null';\n\t  },\n\t\n\t  styleEnabled: function styleEnabled() {\n\t    return this._private.styleEnabled;\n\t  },\n\t\n\t  addToPool: function addToPool(eles) {\n\t    this._private.elements.merge(eles);\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  removeFromPool: function removeFromPool(eles) {\n\t    this._private.elements.unmerge(eles);\n\t\n\t    return this;\n\t  },\n\t\n\t  container: function container() {\n\t    return this._private.container;\n\t  },\n\t\n\t  options: function options() {\n\t    return util.copy(this._private.options);\n\t  },\n\t\n\t  json: function json(obj) {\n\t    var cy = this;\n\t    var _p = cy._private;\n\t    var eles = cy.mutableElements();\n\t\n\t    if (is.plainObject(obj)) {\n\t      // set\n\t\n\t      cy.startBatch();\n\t\n\t      if (obj.elements) {\n\t        var idInJson = {};\n\t\n\t        var updateEles = function updateEles(jsons, gr) {\n\t          for (var i = 0; i < jsons.length; i++) {\n\t            var json = jsons[i];\n\t            var id = json.data.id;\n\t            var ele = cy.getElementById(id);\n\t\n\t            idInJson[id] = true;\n\t\n\t            if (ele.length !== 0) {\n\t              // existing element should be updated\n\t              ele.json(json);\n\t            } else {\n\t              // otherwise should be added\n\t              if (gr) {\n\t                cy.add(util.extend({ group: gr }, json));\n\t              } else {\n\t                cy.add(json);\n\t              }\n\t            }\n\t          }\n\t        };\n\t\n\t        if (is.array(obj.elements)) {\n\t          // elements: []\n\t          updateEles(obj.elements);\n\t        } else {\n\t          // elements: { nodes: [], edges: [] }\n\t          var grs = ['nodes', 'edges'];\n\t          for (var i = 0; i < grs.length; i++) {\n\t            var gr = grs[i];\n\t            var elements = obj.elements[gr];\n\t\n\t            if (is.array(elements)) {\n\t              updateEles(elements, gr);\n\t            }\n\t          }\n\t        }\n\t\n\t        // elements not specified in json should be removed\n\t        eles.stdFilter(function (ele) {\n\t          return !idInJson[ele.id()];\n\t        }).remove();\n\t      }\n\t\n\t      if (obj.style) {\n\t        cy.style(obj.style);\n\t      }\n\t\n\t      if (obj.zoom != null && obj.zoom !== _p.zoom) {\n\t        cy.zoom(obj.zoom);\n\t      }\n\t\n\t      if (obj.pan) {\n\t        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n\t          cy.pan(obj.pan);\n\t        }\n\t      }\n\t\n\t      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];\n\t\n\t      for (var _i = 0; _i < fields.length; _i++) {\n\t        var f = fields[_i];\n\t\n\t        if (obj[f] != null) {\n\t          cy[f](obj[f]);\n\t        }\n\t      }\n\t\n\t      cy.endBatch();\n\t\n\t      return this; // chaining\n\t    } else if (obj === undefined) {\n\t      // get\n\t      var json = {};\n\t\n\t      json.elements = {};\n\t      eles.forEach(function (ele) {\n\t        var group = ele.group();\n\t\n\t        if (!json.elements[group]) {\n\t          json.elements[group] = [];\n\t        }\n\t\n\t        json.elements[group].push(ele.json());\n\t      });\n\t\n\t      if (this._private.styleEnabled) {\n\t        json.style = cy.style().json();\n\t      }\n\t\n\t      json.zoomingEnabled = cy._private.zoomingEnabled;\n\t      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n\t      json.zoom = cy._private.zoom;\n\t      json.minZoom = cy._private.minZoom;\n\t      json.maxZoom = cy._private.maxZoom;\n\t      json.panningEnabled = cy._private.panningEnabled;\n\t      json.userPanningEnabled = cy._private.userPanningEnabled;\n\t      json.pan = util.copy(cy._private.pan);\n\t      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n\t      json.renderer = util.copy(cy._private.options.renderer);\n\t      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n\t      json.textureOnViewport = cy._private.options.textureOnViewport;\n\t      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n\t      json.motionBlur = cy._private.options.motionBlur;\n\t\n\t      return json;\n\t    }\n\t  },\n\t\n\t  scratch: define.data({\n\t    field: 'scratch',\n\t    bindingEvent: 'scratch',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'scratch',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true\n\t  }),\n\t\n\t  removeScratch: define.removeData({\n\t    field: 'scratch',\n\t    event: 'scratch',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true\n\t  })\n\t\n\t});\n\t\n\tcorefn.$id = corefn.getElementById;\n\t\n\t[__webpack_require__(55), __webpack_require__(59), __webpack_require__(64), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71)].forEach(function (props) {\n\t  util.extend(corefn, props);\n\t});\n\t\n\tmodule.exports = Core;\n\t\n\t/***/ }),\n\t/* 13 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar Set = __webpack_require__(9);\n\t\n\t// represents a node or an edge\n\tvar Element = function Element(cy, params, restore) {\n\t  restore = restore === undefined || restore ? true : false;\n\t\n\t  if (cy === undefined || params === undefined || !is.core(cy)) {\n\t    util.error('An element must have a core reference and parameters set');\n\t    return;\n\t  }\n\t\n\t  var group = params.group;\n\t\n\t  // try to automatically infer the group if unspecified\n\t  if (group == null) {\n\t    if (params.data && params.data.source != null && params.data.target != null) {\n\t      group = 'edges';\n\t    } else {\n\t      group = 'nodes';\n\t    }\n\t  }\n\t\n\t  // validate group\n\t  if (group !== 'nodes' && group !== 'edges') {\n\t    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n\t    return;\n\t  }\n\t\n\t  // make the element array-like, just like a collection\n\t  this.length = 1;\n\t  this[0] = this;\n\t\n\t  // NOTE: when something is added here, add also to ele.json()\n\t  var _p = this._private = {\n\t    cy: cy,\n\t    single: true, // indicates this is an element\n\t    data: params.data || {}, // data object\n\t    position: params.position || {}, // (x, y) position pair\n\t    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n\t    autoHeight: undefined,\n\t    autoPadding: undefined,\n\t    compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read\n\t    listeners: [], // array of bound listeners\n\t    group: group, // string; 'nodes' or 'edges'\n\t    style: {}, // properties as set by the style\n\t    rstyle: {}, // properties for style sent from the renderer to the core\n\t    styleCxts: [], // applied style contexts from the styler\n\t    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n\t    selected: params.selected ? true : false, // whether it's selected\n\t    selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable\n\t    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n\t    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n\t    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed\n\t    active: false, // whether the element is active from user interaction\n\t    classes: new Set(), // map ( className => true )\n\t    animation: { // object for currently-running animations\n\t      current: [],\n\t      queue: []\n\t    },\n\t    rscratch: {}, // object in which the renderer can store information\n\t    scratch: params.scratch || {}, // scratch objects\n\t    edges: [], // array of connected edges\n\t    children: [], // array of children\n\t    parent: null, // parent ref\n\t    traversalCache: {} // cache of output of traversal functions\n\t  };\n\t\n\t  // renderedPosition overrides if specified\n\t  if (params.renderedPosition) {\n\t    var rpos = params.renderedPosition;\n\t    var pan = cy.pan();\n\t    var zoom = cy.zoom();\n\t\n\t    _p.position = {\n\t      x: (rpos.x - pan.x) / zoom,\n\t      y: (rpos.y - pan.y) / zoom\n\t    };\n\t  }\n\t\n\t  if (is.string(params.classes)) {\n\t    var classes = params.classes.split(/\\s+/);\n\t    for (var i = 0, l = classes.length; i < l; i++) {\n\t      var cls = classes[i];\n\t      if (!cls || cls === '') {\n\t        continue;\n\t      }\n\t\n\t      _p.classes.add(cls);\n\t    }\n\t  }\n\t\n\t  if (params.style || params.css) {\n\t    cy.style().applyBypass(this, params.style || params.css);\n\t  }\n\t\n\t  this.createEmitter();\n\t\n\t  if (restore === undefined || restore) {\n\t    this.restore();\n\t  }\n\t};\n\t\n\tmodule.exports = Element;\n\t\n\t/***/ }),\n\t/* 14 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/**\n\t *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n\t *  and z-index (low to high).  These styles affect how this applies:\n\t *\n\t *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n\t *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n\t *      root to leaves of the compound graph.  The last drawn is `top`.\n\t *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n\t *      `manual` ignores this convention and draws based on the `z-index` value setting.\n\t *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n\t *      `z-index` will be drawn on top of an element with a lower `z-index`.\n\t */\n\tvar util = __webpack_require__(1);\n\t\n\tvar zIndexSort = function zIndexSort(a, b) {\n\t  var cy = a.cy();\n\t  var hasCompoundNodes = cy.hasCompoundNodes();\n\t\n\t  function getDepth(ele) {\n\t    var style = ele.pstyle('z-compound-depth');\n\t    if (style.value === 'auto') {\n\t      return hasCompoundNodes ? ele.zDepth() : 0;\n\t    } else if (style.value === 'bottom') {\n\t      return -1;\n\t    } else if (style.value === 'top') {\n\t      return util.MAX_INT;\n\t    }\n\t    // 'orphan'\n\t    return 0;\n\t  }\n\t  var depthDiff = getDepth(a) - getDepth(b);\n\t  if (depthDiff !== 0) {\n\t    return depthDiff;\n\t  }\n\t\n\t  function getEleDepth(ele) {\n\t    var style = ele.pstyle('z-index-compare');\n\t    if (style.value === 'auto') {\n\t      return ele.isNode() ? 1 : 0;\n\t    }\n\t    // 'manual'\n\t    return 0;\n\t  }\n\t  var eleDiff = getEleDepth(a) - getEleDepth(b);\n\t  if (eleDiff !== 0) {\n\t    return eleDiff;\n\t  }\n\t\n\t  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n\t  if (zDiff !== 0) {\n\t    return zDiff;\n\t  }\n\t  // compare indices in the core (order added to graph w/ last on top)\n\t  return a.poolIndex() - b.poolIndex();\n\t};\n\t\n\tmodule.exports = zIndexSort;\n\t\n\t/***/ }),\n\t/* 15 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/*!\n\tEvent object based on jQuery events, MIT license\n\t\n\thttps://jquery.org/license/\n\thttps://tldrlegal.com/license/mit-license\n\thttps://github.com/jquery/jquery/blob/master/src/event.js\n\t*/\n\t\n\tvar Event = function Event(src, props) {\n\t  this.recycle(src, props);\n\t};\n\t\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\t\n\tfunction returnTrue() {\n\t  return true;\n\t}\n\t\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tEvent.prototype = {\n\t  instanceString: function instanceString() {\n\t    return 'event';\n\t  },\n\t\n\t  recycle: function recycle(src, props) {\n\t    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n\t\n\t    if (src != null && src.preventDefault) {\n\t      // Browser Event object\n\t      this.type = src.type;\n\t\n\t      // Events bubbling up the document may have been marked as prevented\n\t      // by a handler lower down the tree; reflect the correct value.\n\t      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n\t    } else if (src != null && src.type) {\n\t      // Plain object containing all event details\n\t      props = src;\n\t    } else {\n\t      // Event string\n\t      this.type = src;\n\t    }\n\t\n\t    // Put explicitly provided properties onto the event object\n\t    if (props != null) {\n\t      // more efficient to manually copy fields we use\n\t      this.originalEvent = props.originalEvent;\n\t      this.type = props.type != null ? props.type : this.type;\n\t      this.cy = props.cy;\n\t      this.target = props.target;\n\t      this.position = props.position;\n\t      this.renderedPosition = props.renderedPosition;\n\t      this.namespace = props.namespace;\n\t      this.layout = props.layout;\n\t    }\n\t\n\t    if (this.cy != null && this.position != null && this.renderedPosition == null) {\n\t      // create a rendered position based on the passed position\n\t      var pos = this.position;\n\t      var zoom = this.cy.zoom();\n\t      var pan = this.cy.pan();\n\t\n\t      this.renderedPosition = {\n\t        x: pos.x * zoom + pan.x,\n\t        y: pos.y * zoom + pan.y\n\t      };\n\t    }\n\t\n\t    // Create a timestamp if incoming event doesn't have one\n\t    this.timeStamp = src && src.timeStamp || Date.now();\n\t  },\n\t\n\t  preventDefault: function preventDefault() {\n\t    this.isDefaultPrevented = returnTrue;\n\t\n\t    var e = this.originalEvent;\n\t    if (!e) {\n\t      return;\n\t    }\n\t\n\t    // if preventDefault exists run it on the original event\n\t    if (e.preventDefault) {\n\t      e.preventDefault();\n\t    }\n\t  },\n\t\n\t  stopPropagation: function stopPropagation() {\n\t    this.isPropagationStopped = returnTrue;\n\t\n\t    var e = this.originalEvent;\n\t    if (!e) {\n\t      return;\n\t    }\n\t\n\t    // if stopPropagation exists run it on the original event\n\t    if (e.stopPropagation) {\n\t      e.stopPropagation();\n\t    }\n\t  },\n\t\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    this.isImmediatePropagationStopped = returnTrue;\n\t    this.stopPropagation();\n\t  },\n\t\n\t  isDefaultPrevented: returnFalse,\n\t  isPropagationStopped: returnFalse,\n\t  isImmediatePropagationStopped: returnFalse\n\t};\n\t\n\tmodule.exports = Event;\n\t\n\t/***/ }),\n\t/* 16 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar fullFpsTime = 1000 / 60; // assume 60 frames per second\n\t\n\tmodule.exports = {\n\t  setupDequeueing: function setupDequeueing(opts) {\n\t    return function setupDequeueingImpl() {\n\t      var self = this;\n\t      var r = this.renderer;\n\t\n\t      if (self.dequeueingSetup) {\n\t        return;\n\t      } else {\n\t        self.dequeueingSetup = true;\n\t      }\n\t\n\t      var queueRedraw = util.debounce(function () {\n\t        r.redrawHint('eles', true);\n\t        r.redrawHint('drag', true);\n\t\n\t        r.redraw();\n\t      }, opts.deqRedrawThreshold);\n\t\n\t      var dequeue = function dequeue(willDraw, frameStartTime) {\n\t        var startTime = util.performanceNow();\n\t        var avgRenderTime = r.averageRedrawTime;\n\t        var renderTime = r.lastRedrawTime;\n\t        var deqd = [];\n\t        var extent = r.cy.extent();\n\t        var pixelRatio = r.getPixelRatio();\n\t\n\t        while (true) {\n\t          var now = util.performanceNow();\n\t          var duration = now - startTime;\n\t          var frameDuration = now - frameStartTime;\n\t\n\t          if (renderTime < fullFpsTime) {\n\t            // if we're rendering faster than the ideal fps, then do dequeueing\n\t            // during all of the remaining frame time\n\t\n\t            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n\t\n\t            if (frameDuration >= opts.deqFastCost * timeAvailable) {\n\t              break;\n\t            }\n\t          } else {\n\t            if (willDraw) {\n\t              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n\t                break;\n\t              }\n\t            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n\t              break;\n\t            }\n\t          }\n\t\n\t          var thisDeqd = opts.deq(self, pixelRatio, extent);\n\t\n\t          if (thisDeqd.length > 0) {\n\t            for (var i = 0; i < thisDeqd.length; i++) {\n\t              deqd.push(thisDeqd[i]);\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t\n\t        // callbacks on dequeue\n\t        if (deqd.length > 0) {\n\t          opts.onDeqd(self, deqd);\n\t\n\t          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n\t            queueRedraw();\n\t          }\n\t        }\n\t      };\n\t\n\t      var priority = opts.priority || util.noop;\n\t\n\t      r.beforeRender(dequeue, priority(self));\n\t    };\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 17 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar stateSelectors = [{\n\t  selector: ':selected',\n\t  matches: function matches(ele) {\n\t    return ele.selected();\n\t  }\n\t}, {\n\t  selector: ':unselected',\n\t  matches: function matches(ele) {\n\t    return !ele.selected();\n\t  }\n\t}, {\n\t  selector: ':selectable',\n\t  matches: function matches(ele) {\n\t    return ele.selectable();\n\t  }\n\t}, {\n\t  selector: ':unselectable',\n\t  matches: function matches(ele) {\n\t    return !ele.selectable();\n\t  }\n\t}, {\n\t  selector: ':locked',\n\t  matches: function matches(ele) {\n\t    return ele.locked();\n\t  }\n\t}, {\n\t  selector: ':unlocked',\n\t  matches: function matches(ele) {\n\t    return !ele.locked();\n\t  }\n\t}, {\n\t  selector: ':visible',\n\t  matches: function matches(ele) {\n\t    return ele.visible();\n\t  }\n\t}, {\n\t  selector: ':hidden',\n\t  matches: function matches(ele) {\n\t    return !ele.visible();\n\t  }\n\t}, {\n\t  selector: ':transparent',\n\t  matches: function matches(ele) {\n\t    return ele.transparent();\n\t  }\n\t}, {\n\t  selector: ':grabbed',\n\t  matches: function matches(ele) {\n\t    return ele.grabbed();\n\t  }\n\t}, {\n\t  selector: ':free',\n\t  matches: function matches(ele) {\n\t    return !ele.grabbed();\n\t  }\n\t}, {\n\t  selector: ':removed',\n\t  matches: function matches(ele) {\n\t    return ele.removed();\n\t  }\n\t}, {\n\t  selector: ':inside',\n\t  matches: function matches(ele) {\n\t    return !ele.removed();\n\t  }\n\t}, {\n\t  selector: ':grabbable',\n\t  matches: function matches(ele) {\n\t    return ele.grabbable();\n\t  }\n\t}, {\n\t  selector: ':ungrabbable',\n\t  matches: function matches(ele) {\n\t    return !ele.grabbable();\n\t  }\n\t}, {\n\t  selector: ':animated',\n\t  matches: function matches(ele) {\n\t    return ele.animated();\n\t  }\n\t}, {\n\t  selector: ':unanimated',\n\t  matches: function matches(ele) {\n\t    return !ele.animated();\n\t  }\n\t}, {\n\t  selector: ':parent',\n\t  matches: function matches(ele) {\n\t    return ele.isParent();\n\t  }\n\t}, {\n\t  selector: ':childless',\n\t  matches: function matches(ele) {\n\t    return ele.isChildless();\n\t  }\n\t}, {\n\t  selector: ':child',\n\t  matches: function matches(ele) {\n\t    return ele.isChild();\n\t  }\n\t}, {\n\t  selector: ':orphan',\n\t  matches: function matches(ele) {\n\t    return ele.isOrphan();\n\t  }\n\t}, {\n\t  selector: ':nonorphan',\n\t  matches: function matches(ele) {\n\t    return ele.isChild();\n\t  }\n\t}, {\n\t  selector: ':loop',\n\t  matches: function matches(ele) {\n\t    return ele.isLoop();\n\t  }\n\t}, {\n\t  selector: ':simple',\n\t  matches: function matches(ele) {\n\t    return ele.isSimple();\n\t  }\n\t}, {\n\t  selector: ':active',\n\t  matches: function matches(ele) {\n\t    return ele.active();\n\t  }\n\t}, {\n\t  selector: ':inactive',\n\t  matches: function matches(ele) {\n\t    return !ele.active();\n\t  }\n\t}, {\n\t  selector: ':backgrounding',\n\t  matches: function matches(ele) {\n\t    return ele.backgrounding();\n\t  }\n\t}, {\n\t  selector: ':nonbackgrounding',\n\t  matches: function matches(ele) {\n\t    return !ele.backgrounding();\n\t  }\n\t}].sort(function (a, b) {\n\t  // n.b. selectors that are starting substrings of others must have the longer ones first\n\t  return util.sort.descending(a.selector, b.selector);\n\t});\n\t\n\tvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n\t  var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {\n\t    var selToFn = {};\n\t    var s = void 0;\n\t\n\t    for (var i = 0; i < stateSelectors.length; i++) {\n\t      s = stateSelectors[i];\n\t\n\t      selToFn[s.selector] = s.matches;\n\t    }\n\t\n\t    return selToFn;\n\t  }();\n\t\n\t  return lookup[sel](ele);\n\t};\n\t\n\tvar stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n\t  return s.selector;\n\t}).join('|') + ')';\n\t\n\tmodule.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };\n\t\n\t/***/ }),\n\t/* 18 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar Style = function Style(cy) {\n\t\n\t  if (!(this instanceof Style)) {\n\t    return new Style(cy);\n\t  }\n\t\n\t  if (!is.core(cy)) {\n\t    util.error('A style must have a core reference');\n\t    return;\n\t  }\n\t\n\t  this._private = {\n\t    cy: cy,\n\t    coreStyle: {}\n\t  };\n\t\n\t  this.length = 0;\n\t\n\t  this.resetToDefault();\n\t};\n\t\n\tvar styfn = Style.prototype;\n\t\n\tstyfn.instanceString = function () {\n\t  return 'style';\n\t};\n\t\n\t// remove all contexts\n\tstyfn.clear = function () {\n\t  for (var i = 0; i < this.length; i++) {\n\t    this[i] = undefined;\n\t  }\n\t  this.length = 0;\n\t\n\t  var _p = this._private;\n\t\n\t  _p.newStyle = true;\n\t\n\t  return this; // chaining\n\t};\n\t\n\tstyfn.resetToDefault = function () {\n\t  this.clear();\n\t  this.addDefaultStylesheet();\n\t\n\t  return this;\n\t};\n\t\n\t// builds a style object for the 'core' selector\n\tstyfn.core = function () {\n\t  return this._private.coreStyle;\n\t};\n\t\n\t// create a new context from the specified selector string and switch to that context\n\tstyfn.selector = function (selectorStr) {\n\t  // 'core' is a special case and does not need a selector\n\t  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n\t\n\t  var i = this.length++; // new context means new index\n\t  this[i] = {\n\t    selector: selector,\n\t    properties: [],\n\t    mappedProperties: [],\n\t    index: i\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// add one or many css rules to the current context\n\tstyfn.css = function () {\n\t  var self = this;\n\t  var args = arguments;\n\t\n\t  switch (args.length) {\n\t    case 1:\n\t      var map = args[0];\n\t\n\t      for (var i = 0; i < self.properties.length; i++) {\n\t        var prop = self.properties[i];\n\t        var mapVal = map[prop.name];\n\t\n\t        if (mapVal === undefined) {\n\t          mapVal = map[util.dash2camel(prop.name)];\n\t        }\n\t\n\t        if (mapVal !== undefined) {\n\t          this.cssRule(prop.name, mapVal);\n\t        }\n\t      }\n\t\n\t      break;\n\t\n\t    case 2:\n\t      this.cssRule(args[0], args[1]);\n\t      break;\n\t\n\t    default:\n\t      break; // do nothing if args are invalid\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\tstyfn.style = styfn.css;\n\t\n\t// add a single css rule to the current context\n\tstyfn.cssRule = function (name, value) {\n\t  // name-value pair\n\t  var property = this.parse(name, value);\n\t\n\t  // add property to current context if valid\n\t  if (property) {\n\t    var i = this.length - 1;\n\t    this[i].properties.push(property);\n\t    this[i].properties[property.name] = property; // allow access by name as well\n\t\n\t    if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n\t      this._private.hasPie = true;\n\t    }\n\t\n\t    if (property.mapped) {\n\t      this[i].mappedProperties.push(property);\n\t    }\n\t\n\t    // add to core style if necessary\n\t    var currentSelectorIsCore = !this[i].selector;\n\t    if (currentSelectorIsCore) {\n\t      this._private.coreStyle[property.name] = property;\n\t    }\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\tstyfn.append = function (style) {\n\t  if (is.stylesheet(style)) {\n\t    style.appendToStyle(this);\n\t  } else if (is.array(style)) {\n\t    this.appendFromJson(style);\n\t  } else if (is.string(style)) {\n\t    this.appendFromString(style);\n\t  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\t\n\t  return this;\n\t};\n\t\n\t// static function\n\tStyle.fromJson = function (cy, json) {\n\t  var style = new Style(cy);\n\t\n\t  style.fromJson(json);\n\t\n\t  return style;\n\t};\n\t\n\tStyle.fromString = function (cy, string) {\n\t  return new Style(cy).fromString(string);\n\t};\n\t\n\t[__webpack_require__(122), __webpack_require__(123), __webpack_require__(124), __webpack_require__(125), __webpack_require__(126), __webpack_require__(129), __webpack_require__(128), __webpack_require__(127)].forEach(function (props) {\n\t  util.extend(styfn, props);\n\t});\n\t\n\tStyle.types = styfn.types;\n\tStyle.properties = styfn.properties;\n\t\n\tmodule.exports = Style;\n\t\n\t/***/ }),\n\t/* 19 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = function memoize(fn, keyFn) {\n\t  if (!keyFn) {\n\t    keyFn = function keyFn() {\n\t      if (arguments.length === 1) {\n\t        return arguments[0];\n\t      } else if (arguments.length === 0) {\n\t        return 'undefined';\n\t      }\n\t\n\t      var args = [];\n\t\n\t      for (var i = 0; i < arguments.length; i++) {\n\t        args.push(arguments[i]);\n\t      }\n\t\n\t      return args.join('$');\n\t    };\n\t  }\n\t\n\t  var memoizedFn = function memoizedFn() {\n\t    var self = this;\n\t    var args = arguments;\n\t    var ret = void 0;\n\t    var k = keyFn.apply(self, args);\n\t    var cache = memoizedFn.cache;\n\t\n\t    if (!(ret = cache[k])) {\n\t      ret = cache[k] = fn.apply(self, args);\n\t    }\n\t\n\t    return ret;\n\t  };\n\t\n\t  memoizedFn.cache = {};\n\t\n\t  return memoizedFn;\n\t};\n\t\n\t/***/ }),\n\t/* 20 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar define = __webpack_require__(3);\n\tvar Collection = __webpack_require__(7);\n\tvar Core = __webpack_require__(12);\n\tvar incExts = __webpack_require__(75);\n\tvar is = __webpack_require__(0);\n\tvar Emitter = __webpack_require__(10);\n\t\n\t// registered extensions to cytoscape, indexed by name\n\tvar extensions = {};\n\t\n\t// registered modules for extensions, indexed by name\n\tvar modules = {};\n\t\n\tfunction setExtension(type, name, registrant) {\n\t\n\t  var ext = registrant;\n\t\n\t  var overrideErr = function overrideErr(field) {\n\t    util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n\t  };\n\t\n\t  if (type === 'core') {\n\t    if (Core.prototype[name]) {\n\t      return overrideErr(name);\n\t    } else {\n\t      Core.prototype[name] = registrant;\n\t    }\n\t  } else if (type === 'collection') {\n\t    if (Collection.prototype[name]) {\n\t      return overrideErr(name);\n\t    } else {\n\t      Collection.prototype[name] = registrant;\n\t    }\n\t  } else if (type === 'layout') {\n\t    // fill in missing layout functions in the prototype\n\t\n\t    var Layout = function Layout(options) {\n\t      this.options = options;\n\t\n\t      registrant.call(this, options);\n\t\n\t      // make sure layout has _private for use w/ std apis like .on()\n\t      if (!is.plainObject(this._private)) {\n\t        this._private = {};\n\t      }\n\t\n\t      this._private.cy = options.cy;\n\t      this._private.listeners = [];\n\t\n\t      this.createEmitter();\n\t    };\n\t\n\t    var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n\t\n\t    var optLayoutFns = [];\n\t\n\t    for (var i = 0; i < optLayoutFns.length; i++) {\n\t      var fnName = optLayoutFns[i];\n\t\n\t      layoutProto[fnName] = layoutProto[fnName] || function () {\n\t        return this;\n\t      };\n\t    }\n\t\n\t    // either .start() or .run() is defined, so autogen the other\n\t    if (layoutProto.start && !layoutProto.run) {\n\t      layoutProto.run = function () {\n\t        this.start();return this;\n\t      };\n\t    } else if (!layoutProto.start && layoutProto.run) {\n\t      layoutProto.start = function () {\n\t        this.run();return this;\n\t      };\n\t    }\n\t\n\t    var regStop = registrant.prototype.stop;\n\t    layoutProto.stop = function () {\n\t      var opts = this.options;\n\t\n\t      if (opts && opts.animate) {\n\t        var anis = this.animations;\n\t\n\t        if (anis) {\n\t          for (var _i = 0; _i < anis.length; _i++) {\n\t            anis[_i].stop();\n\t          }\n\t        }\n\t      }\n\t\n\t      if (regStop) {\n\t        regStop.call(this);\n\t      } else {\n\t        this.emit('layoutstop');\n\t      }\n\t\n\t      return this;\n\t    };\n\t\n\t    if (!layoutProto.destroy) {\n\t      layoutProto.destroy = function () {\n\t        return this;\n\t      };\n\t    }\n\t\n\t    layoutProto.cy = function () {\n\t      return this._private.cy;\n\t    };\n\t\n\t    var getCy = function getCy(layout) {\n\t      return layout._private.cy;\n\t    };\n\t\n\t    util.assign(layoutProto, {\n\t      createEmitter: function createEmitter() {\n\t        this._private.emitter = new Emitter({\n\t          eventFields: function eventFields(layout) {\n\t            return {\n\t              layout: layout,\n\t              cy: getCy(layout),\n\t              target: layout\n\t            };\n\t          },\n\t          bubble: function bubble() {\n\t            return true;\n\t          },\n\t          parent: function parent(layout) {\n\t            return getCy(layout);\n\t          },\n\t          context: this\n\t        });\n\t\n\t        return this;\n\t      },\n\t      emitter: function emitter() {\n\t        return this._private.emitter;\n\t      },\n\t      on: function on(evt, cb) {\n\t        this.emitter().on(evt, cb);return this;\n\t      },\n\t      one: function one(evt, cb) {\n\t        this.emitter().one(evt, cb);return this;\n\t      },\n\t      once: function once(evt, cb) {\n\t        this.emitter().one(evt, cb);return this;\n\t      },\n\t      removeListener: function removeListener(evt, cb) {\n\t        this.emitter().removeListener(evt, cb);return this;\n\t      },\n\t      emit: function emit(evt, params) {\n\t        this.emitter().emit(evt, params);return this;\n\t      }\n\t    });\n\t\n\t    define.eventAliasesOn(layoutProto);\n\t\n\t    ext = Layout; // replace with our wrapped layout\n\t  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n\t    // user registered renderers inherit from base\n\t\n\t    var BaseRenderer = getExtension('renderer', 'base');\n\t    var bProto = BaseRenderer.prototype;\n\t    var RegistrantRenderer = registrant;\n\t    var rProto = registrant.prototype;\n\t\n\t    var Renderer = function Renderer() {\n\t      BaseRenderer.apply(this, arguments);\n\t      RegistrantRenderer.apply(this, arguments);\n\t    };\n\t\n\t    var proto = Renderer.prototype;\n\t\n\t    for (var pName in bProto) {\n\t      var pVal = bProto[pName];\n\t      var existsInR = rProto[pName] != null;\n\t\n\t      if (existsInR) {\n\t        return overrideErr(pName);\n\t      }\n\t\n\t      proto[pName] = pVal; // take impl from base\n\t    }\n\t\n\t    for (var _pName in rProto) {\n\t      proto[_pName] = rProto[_pName]; // take impl from registrant\n\t    }\n\t\n\t    bProto.clientFunctions.forEach(function (name) {\n\t      proto[name] = proto[name] || function () {\n\t        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n\t      };\n\t    });\n\t\n\t    ext = Renderer;\n\t  }\n\t\n\t  return util.setMap({\n\t    map: extensions,\n\t    keys: [type, name],\n\t    value: ext\n\t  });\n\t}\n\t\n\tfunction getExtension(type, name) {\n\t  return util.getMap({\n\t    map: extensions,\n\t    keys: [type, name]\n\t  });\n\t}\n\t\n\tfunction setModule(type, name, moduleType, moduleName, registrant) {\n\t  return util.setMap({\n\t    map: modules,\n\t    keys: [type, name, moduleType, moduleName],\n\t    value: registrant\n\t  });\n\t}\n\t\n\tfunction getModule(type, name, moduleType, moduleName) {\n\t  return util.getMap({\n\t    map: modules,\n\t    keys: [type, name, moduleType, moduleName]\n\t  });\n\t}\n\t\n\tvar extension = function extension() {\n\t  // e.g. extension('renderer', 'svg')\n\t  if (arguments.length === 2) {\n\t    return getExtension.apply(null, arguments);\n\t  }\n\t\n\t  // e.g. extension('renderer', 'svg', { ... })\n\t  else if (arguments.length === 3) {\n\t      return setExtension.apply(null, arguments);\n\t    }\n\t\n\t    // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n\t    else if (arguments.length === 4) {\n\t        return getModule.apply(null, arguments);\n\t      }\n\t\n\t      // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n\t      else if (arguments.length === 5) {\n\t          return setModule.apply(null, arguments);\n\t        } else {\n\t          util.error('Invalid extension access syntax');\n\t        }\n\t};\n\t\n\t// allows a core instance to access extensions internally\n\tCore.prototype.extension = extension;\n\t\n\t// included extensions\n\tincExts.forEach(function (group) {\n\t  group.extensions.forEach(function (ext) {\n\t    setExtension(group.type, ext.name, ext.impl);\n\t  });\n\t});\n\t\n\tmodule.exports = extension;\n\t\n\t/***/ }),\n\t/* 21 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Style = __webpack_require__(18);\n\t\n\t// a dummy stylesheet object that doesn't need a reference to the core\n\t// (useful for init)\n\tvar Stylesheet = function Stylesheet() {\n\t  if (!(this instanceof Stylesheet)) {\n\t    return new Stylesheet();\n\t  }\n\t\n\t  this.length = 0;\n\t};\n\t\n\tvar sheetfn = Stylesheet.prototype;\n\t\n\tsheetfn.instanceString = function () {\n\t  return 'stylesheet';\n\t};\n\t\n\t// just store the selector to be parsed later\n\tsheetfn.selector = function (selector) {\n\t  var i = this.length++;\n\t\n\t  this[i] = {\n\t    selector: selector,\n\t    properties: []\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// just store the property to be parsed later\n\tsheetfn.css = function (name, value) {\n\t  var i = this.length - 1;\n\t\n\t  if (is.string(name)) {\n\t    this[i].properties.push({\n\t      name: name,\n\t      value: value\n\t    });\n\t  } else if (is.plainObject(name)) {\n\t    var map = name;\n\t\n\t    for (var j = 0; j < Style.properties.length; j++) {\n\t      var prop = Style.properties[j];\n\t      var mapVal = map[prop.name];\n\t\n\t      if (mapVal === undefined) {\n\t        // also try camel case name\n\t        mapVal = map[util.dash2camel(prop.name)];\n\t      }\n\t\n\t      if (mapVal !== undefined) {\n\t        var _name = prop.name;\n\t        var _value = mapVal;\n\t\n\t        this[i].properties.push({\n\t          name: _name,\n\t          value: _value\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\tsheetfn.style = sheetfn.css;\n\t\n\t// generate a real style object from the dummy stylesheet\n\tsheetfn.generateStyle = function (cy) {\n\t  var style = new Style(cy);\n\t\n\t  return this.appendToStyle(style);\n\t};\n\t\n\t// append a dummy stylesheet object on a real style object\n\tsheetfn.appendToStyle = function (style) {\n\t  for (var i = 0; i < this.length; i++) {\n\t    var context = this[i];\n\t    var selector = context.selector;\n\t    var props = context.properties;\n\t\n\t    style.selector(selector); // apply selector\n\t\n\t    for (var j = 0; j < props.length; j++) {\n\t      var prop = props[j];\n\t\n\t      style.css(prop.name, prop.value); // apply property\n\t    }\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\tmodule.exports = Stylesheet;\n\t\n\t/***/ }),\n\t/* 22 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = \"3.2.5\";\n\t\n\t/***/ }),\n\t/* 23 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar Promise = __webpack_require__(5);\n\t\n\tvar Animation = function Animation(target, opts, opts2) {\n\t  var _p = this._private = util.extend({\n\t    duration: 1000\n\t  }, opts, opts2);\n\t\n\t  _p.target = target;\n\t  _p.style = _p.style || _p.css;\n\t  _p.started = false;\n\t  _p.playing = false;\n\t  _p.hooked = false;\n\t  _p.applying = false;\n\t  _p.progress = 0;\n\t  _p.completes = [];\n\t  _p.frames = [];\n\t\n\t  if (_p.complete && is.fn(_p.complete)) {\n\t    _p.completes.push(_p.complete);\n\t  }\n\t\n\t  // for future timeline/animations impl\n\t  this.length = 1;\n\t  this[0] = this;\n\t};\n\t\n\tvar anifn = Animation.prototype;\n\t\n\tutil.extend(anifn, {\n\t\n\t  instanceString: function instanceString() {\n\t    return 'animation';\n\t  },\n\t\n\t  hook: function hook() {\n\t    var _p = this._private;\n\t\n\t    if (!_p.hooked) {\n\t      // add to target's animation queue\n\t      var q = void 0;\n\t      var tAni = _p.target._private.animation;\n\t      if (_p.queue) {\n\t        q = tAni.queue;\n\t      } else {\n\t        q = tAni.current;\n\t      }\n\t      q.push(this);\n\t\n\t      // add to the animation loop pool\n\t      if (is.elementOrCollection(_p.target)) {\n\t        _p.target.cy().addToAnimationPool(_p.target);\n\t      }\n\t\n\t      _p.hooked = true;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  play: function play() {\n\t    var _p = this._private;\n\t\n\t    // autorewind\n\t    if (_p.progress === 1) {\n\t      _p.progress = 0;\n\t    }\n\t\n\t    _p.playing = true;\n\t    _p.started = false; // needs to be started by animation loop\n\t    _p.stopped = false;\n\t\n\t    this.hook();\n\t\n\t    // the animation loop will start the animation...\n\t\n\t    return this;\n\t  },\n\t\n\t  playing: function playing() {\n\t    return this._private.playing;\n\t  },\n\t\n\t  apply: function apply() {\n\t    var _p = this._private;\n\t\n\t    _p.applying = true;\n\t    _p.started = false; // needs to be started by animation loop\n\t    _p.stopped = false;\n\t\n\t    this.hook();\n\t\n\t    // the animation loop will apply the animation at this progress\n\t\n\t    return this;\n\t  },\n\t\n\t  applying: function applying() {\n\t    return this._private.applying;\n\t  },\n\t\n\t  pause: function pause() {\n\t    var _p = this._private;\n\t\n\t    _p.playing = false;\n\t    _p.started = false;\n\t\n\t    return this;\n\t  },\n\t\n\t  stop: function stop() {\n\t    var _p = this._private;\n\t\n\t    _p.playing = false;\n\t    _p.started = false;\n\t    _p.stopped = true; // to be removed from animation queues\n\t\n\t    return this;\n\t  },\n\t\n\t  rewind: function rewind() {\n\t    return this.progress(0);\n\t  },\n\t\n\t  fastforward: function fastforward() {\n\t    return this.progress(1);\n\t  },\n\t\n\t  time: function time(t) {\n\t    var _p = this._private;\n\t\n\t    if (t === undefined) {\n\t      return _p.progress * _p.duration;\n\t    } else {\n\t      return this.progress(t / _p.duration);\n\t    }\n\t  },\n\t\n\t  progress: function progress(p) {\n\t    var _p = this._private;\n\t    var wasPlaying = _p.playing;\n\t\n\t    if (p === undefined) {\n\t      return _p.progress;\n\t    } else {\n\t      if (wasPlaying) {\n\t        this.pause();\n\t      }\n\t\n\t      _p.progress = p;\n\t      _p.started = false;\n\t\n\t      if (wasPlaying) {\n\t        this.play();\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  completed: function completed() {\n\t    return this._private.progress === 1;\n\t  },\n\t\n\t  reverse: function reverse() {\n\t    var _p = this._private;\n\t    var wasPlaying = _p.playing;\n\t\n\t    if (wasPlaying) {\n\t      this.pause();\n\t    }\n\t\n\t    _p.progress = 1 - _p.progress;\n\t    _p.started = false;\n\t\n\t    var swap = function swap(a, b) {\n\t      var _pa = _p[a];\n\t\n\t      if (_pa == null) {\n\t        return;\n\t      }\n\t\n\t      _p[a] = _p[b];\n\t      _p[b] = _pa;\n\t    };\n\t\n\t    swap('zoom', 'startZoom');\n\t    swap('pan', 'startPan');\n\t    swap('position', 'startPosition');\n\t\n\t    // swap styles\n\t    if (_p.style) {\n\t      for (var i = 0; i < _p.style.length; i++) {\n\t        var prop = _p.style[i];\n\t        var name = prop.name;\n\t        var startStyleProp = _p.startStyle[name];\n\t\n\t        _p.startStyle[name] = prop;\n\t        _p.style[i] = startStyleProp;\n\t      }\n\t    }\n\t\n\t    if (wasPlaying) {\n\t      this.play();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  promise: function promise(type) {\n\t    var _p = this._private;\n\t\n\t    var arr = void 0;\n\t\n\t    switch (type) {\n\t      case 'frame':\n\t        arr = _p.frames;\n\t        break;\n\t      default:\n\t      case 'complete':\n\t      case 'completed':\n\t        arr = _p.completes;\n\t    }\n\t\n\t    return new Promise(function (resolve, reject) {\n\t      arr.push(function () {\n\t        resolve();\n\t      });\n\t    });\n\t  }\n\t\n\t});\n\t\n\tanifn.complete = anifn.completed;\n\t\n\tmodule.exports = Animation;\n\t\n\t/***/ }),\n\t/* 24 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar elesfn = {\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  aStar: function aStar(options) {\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Reconstructs the path from Start to End, acumulating the result in pathAcum\n\t    var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {\n\t      // Base case\n\t      if (start == end) {\n\t        pathAcum.unshift(cy.getElementById(end));\n\t        return pathAcum;\n\t      }\n\t\n\t      if (end in cameFromMap) {\n\t        // We know which node is before the last one\n\t        var previous = cameFromMap[end];\n\t        var previousEdge = cameFromEdge[end];\n\t\n\t        pathAcum.unshift(cy.getElementById(previousEdge));\n\t        pathAcum.unshift(cy.getElementById(end));\n\t\n\t        return reconstructPath(start, previous, cameFromMap, pathAcum);\n\t      }\n\t\n\t      // We should not reach here!\n\t      return undefined;\n\t    };\n\t\n\t    // Returns the index of the element in openSet which has minimum fScore\n\t    var findMin = function findMin(openSet, fScore) {\n\t      if (openSet.length === 0) {\n\t        // Should never be the case\n\t        return undefined;\n\t      }\n\t      var minPos = 0;\n\t      var tempScore = fScore[openSet[0]];\n\t      for (var i = 1; i < openSet.length; i++) {\n\t        var s = fScore[openSet[i]];\n\t        if (s < tempScore) {\n\t          tempScore = s;\n\t          minPos = i;\n\t        }\n\t      }\n\t      return minPos;\n\t    };\n\t\n\t    var cy = this._private.cy;\n\t\n\t    // root - mandatory!\n\t    if (options != null && options.root != null) {\n\t      var source = is.string(options.root) ?\n\t      // use it as a selector, e.g. \"#rootID\n\t      this.filter(options.root)[0] : options.root[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // goal - mandatory!\n\t    if (options.goal != null) {\n\t      var target = is.string(options.goal) ?\n\t      // use it as a selector, e.g. \"#goalID\n\t      this.filter(options.goal)[0] : options.goal[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // Heuristic function - optional\n\t    if (options.heuristic != null && is.fn(options.heuristic)) {\n\t      var heuristic = options.heuristic;\n\t    } else {\n\t      var heuristic = function heuristic() {\n\t        return 0;\n\t      }; // use constant if unspecified\n\t    }\n\t\n\t    // Weight function - optional\n\t    if (options.weight != null && is.fn(options.weight)) {\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function weightFn(e) {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if (options.directed != null) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var sid = source.id();\n\t    var tid = target.id();\n\t\n\t    var closedSet = [];\n\t    var openSet = [sid];\n\t    var cameFrom = {};\n\t    var cameFromEdge = {};\n\t    var gScore = {};\n\t    var fScore = {};\n\t\n\t    gScore[sid] = 0;\n\t    fScore[sid] = heuristic(source);\n\t\n\t    // Counter\n\t    var steps = 0;\n\t\n\t    // Main loop\n\t    while (openSet.length > 0) {\n\t      var minPos = findMin(openSet, fScore);\n\t      var cMin = cy.getElementById(openSet[minPos]);\n\t      var cMinId = cMin.id();\n\t      steps++;\n\t\n\t      // If we've found our goal, then we are done\n\t      if (cMinId == tid) {\n\t        var rPath = reconstructPath(sid, tid, cameFrom, []);\n\t\n\t        return {\n\t          found: true,\n\t          distance: gScore[cMinId],\n\t          path: eles.spawn(rPath),\n\t          steps: steps\n\t        };\n\t      }\n\t\n\t      // Add cMin to processed nodes\n\t      closedSet.push(cMinId);\n\t      // Remove cMin from boundary nodes\n\t      openSet.splice(minPos, 1);\n\t\n\t      // Update scores for neighbors of cMin\n\t      // Take into account if graph is directed or not\n\t      var vwEdges = cMin._private.edges;\n\t\n\t      for (var i = 0; i < vwEdges.length; i++) {\n\t        var e = vwEdges[i];\n\t\n\t        // edge must be in set of calling eles\n\t        if (!this.hasElementWithId(e.id())) {\n\t          continue;\n\t        }\n\t\n\t        // cMin must be the source of edge if directed\n\t        if (directed && e.data('source') !== cMinId) {\n\t          continue;\n\t        }\n\t\n\t        var wSrc = e.source();\n\t        var wTgt = e.target();\n\t\n\t        var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n\t        var wid = w.id();\n\t\n\t        // node must be in set of calling eles\n\t        if (!this.hasElementWithId(wid)) {\n\t          continue;\n\t        }\n\t\n\t        // if node is in closedSet, ignore it\n\t        if (closedSet.indexOf(wid) != -1) {\n\t          continue;\n\t        }\n\t\n\t        // New tentative score for node w\n\t        var tempScore = gScore[cMinId] + weightFn(e);\n\t\n\t        // Update gScore for node w if:\n\t        //   w not present in openSet\n\t        // OR\n\t        //   tentative gScore is less than previous value\n\t\n\t        // w not in openSet\n\t        if (openSet.indexOf(wid) == -1) {\n\t          gScore[wid] = tempScore;\n\t          fScore[wid] = tempScore + heuristic(w);\n\t          openSet.push(wid); // Add node to openSet\n\t          cameFrom[wid] = cMinId;\n\t          cameFromEdge[wid] = e.id();\n\t          continue;\n\t        }\n\t        // w already in openSet, but with greater gScore\n\t        if (tempScore < gScore[wid]) {\n\t          gScore[wid] = tempScore;\n\t          fScore[wid] = tempScore + heuristic(w);\n\t          cameFrom[wid] = cMinId;\n\t        }\n\t      } // End of neighbors update\n\t    } // End of main loop\n\t\n\t    // If we've reached here, then we've not reached our goal\n\t    return {\n\t      found: false,\n\t      distance: undefined,\n\t      path: undefined,\n\t      steps: steps\n\t    };\n\t  }\n\t\n\t}; // elesfn\n\t\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 25 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  bellmanFord: function bellmanFord(options) {\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Weight function - optional\n\t    if (options.weight != null && is.fn(options.weight)) {\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function weightFn(e) {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if (options.directed != null) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    // root - mandatory!\n\t    if (options.root != null) {\n\t      if (is.string(options.root)) {\n\t        // use it as a selector, e.g. \"#rootID\n\t        var source = this.filter(options.root)[0];\n\t      } else {\n\t        var source = options.root[0];\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter(function (e) {\n\t      return !e.isLoop();\n\t    });\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    // mapping: node id -> position in nodes array\n\t    var id2position = {};\n\t    for (var i = 0; i < numNodes; i++) {\n\t      id2position[nodes[i].id()] = i;\n\t    }\n\t\n\t    // Initializations\n\t    var cost = [];\n\t    var predecessor = [];\n\t    var predEdge = [];\n\t\n\t    for (var i = 0; i < numNodes; i++) {\n\t      if (nodes[i].id() === source.id()) {\n\t        cost[i] = 0;\n\t      } else {\n\t        cost[i] = Infinity;\n\t      }\n\t      predecessor[i] = undefined;\n\t    }\n\t\n\t    // Edges relaxation\n\t    var flag = false;\n\t    for (var i = 1; i < numNodes; i++) {\n\t      flag = false;\n\t      for (var e = 0; e < edges.length; e++) {\n\t        var sourceIndex = id2position[edges[e].source().id()];\n\t        var targetIndex = id2position[edges[e].target().id()];\n\t        var weight = weightFn(edges[e]);\n\t\n\t        var temp = cost[sourceIndex] + weight;\n\t        if (temp < cost[targetIndex]) {\n\t          cost[targetIndex] = temp;\n\t          predecessor[targetIndex] = sourceIndex;\n\t          predEdge[targetIndex] = edges[e];\n\t          flag = true;\n\t        }\n\t\n\t        // If undirected graph, we need to take into account the 'reverse' edge\n\t        if (!directed) {\n\t          var temp = cost[targetIndex] + weight;\n\t          if (temp < cost[sourceIndex]) {\n\t            cost[sourceIndex] = temp;\n\t            predecessor[sourceIndex] = targetIndex;\n\t            predEdge[sourceIndex] = edges[e];\n\t            flag = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!flag) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (flag) {\n\t      // Check for negative weight cycles\n\t      for (var e = 0; e < edges.length; e++) {\n\t        var sourceIndex = id2position[edges[e].source().id()];\n\t        var targetIndex = id2position[edges[e].target().id()];\n\t        var weight = weightFn(edges[e]);\n\t\n\t        if (cost[sourceIndex] + weight < cost[targetIndex]) {\n\t          util.error('Graph contains a negative weight cycle for Bellman-Ford');\n\t          return { pathTo: undefined,\n\t            distanceTo: undefined,\n\t            hasNegativeWeightCycle: true };\n\t        }\n\t      }\n\t    }\n\t\n\t    // Build result object\n\t    var position2id = [];\n\t    for (var i = 0; i < numNodes; i++) {\n\t      position2id.push(nodes[i].id());\n\t    }\n\t\n\t    var res = {\n\t      distanceTo: function distanceTo(to) {\n\t        if (is.string(to)) {\n\t          // to is a selector string\n\t          var toId = cy.filter(to)[0].id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        return cost[id2position[toId]];\n\t      },\n\t\n\t      pathTo: function pathTo(to) {\n\t\n\t        var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {\n\t          for (;;) {\n\t            // Add toId to path\n\t            acumPath.push(cy.getElementById(position2id[toPos]));\n\t            acumPath.push(predEdge[toPos]);\n\t\n\t            if (fromPos === toPos) {\n\t              // reached starting node\n\t              return acumPath;\n\t            }\n\t\n\t            // If no path exists, discart acumulated path and return undefined\n\t            var predPos = predecessor[toPos];\n\t            if (typeof predPos === 'undefined') {\n\t              return undefined;\n\t            }\n\t\n\t            toPos = predPos;\n\t          }\n\t        };\n\t\n\t        if (is.string(to)) {\n\t          // to is a selector string\n\t          var toId = cy.filter(to)[0].id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t        var path = [];\n\t\n\t        // This returns a reversed path\n\t        var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);\n\t\n\t        // Get it in the correct order and return it\n\t        if (res != null) {\n\t          res.reverse();\n\t        }\n\t\n\t        return eles.spawn(res);\n\t      },\n\t\n\t      hasNegativeWeightCycle: false\n\t    };\n\t\n\t    return res;\n\t  } // bellmanFord\n\t\n\t}; // elesfn\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 26 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Heap = __webpack_require__(8);\n\t\n\tvar elesfn = {\n\t\n\t  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n\t  betweennessCentrality: function betweennessCentrality(options) {\n\t    options = options || {};\n\t\n\t    // Weight - optional\n\t    var weighted, weightFn;\n\t    if (is.fn(options.weight)) {\n\t      weightFn = options.weight;\n\t      weighted = true;\n\t    } else {\n\t      weighted = false;\n\t    }\n\t\n\t    // Directed - default false\n\t    var directed = options.directed != null ? options.directed : false;\n\t\n\t    var cy = this._private.cy;\n\t\n\t    // starting\n\t    var V = this.nodes();\n\t    var A = {};\n\t    var _C = {};\n\t    var max = 0;\n\t    var C = {\n\t      set: function set(key, val) {\n\t        _C[key] = val;\n\t\n\t        if (val > max) {\n\t          max = val;\n\t        }\n\t      },\n\t\n\t      get: function get(key) {\n\t        return _C[key];\n\t      }\n\t    };\n\t\n\t    // A contains the neighborhoods of every node\n\t    for (var i = 0; i < V.length; i++) {\n\t      var v = V[i];\n\t      var vid = v.id();\n\t\n\t      if (directed) {\n\t        A[vid] = v.outgoers().nodes(); // get outgoers of every node\n\t      } else {\n\t        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n\t      }\n\t\n\t      C.set(vid, 0);\n\t    }\n\t\n\t    for (var s = 0; s < V.length; s++) {\n\t      var sid = V[s].id();\n\t      var S = []; // stack\n\t      var P = {};\n\t      var g = {};\n\t      var d = {};\n\t      var Q = new Heap(function (a, b) {\n\t        return d[a] - d[b];\n\t      }); // queue\n\t\n\t      // init dictionaries\n\t      for (var i = 0; i < V.length; i++) {\n\t        var vid = V[i].id();\n\t\n\t        P[vid] = [];\n\t        g[vid] = 0;\n\t        d[vid] = Infinity;\n\t      }\n\t\n\t      g[sid] = 1; // sigma\n\t      d[sid] = 0; // distance to s\n\t\n\t      Q.push(sid);\n\t\n\t      while (!Q.empty()) {\n\t        var v = Q.pop();\n\t\n\t        S.push(v);\n\t\n\t        if (weighted) {\n\t          for (var j = 0; j < A[v].length; j++) {\n\t            var w = A[v][j];\n\t            var vEle = cy.getElementById(v);\n\t\n\t            var edge;\n\t            if (vEle.edgesTo(w).length > 0) {\n\t              edge = vEle.edgesTo(w)[0];\n\t            } else {\n\t              edge = w.edgesTo(vEle)[0];\n\t            }\n\t\n\t            var edgeWeight = weightFn(edge);\n\t\n\t            w = w.id();\n\t\n\t            if (d[w] > d[v] + edgeWeight) {\n\t              d[w] = d[v] + edgeWeight;\n\t\n\t              if (Q.nodes.indexOf(w) < 0) {\n\t                //if w is not in Q\n\t                Q.push(w);\n\t              } else {\n\t                // update position if w is in Q\n\t                Q.updateItem(w);\n\t              }\n\t\n\t              g[w] = 0;\n\t              P[w] = [];\n\t            }\n\t\n\t            if (d[w] == d[v] + edgeWeight) {\n\t              g[w] = g[w] + g[v];\n\t              P[w].push(v);\n\t            }\n\t          }\n\t        } else {\n\t          for (var j = 0; j < A[v].length; j++) {\n\t            var w = A[v][j].id();\n\t\n\t            if (d[w] == Infinity) {\n\t              Q.push(w);\n\t\n\t              d[w] = d[v] + 1;\n\t            }\n\t\n\t            if (d[w] == d[v] + 1) {\n\t              g[w] = g[w] + g[v];\n\t              P[w].push(v);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      var e = {};\n\t      for (var i = 0; i < V.length; i++) {\n\t        e[V[i].id()] = 0;\n\t      }\n\t\n\t      while (S.length > 0) {\n\t        var w = S.pop();\n\t\n\t        for (var j = 0; j < P[w].length; j++) {\n\t          var v = P[w][j];\n\t\n\t          e[v] = e[v] + g[v] / g[w] * (1 + e[w]);\n\t\n\t          if (w != V[s].id()) {\n\t            C.set(w, C.get(w) + e[w]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    var ret = {\n\t      betweenness: function betweenness(node) {\n\t        if (is.string(node)) {\n\t          var node = cy.filter(node).id();\n\t        } else {\n\t          var node = node.id();\n\t        }\n\t\n\t        return C.get(node);\n\t      },\n\t\n\t      betweennessNormalized: function betweennessNormalized(node) {\n\t        if (max == 0) return 0;\n\t\n\t        if (is.string(node)) {\n\t          var node = cy.filter(node).id();\n\t        } else {\n\t          var node = node.id();\n\t        }\n\t\n\t        return C.get(node) / max;\n\t      }\n\t    };\n\t\n\t    // alias\n\t    ret.betweennessNormalised = ret.betweennessNormalized;\n\t\n\t    return ret;\n\t  } // betweennessCentrality\n\t\n\t}; // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.bc = elesfn.betweennessCentrality;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 27 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar defineSearch = function defineSearch(params) {\n\t  params = {\n\t    bfs: params.bfs || !params.dfs,\n\t    dfs: params.dfs || !params.bfs\n\t  };\n\t\n\t  // from pseudocode on wikipedia\n\t  return function searchFn(roots, fn, directed) {\n\t    var options;\n\t    if (is.plainObject(roots) && !is.elementOrCollection(roots)) {\n\t      options = roots;\n\t      roots = options.roots || options.root;\n\t      fn = options.visit;\n\t      directed = options.directed;\n\t    }\n\t\n\t    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;\n\t    fn = is.fn(fn) ? fn : function () {};\n\t\n\t    var cy = this._private.cy;\n\t    var v = roots = is.string(roots) ? this.filter(roots) : roots;\n\t    var Q = [];\n\t    var connectedNodes = [];\n\t    var connectedBy = {};\n\t    var id2depth = {};\n\t    var V = {};\n\t    var j = 0;\n\t    var found;\n\t    var nodes = this.nodes();\n\t    var edges = this.edges();\n\t\n\t    // enqueue v\n\t    for (var i = 0; i < v.length; i++) {\n\t      if (v[i].isNode()) {\n\t        Q.unshift(v[i]);\n\t\n\t        if (params.bfs) {\n\t          V[v[i].id()] = true;\n\t\n\t          connectedNodes.push(v[i]);\n\t        }\n\t\n\t        id2depth[v[i].id()] = 0;\n\t      }\n\t    }\n\t\n\t    while (Q.length !== 0) {\n\t      var v = params.bfs ? Q.shift() : Q.pop();\n\t\n\t      if (params.dfs) {\n\t        if (V[v.id()]) {\n\t          continue;\n\t        }\n\t\n\t        V[v.id()] = true;\n\t\n\t        connectedNodes.push(v);\n\t      }\n\t\n\t      var depth = id2depth[v.id()];\n\t      var prevEdge = connectedBy[v.id()];\n\t      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];\n\t      var ret;\n\t\n\t      ret = fn(v, prevEdge, prevNode, j++, depth);\n\t\n\t      if (ret === true) {\n\t        found = v;\n\t        break;\n\t      }\n\t\n\t      if (ret === false) {\n\t        break;\n\t      }\n\t\n\t      var vwEdges = v.connectedEdges(directed ? function (ele) {\n\t        return ele.data('source') === v.id();\n\t      } : undefined).intersect(edges);\n\t      for (var i = 0; i < vwEdges.length; i++) {\n\t        var e = vwEdges[i];\n\t        var w = e.connectedNodes(function (n) {\n\t          return n.id() !== v.id();\n\t        }).intersect(nodes);\n\t\n\t        if (w.length !== 0 && !V[w.id()]) {\n\t          w = w[0];\n\t\n\t          Q.push(w);\n\t\n\t          if (params.bfs) {\n\t            V[w.id()] = true;\n\t\n\t            connectedNodes.push(w);\n\t          }\n\t\n\t          connectedBy[w.id()] = e;\n\t\n\t          id2depth[w.id()] = id2depth[v.id()] + 1;\n\t        }\n\t      }\n\t    }\n\t\n\t    var connectedEles = [];\n\t\n\t    for (var i = 0; i < connectedNodes.length; i++) {\n\t      var node = connectedNodes[i];\n\t      var edge = connectedBy[node.id()];\n\t\n\t      if (edge) {\n\t        connectedEles.push(edge);\n\t      }\n\t\n\t      connectedEles.push(node);\n\t    }\n\t\n\t    return {\n\t      path: cy.collection(connectedEles, { unique: true }),\n\t      found: cy.collection(found)\n\t    };\n\t  };\n\t};\n\t\n\t// search, spanning trees, etc\n\tvar elesfn = {\n\t  breadthFirstSearch: defineSearch({ bfs: true }),\n\t  depthFirstSearch: defineSearch({ dfs: true })\n\t};\n\t\n\t// nice, short mathemathical alias\n\telesfn.bfs = elesfn.breadthFirstSearch;\n\telesfn.dfs = elesfn.depthFirstSearch;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 28 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar elesfn = {\n\t\n\t  closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    var harmonic = options.harmonic;\n\t    if (harmonic === undefined) {\n\t      harmonic = true;\n\t    }\n\t\n\t    var closenesses = {};\n\t    var maxCloseness = 0;\n\t    var nodes = this.nodes();\n\t    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });\n\t\n\t    // Compute closeness for every node and find the maximum closeness\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      var currCloseness = 0;\n\t      for (var j = 0; j < nodes.length; j++) {\n\t        if (i != j) {\n\t          var d = fw.distance(nodes[i], nodes[j]);\n\t\n\t          if (harmonic) {\n\t            currCloseness += 1 / d;\n\t          } else {\n\t            currCloseness += d;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!harmonic) {\n\t        currCloseness = 1 / currCloseness;\n\t      }\n\t\n\t      if (maxCloseness < currCloseness) {\n\t        maxCloseness = currCloseness;\n\t      }\n\t\n\t      closenesses[nodes[i].id()] = currCloseness;\n\t    }\n\t\n\t    return {\n\t      closeness: function closeness(node) {\n\t        if (maxCloseness == 0) {\n\t          return 0;\n\t        }\n\t\n\t        if (is.string(node)) {\n\t          // from is a selector string\n\t          var node = cy.filter(node)[0].id();\n\t        } else {\n\t          // from is a node\n\t          var node = node.id();\n\t        }\n\t\n\t        return closenesses[node] / maxCloseness;\n\t      }\n\t    };\n\t  },\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  closenessCentrality: function closenessCentrality(options) {\n\t    options = options || {};\n\t\n\t    // root - mandatory!\n\t    if (options.root != null) {\n\t      if (is.string(options.root)) {\n\t        // use it as a selector, e.g. \"#rootID\n\t        var root = this.filter(options.root)[0];\n\t      } else {\n\t        var root = options.root[0];\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // weight - optional\n\t    if (options.weight != null && is.fn(options.weight)) {\n\t      var weight = options.weight;\n\t    } else {\n\t      var weight = function weight() {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if (options.directed != null && is.bool(options.directed)) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var harmonic = options.harmonic;\n\t    if (harmonic === undefined) {\n\t      harmonic = true;\n\t    }\n\t\n\t    // we need distance from this node to every other node\n\t    var dijkstra = this.dijkstra({\n\t      root: root,\n\t      weight: weight,\n\t      directed: directed\n\t    });\n\t    var totalDistance = 0;\n\t\n\t    var nodes = this.nodes();\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      if (nodes[i].id() != root.id()) {\n\t        var d = dijkstra.distanceTo(nodes[i]);\n\t\n\t        if (harmonic) {\n\t          totalDistance += 1 / d;\n\t        } else {\n\t          totalDistance += d;\n\t        }\n\t      }\n\t    }\n\t\n\t    return harmonic ? totalDistance : 1 / totalDistance;\n\t  } // closenessCentrality\n\t\n\t}; // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.cc = elesfn.closenessCentrality;\n\telesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 29 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {\n\t\n\t  degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    // directed - optional\n\t    if (options.directed != null) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    if (!directed) {\n\t      var degrees = {};\n\t      var maxDegree = 0;\n\t\n\t      for (var i = 0; i < numNodes; i++) {\n\t        var node = nodes[i];\n\t        // add current node to the current options object and call degreeCentrality\n\t        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));\n\t        if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;\n\t\n\t        degrees[node.id()] = currDegree.degree;\n\t      }\n\t\n\t      return {\n\t        degree: function degree(node) {\n\t          if (maxDegree == 0) return 0;\n\t\n\t          if (is.string(node)) {\n\t            // from is a selector string\n\t            var node = cy.filter(node)[0].id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return degrees[node] / maxDegree;\n\t        }\n\t      };\n\t    } else {\n\t      var indegrees = {};\n\t      var outdegrees = {};\n\t      var maxIndegree = 0;\n\t      var maxOutdegree = 0;\n\t\n\t      for (var i = 0; i < numNodes; i++) {\n\t        var node = nodes[i];\n\t        // add current node to the current options object and call degreeCentrality\n\t        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));\n\t\n\t        if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;\n\t\n\t        if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;\n\t\n\t        indegrees[node.id()] = currDegree.indegree;\n\t        outdegrees[node.id()] = currDegree.outdegree;\n\t      }\n\t\n\t      return {\n\t        indegree: function indegree(node) {\n\t          if (maxIndegree == 0) return 0;\n\t\n\t          if (is.string(node)) {\n\t            // from is a selector string\n\t            var node = cy.filter(node)[0].id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return indegrees[node] / maxIndegree;\n\t        },\n\t        outdegree: function outdegree(node) {\n\t          if (maxOutdegree == 0) return 0;\n\t\n\t          if (is.string(node)) {\n\t            // from is a selector string\n\t            var node = cy.filter(node)[0].id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return outdegrees[node] / maxOutdegree;\n\t        }\n\t\n\t      };\n\t    }\n\t  }, // degreeCentralityNormalized\n\t\n\t  // Implemented from the algorithm in Opsahl's paper\n\t  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n\t  // check the heading 2 \"Degree\"\n\t  degreeCentrality: function degreeCentrality(options) {\n\t    options = options || {};\n\t\n\t    var callingEles = this;\n\t\n\t    // root - mandatory!\n\t    if (options != null && options.root != null) {\n\t      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // weight - optional\n\t    if (options.weight != null && is.fn(options.weight)) {\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function weightFn(e) {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if (options.directed != null) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    // alpha - optional\n\t    if (options.alpha != null && is.number(options.alpha)) {\n\t      var alpha = options.alpha;\n\t    } else {\n\t      alpha = 0;\n\t    }\n\t\n\t    if (!directed) {\n\t      var connEdges = root.connectedEdges().intersection(callingEles);\n\t      var k = connEdges.length;\n\t      var s = 0;\n\t\n\t      // Now, sum edge weights\n\t      for (var i = 0; i < connEdges.length; i++) {\n\t        var edge = connEdges[i];\n\t        s += weightFn(edge);\n\t      }\n\t\n\t      return {\n\t        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n\t      };\n\t    } else {\n\t      var incoming = root.connectedEdges('edge[target = \"' + root.id() + '\"]').intersection(callingEles);\n\t      var outgoing = root.connectedEdges('edge[source = \"' + root.id() + '\"]').intersection(callingEles);\n\t      var k_in = incoming.length;\n\t      var k_out = outgoing.length;\n\t      var s_in = 0;\n\t      var s_out = 0;\n\t\n\t      // Now, sum incoming edge weights\n\t      for (var i = 0; i < incoming.length; i++) {\n\t        var edge = incoming[i];\n\t        s_in += weightFn(edge);\n\t      }\n\t\n\t      // Now, sum outgoing edge weights\n\t      for (var i = 0; i < outgoing.length; i++) {\n\t        var edge = outgoing[i];\n\t        s_out += weightFn(edge);\n\t      }\n\t\n\t      return {\n\t        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n\t        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n\t      };\n\t    }\n\t  } // degreeCentrality\n\t\n\t}; // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.dc = elesfn.degreeCentrality;\n\telesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 30 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Heap = __webpack_require__(8);\n\t\n\tvar elesfn = {\n\t\n\t  dijkstra: function dijkstra(root, weightFn, directed) {\n\t    var options;\n\t    if (is.plainObject(root) && !is.elementOrCollection(root)) {\n\t      options = root;\n\t      root = options.root;\n\t      weightFn = options.weight;\n\t      directed = options.directed;\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    weightFn = is.fn(weightFn) ? weightFn : function () {\n\t      return 1;\n\t    }; // if not specified, assume each edge has equal weight (1)\n\t\n\t    var source = is.string(root) ? this.filter(root)[0] : root[0];\n\t    var dist = {};\n\t    var prev = {};\n\t    var knownDist = {};\n\t\n\t    var edges = this.edges().filter(function (ele) {\n\t      return !ele.isLoop();\n\t    });\n\t    var nodes = this.nodes();\n\t\n\t    var getDist = function getDist(node) {\n\t      return dist[node.id()];\n\t    };\n\t\n\t    var setDist = function setDist(node, d) {\n\t      dist[node.id()] = d;\n\t\n\t      Q.updateItem(node);\n\t    };\n\t\n\t    var Q = new Heap(function (a, b) {\n\t      return getDist(a) - getDist(b);\n\t    });\n\t\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      var node = nodes[i];\n\t\n\t      dist[node.id()] = node.same(source) ? 0 : Infinity;\n\t      Q.push(node);\n\t    }\n\t\n\t    var distBetween = function distBetween(u, v) {\n\t      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n\t      var smallestDistance = Infinity;\n\t      var smallestEdge;\n\t\n\t      for (var i = 0; i < uvs.length; i++) {\n\t        var edge = uvs[i];\n\t        var weight = weightFn(edge);\n\t\n\t        if (weight < smallestDistance || !smallestEdge) {\n\t          smallestDistance = weight;\n\t          smallestEdge = edge;\n\t        }\n\t      }\n\t\n\t      return {\n\t        edge: smallestEdge,\n\t        dist: smallestDistance\n\t      };\n\t    };\n\t\n\t    while (Q.size() > 0) {\n\t      var u = Q.pop();\n\t      var smalletsDist = getDist(u);\n\t      var uid = u.id();\n\t\n\t      knownDist[uid] = smalletsDist;\n\t\n\t      if (smalletsDist === Infinity) {\n\t        continue;\n\t      }\n\t\n\t      var neighbors = u.neighborhood().intersect(nodes);\n\t      for (var i = 0; i < neighbors.length; i++) {\n\t        var v = neighbors[i];\n\t        var vid = v.id();\n\t        var vDist = distBetween(u, v);\n\t\n\t        var alt = smalletsDist + vDist.dist;\n\t\n\t        if (alt < getDist(v)) {\n\t          setDist(v, alt);\n\t\n\t          prev[vid] = {\n\t            node: u,\n\t            edge: vDist.edge\n\t          };\n\t        }\n\t      } // for\n\t    } // while\n\t\n\t    return {\n\t      distanceTo: function distanceTo(node) {\n\t        var target = is.string(node) ? nodes.filter(node)[0] : node[0];\n\t\n\t        return knownDist[target.id()];\n\t      },\n\t\n\t      pathTo: function pathTo(node) {\n\t        var target = is.string(node) ? nodes.filter(node)[0] : node[0];\n\t        var S = [];\n\t        var u = target;\n\t\n\t        if (target.length > 0) {\n\t          S.unshift(target);\n\t\n\t          while (prev[u.id()]) {\n\t            var p = prev[u.id()];\n\t\n\t            S.unshift(p.edge);\n\t            S.unshift(p.node);\n\t\n\t            u = p.node;\n\t          }\n\t        }\n\t\n\t        return cy.collection(S);\n\t      }\n\t    };\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 31 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar elesfn = {\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  floydWarshall: function floydWarshall(options) {\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    // Weight function - optional\n\t    if (options.weight != null && is.fn(options.weight)) {\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function weightFn(e) {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if (options.directed != null) {\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var edges = this.edges().stdFilter(function (e) {\n\t      return !e.isLoop();\n\t    });\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    // mapping: node id -> position in nodes array\n\t    var id2position = {};\n\t    for (var i = 0; i < numNodes; i++) {\n\t      id2position[nodes[i].id()] = i;\n\t    }\n\t\n\t    // Initialize distance matrix\n\t    var dist = [];\n\t    for (var i = 0; i < numNodes; i++) {\n\t      var newRow = new Array(numNodes);\n\t      for (var j = 0; j < numNodes; j++) {\n\t        if (i == j) {\n\t          newRow[j] = 0;\n\t        } else {\n\t          newRow[j] = Infinity;\n\t        }\n\t      }\n\t      dist.push(newRow);\n\t    }\n\t\n\t    // Initialize matrix used for path reconstruction\n\t    // Initialize distance matrix\n\t    var next = [];\n\t    var edgeNext = [];\n\t\n\t    var initMatrix = function initMatrix(next) {\n\t      for (var i = 0; i < numNodes; i++) {\n\t        var newRow = new Array(numNodes);\n\t        for (var j = 0; j < numNodes; j++) {\n\t          newRow[j] = undefined;\n\t        }\n\t        next.push(newRow);\n\t      }\n\t    };\n\t\n\t    initMatrix(next);\n\t    initMatrix(edgeNext);\n\t\n\t    // Process edges\n\t    for (var i = 0; i < edges.length; i++) {\n\t      var sourceIndex = id2position[edges[i].source().id()];\n\t      var targetIndex = id2position[edges[i].target().id()];\n\t      var weight = weightFn(edges[i]);\n\t\n\t      // Check if already process another edge between same 2 nodes\n\t      if (dist[sourceIndex][targetIndex] > weight) {\n\t        dist[sourceIndex][targetIndex] = weight;\n\t        next[sourceIndex][targetIndex] = targetIndex;\n\t        edgeNext[sourceIndex][targetIndex] = edges[i];\n\t      }\n\t    }\n\t\n\t    // If undirected graph, process 'reversed' edges\n\t    if (!directed) {\n\t      for (var i = 0; i < edges.length; i++) {\n\t        var sourceIndex = id2position[edges[i].target().id()];\n\t        var targetIndex = id2position[edges[i].source().id()];\n\t        var weight = weightFn(edges[i]);\n\t\n\t        // Check if already process another edge between same 2 nodes\n\t        if (dist[sourceIndex][targetIndex] > weight) {\n\t          dist[sourceIndex][targetIndex] = weight;\n\t          next[sourceIndex][targetIndex] = targetIndex;\n\t          edgeNext[sourceIndex][targetIndex] = edges[i];\n\t        }\n\t      }\n\t    }\n\t\n\t    // Main loop\n\t    for (var k = 0; k < numNodes; k++) {\n\t      for (var i = 0; i < numNodes; i++) {\n\t        for (var j = 0; j < numNodes; j++) {\n\t          if (dist[i][k] + dist[k][j] < dist[i][j]) {\n\t            dist[i][j] = dist[i][k] + dist[k][j];\n\t            next[i][j] = next[i][k];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Build result object\n\t    var position2id = [];\n\t    for (var i = 0; i < numNodes; i++) {\n\t      position2id.push(nodes[i].id());\n\t    }\n\t\n\t    var res = {\n\t      distance: function distance(from, to) {\n\t        if (is.string(from)) {\n\t          // from is a selector string\n\t          var fromId = cy.filter(from)[0].id();\n\t        } else {\n\t          // from is a node\n\t          var fromId = from.id();\n\t        }\n\t\n\t        if (is.string(to)) {\n\t          // to is a selector string\n\t          var toId = cy.filter(to)[0].id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        return dist[id2position[fromId]][id2position[toId]];\n\t      },\n\t\n\t      path: function path(from, to) {\n\t        var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {\n\t          if (from === to) {\n\t            return cy.getElementById(position2id[from]);\n\t          }\n\t          if (next[from][to] === undefined) {\n\t            return undefined;\n\t          }\n\t\n\t          var path = [cy.getElementById(position2id[from])];\n\t          var prev = from;\n\t          while (from !== to) {\n\t            prev = from;\n\t            from = next[from][to];\n\t\n\t            var edge = edgeNext[prev][from];\n\t            path.push(edge);\n\t\n\t            path.push(cy.getElementById(position2id[from]));\n\t          }\n\t          return path;\n\t        };\n\t\n\t        if (is.string(from)) {\n\t          // from is a selector string\n\t          var fromId = cy.filter(from)[0].id();\n\t        } else {\n\t          // from is a node\n\t          var fromId = from.id();\n\t        }\n\t\n\t        if (is.string(to)) {\n\t          // to is a selector string\n\t          var toId = cy.filter(to)[0].id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);\n\t\n\t        return cy.collection(pathArr);\n\t      }\n\t    };\n\t\n\t    return res;\n\t  } // floydWarshall\n\t\n\t}; // elesfn\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 32 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {};\n\t\n\t[__webpack_require__(27), __webpack_require__(30), __webpack_require__(34), __webpack_require__(24), __webpack_require__(31), __webpack_require__(25), __webpack_require__(33), __webpack_require__(35), __webpack_require__(29), __webpack_require__(28), __webpack_require__(26)].forEach(function (props) {\n\t  util.extend(elesfn, props);\n\t});\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 33 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {\n\t\n\t  // Computes the minimum cut of an undirected graph\n\t  // Returns the correct answer with high probability\n\t  kargerStein: function kargerStein(options) {\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Function which colapses 2 (meta) nodes into one\n\t    // Updates the remaining edge lists\n\t    // Receives as a paramater the edge which causes the collapse\n\t    var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {\n\t      var edgeInfo = remainingEdges[edgeIndex];\n\t      var sourceIn = edgeInfo[1];\n\t      var targetIn = edgeInfo[2];\n\t      var partition1 = nodeMap[sourceIn];\n\t      var partition2 = nodeMap[targetIn];\n\t\n\t      // Delete all edges between partition1 and partition2\n\t      var newEdges = remainingEdges.filter(function (edge) {\n\t        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {\n\t          return false;\n\t        }\n\t        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {\n\t          return false;\n\t        }\n\t        return true;\n\t      });\n\t\n\t      // All edges pointing to partition2 should now point to partition1\n\t      for (var i = 0; i < newEdges.length; i++) {\n\t        var edge = newEdges[i];\n\t        if (edge[1] === partition2) {\n\t          // Check source\n\t          newEdges[i] = edge.slice(0);\n\t          newEdges[i][1] = partition1;\n\t        } else if (edge[2] === partition2) {\n\t          // Check target\n\t          newEdges[i] = edge.slice(0);\n\t          newEdges[i][2] = partition1;\n\t        }\n\t      }\n\t\n\t      // Move all nodes from partition2 to partition1\n\t      for (var i = 0; i < nodeMap.length; i++) {\n\t        if (nodeMap[i] === partition2) {\n\t          nodeMap[i] = partition1;\n\t        }\n\t      }\n\t\n\t      return newEdges;\n\t    };\n\t\n\t    // Contracts a graph until we reach a certain number of meta nodes\n\t    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n\t      // Stop condition\n\t      if (size <= sizeLimit) {\n\t        return remainingEdges;\n\t      }\n\t\n\t      // Choose an edge randomly\n\t      var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n\t\n\t      // Colapse graph based on edge\n\t      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);\n\t\n\t      return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);\n\t    };\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter(function (e) {\n\t      return !e.isLoop();\n\t    });\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t    var numEdges = edges.length;\n\t    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n\t    var stopSize = Math.floor(numNodes / Math.sqrt(2));\n\t\n\t    if (numNodes < 2) {\n\t      util.error('At least 2 nodes are required for Karger-Stein algorithm');\n\t      return undefined;\n\t    }\n\t\n\t    // Create numerical identifiers for each node\n\t    // mapping: node id -> position in nodes array\n\t    // for reverse mapping, simply use nodes array\n\t    var id2position = {};\n\t    for (var i = 0; i < numNodes; i++) {\n\t      id2position[nodes[i].id()] = i;\n\t    }\n\t\n\t    // Now store edge destination as indexes\n\t    // Format for each edge (edge index, source node index, target node index)\n\t    var edgeIndexes = [];\n\t    for (var i = 0; i < numEdges; i++) {\n\t      var e = edges[i];\n\t      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);\n\t    }\n\t\n\t    // We will store the best cut found here\n\t    var minCutSize = Infinity;\n\t    var minCut;\n\t\n\t    // Initial meta node partition\n\t    var originalMetaNode = [];\n\t    for (var i = 0; i < numNodes; i++) {\n\t      originalMetaNode.push(i);\n\t    }\n\t\n\t    // Main loop\n\t    for (var iter = 0; iter <= numIter; iter++) {\n\t      // Create new meta node partition\n\t      var metaNodeMap = originalMetaNode.slice(0);\n\t\n\t      // Contract until stop point (stopSize nodes)\n\t      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);\n\t\n\t      // Create a copy of the colapsed nodes state\n\t      var metaNodeMap2 = metaNodeMap.slice(0);\n\t\n\t      // Run 2 iterations starting in the stop state\n\t      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n\t      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);\n\t\n\t      // Is any of the 2 results the best cut so far?\n\t      if (res1.length <= res2.length && res1.length < minCutSize) {\n\t        minCutSize = res1.length;\n\t        minCut = [res1, metaNodeMap];\n\t      } else if (res2.length <= res1.length && res2.length < minCutSize) {\n\t        minCutSize = res2.length;\n\t        minCut = [res2, metaNodeMap2];\n\t      }\n\t    } // end of main loop\n\t\n\t\n\t    // Construct result\n\t    var resEdges = minCut[0].map(function (e) {\n\t      return edges[e[0]];\n\t    });\n\t    var partition1 = [];\n\t    var partition2 = [];\n\t\n\t    // traverse metaNodeMap for best cut\n\t    var witnessNodePartition = minCut[1][0];\n\t    for (var i = 0; i < minCut[1].length; i++) {\n\t      var partitionId = minCut[1][i];\n\t      if (partitionId === witnessNodePartition) {\n\t        partition1.push(nodes[i]);\n\t      } else {\n\t        partition2.push(nodes[i]);\n\t      }\n\t    }\n\t\n\t    var ret = {\n\t      cut: eles.spawn(cy, resEdges),\n\t      partition1: eles.spawn(partition1),\n\t      partition2: eles.spawn(partition2)\n\t    };\n\t\n\t    return ret;\n\t  }\n\t}; // elesfn\n\t\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 34 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\t// search, spanning trees, etc\n\tvar elesfn = {\n\t\n\t  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n\t  // implemented from pseudocode from wikipedia\n\t  kruskal: function kruskal(weightFn) {\n\t    var cy = this.cy();\n\t\n\t    weightFn = is.fn(weightFn) ? weightFn : function () {\n\t      return 1;\n\t    }; // if not specified, assume each edge has equal weight (1)\n\t\n\t    function findSet(ele) {\n\t      for (var i = 0; i < forest.length; i++) {\n\t        var eles = forest[i];\n\t\n\t        if (eles.anySame(ele)) {\n\t          return {\n\t            eles: eles,\n\t            index: i\n\t          };\n\t        }\n\t      }\n\t    }\n\t\n\t    var A = cy.collection(cy, []);\n\t    var forest = [];\n\t    var nodes = this.nodes();\n\t\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      forest.push(nodes[i].collection());\n\t    }\n\t\n\t    var edges = this.edges();\n\t    var S = edges.toArray().sort(function (a, b) {\n\t      var weightA = weightFn(a);\n\t      var weightB = weightFn(b);\n\t\n\t      return weightA - weightB;\n\t    });\n\t\n\t    for (var i = 0; i < S.length; i++) {\n\t      var edge = S[i];\n\t      var u = edge.source()[0];\n\t      var v = edge.target()[0];\n\t      var setU = findSet(u);\n\t      var setV = findSet(v);\n\t\n\t      if (setU.index !== setV.index) {\n\t        A = A.add(edge);\n\t\n\t        // combine forests for u and v\n\t        forest[setU.index] = setU.eles.add(setV.eles);\n\t        forest.splice(setV.index, 1);\n\t      }\n\t    }\n\t\n\t    return nodes.add(A);\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 35 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar elesfn = {\n\t\n\t  pageRank: function pageRank(options) {\n\t    options = options || {};\n\t\n\t    var normalizeVector = function normalizeVector(vector) {\n\t      var length = vector.length;\n\t\n\t      // First, get sum of all elements\n\t      var total = 0;\n\t      for (var i = 0; i < length; i++) {\n\t        total += vector[i];\n\t      }\n\t\n\t      // Now, divide each by the sum of all elements\n\t      for (var i = 0; i < length; i++) {\n\t        vector[i] = vector[i] / total;\n\t      }\n\t    };\n\t\n\t    // dampingFactor - optional\n\t    if (options != null && options.dampingFactor != null) {\n\t      var dampingFactor = options.dampingFactor;\n\t    } else {\n\t      var dampingFactor = 0.8; // Default damping factor\n\t    }\n\t\n\t    // desired precision - optional\n\t    if (options != null && options.precision != null) {\n\t      var epsilon = options.precision;\n\t    } else {\n\t      var epsilon = 0.000001; // Default precision\n\t    }\n\t\n\t    // Max number of iterations - optional\n\t    if (options != null && options.iterations != null) {\n\t      var numIter = options.iterations;\n\t    } else {\n\t      var numIter = 200; // Default number of iterations\n\t    }\n\t\n\t    // Weight function - optional\n\t    if (options != null && options.weight != null && is.fn(options.weight)) {\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function weightFn(e) {\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter(function (e) {\n\t      return !e.isLoop();\n\t    });\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t    var numEdges = edges.length;\n\t\n\t    // Create numerical identifiers for each node\n\t    // mapping: node id -> position in nodes array\n\t    // for reverse mapping, simply use nodes array\n\t    var id2position = {};\n\t    for (var i = 0; i < numNodes; i++) {\n\t      id2position[nodes[i].id()] = i;\n\t    }\n\t\n\t    // Construct transposed adjacency matrix\n\t    // First lets have a zeroed matrix of the right size\n\t    // We'll also keep track of the sum of each column\n\t    var matrix = [];\n\t    var columnSum = [];\n\t    var additionalProb = (1 - dampingFactor) / numNodes;\n\t\n\t    // Create null matric\n\t    for (var i = 0; i < numNodes; i++) {\n\t      var newRow = [];\n\t      for (var j = 0; j < numNodes; j++) {\n\t        newRow.push(0.0);\n\t      }\n\t      matrix.push(newRow);\n\t      columnSum.push(0.0);\n\t    }\n\t\n\t    // Now, process edges\n\t    for (var i = 0; i < numEdges; i++) {\n\t      var edge = edges[i];\n\t      var s = id2position[edge.source().id()];\n\t      var t = id2position[edge.target().id()];\n\t      var w = weightFn(edge);\n\t\n\t      // Update matrix\n\t      matrix[t][s] += w;\n\t\n\t      // Update column sum\n\t      columnSum[s] += w;\n\t    }\n\t\n\t    // Add additional probability based on damping factor\n\t    // Also, take into account columns that have sum = 0\n\t    var p = 1.0 / numNodes + additionalProb; // Shorthand\n\t    // Traverse matrix, column by column\n\t    for (var j = 0; j < numNodes; j++) {\n\t      if (columnSum[j] === 0) {\n\t        // No 'links' out from node jth, assume equal probability for each possible node\n\t        for (var i = 0; i < numNodes; i++) {\n\t          matrix[i][j] = p;\n\t        }\n\t      } else {\n\t        // Node jth has outgoing link, compute normalized probabilities\n\t        for (var i = 0; i < numNodes; i++) {\n\t          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;\n\t        }\n\t      }\n\t    }\n\t\n\t    // Compute dominant eigenvector using power method\n\t    var eigenvector = [];\n\t    var nullVector = [];\n\t    var previous;\n\t\n\t    // Start with a vector of all 1's\n\t    // Also, initialize a null vector which will be used as shorthand\n\t    for (var i = 0; i < numNodes; i++) {\n\t      eigenvector.push(1.0);\n\t      nullVector.push(0.0);\n\t    }\n\t\n\t    for (var iter = 0; iter < numIter; iter++) {\n\t      // New array with all 0's\n\t      var temp = nullVector.slice(0);\n\t\n\t      // Multiply matrix with previous result\n\t      for (var i = 0; i < numNodes; i++) {\n\t        for (var j = 0; j < numNodes; j++) {\n\t          temp[i] += matrix[i][j] * eigenvector[j];\n\t        }\n\t      }\n\t\n\t      normalizeVector(temp);\n\t      previous = eigenvector;\n\t      eigenvector = temp;\n\t\n\t      var diff = 0;\n\t      // Compute difference (squared module) of both vectors\n\t      for (var i = 0; i < numNodes; i++) {\n\t        diff += Math.pow(previous[i] - eigenvector[i], 2);\n\t      }\n\t\n\t      // If difference is less than the desired threshold, stop iterating\n\t      if (diff < epsilon) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    // Construct result\n\t    var res = {\n\t      rank: function rank(node) {\n\t        if (is.string(node)) {\n\t          // is a selector string\n\t          var nodeId = cy.filter(node)[0].id();\n\t        } else {\n\t          // is a node object\n\t          var nodeId = node.id();\n\t        }\n\t        return eigenvector[id2position[nodeId]];\n\t      }\n\t    };\n\t\n\t    return res;\n\t  } // pageRank\n\t\n\t}; // elesfn\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 36 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar define = __webpack_require__(3);\n\t\n\tvar elesfn = {\n\t  animate: define.animate(),\n\t  animation: define.animation(),\n\t  animated: define.animated(),\n\t  clearQueue: define.clearQueue(),\n\t  delay: define.delay(),\n\t  delayAnimation: define.delayAnimation(),\n\t  stop: define.stop()\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 37 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar Set = __webpack_require__(9);\n\t\n\tvar elesfn = {\n\t  classes: function classes(_classes) {\n\t    _classes = (_classes || '').match(/\\S+/g) || [];\n\t    var self = this;\n\t    var changed = [];\n\t    var classesMap = new Set(_classes);\n\t\n\t    // check and update each ele\n\t\n\t    var _loop = function _loop(j) {\n\t      var ele = self[j];\n\t      var _p = ele._private;\n\t      var eleClasses = _p.classes;\n\t      var changedEle = false;\n\t\n\t      // check if ele has all of the passed classes\n\t      classesMap.forEach(function (cls) {\n\t        var eleHasClass = eleClasses.has(cls);\n\t\n\t        if (!eleHasClass) {\n\t          changedEle = true;\n\t        }\n\t      });\n\t\n\t      // check if ele has classes outside of those passed\n\t      if (!changedEle) {\n\t        eleClasses.forEach(function (eleCls) {\n\t          var specdClass = classesMap.has(eleCls);\n\t\n\t          if (!specdClass) {\n\t            changedEle = true;\n\t          }\n\t        });\n\t      }\n\t\n\t      if (changedEle) {\n\t        _p.classes = new Set(classesMap);\n\t\n\t        changed.push(ele);\n\t      }\n\t    };\n\t\n\t    for (var j = 0; j < self.length; j++) {\n\t      _loop(j);\n\t    }\n\t\n\t    // trigger update style on those eles that had class changes\n\t    if (changed.length > 0) {\n\t      this.spawn(changed).updateStyle().emit('class');\n\t    }\n\t\n\t    return self;\n\t  },\n\t\n\t  addClass: function addClass(classes) {\n\t    return this.toggleClass(classes, true);\n\t  },\n\t\n\t  hasClass: function hasClass(className) {\n\t    var ele = this[0];\n\t    return ele != null && ele._private.classes.has(className);\n\t  },\n\t\n\t  toggleClass: function toggleClass(classesStr, toggle) {\n\t    var classes = classesStr.match(/\\S+/g) || [];\n\t    var self = this;\n\t    var changed = []; // eles who had classes changed\n\t\n\t    for (var i = 0, il = self.length; i < il; i++) {\n\t      var _ele = self[i];\n\t      var _changedEle = false;\n\t\n\t      for (var j = 0; j < classes.length; j++) {\n\t        var cls = classes[j];\n\t        var _eleClasses = _ele._private.classes;\n\t        var hasClass = _eleClasses.has(cls);\n\t        var shouldAdd = toggle || toggle === undefined && !hasClass;\n\t\n\t        if (shouldAdd) {\n\t          _eleClasses.add(cls);\n\t\n\t          if (!hasClass && !_changedEle) {\n\t            changed.push(_ele);\n\t            _changedEle = true;\n\t          }\n\t        } else {\n\t          // then remove\n\t          _eleClasses.delete(cls);\n\t\n\t          if (hasClass && !_changedEle) {\n\t            changed.push(_ele);\n\t            _changedEle = true;\n\t          }\n\t        }\n\t      } // for j classes\n\t    } // for i eles\n\t\n\t    // trigger update style on those eles that had class changes\n\t    if (changed.length > 0) {\n\t      this.spawn(changed).updateStyle().emit('class');\n\t    }\n\t\n\t    return self;\n\t  },\n\t\n\t  removeClass: function removeClass(classes) {\n\t    return this.toggleClass(classes, false);\n\t  },\n\t\n\t  flashClass: function flashClass(classes, duration) {\n\t    var self = this;\n\t\n\t    if (duration == null) {\n\t      duration = 250;\n\t    } else if (duration === 0) {\n\t      return self; // nothing to do really\n\t    }\n\t\n\t    self.addClass(classes);\n\t    setTimeout(function () {\n\t      self.removeClass(classes);\n\t    }, duration);\n\t\n\t    return self;\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 38 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar elesfn = {\n\t  allAre: function allAre(selector) {\n\t    var selObj = new Selector(selector);\n\t\n\t    return this.every(function (ele) {\n\t      return selObj.matches(ele);\n\t    });\n\t  },\n\t\n\t  is: function is(selector) {\n\t    var selObj = new Selector(selector);\n\t\n\t    return this.some(function (ele) {\n\t      return selObj.matches(ele);\n\t    });\n\t  },\n\t\n\t  some: function some(fn, thisArg) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\t\n\t      if (ret) {\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  every: function every(fn, thisArg) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\t\n\t      if (!ret) {\n\t        return false;\n\t      }\n\t    }\n\t\n\t    return true;\n\t  },\n\t\n\t  same: function same(collection) {\n\t    collection = this.cy().collection(collection);\n\t\n\t    // cheap extra check\n\t    if (this.length !== collection.length) {\n\t      return false;\n\t    }\n\t\n\t    return this.every(function (ele) {\n\t      return collection.hasElementWithId(ele.id());\n\t    });\n\t  },\n\t\n\t  anySame: function anySame(collection) {\n\t    collection = this.cy().collection(collection);\n\t\n\t    return this.some(function (ele) {\n\t      return collection.hasElementWithId(ele.id());\n\t    });\n\t  },\n\t\n\t  allAreNeighbors: function allAreNeighbors(collection) {\n\t    collection = this.cy().collection(collection);\n\t\n\t    var nhood = this.neighborhood();\n\t\n\t    return collection.every(function (ele) {\n\t      return nhood.hasElementWithId(ele.id());\n\t    });\n\t  },\n\t\n\t  contains: function contains(collection) {\n\t    collection = this.cy().collection(collection);\n\t\n\t    var self = this;\n\t\n\t    return collection.every(function (ele) {\n\t      return self.hasElementWithId(ele.id());\n\t    });\n\t  }\n\t};\n\t\n\telesfn.allAreNeighbours = elesfn.allAreNeighbors;\n\telesfn.has = elesfn.contains;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 39 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar Set = __webpack_require__(9);\n\t\n\tvar elesfn = {\n\t  parent: function parent(selector) {\n\t    var parents = [];\n\t\n\t    // optimisation for single ele call\n\t    if (this.length === 1) {\n\t      var parent = this[0]._private.parent;\n\t\n\t      if (parent) {\n\t        return parent;\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t      var _parent = ele._private.parent;\n\t\n\t      if (_parent) {\n\t        parents.push(_parent);\n\t      }\n\t    }\n\t\n\t    return this.spawn(parents, { unique: true }).filter(selector);\n\t  },\n\t\n\t  parents: function parents(selector) {\n\t    var parents = [];\n\t\n\t    var eles = this.parent();\n\t    while (eles.nonempty()) {\n\t      for (var i = 0; i < eles.length; i++) {\n\t        var ele = eles[i];\n\t        parents.push(ele);\n\t      }\n\t\n\t      eles = eles.parent();\n\t    }\n\t\n\t    return this.spawn(parents, { unique: true }).filter(selector);\n\t  },\n\t\n\t  commonAncestors: function commonAncestors(selector) {\n\t    var ancestors = void 0;\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t      var parents = ele.parents();\n\t\n\t      ancestors = ancestors || parents;\n\t\n\t      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n\t    }\n\t\n\t    return ancestors.filter(selector);\n\t  },\n\t\n\t  orphans: function orphans(selector) {\n\t    return this.stdFilter(function (ele) {\n\t      return ele.isOrphan();\n\t    }).filter(selector);\n\t  },\n\t\n\t  nonorphans: function nonorphans(selector) {\n\t    return this.stdFilter(function (ele) {\n\t      return ele.isChild();\n\t    }).filter(selector);\n\t  },\n\t\n\t  children: function children(selector) {\n\t    var children = [];\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t      children = children.concat(ele._private.children);\n\t    }\n\t\n\t    return this.spawn(children, { unique: true }).filter(selector);\n\t  },\n\t\n\t  siblings: function siblings(selector) {\n\t    return this.parent().children().not(this).filter(selector);\n\t  },\n\t\n\t  isParent: function isParent() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele.isNode() && ele._private.children.length !== 0;\n\t    }\n\t  },\n\t\n\t  isChildless: function isChildless() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele.isNode() && ele._private.children.length === 0;\n\t    }\n\t  },\n\t\n\t  isChild: function isChild() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele.isNode() && ele._private.parent != null;\n\t    }\n\t  },\n\t\n\t  isOrphan: function isOrphan() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele.isNode() && ele._private.parent == null;\n\t    }\n\t  },\n\t\n\t  descendants: function descendants(selector) {\n\t    var elements = [];\n\t\n\t    function add(eles) {\n\t      for (var i = 0; i < eles.length; i++) {\n\t        var ele = eles[i];\n\t\n\t        elements.push(ele);\n\t\n\t        if (ele.children().nonempty()) {\n\t          add(ele.children());\n\t        }\n\t      }\n\t    }\n\t\n\t    add(this.children());\n\t\n\t    return this.spawn(elements, { unique: true }).filter(selector);\n\t  }\n\t};\n\t\n\tfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n\t  var q = [];\n\t  var did = new Set();\n\t  var cy = eles.cy();\n\t  var hasCompounds = cy.hasCompoundNodes();\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    if (includeSelf) {\n\t      q.push(ele);\n\t    } else if (hasCompounds) {\n\t      recursiveStep(q, did, ele);\n\t    }\n\t  }\n\t\n\t  while (q.length > 0) {\n\t    var _ele = q.shift();\n\t\n\t    fn(_ele);\n\t\n\t    did.add(_ele.id());\n\t\n\t    if (hasCompounds) {\n\t      recursiveStep(q, did, _ele);\n\t    }\n\t  }\n\t\n\t  return eles;\n\t}\n\t\n\tfunction addChildren(q, did, ele) {\n\t  if (ele.isParent()) {\n\t    var children = ele._private.children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t\n\t      if (!did.has(child.id())) {\n\t        q.push(child);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// very efficient version of eles.add( eles.descendants() ).forEach()\n\t// for internal use\n\telesfn.forEachDown = function (fn) {\n\t  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  return forEachCompound(this, fn, includeSelf, addChildren);\n\t};\n\t\n\tfunction addParent(q, did, ele) {\n\t  if (ele.isChild()) {\n\t    var parent = ele._private.parent;\n\t\n\t    if (!did.has(parent.id())) {\n\t      q.push(parent);\n\t    }\n\t  }\n\t}\n\t\n\telesfn.forEachUp = function (fn) {\n\t  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  return forEachCompound(this, fn, includeSelf, addParent);\n\t};\n\t\n\tfunction addParentAndChildren(q, did, ele) {\n\t  addParent(q, did, ele);\n\t  addChildren(q, did, ele);\n\t}\n\t\n\telesfn.forEachUpAndDown = function (fn) {\n\t  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n\t};\n\t\n\t// aliases\n\telesfn.ancestors = elesfn.parents;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 40 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar define = __webpack_require__(3);\n\tvar fn = void 0,\n\t    elesfn = void 0;\n\t\n\tfn = elesfn = {\n\t\n\t  data: define.data({\n\t    field: 'data',\n\t    bindingEvent: 'data',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'data',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true,\n\t    immutableKeys: {\n\t      'id': true,\n\t      'source': true,\n\t      'target': true,\n\t      'parent': true\n\t    },\n\t    updateStyle: true\n\t  }),\n\t\n\t  removeData: define.removeData({\n\t    field: 'data',\n\t    event: 'data',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true,\n\t    immutableKeys: {\n\t      'id': true,\n\t      'source': true,\n\t      'target': true,\n\t      'parent': true\n\t    },\n\t    updateStyle: true\n\t  }),\n\t\n\t  scratch: define.data({\n\t    field: 'scratch',\n\t    bindingEvent: 'scratch',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'scratch',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true,\n\t    updateStyle: true\n\t  }),\n\t\n\t  removeScratch: define.removeData({\n\t    field: 'scratch',\n\t    event: 'scratch',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true,\n\t    updateStyle: true\n\t  }),\n\t\n\t  rscratch: define.data({\n\t    field: 'rscratch',\n\t    allowBinding: false,\n\t    allowSetting: true,\n\t    settingTriggersEvent: false,\n\t    allowGetting: true\n\t  }),\n\t\n\t  removeRscratch: define.removeData({\n\t    field: 'rscratch',\n\t    triggerEvent: false\n\t  }),\n\t\n\t  id: function id() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele._private.data.id;\n\t    }\n\t  }\n\t\n\t};\n\t\n\t// aliases\n\tfn.attr = fn.data;\n\tfn.removeAttr = fn.removeData;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 41 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {};\n\t\n\tfunction defineDegreeFunction(callback) {\n\t  return function (includeLoops) {\n\t    var self = this;\n\t\n\t    if (includeLoops === undefined) {\n\t      includeLoops = true;\n\t    }\n\t\n\t    if (self.length === 0) {\n\t      return;\n\t    }\n\t\n\t    if (self.isNode() && !self.removed()) {\n\t      var degree = 0;\n\t      var node = self[0];\n\t      var connectedEdges = node._private.edges;\n\t\n\t      for (var i = 0; i < connectedEdges.length; i++) {\n\t        var edge = connectedEdges[i];\n\t\n\t        if (!includeLoops && edge.isLoop()) {\n\t          continue;\n\t        }\n\t\n\t        degree += callback(node, edge);\n\t      }\n\t\n\t      return degree;\n\t    } else {\n\t      return;\n\t    }\n\t  };\n\t}\n\t\n\tutil.extend(elesfn, {\n\t  degree: defineDegreeFunction(function (node, edge) {\n\t    if (edge.source().same(edge.target())) {\n\t      return 2;\n\t    } else {\n\t      return 1;\n\t    }\n\t  }),\n\t\n\t  indegree: defineDegreeFunction(function (node, edge) {\n\t    if (edge.target().same(node)) {\n\t      return 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }),\n\t\n\t  outdegree: defineDegreeFunction(function (node, edge) {\n\t    if (edge.source().same(node)) {\n\t      return 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  })\n\t});\n\t\n\tfunction defineDegreeBoundsFunction(degreeFn, callback) {\n\t  return function (includeLoops) {\n\t    var ret = void 0;\n\t    var nodes = this.nodes();\n\t\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      var ele = nodes[i];\n\t      var degree = ele[degreeFn](includeLoops);\n\t      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n\t        ret = degree;\n\t      }\n\t    }\n\t\n\t    return ret;\n\t  };\n\t}\n\t\n\tutil.extend(elesfn, {\n\t  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n\t    return degree < min;\n\t  }),\n\t\n\t  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n\t    return degree > max;\n\t  }),\n\t\n\t  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n\t    return degree < min;\n\t  }),\n\t\n\t  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n\t    return degree > max;\n\t  }),\n\t\n\t  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n\t    return degree < min;\n\t  }),\n\t\n\t  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n\t    return degree > max;\n\t  })\n\t});\n\t\n\tutil.extend(elesfn, {\n\t  totalDegree: function totalDegree(includeLoops) {\n\t    var total = 0;\n\t    var nodes = this.nodes();\n\t\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      total += nodes[i].degree(includeLoops);\n\t    }\n\t\n\t    return total;\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 42 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar fn = void 0,\n\t    elesfn = void 0;\n\t\n\tfn = elesfn = {};\n\t\n\telesfn.renderedBoundingBox = function (options) {\n\t  var bb = this.boundingBox(options);\n\t  var cy = this.cy();\n\t  var zoom = cy.zoom();\n\t  var pan = cy.pan();\n\t\n\t  var x1 = bb.x1 * zoom + pan.x;\n\t  var x2 = bb.x2 * zoom + pan.x;\n\t  var y1 = bb.y1 * zoom + pan.y;\n\t  var y2 = bb.y2 * zoom + pan.y;\n\t\n\t  return {\n\t    x1: x1,\n\t    x2: x2,\n\t    y1: y1,\n\t    y2: y2,\n\t    w: x2 - x1,\n\t    h: y2 - y1\n\t  };\n\t};\n\t\n\telesfn.dirtyCompoundBoundsCache = function () {\n\t  var cy = this.cy();\n\t\n\t  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n\t    return this;\n\t  }\n\t\n\t  this.forEachUp(function (ele) {\n\t    ele._private.compoundBoundsClean = false;\n\t\n\t    if (ele.isParent()) {\n\t      ele.emit('bounds');\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\telesfn.updateCompoundBounds = function () {\n\t  var cy = this.cy();\n\t\n\t  // save cycles for non compound graphs or when style disabled\n\t  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n\t    return this;\n\t  }\n\t\n\t  // save cycles when batching -- but bounds will be stale (or not exist yet)\n\t  if (cy.batching()) {\n\t    return this;\n\t  }\n\t\n\t  var updated = [];\n\t\n\t  function update(parent) {\n\t    if (!parent.isParent()) {\n\t      return;\n\t    }\n\t\n\t    var _p = parent._private;\n\t    var children = parent.children();\n\t    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n\t\n\t    var min = {\n\t      width: {\n\t        val: parent.pstyle('min-width').pfValue,\n\t        left: parent.pstyle('min-width-bias-left'),\n\t        right: parent.pstyle('min-width-bias-right')\n\t      },\n\t      height: {\n\t        val: parent.pstyle('min-height').pfValue,\n\t        top: parent.pstyle('min-height-bias-top'),\n\t        bottom: parent.pstyle('min-height-bias-bottom')\n\t      }\n\t    };\n\t\n\t    var bb = children.boundingBox({\n\t      includeLabels: includeLabels,\n\t      includeOverlays: false,\n\t\n\t      // updating the compound bounds happens outside of the regular\n\t      // cache cycle (i.e. before fired events)\n\t      useCache: false\n\t    });\n\t    var pos = _p.position;\n\t\n\t    // if children take up zero area then keep position and fall back on stylesheet w/h\n\t    if (bb.w === 0 || bb.h === 0) {\n\t      bb = {\n\t        w: parent.pstyle('width').pfValue,\n\t        h: parent.pstyle('height').pfValue\n\t      };\n\t\n\t      bb.x1 = pos.x - bb.w / 2;\n\t      bb.x2 = pos.x + bb.w / 2;\n\t      bb.y1 = pos.y - bb.h / 2;\n\t      bb.y2 = pos.y + bb.h / 2;\n\t    }\n\t\n\t    function computeBiasValues(propDiff, propBias, propBiasComplement) {\n\t      var biasDiff = 0;\n\t      var biasComplementDiff = 0;\n\t      var biasTotal = propBias + propBiasComplement;\n\t\n\t      if (propDiff > 0 && biasTotal > 0) {\n\t        biasDiff = propBias / biasTotal * propDiff;\n\t        biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n\t      }\n\t      return {\n\t        biasDiff: biasDiff,\n\t        biasComplementDiff: biasComplementDiff\n\t      };\n\t    }\n\t\n\t    function computePaddingValues(width, height, paddingObject, relativeTo) {\n\t      // Assuming percentage is number from 0 to 1\n\t      if (paddingObject.units === '%') {\n\t        switch (relativeTo) {\n\t          case 'width':\n\t            return width > 0 ? paddingObject.pfValue * width : 0;\n\t          case 'height':\n\t            return height > 0 ? paddingObject.pfValue * height : 0;\n\t          case 'average':\n\t            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n\t          case 'min':\n\t            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n\t          case 'max':\n\t            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n\t          default:\n\t            return 0;\n\t        }\n\t      } else if (paddingObject.units === 'px') {\n\t        return paddingObject.pfValue;\n\t      } else {\n\t        return 0;\n\t      }\n\t    }\n\t\n\t    var leftVal = min.width.left.value;\n\t    if (min.width.left.units === 'px' && min.width.val > 0) {\n\t      leftVal = leftVal * 100 / min.width.val;\n\t    }\n\t    var rightVal = min.width.right.value;\n\t    if (min.width.right.units === 'px' && min.width.val > 0) {\n\t      rightVal = rightVal * 100 / min.width.val;\n\t    }\n\t\n\t    var topVal = min.height.top.value;\n\t    if (min.height.top.units === 'px' && min.height.val > 0) {\n\t      topVal = topVal * 100 / min.height.val;\n\t    }\n\t\n\t    var bottomVal = min.height.bottom.value;\n\t    if (min.height.bottom.units === 'px' && min.height.val > 0) {\n\t      bottomVal = bottomVal * 100 / min.height.val;\n\t    }\n\t\n\t    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n\t    var diffLeft = widthBiasDiffs.biasDiff;\n\t    var diffRight = widthBiasDiffs.biasComplementDiff;\n\t\n\t    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n\t    var diffTop = heightBiasDiffs.biasDiff;\n\t    var diffBottom = heightBiasDiffs.biasComplementDiff;\n\t\n\t    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n\t\n\t    _p.autoWidth = Math.max(bb.w, min.width.val);\n\t    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n\t\n\t    _p.autoHeight = Math.max(bb.h, min.height.val);\n\t    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n\t\n\t    updated.push(parent);\n\t  }\n\t\n\t  for (var i = 0; i < this.length; i++) {\n\t    var ele = this[i];\n\t    var _p = ele._private;\n\t\n\t    if (!_p.compoundBoundsClean) {\n\t      update(ele);\n\t\n\t      if (!cy._private.batchingStyle) {\n\t        _p.compoundBoundsClean = true;\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tvar noninf = function noninf(x) {\n\t  if (x === Infinity || x === -Infinity) {\n\t    return 0;\n\t  }\n\t\n\t  return x;\n\t};\n\t\n\tvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n\t  // don't update with zero area boxes\n\t  if (x2 - x1 === 0 || y2 - y1 === 0) {\n\t    return;\n\t  }\n\t\n\t  // don't update with null dim\n\t  if (x1 == null || y1 == null || x2 == null || y2 == null) {\n\t    return;\n\t  }\n\t\n\t  b.x1 = x1 < b.x1 ? x1 : b.x1;\n\t  b.x2 = x2 > b.x2 ? x2 : b.x2;\n\t  b.y1 = y1 < b.y1 ? y1 : b.y1;\n\t  b.y2 = y2 > b.y2 ? y2 : b.y2;\n\t};\n\t\n\tvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n\t  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n\t};\n\t\n\tvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n\t  return util.getPrefixedProperty(obj, field, prefix);\n\t};\n\t\n\tvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n\t  if (ele.cy().headless()) {\n\t    return;\n\t  }\n\t\n\t  var _p = ele._private;\n\t  var rstyle = _p.rstyle;\n\t  var halfArW = rstyle.arrowWidth / 2;\n\t  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n\t  var x = void 0;\n\t  var y = void 0;\n\t\n\t  if (arrowType !== 'none') {\n\t    if (prefix === 'source') {\n\t      x = rstyle.srcX;\n\t      y = rstyle.srcY;\n\t    } else if (prefix === 'target') {\n\t      x = rstyle.tgtX;\n\t      y = rstyle.tgtY;\n\t    } else {\n\t      x = rstyle.midX;\n\t      y = rstyle.midY;\n\t    }\n\t\n\t    updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);\n\t  }\n\t};\n\t\n\tvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n\t  if (ele.cy().headless()) {\n\t    return;\n\t  }\n\t\n\t  var prefixDash = void 0;\n\t\n\t  if (prefix) {\n\t    prefixDash = prefix + '-';\n\t  } else {\n\t    prefixDash = '';\n\t  }\n\t\n\t  var _p = ele._private;\n\t  var rstyle = _p.rstyle;\n\t  var label = ele.pstyle(prefixDash + 'label').strValue;\n\t\n\t  if (label) {\n\t    var halign = ele.pstyle('text-halign');\n\t    var valign = ele.pstyle('text-valign');\n\t    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n\t    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n\t    var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n\t    var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n\t    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n\t    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n\t    var isEdge = ele.isEdge();\n\t    var rotation = ele.pstyle(prefixDash + 'text-rotation');\n\t    var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n\t    var borderWidth = ele.pstyle('text-border-width').pfValue;\n\t    var halfBorderWidth = borderWidth / 2;\n\t    var padding = ele.pstyle('text-background-padding').pfValue;\n\t\n\t    var lh = labelHeight + 2 * padding;\n\t    var lw = labelWidth + 2 * padding;\n\t    var lw_2 = lw / 2;\n\t    var lh_2 = lh / 2;\n\t    var lx1 = void 0,\n\t        lx2 = void 0,\n\t        ly1 = void 0,\n\t        ly2 = void 0;\n\t\n\t    if (isEdge) {\n\t      lx1 = labelX - lw_2;\n\t      lx2 = labelX + lw_2;\n\t      ly1 = labelY - lh_2;\n\t      ly2 = labelY + lh_2;\n\t    } else {\n\t      switch (halign.value) {\n\t        case 'left':\n\t          lx1 = labelX - lw;\n\t          lx2 = labelX;\n\t          break;\n\t\n\t        case 'center':\n\t          lx1 = labelX - lw_2;\n\t          lx2 = labelX + lw_2;\n\t          break;\n\t\n\t        case 'right':\n\t          lx1 = labelX;\n\t          lx2 = labelX + lw;\n\t          break;\n\t      }\n\t\n\t      switch (valign.value) {\n\t        case 'top':\n\t          ly1 = labelY - lh;\n\t          ly2 = labelY;\n\t          break;\n\t\n\t        case 'center':\n\t          ly1 = labelY - lh_2;\n\t          ly2 = labelY + lh_2;\n\t          break;\n\t\n\t        case 'bottom':\n\t          ly1 = labelY;\n\t          ly2 = labelY + lh;\n\t          break;\n\t      }\n\t    }\n\t\n\t    var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n\t    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n\t\n\t    if (isAutorotate || isPfValue) {\n\t      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n\t      var cos = Math.cos(theta);\n\t      var sin = Math.sin(theta);\n\t\n\t      var rotate = function rotate(x, y) {\n\t        x = x - labelX;\n\t        y = y - labelY;\n\t\n\t        return {\n\t          x: x * cos - y * sin + labelX,\n\t          y: x * sin + y * cos + labelY\n\t        };\n\t      };\n\t\n\t      var px1y1 = rotate(lx1, ly1);\n\t      var px1y2 = rotate(lx1, ly2);\n\t      var px2y1 = rotate(lx2, ly1);\n\t      var px2y2 = rotate(lx2, ly2);\n\t\n\t      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n\t      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n\t      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n\t      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n\t    }\n\t\n\t    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);\n\t    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);\n\t    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);\n\t    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);\n\t\n\t    updateBounds(bounds, lx1, ly1, lx2, ly2);\n\t  }\n\t\n\t  return bounds;\n\t};\n\t\n\t// get the bounding box of the elements (in raw model position)\n\tvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n\t  var cy = ele._private.cy;\n\t  var styleEnabled = cy.styleEnabled();\n\t  var headless = cy.headless();\n\t\n\t  var bounds = {\n\t    x1: Infinity,\n\t    y1: Infinity,\n\t    x2: -Infinity,\n\t    y2: -Infinity\n\t  };\n\t\n\t  var _p = ele._private;\n\t  var display = styleEnabled ? ele.pstyle('display').value : 'element';\n\t  var isNode = ele.isNode();\n\t  var isEdge = ele.isEdge();\n\t  var ex1 = void 0,\n\t      ex2 = void 0,\n\t      ey1 = void 0,\n\t      ey2 = void 0; // extrema of body / lines\n\t  var x = void 0,\n\t      y = void 0; // node pos\n\t  var displayed = display !== 'none';\n\t\n\t  if (displayed) {\n\t    var overlayOpacity = 0;\n\t    var overlayPadding = 0;\n\t\n\t    if (styleEnabled && options.includeOverlays) {\n\t      overlayOpacity = ele.pstyle('overlay-opacity').value;\n\t\n\t      if (overlayOpacity !== 0) {\n\t        overlayPadding = ele.pstyle('overlay-padding').value;\n\t      }\n\t    }\n\t\n\t    var w = 0;\n\t    var wHalf = 0;\n\t\n\t    if (styleEnabled) {\n\t      w = ele.pstyle('width').pfValue;\n\t      wHalf = w / 2;\n\t    }\n\t\n\t    if (isNode && options.includeNodes) {\n\t      var pos = ele.position();\n\t      x = pos.x;\n\t      y = pos.y;\n\t      var _w = ele.outerWidth();\n\t      var halfW = _w / 2;\n\t      var h = ele.outerHeight();\n\t      var halfH = h / 2;\n\t\n\t      // handle node dimensions\n\t      /////////////////////////\n\t\n\t      ex1 = x - halfW - overlayPadding;\n\t      ex2 = x + halfW + overlayPadding;\n\t      ey1 = y - halfH - overlayPadding;\n\t      ey2 = y + halfH + overlayPadding;\n\t\n\t      updateBounds(bounds, ex1, ey1, ex2, ey2);\n\t    } else if (isEdge && options.includeEdges) {\n\t      var rstyle = _p.rstyle || {};\n\t\n\t      // handle edge dimensions (rough box estimate)\n\t      //////////////////////////////////////////////\n\t      if (styleEnabled && !headless) {\n\t        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n\t        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n\t        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n\t        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n\t\n\t        // take into account edge width\n\t        ex1 -= wHalf;\n\t        ex2 += wHalf;\n\t        ey1 -= wHalf;\n\t        ey2 += wHalf;\n\t\n\t        updateBounds(bounds, ex1, ey1, ex2, ey2);\n\t      }\n\t\n\t      // precise haystacks\n\t      ////////////////////\n\t      if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {\n\t        var hpts = rstyle.haystackPts || [];\n\t\n\t        ex1 = hpts[0].x;\n\t        ey1 = hpts[0].y;\n\t        ex2 = hpts[1].x;\n\t        ey2 = hpts[1].y;\n\t\n\t        if (ex1 > ex2) {\n\t          var temp = ex1;\n\t          ex1 = ex2;\n\t          ex2 = temp;\n\t        }\n\t\n\t        if (ey1 > ey2) {\n\t          var _temp = ey1;\n\t          ey1 = ey2;\n\t          ey2 = _temp;\n\t        }\n\t\n\t        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n\t\n\t        // handle points along edge\n\t        ///////////////////////////\n\t      } else {\n\t        var pts = rstyle.bezierPts || rstyle.linePts || [];\n\t\n\t        for (var j = 0; j < pts.length; j++) {\n\t          var pt = pts[j];\n\t\n\t          ex1 = pt.x - wHalf;\n\t          ex2 = pt.x + wHalf;\n\t          ey1 = pt.y - wHalf;\n\t          ey2 = pt.y + wHalf;\n\t\n\t          updateBounds(bounds, ex1, ey1, ex2, ey2);\n\t        }\n\t\n\t        // fallback on source and target positions\n\t        //////////////////////////////////////////\n\t        if (pts.length === 0) {\n\t          var n1 = ele.source();\n\t          var n1pos = n1.position();\n\t\n\t          var n2 = ele.target();\n\t          var n2pos = n2.position();\n\t\n\t          ex1 = n1pos.x;\n\t          ex2 = n2pos.x;\n\t          ey1 = n1pos.y;\n\t          ey2 = n2pos.y;\n\t\n\t          if (ex1 > ex2) {\n\t            var _temp2 = ex1;\n\t            ex1 = ex2;\n\t            ex2 = _temp2;\n\t          }\n\t\n\t          if (ey1 > ey2) {\n\t            var _temp3 = ey1;\n\t            ey1 = ey2;\n\t            ey2 = _temp3;\n\t          }\n\t\n\t          // take into account edge width\n\t          ex1 -= wHalf;\n\t          ex2 += wHalf;\n\t          ey1 -= wHalf;\n\t          ey2 += wHalf;\n\t\n\t          updateBounds(bounds, ex1, ey1, ex2, ey2);\n\t        }\n\t      }\n\t    } // edges\n\t\n\t\n\t    // handle edge arrow size\n\t    /////////////////////////\n\t\n\t    if (styleEnabled && options.includeEdges && isEdge) {\n\t      updateBoundsFromArrow(bounds, ele, 'mid-source', options);\n\t      updateBoundsFromArrow(bounds, ele, 'mid-target', options);\n\t      updateBoundsFromArrow(bounds, ele, 'source', options);\n\t      updateBoundsFromArrow(bounds, ele, 'target', options);\n\t    }\n\t\n\t    // ghost\n\t    ////////\n\t\n\t    if (styleEnabled) {\n\t      var ghost = ele.pstyle('ghost').value === 'yes';\n\t\n\t      if (ghost) {\n\t        var gx = ele.pstyle('ghost-offset-x').pfValue;\n\t        var gy = ele.pstyle('ghost-offset-y').pfValue;\n\t\n\t        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n\t      }\n\t    }\n\t\n\t    // overlay\n\t    //////////\n\t\n\t    if (styleEnabled) {\n\t\n\t      ex1 = bounds.x1;\n\t      ex2 = bounds.x2;\n\t      ey1 = bounds.y1;\n\t      ey2 = bounds.y2;\n\t\n\t      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);\n\t    }\n\t\n\t    // handle label dimensions\n\t    //////////////////////////\n\t\n\t    if (styleEnabled && options.includeLabels) {\n\t      updateBoundsFromLabel(bounds, ele, null, options);\n\t\n\t      if (isEdge) {\n\t        updateBoundsFromLabel(bounds, ele, 'source', options);\n\t        updateBoundsFromLabel(bounds, ele, 'target', options);\n\t      }\n\t    } // style enabled for labels\n\t  } // if displayed\n\t\n\t  bounds.x1 = noninf(bounds.x1);\n\t  bounds.y1 = noninf(bounds.y1);\n\t  bounds.x2 = noninf(bounds.x2);\n\t  bounds.y2 = noninf(bounds.y2);\n\t  bounds.w = noninf(bounds.x2 - bounds.x1);\n\t  bounds.h = noninf(bounds.y2 - bounds.y1);\n\t\n\t  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n\t  if (bounds.w > 0 && bounds.h > 0 && displayed) {\n\t    math.expandBoundingBox(bounds, 1);\n\t  }\n\t\n\t  return bounds;\n\t};\n\t\n\tvar tf = function tf(val) {\n\t  if (val) {\n\t    return 't';\n\t  } else {\n\t    return 'f';\n\t  }\n\t};\n\t\n\tvar getKey = function getKey(opts) {\n\t  var key = '';\n\t\n\t  key += tf(opts.incudeNodes);\n\t  key += tf(opts.includeEdges);\n\t  key += tf(opts.includeLabels);\n\t  key += tf(opts.includeOverlays);\n\t\n\t  return key;\n\t};\n\t\n\tvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n\t  var _p = ele._private;\n\t  var bb = void 0;\n\t  var headless = ele.cy().headless();\n\t  var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);\n\t\n\t  if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {\n\t    bb = boundingBoxImpl(ele, opts);\n\t\n\t    if (!headless) {\n\t      _p.bbCache = _p.bbCache || {};\n\t      _p.bbCache[key] = bb;\n\t    }\n\t  } else {\n\t    bb = _p.bbCache[key];\n\t  }\n\t\n\t  return bb;\n\t};\n\t\n\tvar defBbOpts = {\n\t  includeNodes: true,\n\t  includeEdges: true,\n\t  includeLabels: true,\n\t  includeOverlays: true,\n\t  useCache: true\n\t};\n\t\n\tvar defBbOptsKey = getKey(defBbOpts);\n\t\n\tfunction filledBbOpts(options) {\n\t  return {\n\t    includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),\n\t    includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),\n\t    includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),\n\t    includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),\n\t    useCache: util.default(options.useCache, defBbOpts.useCache)\n\t  };\n\t}\n\t\n\telesfn.boundingBox = function (options) {\n\t  // the main usecase is ele.boundingBox() for a single element with no/def options\n\t  // specified s.t. the cache is used, so check for this case to make it faster by\n\t  // avoiding the overhead of the rest of the function\n\t  if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n\t    if (options === undefined) {\n\t      options = defBbOpts;\n\t    } else {\n\t      options = filledBbOpts(options);\n\t    }\n\t\n\t    return cachedBoundingBoxImpl(this[0], options);\n\t  }\n\t\n\t  var bounds = {\n\t    x1: Infinity,\n\t    y1: Infinity,\n\t    x2: -Infinity,\n\t    y2: -Infinity\n\t  };\n\t\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var opts = filledBbOpts(options);\n\t\n\t  var eles = this;\n\t  var cy = eles.cy();\n\t  var styleEnabled = cy.styleEnabled();\n\t\n\t  if (styleEnabled) {\n\t    this.recalculateRenderedStyle(opts.useCache);\n\t  }\n\t\n\t  this.updateCompoundBounds();\n\t\n\t  var updatedEdge = {}; // use to avoid duplicated edge updates\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {\n\t      var edges = ele.parallelEdges();\n\t\n\t      for (var j = 0; j < edges.length; j++) {\n\t        // make all as updated\n\t        updatedEdge[edges[j].id()] = true;\n\t      }\n\t\n\t      edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached\n\t    }\n\t\n\t    updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));\n\t  }\n\t\n\t  bounds.x1 = noninf(bounds.x1);\n\t  bounds.y1 = noninf(bounds.y1);\n\t  bounds.x2 = noninf(bounds.x2);\n\t  bounds.y2 = noninf(bounds.y2);\n\t  bounds.w = noninf(bounds.x2 - bounds.x1);\n\t  bounds.h = noninf(bounds.y2 - bounds.y1);\n\t\n\t  return bounds;\n\t};\n\t\n\t// private helper to get bounding box for custom node positions\n\t// - good for perf in certain cases but currently requires dirtying the rendered style\n\t// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n\t// - try to use for only things like discrete layouts where the node position would change anyway\n\telesfn.boundingBoxAt = function (fn) {\n\t  var nodes = this.nodes();\n\t\n\t  if (is.plainObject(fn)) {\n\t    var obj = fn;\n\t\n\t    fn = function fn() {\n\t      return obj;\n\t    };\n\t  }\n\t\n\t  // save the current position and set the new one, per node\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    var n = nodes[i];\n\t    var _p = n._private;\n\t    var pos = _p.position;\n\t    var newPos = fn.call(n, n, i);\n\t\n\t    _p.bbAtOldPos = { x: pos.x, y: pos.y };\n\t\n\t    if (newPos) {\n\t      pos.x = newPos.x;\n\t      pos.y = newPos.y;\n\t    }\n\t  }\n\t\n\t  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs\n\t\n\t  nodes.dirtyCompoundBoundsCache().updateCompoundBounds();\n\t\n\t  var bb = this.boundingBox({ useCache: false });\n\t\n\t  // restore the original position, per node\n\t  for (var _i = 0; _i < nodes.length; _i++) {\n\t    var _n = nodes[_i];\n\t    var _p2 = _n._private;\n\t    var _pos = _n._private.position;\n\t    var old = _p2.bbAtOldPos;\n\t\n\t    _pos.x = old.x;\n\t    _pos.y = old.y;\n\t  }\n\t\n\t  nodes.dirtyCompoundBoundsCache();\n\t\n\t  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs\n\t\n\t  return bb;\n\t};\n\t\n\tfn.boundingbox = fn.boundingBox;\n\tfn.renderedBoundingbox = fn.renderedBoundingBox;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 43 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar ifEdge = function ifEdge(self, then) {\n\t  if (self.isEdge()) {\n\t    return then(self.renderer());\n\t  }\n\t};\n\t\n\tmodule.exports = {\n\t  controlPoints: function controlPoints() {\n\t    var _this = this;\n\t\n\t    return ifEdge(this, function (renderer) {\n\t      return renderer.getControlPoints(_this);\n\t    });\n\t  },\n\t  segmentPoints: function segmentPoints() {\n\t    var _this2 = this;\n\t\n\t    return ifEdge(this, function (renderer) {\n\t      return renderer.getSegmentPoints(_this2);\n\t    });\n\t  },\n\t  sourceEndpoint: function sourceEndpoint() {\n\t    var _this3 = this;\n\t\n\t    return ifEdge(this, function (renderer) {\n\t      return renderer.getSourceEndpoint(_this3);\n\t    });\n\t  },\n\t  targetEndpoint: function targetEndpoint() {\n\t    var _this4 = this;\n\t\n\t    return ifEdge(this, function (renderer) {\n\t      return renderer.getTargetEndpoint(_this4);\n\t    });\n\t  },\n\t  midpoint: function midpoint() {\n\t    var _this5 = this;\n\t\n\t    return ifEdge(this, function (renderer) {\n\t      return renderer.getEdgeMidpoint(_this5);\n\t    });\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 44 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar position = __webpack_require__(45);\n\tvar bounds = __webpack_require__(42);\n\tvar widthHeight = __webpack_require__(46);\n\tvar edgePoints = __webpack_require__(43);\n\t\n\tmodule.exports = util.assign({}, position, bounds, widthHeight, edgePoints);\n\t\n\t/***/ }),\n\t/* 45 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar define = __webpack_require__(3);\n\tvar is = __webpack_require__(0);\n\tvar math = __webpack_require__(2);\n\tvar fn = void 0,\n\t    elesfn = void 0;\n\t\n\tvar beforePositionSet = function beforePositionSet(eles, newPos) {\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    if (ele.isParent() && !ele.locked()) {\n\t      var oldPos = ele._private.position;\n\t      var delta = {\n\t        x: newPos.x - oldPos.x,\n\t        y: newPos.y - oldPos.y\n\t      };\n\t\n\t      eles.children().shift(delta);\n\t    }\n\t  }\n\t};\n\t\n\tfn = elesfn = {\n\t\n\t  position: define.data({\n\t    field: 'position',\n\t    bindingEvent: 'position',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'position',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'emitAndNotify',\n\t    allowGetting: true,\n\t    validKeys: ['x', 'y'],\n\t    beforeGet: function beforeGet(ele) {\n\t      ele.updateCompoundBounds();\n\t    },\n\t    beforeSet: beforePositionSet,\n\t    onSet: function onSet(eles) {\n\t      eles.dirtyCompoundBoundsCache();\n\t    },\n\t    canSet: function canSet(ele) {\n\t      return !ele.locked();\n\t    }\n\t  }),\n\t\n\t  // position but no notification to renderer\n\t  silentPosition: define.data({\n\t    field: 'position',\n\t    bindingEvent: 'position',\n\t    allowBinding: false,\n\t    allowSetting: true,\n\t    settingEvent: 'position',\n\t    settingTriggersEvent: false,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: false,\n\t    validKeys: ['x', 'y'],\n\t    beforeSet: beforePositionSet,\n\t    onSet: function onSet(eles) {\n\t      eles.dirtyCompoundBoundsCache();\n\t    },\n\t    canSet: function canSet(ele) {\n\t      return !ele.locked();\n\t    }\n\t  }),\n\t\n\t  positions: function positions(pos, silent) {\n\t    if (is.plainObject(pos)) {\n\t      if (silent) {\n\t        this.silentPosition(pos);\n\t      } else {\n\t        this.position(pos);\n\t      }\n\t    } else if (is.fn(pos)) {\n\t      var _fn = pos;\n\t      var cy = this.cy();\n\t\n\t      cy.startBatch();\n\t\n\t      for (var i = 0; i < this.length; i++) {\n\t        var ele = this[i];\n\t        var _pos = void 0;\n\t\n\t        if (_pos = _fn(ele, i)) {\n\t          if (silent) {\n\t            ele.silentPosition(_pos);\n\t          } else {\n\t            ele.position(_pos);\n\t          }\n\t        }\n\t      }\n\t\n\t      cy.endBatch();\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  silentPositions: function silentPositions(pos) {\n\t    return this.positions(pos, true);\n\t  },\n\t\n\t  shift: function shift(dim, val) {\n\t    var delta = void 0;\n\t\n\t    if (is.plainObject(dim)) {\n\t      delta = dim;\n\t    } else if (is.string(dim) && is.number(val)) {\n\t      delta = { x: 0, y: 0 };\n\t\n\t      delta[dim] = val;\n\t    }\n\t\n\t    if (delta != null) {\n\t      for (var i = 0; i < this.length; i++) {\n\t        var ele = this[i];\n\t        var pos = ele.position();\n\t\n\t        ele.position({\n\t          x: pos.x + delta.x,\n\t          y: pos.y + delta.y\n\t        });\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  // get/set the rendered (i.e. on screen) positon of the element\n\t  renderedPosition: function renderedPosition(dim, val) {\n\t    var ele = this[0];\n\t    var cy = this.cy();\n\t    var zoom = cy.zoom();\n\t    var pan = cy.pan();\n\t    var rpos = is.plainObject(dim) ? dim : undefined;\n\t    var setting = rpos !== undefined || val !== undefined && is.string(dim);\n\t\n\t    if (ele && ele.isNode()) {\n\t      // must have an element and must be a node to return position\n\t      if (setting) {\n\t        for (var i = 0; i < this.length; i++) {\n\t          var _ele = this[i];\n\t\n\t          if (val !== undefined) {\n\t            // set one dimension\n\t            _ele.position(dim, (val - pan[dim]) / zoom);\n\t          } else if (rpos !== undefined) {\n\t            // set whole position\n\t            _ele.position(math.renderedToModelPosition(rpos, zoom, pan));\n\t          }\n\t        }\n\t      } else {\n\t        // getting\n\t        var pos = ele.position();\n\t        rpos = math.modelToRenderedPosition(pos, zoom, pan);\n\t\n\t        if (dim === undefined) {\n\t          // then return the whole rendered position\n\t          return rpos;\n\t        } else {\n\t          // then return the specified dimension\n\t          return rpos[dim];\n\t        }\n\t      }\n\t    } else if (!setting) {\n\t      return undefined; // for empty collection case\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // get/set the position relative to the parent\n\t  relativePosition: function relativePosition(dim, val) {\n\t    var ele = this[0];\n\t    var cy = this.cy();\n\t    var ppos = is.plainObject(dim) ? dim : undefined;\n\t    var setting = ppos !== undefined || val !== undefined && is.string(dim);\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t\n\t    if (ele && ele.isNode()) {\n\t      // must have an element and must be a node to return position\n\t      if (setting) {\n\t        for (var i = 0; i < this.length; i++) {\n\t          var _ele2 = this[i];\n\t          var parent = hasCompoundNodes ? _ele2.parent() : null;\n\t          var hasParent = parent && parent.length > 0;\n\t          var relativeToParent = hasParent;\n\t\n\t          if (hasParent) {\n\t            parent = parent[0];\n\t          }\n\t\n\t          var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };\n\t\n\t          if (val !== undefined) {\n\t            // set one dimension\n\t            _ele2.position(dim, val + origin[dim]);\n\t          } else if (ppos !== undefined) {\n\t            // set whole position\n\t            _ele2.position({\n\t              x: ppos.x + origin.x,\n\t              y: ppos.y + origin.y\n\t            });\n\t          }\n\t        }\n\t      } else {\n\t        // getting\n\t        var pos = ele.position();\n\t        var _parent = hasCompoundNodes ? ele.parent() : null;\n\t        var _hasParent = _parent && _parent.length > 0;\n\t        var _relativeToParent = _hasParent;\n\t\n\t        if (_hasParent) {\n\t          _parent = _parent[0];\n\t        }\n\t\n\t        var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };\n\t\n\t        ppos = {\n\t          x: pos.x - _origin.x,\n\t          y: pos.y - _origin.y\n\t        };\n\t\n\t        if (dim === undefined) {\n\t          // then return the whole rendered position\n\t          return ppos;\n\t        } else {\n\t          // then return the specified dimension\n\t          return ppos[dim];\n\t        }\n\t      }\n\t    } else if (!setting) {\n\t      return undefined; // for empty collection case\n\t    }\n\t\n\t    return this; // chaining\n\t  }\n\t};\n\t\n\t// aliases\n\tfn.modelPosition = fn.point = fn.position;\n\tfn.modelPositions = fn.points = fn.positions;\n\tfn.renderedPoint = fn.renderedPosition;\n\tfn.relativePoint = fn.relativePosition;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 46 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar fn = void 0,\n\t    elesfn = void 0;\n\t\n\tfn = elesfn = {};\n\t\n\tvar defineDimFns = function defineDimFns(opts) {\n\t  opts.uppercaseName = util.capitalize(opts.name);\n\t  opts.autoName = 'auto' + opts.uppercaseName;\n\t  opts.labelName = 'label' + opts.uppercaseName;\n\t  opts.outerName = 'outer' + opts.uppercaseName;\n\t  opts.uppercaseOuterName = util.capitalize(opts.outerName);\n\t\n\t  fn[opts.name] = function dimImpl() {\n\t    var ele = this[0];\n\t    var _p = ele._private;\n\t    var cy = _p.cy;\n\t    var styleEnabled = cy._private.styleEnabled;\n\t\n\t    if (ele) {\n\t      if (styleEnabled) {\n\t        if (ele.isParent()) {\n\t          ele.updateCompoundBounds();\n\t\n\t          return _p[opts.autoName] || 0;\n\t        }\n\t\n\t        var d = ele.pstyle(opts.name);\n\t\n\t        switch (d.strValue) {\n\t          case 'label':\n\t            ele.recalculateRenderedStyle();\n\t\n\t            return _p.rstyle[opts.labelName] || 0;\n\t\n\t          default:\n\t            return d.pfValue;\n\t        }\n\t      } else {\n\t        return 1;\n\t      }\n\t    }\n\t  };\n\t\n\t  fn['outer' + opts.uppercaseName] = function outerDimImpl() {\n\t    var ele = this[0];\n\t    var _p = ele._private;\n\t    var cy = _p.cy;\n\t    var styleEnabled = cy._private.styleEnabled;\n\t\n\t    if (ele) {\n\t      if (styleEnabled) {\n\t        var dim = ele[opts.name]();\n\t        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n\t        var padding = 2 * ele.padding();\n\t\n\t        return dim + border + padding;\n\t      } else {\n\t        return 1;\n\t      }\n\t    }\n\t  };\n\t\n\t  fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      var d = ele[opts.name]();\n\t      return d * this.cy().zoom();\n\t    }\n\t  };\n\t\n\t  fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      var od = ele[opts.outerName]();\n\t      return od * this.cy().zoom();\n\t    }\n\t  };\n\t};\n\t\n\tdefineDimFns({\n\t  name: 'width'\n\t});\n\t\n\tdefineDimFns({\n\t  name: 'height'\n\t});\n\t\n\telesfn.padding = function () {\n\t  var ele = this[0];\n\t  var _p = ele._private;\n\t  if (ele.isParent()) {\n\t    ele.updateCompoundBounds();\n\t\n\t    if (_p.autoPadding !== undefined) {\n\t      return _p.autoPadding;\n\t    } else {\n\t      return ele.pstyle('padding').pfValue;\n\t    }\n\t  } else {\n\t    return ele.pstyle('padding').pfValue;\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 47 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar Emitter = __webpack_require__(10);\n\tvar define = __webpack_require__(3);\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar emitterOptions = {\n\t  qualifierCompare: function qualifierCompare(selector1, selector2) {\n\t    if (selector1 == null || selector2 == null) {\n\t      return selector1 == null && selector2 == null;\n\t    } else {\n\t      return selector1.sameText(selector2);\n\t    }\n\t  },\n\t  eventMatches: function eventMatches(ele, listener, eventObj) {\n\t    var selector = listener.qualifier;\n\t\n\t    if (selector != null) {\n\t      return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);\n\t    }\n\t\n\t    return true;\n\t  },\n\t  eventFields: function eventFields(ele) {\n\t    return {\n\t      cy: ele.cy(),\n\t      target: ele\n\t    };\n\t  },\n\t  callbackContext: function callbackContext(ele, listener, eventObj) {\n\t    return listener.qualifier != null ? eventObj.target : ele;\n\t  },\n\t  beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {\n\t    if (listener.conf && listener.conf.once) {\n\t      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n\t    }\n\t  },\n\t  bubble: function bubble() {\n\t    return true;\n\t  },\n\t  parent: function parent(ele) {\n\t    return ele.isChild() ? ele.parent() : ele.cy();\n\t  }\n\t};\n\t\n\tvar argSelector = function argSelector(arg) {\n\t  if (is.string(arg)) {\n\t    return new Selector(arg);\n\t  } else {\n\t    return arg;\n\t  }\n\t};\n\t\n\tvar elesfn = {\n\t  createEmitter: function createEmitter() {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t      var _p = ele._private;\n\t\n\t      if (!_p.emitter) {\n\t        _p.emitter = new Emitter(util.assign({\n\t          context: ele\n\t        }, emitterOptions));\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  emitter: function emitter() {\n\t    return this._private.emitter;\n\t  },\n\t\n\t  on: function on(events, selector, callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t\n\t      ele.emitter().on(events, argSelector(selector), callback);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  removeListener: function removeListener(events, selector, callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t\n\t      ele.emitter().removeListener(events, argSelector(selector), callback);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  one: function one(events, selector, callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t\n\t      ele.emitter().one(events, argSelector(selector), callback);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  once: function once(events, selector, callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t\n\t      ele.emitter().on(events, argSelector(selector), callback, {\n\t        once: true,\n\t        onceCollection: this\n\t      });\n\t    }\n\t  },\n\t\n\t  emit: function emit(events, extraParams) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t\n\t      ele.emitter().emit(events, extraParams);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  emitAndNotify: function emitAndNotify(event, extraParams) {\n\t    // for internal use only\n\t    if (this.length === 0) {\n\t      return;\n\t    } // empty collections don't need to notify anything\n\t\n\t    // notify renderer\n\t    this.cy().notify({\n\t      type: event,\n\t      eles: this\n\t    });\n\t\n\t    this.emit(event, extraParams);\n\t\n\t    return this;\n\t  }\n\t};\n\t\n\tdefine.eventAliasesOn(elesfn);\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 48 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar elesfn = {\n\t  nodes: function nodes(selector) {\n\t    return this.filter(function (ele) {\n\t      return ele.isNode();\n\t    }).filter(selector);\n\t  },\n\t\n\t  edges: function edges(selector) {\n\t    return this.filter(function (ele) {\n\t      return ele.isEdge();\n\t    }).filter(selector);\n\t  },\n\t\n\t  filter: function filter(_filter, thisArg) {\n\t    if (_filter === undefined) {\n\t      // check this first b/c it's the most common/performant case\n\t      return this;\n\t    } else if (is.string(_filter) || is.elementOrCollection(_filter)) {\n\t      return new Selector(_filter).filter(this);\n\t    } else if (is.fn(_filter)) {\n\t      var filterEles = this.spawn();\n\t      var eles = this;\n\t\n\t      for (var i = 0; i < eles.length; i++) {\n\t        var ele = eles[i];\n\t        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\t\n\t        if (include) {\n\t          filterEles.merge(ele);\n\t        }\n\t      }\n\t\n\t      return filterEles;\n\t    }\n\t\n\t    return this.spawn(); // if not handled by above, give 'em an empty collection\n\t  },\n\t\n\t  not: function not(toRemove) {\n\t    if (!toRemove) {\n\t      return this;\n\t    } else {\n\t\n\t      if (is.string(toRemove)) {\n\t        toRemove = this.filter(toRemove);\n\t      }\n\t\n\t      var elements = [];\n\t      var rMap = toRemove._private.map;\n\t\n\t      for (var i = 0; i < this.length; i++) {\n\t        var element = this[i];\n\t\n\t        var remove = rMap.has(element.id());\n\t        if (!remove) {\n\t          elements.push(element);\n\t        }\n\t      }\n\t\n\t      return this.spawn(elements);\n\t    }\n\t  },\n\t\n\t  absoluteComplement: function absoluteComplement() {\n\t    var cy = this.cy();\n\t\n\t    return cy.mutableElements().not(this);\n\t  },\n\t\n\t  intersect: function intersect(other) {\n\t    // if a selector is specified, then filter by it instead\n\t    if (is.string(other)) {\n\t      var selector = other;\n\t      return this.filter(selector);\n\t    }\n\t\n\t    var elements = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t    var col1Smaller = this.length < other.length;\n\t    var map2 = col1Smaller ? col2._private.map : col1._private.map;\n\t    var col = col1Smaller ? col1 : col2;\n\t\n\t    for (var i = 0; i < col.length; i++) {\n\t      var id = col[i]._private.data.id;\n\t      var entry = map2.get(id);\n\t\n\t      if (entry) {\n\t        elements.push(entry.ele);\n\t      }\n\t    }\n\t\n\t    return this.spawn(elements);\n\t  },\n\t\n\t  xor: function xor(other) {\n\t    var cy = this._private.cy;\n\t\n\t    if (is.string(other)) {\n\t      other = cy.$(other);\n\t    }\n\t\n\t    var elements = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t\n\t    var add = function add(col, other) {\n\t      for (var i = 0; i < col.length; i++) {\n\t        var ele = col[i];\n\t        var id = ele._private.data.id;\n\t        var inOther = other.hasElementWithId(id);\n\t\n\t        if (!inOther) {\n\t          elements.push(ele);\n\t        }\n\t      }\n\t    };\n\t\n\t    add(col1, col2);\n\t    add(col2, col1);\n\t\n\t    return this.spawn(elements);\n\t  },\n\t\n\t  diff: function diff(other) {\n\t    var cy = this._private.cy;\n\t\n\t    if (is.string(other)) {\n\t      other = cy.$(other);\n\t    }\n\t\n\t    var left = [];\n\t    var right = [];\n\t    var both = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t\n\t    var add = function add(col, other, retEles) {\n\t\n\t      for (var i = 0; i < col.length; i++) {\n\t        var ele = col[i];\n\t        var id = ele._private.data.id;\n\t        var inOther = other.hasElementWithId(id);\n\t\n\t        if (inOther) {\n\t          both.push(ele);\n\t        } else {\n\t          retEles.push(ele);\n\t        }\n\t      }\n\t    };\n\t\n\t    add(col1, col2, left);\n\t    add(col2, col1, right);\n\t\n\t    return {\n\t      left: this.spawn(left, { unique: true }),\n\t      right: this.spawn(right, { unique: true }),\n\t      both: this.spawn(both, { unique: true })\n\t    };\n\t  },\n\t\n\t  add: function add(toAdd) {\n\t    var cy = this._private.cy;\n\t\n\t    if (!toAdd) {\n\t      return this;\n\t    }\n\t\n\t    if (is.string(toAdd)) {\n\t      var selector = toAdd;\n\t      toAdd = cy.mutableElements().filter(selector);\n\t    }\n\t\n\t    var elements = [];\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      elements.push(this[i]);\n\t    }\n\t\n\t    var map = this._private.map;\n\t\n\t    for (var _i = 0; _i < toAdd.length; _i++) {\n\t\n\t      var add = !map.has(toAdd[_i].id());\n\t      if (add) {\n\t        elements.push(toAdd[_i]);\n\t      }\n\t    }\n\t\n\t    return this.spawn(elements);\n\t  },\n\t\n\t  // in place merge on calling collection\n\t  merge: function merge(toAdd) {\n\t    var _p = this._private;\n\t    var cy = _p.cy;\n\t\n\t    if (!toAdd) {\n\t      return this;\n\t    }\n\t\n\t    if (toAdd && is.string(toAdd)) {\n\t      var selector = toAdd;\n\t      toAdd = cy.mutableElements().filter(selector);\n\t    }\n\t\n\t    var map = _p.map;\n\t\n\t    for (var i = 0; i < toAdd.length; i++) {\n\t      var toAddEle = toAdd[i];\n\t      var id = toAddEle._private.data.id;\n\t      var add = !map.has(id);\n\t\n\t      if (add) {\n\t        var index = this.length++;\n\t\n\t        this[index] = toAddEle;\n\t\n\t        map.set(id, { ele: toAddEle, index: index });\n\t      } else {\n\t        // replace\n\t        var _index = map.get(id).index;\n\t\n\t        this[_index] = toAddEle;\n\t        map.set(id, { ele: toAddEle, index: _index });\n\t      }\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // remove single ele in place in calling collection\n\t  unmergeOne: function unmergeOne(ele) {\n\t    ele = ele[0];\n\t\n\t    var _p = this._private;\n\t    var id = ele._private.data.id;\n\t    var map = _p.map;\n\t    var entry = map.get(id);\n\t\n\t    if (!entry) {\n\t      return this; // no need to remove\n\t    }\n\t\n\t    var i = entry.index;\n\t\n\t    // remove ele\n\t    this[i] = undefined;\n\t    map.delete(id);\n\t\n\t    var unmergedLastEle = i === this.length - 1;\n\t\n\t    // replace empty spot with last ele in collection\n\t    if (this.length > 1 && !unmergedLastEle) {\n\t      var lastEleI = this.length - 1;\n\t      var lastEle = this[lastEleI];\n\t      var lastEleId = lastEle._private.data.id;\n\t\n\t      this[lastEleI] = undefined;\n\t      this[i] = lastEle;\n\t      map.set(lastEleId, { ele: lastEle, index: i });\n\t    }\n\t\n\t    // the collection is now 1 ele smaller\n\t    this.length--;\n\t\n\t    return this;\n\t  },\n\t\n\t  // remove eles in place on calling collection\n\t  unmerge: function unmerge(toRemove) {\n\t    var cy = this._private.cy;\n\t\n\t    if (!toRemove) {\n\t      return this;\n\t    }\n\t\n\t    if (toRemove && is.string(toRemove)) {\n\t      var selector = toRemove;\n\t      toRemove = cy.mutableElements().filter(selector);\n\t    }\n\t\n\t    for (var i = 0; i < toRemove.length; i++) {\n\t      this.unmergeOne(toRemove[i]);\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  map: function map(mapFn, thisArg) {\n\t    var arr = [];\n\t    var eles = this;\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n\t\n\t      arr.push(ret);\n\t    }\n\t\n\t    return arr;\n\t  },\n\t\n\t  reduce: function reduce(fn, initialValue) {\n\t    var val = initialValue;\n\t    var eles = this;\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      val = fn(val, eles[i], i, eles);\n\t    }\n\t\n\t    return val;\n\t  },\n\t\n\t  max: function max(valFn, thisArg) {\n\t    var max = -Infinity;\n\t    var maxEle = void 0;\n\t    var eles = this;\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\t\n\t      if (val > max) {\n\t        max = val;\n\t        maxEle = ele;\n\t      }\n\t    }\n\t\n\t    return {\n\t      value: max,\n\t      ele: maxEle\n\t    };\n\t  },\n\t\n\t  min: function min(valFn, thisArg) {\n\t    var min = Infinity;\n\t    var minEle = void 0;\n\t    var eles = this;\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\t\n\t      if (val < min) {\n\t        min = val;\n\t        minEle = ele;\n\t      }\n\t    }\n\t\n\t    return {\n\t      value: min,\n\t      ele: minEle\n\t    };\n\t  }\n\t};\n\t\n\t// aliases\n\tvar fn = elesfn;\n\tfn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;\n\tfn['\\\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;\n\tfn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;\n\tfn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;\n\tfn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;\n\tfn.complement = fn.abscomp = fn.absoluteComplement;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 49 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar elesfn = {\n\t  isNode: function isNode() {\n\t    return this.group() === 'nodes';\n\t  },\n\t\n\t  isEdge: function isEdge() {\n\t    return this.group() === 'edges';\n\t  },\n\t\n\t  isLoop: function isLoop() {\n\t    return this.isEdge() && this.source().id() === this.target().id();\n\t  },\n\t\n\t  isSimple: function isSimple() {\n\t    return this.isEdge() && this.source().id() !== this.target().id();\n\t  },\n\t\n\t  group: function group() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return ele._private.group;\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 50 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar zIndexSort = __webpack_require__(14);\n\tvar util = __webpack_require__(1);\n\t\n\tvar elesfn = {\n\t  forEach: function forEach(fn, thisArg) {\n\t    if (is.fn(fn)) {\n\t\n\t      for (var i = 0; i < this.length; i++) {\n\t        var ele = this[i];\n\t        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n\t\n\t        if (ret === false) {\n\t          break;\n\t        } // exit each early on return false\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  toArray: function toArray() {\n\t    var array = [];\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      array.push(this[i]);\n\t    }\n\t\n\t    return array;\n\t  },\n\t\n\t  slice: function slice(start, end) {\n\t    var array = [];\n\t    var thisSize = this.length;\n\t\n\t    if (end == null) {\n\t      end = thisSize;\n\t    }\n\t\n\t    if (start == null) {\n\t      start = 0;\n\t    }\n\t\n\t    if (start < 0) {\n\t      start = thisSize + start;\n\t    }\n\t\n\t    if (end < 0) {\n\t      end = thisSize + end;\n\t    }\n\t\n\t    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n\t      array.push(this[i]);\n\t    }\n\t\n\t    return this.spawn(array);\n\t  },\n\t\n\t  size: function size() {\n\t    return this.length;\n\t  },\n\t\n\t  eq: function eq(i) {\n\t    return this[i] || this.spawn();\n\t  },\n\t\n\t  first: function first() {\n\t    return this[0] || this.spawn();\n\t  },\n\t\n\t  last: function last() {\n\t    return this[this.length - 1] || this.spawn();\n\t  },\n\t\n\t  empty: function empty() {\n\t    return this.length === 0;\n\t  },\n\t\n\t  nonempty: function nonempty() {\n\t    return !this.empty();\n\t  },\n\t\n\t  sort: function sort(sortFn) {\n\t    if (!is.fn(sortFn)) {\n\t      return this;\n\t    }\n\t\n\t    var sorted = this.toArray().sort(sortFn);\n\t\n\t    return this.spawn(sorted);\n\t  },\n\t\n\t  sortByZIndex: function sortByZIndex() {\n\t    return this.sort(zIndexSort);\n\t  },\n\t\n\t  zDepth: function zDepth() {\n\t    var ele = this[0];\n\t    if (!ele) {\n\t      return undefined;\n\t    }\n\t\n\t    // let cy = ele.cy();\n\t    var _p = ele._private;\n\t    var group = _p.group;\n\t\n\t    if (group === 'nodes') {\n\t      var depth = _p.data.parent ? ele.parents().size() : 0;\n\t\n\t      if (!ele.isParent()) {\n\t        return util.MAX_INT - 1; // childless nodes always on top\n\t      }\n\t\n\t      return depth;\n\t    } else {\n\t      var src = _p.source;\n\t      var tgt = _p.target;\n\t      var srcDepth = src.zDepth();\n\t      var tgtDepth = tgt.zDepth();\n\t\n\t      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n\t    }\n\t  }\n\t};\n\t\n\telesfn.each = elesfn.forEach;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 51 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Promise = __webpack_require__(5);\n\tvar math = __webpack_require__(2);\n\t\n\tvar elesfn = {\n\t  // Calculates and returns node dimensions { x, y } based on options given\n\t  layoutDimensions: function layoutDimensions(options) {\n\t    options = util.assign({\n\t      nodeDimensionsIncludeLabels: true\n\t    }, options);\n\t\n\t    if (options.nodeDimensionsIncludeLabels) {\n\t      var bbDim = this.boundingBox();\n\t      return {\n\t        w: bbDim.w,\n\t        h: bbDim.h\n\t      };\n\t    } else {\n\t      return {\n\t        w: this.outerWidth(),\n\t        h: this.outerHeight()\n\t      };\n\t    }\n\t  },\n\t\n\t  // using standard layout options, apply position function (w/ or w/o animation)\n\t  layoutPositions: function layoutPositions(layout, options, fn) {\n\t    var nodes = this.nodes();\n\t    var cy = this.cy();\n\t    var layoutEles = options.eles; // nodes & edges\n\t    var getMemoizeKey = function getMemoizeKey(node, i) {\n\t      return node.id() + '$' + i;\n\t    };\n\t    var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function\n\t\n\t    layout.emit({ type: 'layoutstart', layout: layout });\n\t\n\t    layout.animations = [];\n\t\n\t    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n\t      var center = {\n\t        x: nodesBb.x1 + nodesBb.w / 2,\n\t        y: nodesBb.y1 + nodesBb.h / 2\n\t      };\n\t\n\t      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)\n\t        x: (pos.x - center.x) * spacing,\n\t        y: (pos.y - center.y) * spacing\n\t      };\n\t\n\t      return {\n\t        x: center.x + spacingVector.x,\n\t        y: center.y + spacingVector.y\n\t      };\n\t    };\n\t\n\t    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\t\n\t    var spacingBb = function spacingBb() {\n\t      if (!useSpacingFactor) {\n\t        return null;\n\t      }\n\t\n\t      var bb = math.makeBoundingBox();\n\t\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        var node = nodes[i];\n\t        var pos = fnMem(node, i);\n\t\n\t        math.expandBoundingBoxByPoint(bb, pos.x, pos.y);\n\t      }\n\t\n\t      return bb;\n\t    };\n\t\n\t    var bb = spacingBb();\n\t\n\t    var getFinalPos = util.memoize(function (node, i) {\n\t      var newPos = fnMem(node, i);\n\t      var pos = node.position();\n\t\n\t      if (!is.number(pos.x) || !is.number(pos.y)) {\n\t        node.silentPosition({ x: 0, y: 0 });\n\t      }\n\t\n\t      if (useSpacingFactor) {\n\t        var spacing = Math.abs(options.spacingFactor);\n\t\n\t        newPos = calculateSpacing(spacing, bb, newPos);\n\t      }\n\t\n\t      if (options.transform != null) {\n\t        newPos = options.transform(node, newPos);\n\t      }\n\t\n\t      return newPos;\n\t    }, getMemoizeKey);\n\t\n\t    if (options.animate) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        var node = nodes[i];\n\t        var newPos = getFinalPos(node, i);\n\t        var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\t\n\t        if (animateNode) {\n\t          var ani = node.animation({\n\t            position: newPos,\n\t            duration: options.animationDuration,\n\t            easing: options.animationEasing\n\t          });\n\t\n\t          layout.animations.push(ani);\n\t\n\t          ani.play();\n\t        } else {\n\t          node.position(newPos);\n\t        }\n\t      }\n\t\n\t      if (options.fit) {\n\t        var fitAni = cy.animation({\n\t          fit: {\n\t            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n\t            padding: options.padding\n\t          },\n\t          duration: options.animationDuration,\n\t          easing: options.animationEasing\n\t        });\n\t\n\t        layout.animations.push(fitAni);\n\t\n\t        fitAni.play();\n\t      } else if (options.zoom !== undefined && options.pan !== undefined) {\n\t        var zoomPanAni = cy.animation({\n\t          zoom: options.zoom,\n\t          pan: options.pan,\n\t          duration: options.animationDuration,\n\t          easing: options.animationEasing\n\t        });\n\t\n\t        layout.animations.push(zoomPanAni);\n\t\n\t        zoomPanAni.play();\n\t      }\n\t\n\t      layout.one('layoutready', options.ready);\n\t      layout.emit({ type: 'layoutready', layout: layout });\n\t\n\t      Promise.all(layout.animations.map(function (ani) {\n\t        return ani.promise();\n\t      })).then(function () {\n\t        layout.one('layoutstop', options.stop);\n\t        layout.emit({ type: 'layoutstop', layout: layout });\n\t      });\n\t    } else {\n\t\n\t      nodes.positions(getFinalPos);\n\t\n\t      if (options.fit) {\n\t        cy.fit(options.eles, options.padding);\n\t      }\n\t\n\t      if (options.zoom != null) {\n\t        cy.zoom(options.zoom);\n\t      }\n\t\n\t      if (options.pan) {\n\t        cy.pan(options.pan);\n\t      }\n\t\n\t      layout.one('layoutready', options.ready);\n\t      layout.emit({ type: 'layoutready', layout: layout });\n\t\n\t      layout.one('layoutstop', options.stop);\n\t      layout.emit({ type: 'layoutstop', layout: layout });\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  layout: function layout(options) {\n\t    var cy = this.cy();\n\t\n\t    return cy.makeLayout(util.extend({}, options, {\n\t      eles: this\n\t    }));\n\t  }\n\t\n\t};\n\t\n\t// aliases:\n\telesfn.createLayout = elesfn.makeLayout = elesfn.layout;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 52 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tfunction styleCache(key, fn, ele) {\n\t  var _p = ele._private;\n\t  var cache = _p.styleCache = _p.styleCache || {};\n\t  var val;\n\t\n\t  if ((val = cache[key]) != null) {\n\t    return val;\n\t  } else {\n\t    val = cache[key] = fn(ele);\n\t\n\t    return val;\n\t  }\n\t}\n\t\n\tfunction cacheStyleFunction(key, fn) {\n\t  return function cachedStyleFunction(ele) {\n\t    return styleCache(key, fn, ele);\n\t  };\n\t}\n\t\n\tfunction cachePrototypeStyleFunction(key, fn) {\n\t  var selfFn = function selfFn(ele) {\n\t    return fn.call(ele);\n\t  };\n\t\n\t  return function cachedPrototypeStyleFunction() {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return styleCache(key, selfFn, ele);\n\t    }\n\t  };\n\t}\n\t\n\tvar elesfn = {\n\t\n\t  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n\t    var cy = this.cy();\n\t    var renderer = cy.renderer();\n\t    var styleEnabled = cy.styleEnabled();\n\t\n\t    if (renderer && styleEnabled) {\n\t      renderer.recalculateRenderedStyle(this, useCache);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  dirtyStyleCache: function dirtyStyleCache() {\n\t    var cy = this.cy();\n\t    var dirty = function dirty(ele) {\n\t      return ele._private.styleCache = {};\n\t    };\n\t\n\t    if (cy.hasCompoundNodes()) {\n\t      var eles = void 0;\n\t\n\t      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n\t\n\t      eles.merge(eles.connectedEdges());\n\t\n\t      eles.forEach(dirty);\n\t    } else {\n\t      this.forEach(function (ele) {\n\t        dirty(ele);\n\t\n\t        ele.connectedEdges().forEach(dirty);\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  // fully updates (recalculates) the style for the elements\n\t  updateStyle: function updateStyle(notifyRenderer) {\n\t    var cy = this._private.cy;\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return this;\n\t    }\n\t\n\t    if (cy._private.batchingStyle) {\n\t      var bEles = cy._private.batchStyleEles;\n\t\n\t      bEles.merge(this);\n\t\n\t      return this; // chaining and exit early when batching\n\t    }\n\t\n\t    var hasCompounds = cy.hasCompoundNodes();\n\t    var style = cy.style();\n\t    var updatedEles = this;\n\t\n\t    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\t\n\t    if (hasCompounds) {\n\t      // then add everything up and down for compound selector checks\n\t      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n\t    }\n\t\n\t    var changedEles = style.apply(updatedEles);\n\t\n\t    changedEles.dirtyStyleCache();\n\t    changedEles.dirtyCompoundBoundsCache();\n\t\n\t    if (notifyRenderer) {\n\t      changedEles.emitAndNotify('style'); // let renderer know we changed style\n\t    } else {\n\t      changedEles.emit('style'); // just fire the event\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n\t  updateMappers: function updateMappers(notifyRenderer) {\n\t    var cy = this._private.cy;\n\t    var style = cy.style();\n\t    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return this;\n\t    }\n\t\n\t    var changedEles = style.updateMappers(this);\n\t\n\t    changedEles.dirtyStyleCache();\n\t    changedEles.dirtyCompoundBoundsCache();\n\t\n\t    if (notifyRenderer) {\n\t      changedEles.emitAndNotify('style'); // let renderer know we changed style\n\t    } else {\n\t      changedEles.emit('style'); // just fire the event\n\t    }\n\t    return this; // chaining\n\t  },\n\t\n\t  // get the internal parsed style object for the specified property\n\t  parsedStyle: function parsedStyle(property) {\n\t    var ele = this[0];\n\t    var cy = ele.cy();\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return;\n\t    }\n\t\n\t    if (ele) {\n\t      return ele._private.style[property] || cy.style().getDefaultProperty(property);\n\t    }\n\t  },\n\t\n\t  numericStyle: function numericStyle(property) {\n\t    var ele = this[0];\n\t\n\t    if (!ele.cy().styleEnabled()) {\n\t      return;\n\t    }\n\t\n\t    if (ele) {\n\t      var pstyle = ele.pstyle(property);\n\t\n\t      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n\t    }\n\t  },\n\t\n\t  numericStyleUnits: function numericStyleUnits(property) {\n\t    var ele = this[0];\n\t\n\t    if (!ele.cy().styleEnabled()) {\n\t      return;\n\t    }\n\t\n\t    if (ele) {\n\t      return ele.pstyle(property).units;\n\t    }\n\t  },\n\t\n\t  // get the specified css property as a rendered value (i.e. on-screen value)\n\t  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n\t  renderedStyle: function renderedStyle(property) {\n\t    var cy = this.cy();\n\t    if (!cy.styleEnabled()) {\n\t      return this;\n\t    }\n\t\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      return cy.style().getRenderedStyle(ele, property);\n\t    }\n\t  },\n\t\n\t  // read the calculated css style of the element or override the style (via a bypass)\n\t  style: function style(name, value) {\n\t    var cy = this.cy();\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return this;\n\t    }\n\t\n\t    var updateTransitions = false;\n\t    var style = cy.style();\n\t\n\t    if (is.plainObject(name)) {\n\t      // then extend the bypass\n\t      var props = name;\n\t      style.applyBypass(this, props, updateTransitions);\n\t\n\t      this.dirtyStyleCache();\n\t      this.dirtyCompoundBoundsCache();\n\t\n\t      this.emitAndNotify('style'); // let the renderer know we've updated style\n\t    } else if (is.string(name)) {\n\t\n\t      if (value === undefined) {\n\t        // then get the property from the style\n\t        var ele = this[0];\n\t\n\t        if (ele) {\n\t          return style.getStylePropertyValue(ele, name);\n\t        } else {\n\t          // empty collection => can't get any value\n\t          return;\n\t        }\n\t      } else {\n\t        // then set the bypass with the property value\n\t        style.applyBypass(this, name, value, updateTransitions);\n\t\n\t        this.dirtyStyleCache();\n\t        this.dirtyCompoundBoundsCache();\n\t\n\t        this.emitAndNotify('style'); // let the renderer know we've updated style\n\t      }\n\t    } else if (name === undefined) {\n\t      var _ele = this[0];\n\t\n\t      if (_ele) {\n\t        return style.getRawStyle(_ele);\n\t      } else {\n\t        // empty collection => can't get any value\n\t        return;\n\t      }\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  removeStyle: function removeStyle(names) {\n\t    var cy = this.cy();\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return this;\n\t    }\n\t\n\t    var updateTransitions = false;\n\t    var style = cy.style();\n\t    var eles = this;\n\t\n\t    if (names === undefined) {\n\t      for (var i = 0; i < eles.length; i++) {\n\t        var ele = eles[i];\n\t\n\t        style.removeAllBypasses(ele, updateTransitions);\n\t      }\n\t    } else {\n\t      names = names.split(/\\s+/);\n\t\n\t      for (var _i = 0; _i < eles.length; _i++) {\n\t        var _ele2 = eles[_i];\n\t\n\t        style.removeBypasses(_ele2, names, updateTransitions);\n\t      }\n\t    }\n\t\n\t    this.dirtyStyleCache();\n\t    this.dirtyCompoundBoundsCache();\n\t\n\t    this.emitAndNotify('style'); // let the renderer know we've updated style\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  show: function show() {\n\t    this.css('display', 'element');\n\t    return this; // chaining\n\t  },\n\t\n\t  hide: function hide() {\n\t    this.css('display', 'none');\n\t    return this; // chaining\n\t  },\n\t\n\t  effectiveOpacity: function effectiveOpacity() {\n\t    var cy = this.cy();\n\t    if (!cy.styleEnabled()) {\n\t      return 1;\n\t    }\n\t\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      var _p = ele._private;\n\t      var parentOpacity = ele.pstyle('opacity').value;\n\t\n\t      if (!hasCompoundNodes) {\n\t        return parentOpacity;\n\t      }\n\t\n\t      var parents = !_p.data.parent ? null : ele.parents();\n\t\n\t      if (parents) {\n\t        for (var i = 0; i < parents.length; i++) {\n\t          var parent = parents[i];\n\t          var opacity = parent.pstyle('opacity').value;\n\t\n\t          parentOpacity = opacity * parentOpacity;\n\t        }\n\t      }\n\t\n\t      return parentOpacity;\n\t    }\n\t  },\n\t\n\t  transparent: function transparent() {\n\t    var cy = this.cy();\n\t    if (!cy.styleEnabled()) {\n\t      return false;\n\t    }\n\t\n\t    var ele = this[0];\n\t    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\t\n\t    if (ele) {\n\t      if (!hasCompoundNodes) {\n\t        return ele.pstyle('opacity').value === 0;\n\t      } else {\n\t        return ele.effectiveOpacity() === 0;\n\t      }\n\t    }\n\t  },\n\t\n\t  backgrounding: function backgrounding() {\n\t    var cy = this.cy();\n\t    if (!cy.styleEnabled()) {\n\t      return false;\n\t    }\n\t\n\t    var ele = this[0];\n\t\n\t    return ele._private.backgrounding ? true : false;\n\t  }\n\t\n\t};\n\t\n\tfunction checkCompound(ele, parentOk) {\n\t  var _p = ele._private;\n\t  var parents = _p.data.parent ? ele.parents() : null;\n\t\n\t  if (parents) {\n\t    for (var i = 0; i < parents.length; i++) {\n\t      var parent = parents[i];\n\t\n\t      if (!parentOk(parent)) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\tfunction defineDerivedStateFunction(specs) {\n\t  var ok = specs.ok;\n\t  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n\t  var parentOk = specs.parentOk || specs.ok;\n\t\n\t  return function () {\n\t    var cy = this.cy();\n\t    if (!cy.styleEnabled()) {\n\t      return true;\n\t    }\n\t\n\t    var ele = this[0];\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t\n\t    if (ele) {\n\t      var _p = ele._private;\n\t\n\t      if (!ok(ele)) {\n\t        return false;\n\t      }\n\t\n\t      if (ele.isNode()) {\n\t        return !hasCompoundNodes || checkCompound(ele, parentOk);\n\t      } else {\n\t        var src = _p.source;\n\t        var tgt = _p.target;\n\t\n\t        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n\t  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n\t});\n\t\n\telesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n\t  ok: eleTakesUpSpace\n\t}));\n\t\n\tvar eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n\t  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n\t});\n\t\n\tvar parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n\t  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n\t});\n\t\n\telesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n\t  ok: eleInteractive,\n\t  parentOk: parentInteractive,\n\t  edgeOkViaNode: eleTakesUpSpace\n\t}));\n\t\n\telesfn.noninteractive = function () {\n\t  var ele = this[0];\n\t\n\t  if (ele) {\n\t    return !ele.interactive();\n\t  }\n\t};\n\t\n\tvar eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n\t  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n\t});\n\t\n\tvar edgeVisibleViaNode = eleTakesUpSpace;\n\t\n\telesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n\t  ok: eleVisible,\n\t  edgeOkViaNode: edgeVisibleViaNode\n\t}));\n\t\n\telesfn.hidden = function () {\n\t  var ele = this[0];\n\t\n\t  if (ele) {\n\t    return !ele.visible();\n\t  }\n\t};\n\t\n\telesfn.bypass = elesfn.css = elesfn.style;\n\telesfn.renderedCss = elesfn.renderedStyle;\n\telesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;\n\telesfn.pstyle = elesfn.parsedStyle;\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 53 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar elesfn = {};\n\t\n\tfunction defineSwitchFunction(params) {\n\t  return function () {\n\t    var args = arguments;\n\t    var changedEles = [];\n\t\n\t    // e.g. cy.nodes().select( data, handler )\n\t    if (args.length === 2) {\n\t      var data = args[0];\n\t      var handler = args[1];\n\t      this.on(params.event, data, handler);\n\t    }\n\t\n\t    // e.g. cy.nodes().select( handler )\n\t    else if (args.length === 1) {\n\t        var _handler = args[0];\n\t        this.on(params.event, _handler);\n\t      }\n\t\n\t      // e.g. cy.nodes().select()\n\t      else if (args.length === 0) {\n\t          for (var i = 0; i < this.length; i++) {\n\t            var ele = this[i];\n\t            var able = !params.ableField || ele._private[params.ableField];\n\t            var changed = ele._private[params.field] != params.value;\n\t\n\t            if (params.overrideAble) {\n\t              var overrideAble = params.overrideAble(ele);\n\t\n\t              if (overrideAble !== undefined) {\n\t                able = overrideAble;\n\t\n\t                if (!overrideAble) {\n\t                  return this;\n\t                } // to save cycles assume not able for all on override\n\t              }\n\t            }\n\t\n\t            if (able) {\n\t              ele._private[params.field] = params.value;\n\t\n\t              if (changed) {\n\t                changedEles.push(ele);\n\t              }\n\t            }\n\t          }\n\t\n\t          var changedColl = this.spawn(changedEles);\n\t          changedColl.updateStyle(); // change of state => possible change of style\n\t          changedColl.emit(params.event);\n\t        }\n\t\n\t    return this;\n\t  };\n\t}\n\t\n\tfunction defineSwitchSet(params) {\n\t  elesfn[params.field] = function () {\n\t    var ele = this[0];\n\t\n\t    if (ele) {\n\t      if (params.overrideField) {\n\t        var val = params.overrideField(ele);\n\t\n\t        if (val !== undefined) {\n\t          return val;\n\t        }\n\t      }\n\t\n\t      return ele._private[params.field];\n\t    }\n\t  };\n\t\n\t  elesfn[params.on] = defineSwitchFunction({\n\t    event: params.on,\n\t    field: params.field,\n\t    ableField: params.ableField,\n\t    overrideAble: params.overrideAble,\n\t    value: true\n\t  });\n\t\n\t  elesfn[params.off] = defineSwitchFunction({\n\t    event: params.off,\n\t    field: params.field,\n\t    ableField: params.ableField,\n\t    overrideAble: params.overrideAble,\n\t    value: false\n\t  });\n\t}\n\t\n\tdefineSwitchSet({\n\t  field: 'locked',\n\t  overrideField: function overrideField(ele) {\n\t    return ele.cy().autolock() ? true : undefined;\n\t  },\n\t  on: 'lock',\n\t  off: 'unlock'\n\t});\n\t\n\tdefineSwitchSet({\n\t  field: 'grabbable',\n\t  overrideField: function overrideField(ele) {\n\t    return ele.cy().autoungrabify() ? false : undefined;\n\t  },\n\t  on: 'grabify',\n\t  off: 'ungrabify'\n\t});\n\t\n\tdefineSwitchSet({\n\t  field: 'selected',\n\t  ableField: 'selectable',\n\t  overrideAble: function overrideAble(ele) {\n\t    return ele.cy().autounselectify() ? false : undefined;\n\t  },\n\t  on: 'select',\n\t  off: 'unselect'\n\t});\n\t\n\tdefineSwitchSet({\n\t  field: 'selectable',\n\t  overrideField: function overrideField(ele) {\n\t    return ele.cy().autounselectify() ? false : undefined;\n\t  },\n\t  on: 'selectify',\n\t  off: 'unselectify'\n\t});\n\t\n\telesfn.deselect = elesfn.unselect;\n\t\n\telesfn.grabbed = function () {\n\t  var ele = this[0];\n\t  if (ele) {\n\t    return ele._private.grabbed;\n\t  }\n\t};\n\t\n\tdefineSwitchSet({\n\t  field: 'active',\n\t  on: 'activate',\n\t  off: 'unactivate'\n\t});\n\t\n\telesfn.inactive = function () {\n\t  var ele = this[0];\n\t  if (ele) {\n\t    return !ele._private.active;\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 54 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar elesfn = {};\n\t\n\tvar cache = function cache(fn, name) {\n\t  return function traversalCache(arg1, arg2, arg3, arg4) {\n\t    var selectorOrEles = arg1;\n\t    var eles = this;\n\t    var key = void 0;\n\t\n\t    if (selectorOrEles == null) {\n\t      key = 'null';\n\t    } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n\t      key = '#' + selectorOrEles.id();\n\t    }\n\t\n\t    if (eles.length === 1 && key) {\n\t      var _p = eles[0]._private;\n\t      var tch = _p.traversalCache = _p.traversalCache || {};\n\t      var ch = tch[name] = tch[name] || {};\n\t      var cacheHit = ch[key];\n\t\n\t      if (cacheHit) {\n\t        return cacheHit;\n\t      } else {\n\t        return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);\n\t      }\n\t    } else {\n\t      return fn.call(eles, arg1, arg2, arg3, arg4);\n\t    }\n\t  };\n\t};\n\t\n\t// DAG functions\n\t////////////////\n\t\n\tvar defineDagExtremity = function defineDagExtremity(params) {\n\t  return function dagExtremityImpl(selector) {\n\t    var eles = this;\n\t    var ret = [];\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t      if (!ele.isNode()) {\n\t        continue;\n\t      }\n\t\n\t      var disqualified = false;\n\t      var edges = ele.connectedEdges();\n\t\n\t      for (var j = 0; j < edges.length; j++) {\n\t        var edge = edges[j];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t\n\t        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n\t          disqualified = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (!disqualified) {\n\t        ret.push(ele);\n\t      }\n\t    }\n\t\n\t    return this.spawn(ret, { unique: true }).filter(selector);\n\t  };\n\t};\n\t\n\tvar defineDagOneHop = function defineDagOneHop(params) {\n\t  return function (selector) {\n\t    var eles = this;\n\t    var oEles = [];\n\t\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t\n\t      if (!ele.isNode()) {\n\t        continue;\n\t      }\n\t\n\t      var edges = ele.connectedEdges();\n\t      for (var j = 0; j < edges.length; j++) {\n\t        var edge = edges[j];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t\n\t        if (params.outgoing && src === ele) {\n\t          oEles.push(edge);\n\t          oEles.push(tgt);\n\t        } else if (params.incoming && tgt === ele) {\n\t          oEles.push(edge);\n\t          oEles.push(src);\n\t        }\n\t      }\n\t    }\n\t\n\t    return this.spawn(oEles, { unique: true }).filter(selector);\n\t  };\n\t};\n\t\n\tvar defineDagAllHops = function defineDagAllHops(params) {\n\t  return function (selector) {\n\t    var eles = this;\n\t    var sEles = [];\n\t    var sElesIds = {};\n\t\n\t    for (;;) {\n\t      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\t\n\t      if (next.length === 0) {\n\t        break;\n\t      } // done if none left\n\t\n\t      var newNext = false;\n\t      for (var i = 0; i < next.length; i++) {\n\t        var n = next[i];\n\t        var nid = n.id();\n\t\n\t        if (!sElesIds[nid]) {\n\t          sElesIds[nid] = true;\n\t          sEles.push(n);\n\t          newNext = true;\n\t        }\n\t      }\n\t\n\t      if (!newNext) {\n\t        break;\n\t      } // done if touched all outgoers already\n\t\n\t      eles = next;\n\t    }\n\t\n\t    return this.spawn(sEles, { unique: true }).filter(selector);\n\t  };\n\t};\n\t\n\telesfn.clearTraversalCache = function () {\n\t  for (var i = 0; i < this.length; i++) {\n\t    this[i]._private.traversalCache = null;\n\t  }\n\t};\n\t\n\tutil.extend(elesfn, {\n\t  // get the root nodes in the DAG\n\t  roots: defineDagExtremity({ noIncomingEdges: true }),\n\t\n\t  // get the leaf nodes in the DAG\n\t  leaves: defineDagExtremity({ noOutgoingEdges: true }),\n\t\n\t  // normally called children in graph theory\n\t  // these nodes =edges=> outgoing nodes\n\t  outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),\n\t\n\t  // aka DAG descendants\n\t  successors: defineDagAllHops({ outgoing: true }),\n\t\n\t  // normally called parents in graph theory\n\t  // these nodes <=edges= incoming nodes\n\t  incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),\n\t\n\t  // aka DAG ancestors\n\t  predecessors: defineDagAllHops({ incoming: true })\n\t});\n\t\n\t// Neighbourhood functions\n\t//////////////////////////\n\t\n\tutil.extend(elesfn, {\n\t  neighborhood: cache(function (selector) {\n\t    var elements = [];\n\t    var nodes = this.nodes();\n\t\n\t    for (var i = 0; i < nodes.length; i++) {\n\t      // for all nodes\n\t      var node = nodes[i];\n\t      var connectedEdges = node.connectedEdges();\n\t\n\t      // for each connected edge, add the edge and the other node\n\t      for (var j = 0; j < connectedEdges.length; j++) {\n\t        var edge = connectedEdges[j];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t        var otherNode = node === src ? tgt : src;\n\t\n\t        // need check in case of loop\n\t        if (otherNode.length > 0) {\n\t          elements.push(otherNode[0]); // add node 1 hop away\n\t        }\n\t\n\t        // add connected edge\n\t        elements.push(edge[0]);\n\t      }\n\t    }\n\t\n\t    return this.spawn(elements, { unique: true }).filter(selector);\n\t  }, 'neighborhood'),\n\t\n\t  closedNeighborhood: function closedNeighborhood(selector) {\n\t    return this.neighborhood().add(this).filter(selector);\n\t  },\n\t\n\t  openNeighborhood: function openNeighborhood(selector) {\n\t    return this.neighborhood(selector);\n\t  }\n\t});\n\t\n\t// aliases\n\telesfn.neighbourhood = elesfn.neighborhood;\n\telesfn.closedNeighbourhood = elesfn.closedNeighborhood;\n\telesfn.openNeighbourhood = elesfn.openNeighborhood;\n\t\n\t// Edge functions\n\t/////////////////\n\t\n\tutil.extend(elesfn, {\n\t  source: cache(function sourceImpl(selector) {\n\t    var ele = this[0];\n\t    var src = void 0;\n\t\n\t    if (ele) {\n\t      src = ele._private.source || ele.cy().collection();\n\t    }\n\t\n\t    return src && selector ? src.filter(selector) : src;\n\t  }, 'source'),\n\t\n\t  target: cache(function targetImpl(selector) {\n\t    var ele = this[0];\n\t    var tgt = void 0;\n\t\n\t    if (ele) {\n\t      tgt = ele._private.target || ele.cy().collection();\n\t    }\n\t\n\t    return tgt && selector ? tgt.filter(selector) : tgt;\n\t  }, 'target'),\n\t\n\t  sources: defineSourceFunction({\n\t    attr: 'source'\n\t  }),\n\t\n\t  targets: defineSourceFunction({\n\t    attr: 'target'\n\t  })\n\t});\n\t\n\tfunction defineSourceFunction(params) {\n\t  return function sourceImpl(selector) {\n\t    var sources = [];\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var ele = this[i];\n\t      var src = ele._private[params.attr];\n\t\n\t      if (src) {\n\t        sources.push(src);\n\t      }\n\t    }\n\t\n\t    return this.spawn(sources, { unique: true }).filter(selector);\n\t  };\n\t}\n\t\n\tutil.extend(elesfn, {\n\t  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n\t\n\t  edgesTo: cache(defineEdgesWithFunction({\n\t    thisIsSrc: true\n\t  }), 'edgesTo')\n\t});\n\t\n\tfunction defineEdgesWithFunction(params) {\n\t\n\t  return function edgesWithImpl(otherNodes) {\n\t    var elements = [];\n\t    var cy = this._private.cy;\n\t    var p = params || {};\n\t\n\t    // get elements if a selector is specified\n\t    if (is.string(otherNodes)) {\n\t      otherNodes = cy.$(otherNodes);\n\t    }\n\t\n\t    for (var h = 0; h < otherNodes.length; h++) {\n\t      var edges = otherNodes[h]._private.edges;\n\t\n\t      for (var i = 0; i < edges.length; i++) {\n\t        var edge = edges[i];\n\t        var edgeData = edge._private.data;\n\t        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n\t        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n\t        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\t\n\t        if (!edgeConnectsThisAndOther) {\n\t          continue;\n\t        }\n\t\n\t        if (p.thisIsSrc || p.thisIsTgt) {\n\t          if (p.thisIsSrc && !thisToOther) {\n\t            continue;\n\t          }\n\t\n\t          if (p.thisIsTgt && !otherToThis) {\n\t            continue;\n\t          }\n\t        }\n\t\n\t        elements.push(edge);\n\t      }\n\t    }\n\t\n\t    return this.spawn(elements, { unique: true });\n\t  };\n\t}\n\t\n\tutil.extend(elesfn, {\n\t  connectedEdges: cache(function (selector) {\n\t    var retEles = [];\n\t\n\t    var eles = this;\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var node = eles[i];\n\t      if (!node.isNode()) {\n\t        continue;\n\t      }\n\t\n\t      var edges = node._private.edges;\n\t\n\t      for (var j = 0; j < edges.length; j++) {\n\t        var edge = edges[j];\n\t        retEles.push(edge);\n\t      }\n\t    }\n\t\n\t    return this.spawn(retEles, { unique: true }).filter(selector);\n\t  }, 'connectedEdges'),\n\t\n\t  connectedNodes: cache(function (selector) {\n\t    var retEles = [];\n\t\n\t    var eles = this;\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var edge = eles[i];\n\t      if (!edge.isEdge()) {\n\t        continue;\n\t      }\n\t\n\t      retEles.push(edge.source()[0]);\n\t      retEles.push(edge.target()[0]);\n\t    }\n\t\n\t    return this.spawn(retEles, { unique: true }).filter(selector);\n\t  }, 'connectedNodes'),\n\t\n\t  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n\t\n\t  codirectedEdges: cache(defineParallelEdgesFunction({\n\t    codirected: true\n\t  }), 'codirectedEdges')\n\t});\n\t\n\tfunction defineParallelEdgesFunction(params) {\n\t  var defaults = {\n\t    codirected: false\n\t  };\n\t  params = util.extend({}, defaults, params);\n\t\n\t  return function parallelEdgesImpl(selector) {\n\t    // micro-optimised for renderer\n\t    var elements = [];\n\t    var edges = this.edges();\n\t    var p = params;\n\t\n\t    // look at all the edges in the collection\n\t    for (var i = 0; i < edges.length; i++) {\n\t      var edge1 = edges[i];\n\t      var edge1_p = edge1._private;\n\t      var src1 = edge1_p.source;\n\t      var srcid1 = src1._private.data.id;\n\t      var tgtid1 = edge1_p.data.target;\n\t      var srcEdges1 = src1._private.edges;\n\t\n\t      // look at edges connected to the src node of this edge\n\t      for (var j = 0; j < srcEdges1.length; j++) {\n\t        var edge2 = srcEdges1[j];\n\t        var edge2data = edge2._private.data;\n\t        var tgtid2 = edge2data.target;\n\t        var srcid2 = edge2data.source;\n\t\n\t        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n\t        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\t\n\t        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n\t          elements.push(edge2);\n\t        }\n\t      }\n\t    }\n\t\n\t    return this.spawn(elements, { unique: true }).filter(selector);\n\t  };\n\t}\n\t\n\t// Misc functions\n\t/////////////////\n\t\n\tutil.extend(elesfn, {\n\t  components: function components() {\n\t    var self = this;\n\t    var cy = self.cy();\n\t    var visited = self.spawn();\n\t    var unvisited = self.nodes().spawnSelf();\n\t    var components = [];\n\t\n\t    var visitInComponent = function visitInComponent(node, component) {\n\t      visited.merge(node);\n\t      unvisited.unmerge(node);\n\t      component.merge(node);\n\t    };\n\t\n\t    if (unvisited.empty()) {\n\t      return self.spawn();\n\t    }\n\t\n\t    var _loop = function _loop() {\n\t      var component = cy.collection();\n\t      components.push(component);\n\t\n\t      var root = unvisited[0];\n\t      visitInComponent(root, component);\n\t\n\t      self.bfs({\n\t        directed: false,\n\t        roots: root,\n\t        visit: function visit(v, e, u, i, depth) {\n\t          visitInComponent(v, component);\n\t        }\n\t      });\n\t    };\n\t\n\t    do {\n\t      _loop();\n\t    } while (unvisited.length > 0);\n\t\n\t    return components.map(function (component) {\n\t      var connectedEdges = component.connectedEdges().stdFilter(function (edge) {\n\t        return component.anySame(edge.source()) && component.anySame(edge.target());\n\t      });\n\t\n\t      return component.union(connectedEdges);\n\t    });\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 55 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Collection = __webpack_require__(7);\n\tvar Element = __webpack_require__(13);\n\t\n\tvar corefn = {\n\t  add: function add(opts) {\n\t\n\t    var elements = void 0;\n\t    var cy = this;\n\t\n\t    // add the elements\n\t    if (is.elementOrCollection(opts)) {\n\t      var eles = opts;\n\t\n\t      if (eles._private.cy === cy) {\n\t        // same instance => just restore\n\t        elements = eles.restore();\n\t      } else {\n\t        // otherwise, copy from json\n\t        var jsons = [];\n\t\n\t        for (var i = 0; i < eles.length; i++) {\n\t          var ele = eles[i];\n\t          jsons.push(ele.json());\n\t        }\n\t\n\t        elements = new Collection(cy, jsons);\n\t      }\n\t    }\n\t\n\t    // specify an array of options\n\t    else if (is.array(opts)) {\n\t        var _jsons = opts;\n\t\n\t        elements = new Collection(cy, _jsons);\n\t      }\n\t\n\t      // specify via opts.nodes and opts.edges\n\t      else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {\n\t          var elesByGroup = opts;\n\t          var _jsons2 = [];\n\t\n\t          var grs = ['nodes', 'edges'];\n\t          for (var _i = 0, il = grs.length; _i < il; _i++) {\n\t            var group = grs[_i];\n\t            var elesArray = elesByGroup[group];\n\t\n\t            if (is.array(elesArray)) {\n\t\n\t              for (var j = 0, jl = elesArray.length; j < jl; j++) {\n\t                var json = util.extend({ group: group }, elesArray[j]);\n\t\n\t                _jsons2.push(json);\n\t              }\n\t            }\n\t          }\n\t\n\t          elements = new Collection(cy, _jsons2);\n\t        }\n\t\n\t        // specify options for one element\n\t        else {\n\t            var _json = opts;\n\t            elements = new Element(cy, _json).collection();\n\t          }\n\t\n\t    return elements;\n\t  },\n\t\n\t  remove: function remove(collection) {\n\t    if (is.elementOrCollection(collection)) {\n\t      // already have right ref\n\t    } else if (is.string(collection)) {\n\t      var selector = collection;\n\t      collection = this.$(selector);\n\t    }\n\t\n\t    return collection.remove();\n\t  }\n\t};\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 56 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/* global Float32Array */\n\t\n\t/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\tfunction generateCubicBezier(mX1, mY1, mX2, mY2) {\n\t  var NEWTON_ITERATIONS = 4,\n\t      NEWTON_MIN_SLOPE = 0.001,\n\t      SUBDIVISION_PRECISION = 0.0000001,\n\t      SUBDIVISION_MAX_ITERATIONS = 10,\n\t      kSplineTableSize = 11,\n\t      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n\t      float32ArraySupported = typeof Float32Array !== 'undefined';\n\t\n\t  /* Must contain four arguments. */\n\t  if (arguments.length !== 4) {\n\t    return false;\n\t  }\n\t\n\t  /* Arguments must be numbers. */\n\t  for (var i = 0; i < 4; ++i) {\n\t    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  /* X values must be in the [0, 1] range. */\n\t  mX1 = Math.min(mX1, 1);\n\t  mX2 = Math.min(mX2, 1);\n\t  mX1 = Math.max(mX1, 0);\n\t  mX2 = Math.max(mX2, 0);\n\t\n\t  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\t\n\t  function A(aA1, aA2) {\n\t    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n\t  }\n\t\n\t  function B(aA1, aA2) {\n\t    return 3.0 * aA2 - 6.0 * aA1;\n\t  }\n\t\n\t  function C(aA1) {\n\t    return 3.0 * aA1;\n\t  }\n\t\n\t  function calcBezier(aT, aA1, aA2) {\n\t    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n\t  }\n\t\n\t  function getSlope(aT, aA1, aA2) {\n\t    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n\t  }\n\t\n\t  function newtonRaphsonIterate(aX, aGuessT) {\n\t    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n\t      var currentSlope = getSlope(aGuessT, mX1, mX2);\n\t\n\t      if (currentSlope === 0.0) {\n\t        return aGuessT;\n\t      }\n\t\n\t      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n\t      aGuessT -= currentX / currentSlope;\n\t    }\n\t\n\t    return aGuessT;\n\t  }\n\t\n\t  function calcSampleValues() {\n\t    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n\t      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n\t    }\n\t  }\n\t\n\t  function binarySubdivide(aX, aA, aB) {\n\t    var currentX = void 0,\n\t        currentT = void 0,\n\t        i = 0;\n\t\n\t    do {\n\t      currentT = aA + (aB - aA) / 2.0;\n\t      currentX = calcBezier(currentT, mX1, mX2) - aX;\n\t      if (currentX > 0.0) {\n\t        aB = currentT;\n\t      } else {\n\t        aA = currentT;\n\t      }\n\t    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\t\n\t    return currentT;\n\t  }\n\t\n\t  function getTForX(aX) {\n\t    var intervalStart = 0.0,\n\t        currentSample = 1,\n\t        lastSample = kSplineTableSize - 1;\n\t\n\t    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n\t      intervalStart += kSampleStepSize;\n\t    }\n\t\n\t    --currentSample;\n\t\n\t    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n\t        guessForT = intervalStart + dist * kSampleStepSize,\n\t        initialSlope = getSlope(guessForT, mX1, mX2);\n\t\n\t    if (initialSlope >= NEWTON_MIN_SLOPE) {\n\t      return newtonRaphsonIterate(aX, guessForT);\n\t    } else if (initialSlope === 0.0) {\n\t      return guessForT;\n\t    } else {\n\t      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n\t    }\n\t  }\n\t\n\t  var _precomputed = false;\n\t\n\t  function precompute() {\n\t    _precomputed = true;\n\t    if (mX1 !== mY1 || mX2 !== mY2) {\n\t      calcSampleValues();\n\t    }\n\t  }\n\t\n\t  var f = function f(aX) {\n\t    if (!_precomputed) {\n\t      precompute();\n\t    }\n\t    if (mX1 === mY1 && mX2 === mY2) {\n\t      return aX;\n\t    }\n\t    if (aX === 0) {\n\t      return 0;\n\t    }\n\t    if (aX === 1) {\n\t      return 1;\n\t    }\n\t\n\t    return calcBezier(getTForX(aX), mY1, mY2);\n\t  };\n\t\n\t  f.getControlPoints = function () {\n\t    return [{\n\t      x: mX1,\n\t      y: mY1\n\t    }, {\n\t      x: mX2,\n\t      y: mY2\n\t    }];\n\t  };\n\t\n\t  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\t  f.toString = function () {\n\t    return str;\n\t  };\n\t\n\t  return f;\n\t}\n\t\n\tmodule.exports = generateCubicBezier;\n\t\n\t/***/ }),\n\t/* 57 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tfunction getEasedValue(type, start, end, percent, easingFn) {\n\t  if (percent === 1) {\n\t    return end;\n\t  }\n\t\n\t  var val = easingFn(start, end, percent);\n\t\n\t  if (type == null) {\n\t    return val;\n\t  }\n\t\n\t  if (type.roundValue || type.color) {\n\t    val = Math.round(val);\n\t  }\n\t\n\t  if (type.min !== undefined) {\n\t    val = Math.max(val, type.min);\n\t  }\n\t\n\t  if (type.max !== undefined) {\n\t    val = Math.min(val, type.max);\n\t  }\n\t\n\t  return val;\n\t}\n\t\n\tfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n\t  var type = propSpec != null ? propSpec.type : null;\n\t\n\t  if (percent < 0) {\n\t    percent = 0;\n\t  } else if (percent > 1) {\n\t    percent = 1;\n\t  }\n\t\n\t  var start = void 0,\n\t      end = void 0;\n\t\n\t  if (startProp.pfValue != null || startProp.value != null) {\n\t    start = startProp.pfValue != null ? startProp.pfValue : startProp.value;\n\t  } else {\n\t    start = startProp;\n\t  }\n\t\n\t  if (endProp.pfValue != null || endProp.value != null) {\n\t    end = endProp.pfValue != null ? endProp.pfValue : endProp.value;\n\t  } else {\n\t    end = endProp;\n\t  }\n\t\n\t  if (is.number(start) && is.number(end)) {\n\t    return getEasedValue(type, start, end, percent, easingFn);\n\t  } else if (is.array(start) && is.array(end)) {\n\t    var easedArr = [];\n\t\n\t    for (var i = 0; i < end.length; i++) {\n\t      var si = start[i];\n\t      var ei = end[i];\n\t\n\t      if (si != null && ei != null) {\n\t        var val = getEasedValue(type, si, ei, percent, easingFn);\n\t\n\t        easedArr.push(val);\n\t      } else {\n\t        easedArr.push(ei);\n\t      }\n\t    }\n\t\n\t    return easedArr;\n\t  }\n\t\n\t  return undefined;\n\t}\n\t\n\tmodule.exports = ease;\n\t\n\t/***/ }),\n\t/* 58 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar generateCubicBezier = __webpack_require__(56);\n\tvar generateSpringRK4 = __webpack_require__(60);\n\t\n\tvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n\t  var bezier = generateCubicBezier(t1, p1, t2, p2);\n\t\n\t  return function (start, end, percent) {\n\t    return start + (end - start) * bezier(percent);\n\t  };\n\t};\n\t\n\tvar easings = {\n\t  'linear': function linear(start, end, percent) {\n\t    return start + (end - start) * percent;\n\t  },\n\t\n\t  // default easings\n\t  'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n\t  'ease-in': cubicBezier(0.42, 0, 1, 1),\n\t  'ease-out': cubicBezier(0, 0, 0.58, 1),\n\t  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n\t\n\t  // sine\n\t  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n\t  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n\t  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n\t\n\t  // quad\n\t  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n\t  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n\t  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n\t\n\t  // cubic\n\t  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n\t  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n\t  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n\t\n\t  // quart\n\t  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n\t  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n\t  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n\t\n\t  // quint\n\t  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n\t  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n\t  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n\t\n\t  // expo\n\t  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n\t  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n\t  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n\t\n\t  // circ\n\t  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n\t  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n\t  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n\t\n\t  // user param easings...\n\t\n\t  'spring': function spring(tension, friction, duration) {\n\t    if (duration === 0) {\n\t      // can't get a spring w/ duration 0\n\t      return easings.linear; // duration 0 => jump to end so impl doesn't matter\n\t    }\n\t\n\t    var spring = generateSpringRK4(tension, friction, duration);\n\t\n\t    return function (start, end, percent) {\n\t      return start + (end - start) * spring(percent);\n\t    };\n\t  },\n\t\n\t  'cubic-bezier': cubicBezier\n\t};\n\t\n\tmodule.exports = easings;\n\t\n\t/***/ }),\n\t/* 59 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar define = __webpack_require__(3);\n\tvar util = __webpack_require__(1);\n\tvar stepAll = __webpack_require__(62);\n\t\n\tvar corefn = {\n\t\n\t  // pull in animation functions\n\t  animate: define.animate(),\n\t  animation: define.animation(),\n\t  animated: define.animated(),\n\t  clearQueue: define.clearQueue(),\n\t  delay: define.delay(),\n\t  delayAnimation: define.delayAnimation(),\n\t  stop: define.stop(),\n\t\n\t  addToAnimationPool: function addToAnimationPool(eles) {\n\t    var cy = this;\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return;\n\t    } // save cycles when no style used\n\t\n\t    cy._private.aniEles.merge(eles);\n\t  },\n\t\n\t  stopAnimationLoop: function stopAnimationLoop() {\n\t    this._private.animationsRunning = false;\n\t  },\n\t\n\t  startAnimationLoop: function startAnimationLoop() {\n\t    var cy = this;\n\t\n\t    cy._private.animationsRunning = true;\n\t\n\t    if (!cy.styleEnabled()) {\n\t      return;\n\t    } // save cycles when no style used\n\t\n\t    // NB the animation loop will exec in headless environments if style enabled\n\t    // and explicit cy.destroy() is necessary to stop the loop\n\t\n\t    function headlessStep() {\n\t      if (!cy._private.animationsRunning) {\n\t        return;\n\t      }\n\t\n\t      util.requestAnimationFrame(function animationStep(now) {\n\t        stepAll(now, cy);\n\t        headlessStep();\n\t      });\n\t    }\n\t\n\t    var renderer = cy.renderer();\n\t\n\t    if (renderer && renderer.beforeRender) {\n\t      // let the renderer schedule animations\n\t      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n\t        stepAll(now, cy);\n\t      }, renderer.beforeRenderPriorities.animations);\n\t    } else {\n\t      // manage the animation loop ourselves\n\t      headlessStep(); // first call\n\t    }\n\t  }\n\t\n\t};\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 60 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\t/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n\t   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n\tvar generateSpringRK4 = function () {\n\t  function springAccelerationForState(state) {\n\t    return -state.tension * state.x - state.friction * state.v;\n\t  }\n\t\n\t  function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n\t    var state = {\n\t      x: initialState.x + derivative.dx * dt,\n\t      v: initialState.v + derivative.dv * dt,\n\t      tension: initialState.tension,\n\t      friction: initialState.friction\n\t    };\n\t\n\t    return { dx: state.v, dv: springAccelerationForState(state) };\n\t  }\n\t\n\t  function springIntegrateState(state, dt) {\n\t    var a = {\n\t      dx: state.v,\n\t      dv: springAccelerationForState(state)\n\t    },\n\t        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n\t        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n\t        d = springEvaluateStateWithDerivative(state, dt, c),\n\t        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n\t        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n\t\n\t    state.x = state.x + dxdt * dt;\n\t    state.v = state.v + dvdt * dt;\n\t\n\t    return state;\n\t  }\n\t\n\t  return function springRK4Factory(tension, friction, duration) {\n\t\n\t    var initState = {\n\t      x: -1,\n\t      v: 0,\n\t      tension: null,\n\t      friction: null\n\t    },\n\t        path = [0],\n\t        time_lapsed = 0,\n\t        tolerance = 1 / 10000,\n\t        DT = 16 / 1000,\n\t        have_duration = void 0,\n\t        dt = void 0,\n\t        last_state = void 0;\n\t\n\t    tension = parseFloat(tension) || 500;\n\t    friction = parseFloat(friction) || 20;\n\t    duration = duration || null;\n\t\n\t    initState.tension = tension;\n\t    initState.friction = friction;\n\t\n\t    have_duration = duration !== null;\n\t\n\t    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\t    if (have_duration) {\n\t      /* Run the simulation without a duration. */\n\t      time_lapsed = springRK4Factory(tension, friction);\n\t      /* Compute the adjusted time delta. */\n\t      dt = time_lapsed / duration * DT;\n\t    } else {\n\t      dt = DT;\n\t    }\n\t\n\t    for (;;) {\n\t      /* Next/step function .*/\n\t      last_state = springIntegrateState(last_state || initState, dt);\n\t      /* Store the position. */\n\t      path.push(1 + last_state.x);\n\t      time_lapsed += 16;\n\t      /* If the change threshold is reached, break. */\n\t      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n\t       computed path and returns a snapshot of the position according to a given percentComplete. */\n\t    return !have_duration ? time_lapsed : function (percentComplete) {\n\t      return path[percentComplete * (path.length - 1) | 0];\n\t    };\n\t  };\n\t}();\n\t\n\tmodule.exports = generateSpringRK4;\n\t\n\t/***/ }),\n\t/* 61 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tfunction startAnimation(self, ani, now, isCore) {\n\t  var isEles = !isCore;\n\t  var ele = self;\n\t  var ani_p = ani._private;\n\t  var cy = isCore ? self : self.cy();\n\t  var style = cy.style();\n\t\n\t  if (isEles) {\n\t    var pos = ele.position();\n\t\n\t    ani_p.startPosition = ani_p.startPosition || {\n\t      x: pos.x,\n\t      y: pos.y\n\t    };\n\t\n\t    ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);\n\t  }\n\t\n\t  if (isCore) {\n\t    var pan = cy._private.pan;\n\t\n\t    ani_p.startPan = ani_p.startPan || {\n\t      x: pan.x,\n\t      y: pan.y\n\t    };\n\t\n\t    ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;\n\t  }\n\t\n\t  ani_p.started = true;\n\t  ani_p.startTime = now - ani_p.progress * ani_p.duration;\n\t}\n\t\n\tmodule.exports = startAnimation;\n\t\n\t/***/ }),\n\t/* 62 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar step = __webpack_require__(63);\n\tvar startAnimation = __webpack_require__(61);\n\t\n\tfunction stepAll(now, cy) {\n\t  var eles = cy._private.aniEles;\n\t  var doneEles = [];\n\t\n\t  function stepOne(ele, isCore) {\n\t    var _p = ele._private;\n\t    var current = _p.animation.current;\n\t    var queue = _p.animation.queue;\n\t    var ranAnis = false;\n\t\n\t    // cancel all animations on display:none ele\n\t    if (!isCore && ele.pstyle('display').value === 'none') {\n\t      // put all current and queue animations in this tick's current list\n\t      // and empty the lists for the element\n\t      current = current.splice(0, current.length).concat(queue.splice(0, queue.length));\n\t\n\t      // stop all animations\n\t      for (var i = 0; i < current.length; i++) {\n\t        current[i].stop();\n\t      }\n\t    }\n\t\n\t    // if nothing currently animating, get something from the queue\n\t    if (current.length === 0) {\n\t      var next = queue.shift();\n\t\n\t      if (next) {\n\t        current.push(next);\n\t      }\n\t    }\n\t\n\t    var callbacks = function callbacks(_callbacks) {\n\t      for (var j = _callbacks.length - 1; j >= 0; j--) {\n\t        var cb = _callbacks[j];\n\t\n\t        cb();\n\t      }\n\t\n\t      _callbacks.splice(0, _callbacks.length);\n\t    };\n\t\n\t    // step and remove if done\n\t    for (var _i = current.length - 1; _i >= 0; _i--) {\n\t      var ani = current[_i];\n\t      var ani_p = ani._private;\n\t\n\t      if (ani_p.stopped) {\n\t        current.splice(_i, 1);\n\t\n\t        ani_p.hooked = false;\n\t        ani_p.playing = false;\n\t        ani_p.started = false;\n\t\n\t        callbacks(ani_p.frames);\n\t\n\t        continue;\n\t      }\n\t\n\t      if (!ani_p.playing && !ani_p.applying) {\n\t        continue;\n\t      }\n\t\n\t      // an apply() while playing shouldn't do anything\n\t      if (ani_p.playing && ani_p.applying) {\n\t        ani_p.applying = false;\n\t      }\n\t\n\t      if (!ani_p.started) {\n\t        startAnimation(ele, ani, now, isCore);\n\t      }\n\t\n\t      step(ele, ani, now, isCore);\n\t\n\t      if (ani_p.applying) {\n\t        ani_p.applying = false;\n\t      }\n\t\n\t      callbacks(ani_p.frames);\n\t\n\t      if (ani.completed()) {\n\t        current.splice(_i, 1);\n\t\n\t        ani_p.hooked = false;\n\t        ani_p.playing = false;\n\t        ani_p.started = false;\n\t\n\t        callbacks(ani_p.completes);\n\t      }\n\t\n\t      ranAnis = true;\n\t    }\n\t\n\t    if (!isCore && current.length === 0 && queue.length === 0) {\n\t      doneEles.push(ele);\n\t    }\n\t\n\t    return ranAnis;\n\t  } // stepElement\n\t\n\t  // handle all eles\n\t  var ranEleAni = false;\n\t  for (var e = 0; e < eles.length; e++) {\n\t    var ele = eles[e];\n\t    var handledThisEle = stepOne(ele);\n\t\n\t    ranEleAni = ranEleAni || handledThisEle;\n\t  } // each element\n\t\n\t  var ranCoreAni = stepOne(cy, true);\n\t\n\t  // notify renderer\n\t  if (ranEleAni || ranCoreAni) {\n\t    if (eles.length > 0) {\n\t      eles.dirtyCompoundBoundsCache();\n\t\n\t      cy.notify({\n\t        type: 'draw',\n\t        eles: eles\n\t      });\n\t    } else {\n\t      cy.notify({\n\t        type: 'draw'\n\t      });\n\t    }\n\t  }\n\t\n\t  // remove elements from list of currently animating if its queues are empty\n\t  eles.unmerge(doneEles);\n\t\n\t  cy.emit('step');\n\t} // stepAll\n\t\n\tmodule.exports = stepAll;\n\t\n\t/***/ }),\n\t/* 63 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar easings = __webpack_require__(58);\n\tvar ease = __webpack_require__(57);\n\tvar is = __webpack_require__(0);\n\t\n\tfunction step(self, ani, now, isCore) {\n\t  var isEles = !isCore;\n\t  var _p = self._private;\n\t  var ani_p = ani._private;\n\t  var pEasing = ani_p.easing;\n\t  var startTime = ani_p.startTime;\n\t  var cy = isCore ? self : self.cy();\n\t  var style = cy.style();\n\t\n\t  if (!ani_p.easingImpl) {\n\t\n\t    if (pEasing == null) {\n\t      // use default\n\t      ani_p.easingImpl = easings['linear'];\n\t    } else {\n\t      // then define w/ name\n\t      var easingVals = void 0;\n\t\n\t      if (is.string(pEasing)) {\n\t        var easingProp = style.parse('transition-timing-function', pEasing);\n\t\n\t        easingVals = easingProp.value;\n\t      } else {\n\t        // then assume preparsed array\n\t        easingVals = pEasing;\n\t      }\n\t\n\t      var name = void 0,\n\t          args = void 0;\n\t\n\t      if (is.string(easingVals)) {\n\t        name = easingVals;\n\t        args = [];\n\t      } else {\n\t        name = easingVals[1];\n\t        args = easingVals.slice(2).map(function (n) {\n\t          return +n;\n\t        });\n\t      }\n\t\n\t      if (args.length > 0) {\n\t        // create with args\n\t        if (name === 'spring') {\n\t          args.push(ani_p.duration); // need duration to generate spring\n\t        }\n\t\n\t        ani_p.easingImpl = easings[name].apply(null, args);\n\t      } else {\n\t        // static impl by name\n\t        ani_p.easingImpl = easings[name];\n\t      }\n\t    }\n\t  }\n\t\n\t  var easing = ani_p.easingImpl;\n\t  var percent = void 0;\n\t\n\t  if (ani_p.duration === 0) {\n\t    percent = 1;\n\t  } else {\n\t    percent = (now - startTime) / ani_p.duration;\n\t  }\n\t\n\t  if (ani_p.applying) {\n\t    percent = ani_p.progress;\n\t  }\n\t\n\t  if (percent < 0) {\n\t    percent = 0;\n\t  } else if (percent > 1) {\n\t    percent = 1;\n\t  }\n\t\n\t  if (ani_p.delay == null) {\n\t    // then update\n\t\n\t    var startPos = ani_p.startPosition;\n\t    var endPos = ani_p.position;\n\t\n\t    if (endPos && isEles && !self.locked()) {\n\t      var pos = self.position();\n\t\n\t      if (valid(startPos.x, endPos.x)) {\n\t        pos.x = ease(startPos.x, endPos.x, percent, easing);\n\t      }\n\t\n\t      if (valid(startPos.y, endPos.y)) {\n\t        pos.y = ease(startPos.y, endPos.y, percent, easing);\n\t      }\n\t\n\t      self.emit('position');\n\t    }\n\t\n\t    var startPan = ani_p.startPan;\n\t    var endPan = ani_p.pan;\n\t    var pan = _p.pan;\n\t    var animatingPan = endPan != null && isCore;\n\t    if (animatingPan) {\n\t      if (valid(startPan.x, endPan.x)) {\n\t        pan.x = ease(startPan.x, endPan.x, percent, easing);\n\t      }\n\t\n\t      if (valid(startPan.y, endPan.y)) {\n\t        pan.y = ease(startPan.y, endPan.y, percent, easing);\n\t      }\n\t\n\t      self.emit('pan');\n\t    }\n\t\n\t    var startZoom = ani_p.startZoom;\n\t    var endZoom = ani_p.zoom;\n\t    var animatingZoom = endZoom != null && isCore;\n\t    if (animatingZoom) {\n\t      if (valid(startZoom, endZoom)) {\n\t        _p.zoom = ease(startZoom, endZoom, percent, easing);\n\t      }\n\t\n\t      self.emit('zoom');\n\t    }\n\t\n\t    if (animatingPan || animatingZoom) {\n\t      self.emit('viewport');\n\t    }\n\t\n\t    var props = ani_p.style;\n\t    if (props && props.length > 0 && isEles) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var prop = props[i];\n\t        var _name = prop.name;\n\t        var end = prop;\n\t        var start = ani_p.startStyle[_name];\n\t        var propSpec = style.properties[start.name];\n\t        var easedVal = ease(start, end, percent, easing, propSpec);\n\t\n\t        style.overrideBypass(self, _name, easedVal);\n\t      } // for props\n\t\n\t      self.emit('style');\n\t    } // if\n\t  }\n\t\n\t  ani_p.progress = percent;\n\t\n\t  return percent;\n\t}\n\t\n\tfunction valid(start, end) {\n\t  if (start == null || end == null) {\n\t    return false;\n\t  }\n\t\n\t  if (is.number(start) && is.number(end)) {\n\t    return true;\n\t  } else if (start && end) {\n\t    return true;\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\tmodule.exports = step;\n\t\n\t/***/ }),\n\t/* 64 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar Emitter = __webpack_require__(10);\n\tvar define = __webpack_require__(3);\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar emitterOptions = {\n\t  qualifierCompare: function qualifierCompare(selector1, selector2) {\n\t    if (selector1 == null || selector2 == null) {\n\t      return selector1 == null && selector2 == null;\n\t    } else {\n\t      return selector1.sameText(selector2);\n\t    }\n\t  },\n\t  eventMatches: function eventMatches(cy, listener, eventObj) {\n\t    var selector = listener.qualifier;\n\t\n\t    if (selector != null) {\n\t      return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);\n\t    }\n\t\n\t    return true;\n\t  },\n\t  eventFields: function eventFields(cy) {\n\t    return {\n\t      cy: cy,\n\t      target: cy\n\t    };\n\t  },\n\t  callbackContext: function callbackContext(cy, listener, eventObj) {\n\t    return listener.qualifier != null ? eventObj.target : cy;\n\t  }\n\t};\n\t\n\tvar argSelector = function argSelector(arg) {\n\t  if (is.string(arg)) {\n\t    return new Selector(arg);\n\t  } else {\n\t    return arg;\n\t  }\n\t};\n\t\n\tvar elesfn = {\n\t  createEmitter: function createEmitter() {\n\t    var _p = this._private;\n\t\n\t    if (!_p.emitter) {\n\t      _p.emitter = new Emitter(util.assign({\n\t        context: this\n\t      }, emitterOptions));\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  emitter: function emitter() {\n\t    return this._private.emitter;\n\t  },\n\t\n\t  on: function on(events, selector, callback) {\n\t    this.emitter().on(events, argSelector(selector), callback);\n\t\n\t    return this;\n\t  },\n\t\n\t  removeListener: function removeListener(events, selector, callback) {\n\t    this.emitter().removeListener(events, argSelector(selector), callback);\n\t\n\t    return this;\n\t  },\n\t\n\t  one: function one(events, selector, callback) {\n\t    this.emitter().one(events, argSelector(selector), callback);\n\t\n\t    return this;\n\t  },\n\t\n\t  once: function once(events, selector, callback) {\n\t    this.emitter().one(events, argSelector(selector), callback);\n\t\n\t    return this;\n\t  },\n\t\n\t  emit: function emit(events, extraParams) {\n\t    this.emitter().emit(events, extraParams);\n\t\n\t    return this;\n\t  }\n\t};\n\t\n\tdefine.eventAliasesOn(elesfn);\n\t\n\tmodule.exports = elesfn;\n\t\n\t/***/ }),\n\t/* 65 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar corefn = {\n\t\n\t  png: function png(options) {\n\t    var renderer = this._private.renderer;\n\t    options = options || {};\n\t\n\t    return renderer.png(options);\n\t  },\n\t\n\t  jpg: function jpg(options) {\n\t    var renderer = this._private.renderer;\n\t    options = options || {};\n\t\n\t    options.bg = options.bg || '#fff';\n\t\n\t    return renderer.jpg(options);\n\t  }\n\t\n\t};\n\t\n\tcorefn.jpeg = corefn.jpg;\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 66 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar corefn = {\n\t\n\t  layout: function layout(options) {\n\t    var cy = this;\n\t\n\t    if (options == null) {\n\t      util.error('Layout options must be specified to make a layout');\n\t      return;\n\t    }\n\t\n\t    if (options.name == null) {\n\t      util.error('A `name` must be specified to make a layout');\n\t      return;\n\t    }\n\t\n\t    var name = options.name;\n\t    var Layout = cy.extension('layout', name);\n\t\n\t    if (Layout == null) {\n\t      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');\n\t      return;\n\t    }\n\t\n\t    var eles = void 0;\n\t    if (is.string(options.eles)) {\n\t      eles = cy.$(options.eles);\n\t    } else {\n\t      eles = options.eles != null ? options.eles : cy.$();\n\t    }\n\t\n\t    var layout = new Layout(util.extend({}, options, {\n\t      cy: cy,\n\t      eles: eles\n\t    }));\n\t\n\t    return layout;\n\t  }\n\t\n\t};\n\t\n\tcorefn.createLayout = corefn.makeLayout = corefn.layout;\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 67 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar corefn = {\n\t  notify: function notify(params) {\n\t    var _p = this._private;\n\t\n\t    if (_p.batchingNotify) {\n\t      var bEles = _p.batchNotifyEles;\n\t      var bTypes = _p.batchNotifyTypes;\n\t\n\t      if (params.eles) {\n\t        bEles.merge(params.eles);\n\t      }\n\t\n\t      if (!bTypes.ids[params.type]) {\n\t        bTypes.push(params.type);\n\t        bTypes.ids[params.type] = true;\n\t      }\n\t\n\t      return; // notifications are disabled during batching\n\t    }\n\t\n\t    if (!_p.notificationsEnabled) {\n\t      return;\n\t    } // exit on disabled\n\t\n\t    var renderer = this.renderer();\n\t\n\t    // exit if destroy() called on core or renderer in between frames #1499 #1528\n\t    if (this.isDestroyed() || !renderer) {\n\t      return;\n\t    }\n\t\n\t    renderer.notify(params);\n\t  },\n\t\n\t  notifications: function notifications(bool) {\n\t    var p = this._private;\n\t\n\t    if (bool === undefined) {\n\t      return p.notificationsEnabled;\n\t    } else {\n\t      p.notificationsEnabled = bool ? true : false;\n\t    }\n\t  },\n\t\n\t  noNotifications: function noNotifications(callback) {\n\t    this.notifications(false);\n\t    callback();\n\t    this.notifications(true);\n\t  },\n\t\n\t  batching: function batching() {\n\t    return this._private.batchCount > 0;\n\t  },\n\t\n\t  startBatch: function startBatch() {\n\t    var _p = this._private;\n\t\n\t    if (_p.batchCount == null) {\n\t      _p.batchCount = 0;\n\t    }\n\t\n\t    if (_p.batchCount === 0) {\n\t      _p.batchingStyle = _p.batchingNotify = true;\n\t      _p.batchStyleEles = this.collection();\n\t      _p.batchNotifyEles = this.collection();\n\t      _p.batchNotifyTypes = [];\n\t      _p.batchNotifyTypes.ids = {};\n\t    }\n\t\n\t    _p.batchCount++;\n\t\n\t    return this;\n\t  },\n\t\n\t  endBatch: function endBatch() {\n\t    var _p = this._private;\n\t\n\t    _p.batchCount--;\n\t\n\t    if (_p.batchCount === 0) {\n\t      // update style for dirty eles\n\t      _p.batchingStyle = false;\n\t      _p.batchStyleEles.updateStyle();\n\t\n\t      // notify the renderer of queued eles and event types\n\t      _p.batchingNotify = false;\n\t      this.notify({\n\t        type: _p.batchNotifyTypes,\n\t        eles: _p.batchNotifyEles\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  batch: function batch(callback) {\n\t    this.startBatch();\n\t    callback();\n\t    this.endBatch();\n\t\n\t    return this;\n\t  },\n\t\n\t  // for backwards compatibility\n\t  batchData: function batchData(map) {\n\t    var cy = this;\n\t\n\t    return this.batch(function () {\n\t      var ids = Object.keys(map);\n\t\n\t      for (var i = 0; i < ids.length; i++) {\n\t        var id = ids[i];\n\t        var data = map[id];\n\t        var ele = cy.getElementById(id);\n\t\n\t        ele.data(data);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 68 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar corefn = {\n\t\n\t  renderTo: function renderTo(context, zoom, pan, pxRatio) {\n\t    var r = this._private.renderer;\n\t\n\t    r.renderTo(context, zoom, pan, pxRatio);\n\t    return this;\n\t  },\n\t\n\t  renderer: function renderer() {\n\t    return this._private.renderer;\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this.notify({\n\t      type: 'draw'\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  resize: function resize() {\n\t    this.invalidateSize();\n\t\n\t    this.notify({\n\t      type: 'resize'\n\t    });\n\t\n\t    this.emit('resize');\n\t\n\t    return this;\n\t  },\n\t\n\t  initRenderer: function initRenderer(options) {\n\t    var cy = this;\n\t\n\t    var RendererProto = cy.extension('renderer', options.name);\n\t    if (RendererProto == null) {\n\t      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);\n\t      return;\n\t    }\n\t\n\t    cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));\n\t\n\t    this.notify({ type: 'init' });\n\t  },\n\t\n\t  destroyRenderer: function destroyRenderer() {\n\t    var cy = this;\n\t\n\t    cy.notify({ type: 'destroy' }); // destroy the renderer\n\t\n\t    var domEle = cy.container();\n\t    if (domEle) {\n\t      domEle._cyreg = null;\n\t\n\t      while (domEle.childNodes.length > 0) {\n\t        domEle.removeChild(domEle.childNodes[0]);\n\t      }\n\t    }\n\t\n\t    cy._private.renderer = null; // to be extra safe, remove the ref\n\t  },\n\t\n\t  onRender: function onRender(fn) {\n\t    return this.on('render', fn);\n\t  },\n\t\n\t  offRender: function offRender(fn) {\n\t    return this.off('render', fn);\n\t  }\n\t\n\t};\n\t\n\tcorefn.invalidateDimensions = corefn.resize;\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 69 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Collection = __webpack_require__(7);\n\t\n\tvar corefn = {\n\t\n\t  // get a collection\n\t  // - empty collection on no args\n\t  // - collection of elements in the graph on selector arg\n\t  // - guarantee a returned collection when elements or collection specified\n\t  collection: function collection(eles, opts) {\n\t\n\t    if (is.string(eles)) {\n\t      return this.$(eles);\n\t    } else if (is.elementOrCollection(eles)) {\n\t      return eles.collection();\n\t    } else if (is.array(eles)) {\n\t      return new Collection(this, eles, opts);\n\t    }\n\t\n\t    return new Collection(this);\n\t  },\n\t\n\t  nodes: function nodes(selector) {\n\t    var nodes = this.$(function (ele) {\n\t      return ele.isNode();\n\t    });\n\t\n\t    if (selector) {\n\t      return nodes.filter(selector);\n\t    }\n\t\n\t    return nodes;\n\t  },\n\t\n\t  edges: function edges(selector) {\n\t    var edges = this.$(function (ele) {\n\t      return ele.isEdge();\n\t    });\n\t\n\t    if (selector) {\n\t      return edges.filter(selector);\n\t    }\n\t\n\t    return edges;\n\t  },\n\t\n\t  // search the graph like jQuery\n\t  $: function $(selector) {\n\t    var eles = this._private.elements;\n\t\n\t    if (selector) {\n\t      return eles.filter(selector);\n\t    } else {\n\t      return eles.spawnSelf();\n\t    }\n\t  },\n\t\n\t  mutableElements: function mutableElements() {\n\t    return this._private.elements;\n\t  }\n\t\n\t};\n\t\n\t// aliases\n\tcorefn.elements = corefn.filter = corefn.$;\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 70 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Style = __webpack_require__(18);\n\t\n\tvar corefn = {\n\t\n\t  style: function style(newStyle) {\n\t    if (newStyle) {\n\t      var s = this.setStyle(newStyle);\n\t\n\t      s.update();\n\t    }\n\t\n\t    return this._private.style;\n\t  },\n\t\n\t  setStyle: function setStyle(style) {\n\t    var _p = this._private;\n\t\n\t    if (is.stylesheet(style)) {\n\t      _p.style = style.generateStyle(this);\n\t    } else if (is.array(style)) {\n\t      _p.style = Style.fromJson(this, style);\n\t    } else if (is.string(style)) {\n\t      _p.style = Style.fromString(this, style);\n\t    } else {\n\t      _p.style = Style(this);\n\t    }\n\t\n\t    return _p.style;\n\t  }\n\t};\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 71 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar window = __webpack_require__(4);\n\tvar math = __webpack_require__(2);\n\t\n\tvar corefn = {\n\t\n\t  autolock: function autolock(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.autolock = bool ? true : false;\n\t    } else {\n\t      return this._private.autolock;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  autoungrabify: function autoungrabify(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.autoungrabify = bool ? true : false;\n\t    } else {\n\t      return this._private.autoungrabify;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  autounselectify: function autounselectify(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.autounselectify = bool ? true : false;\n\t    } else {\n\t      return this._private.autounselectify;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  panningEnabled: function panningEnabled(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.panningEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.panningEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  userPanningEnabled: function userPanningEnabled(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.userPanningEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.userPanningEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  zoomingEnabled: function zoomingEnabled(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.zoomingEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.zoomingEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  userZoomingEnabled: function userZoomingEnabled(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.userZoomingEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.userZoomingEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  boxSelectionEnabled: function boxSelectionEnabled(bool) {\n\t    if (bool !== undefined) {\n\t      this._private.boxSelectionEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.boxSelectionEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  pan: function pan() {\n\t    var args = arguments;\n\t    var pan = this._private.pan;\n\t    var dim = void 0,\n\t        val = void 0,\n\t        dims = void 0,\n\t        x = void 0,\n\t        y = void 0;\n\t\n\t    switch (args.length) {\n\t      case 0:\n\t        // .pan()\n\t        return pan;\n\t\n\t      case 1:\n\t\n\t        if (is.string(args[0])) {\n\t          // .pan('x')\n\t          dim = args[0];\n\t          return pan[dim];\n\t        } else if (is.plainObject(args[0])) {\n\t          // .pan({ x: 0, y: 100 })\n\t          if (!this._private.panningEnabled) {\n\t            return this;\n\t          }\n\t\n\t          dims = args[0];\n\t          x = dims.x;\n\t          y = dims.y;\n\t\n\t          if (is.number(x)) {\n\t            pan.x = x;\n\t          }\n\t\n\t          if (is.number(y)) {\n\t            pan.y = y;\n\t          }\n\t\n\t          this.emit('pan viewport');\n\t        }\n\t        break;\n\t\n\t      case 2:\n\t        // .pan('x', 100)\n\t        if (!this._private.panningEnabled) {\n\t          return this;\n\t        }\n\t\n\t        dim = args[0];\n\t        val = args[1];\n\t\n\t        if ((dim === 'x' || dim === 'y') && is.number(val)) {\n\t          pan[dim] = val;\n\t        }\n\t\n\t        this.emit('pan viewport');\n\t        break;\n\t\n\t      default:\n\t        break; // invalid\n\t    }\n\t\n\t    this.notify({ // notify the renderer that the viewport changed\n\t      type: 'viewport'\n\t    });\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  panBy: function panBy(arg0, arg1) {\n\t    var args = arguments;\n\t    var pan = this._private.pan;\n\t    var dim = void 0,\n\t        val = void 0,\n\t        dims = void 0,\n\t        x = void 0,\n\t        y = void 0;\n\t\n\t    if (!this._private.panningEnabled) {\n\t      return this;\n\t    }\n\t\n\t    switch (args.length) {\n\t      case 1:\n\t\n\t        if (is.plainObject(arg0)) {\n\t          // .panBy({ x: 0, y: 100 })\n\t          dims = args[0];\n\t          x = dims.x;\n\t          y = dims.y;\n\t\n\t          if (is.number(x)) {\n\t            pan.x += x;\n\t          }\n\t\n\t          if (is.number(y)) {\n\t            pan.y += y;\n\t          }\n\t\n\t          this.emit('pan viewport');\n\t        }\n\t        break;\n\t\n\t      case 2:\n\t        // .panBy('x', 100)\n\t        dim = arg0;\n\t        val = arg1;\n\t\n\t        if ((dim === 'x' || dim === 'y') && is.number(val)) {\n\t          pan[dim] += val;\n\t        }\n\t\n\t        this.emit('pan viewport');\n\t        break;\n\t\n\t      default:\n\t        break; // invalid\n\t    }\n\t\n\t    this.notify({ // notify the renderer that the viewport changed\n\t      type: 'viewport'\n\t    });\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  fit: function fit(elements, padding) {\n\t    var viewportState = this.getFitViewport(elements, padding);\n\t\n\t    if (viewportState) {\n\t      var _p = this._private;\n\t      _p.zoom = viewportState.zoom;\n\t      _p.pan = viewportState.pan;\n\t\n\t      this.emit('pan zoom viewport');\n\t\n\t      this.notify({ // notify the renderer that the viewport changed\n\t        type: 'viewport'\n\t      });\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  getFitViewport: function getFitViewport(elements, padding) {\n\t    if (is.number(elements) && padding === undefined) {\n\t      // elements is optional\n\t      padding = elements;\n\t      elements = undefined;\n\t    }\n\t\n\t    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n\t      return;\n\t    }\n\t\n\t    var bb = void 0;\n\t\n\t    if (is.string(elements)) {\n\t      var sel = elements;\n\t      elements = this.$(sel);\n\t    } else if (is.boundingBox(elements)) {\n\t      // assume bb\n\t      var bbe = elements;\n\t      bb = {\n\t        x1: bbe.x1,\n\t        y1: bbe.y1,\n\t        x2: bbe.x2,\n\t        y2: bbe.y2\n\t      };\n\t\n\t      bb.w = bb.x2 - bb.x1;\n\t      bb.h = bb.y2 - bb.y1;\n\t    } else if (!is.elementOrCollection(elements)) {\n\t      elements = this.mutableElements();\n\t    }\n\t\n\t    if (is.elementOrCollection(elements) && elements.empty()) {\n\t      return;\n\t    } // can't fit to nothing\n\t\n\t    bb = bb || elements.boundingBox();\n\t\n\t    var w = this.width();\n\t    var h = this.height();\n\t    var zoom = void 0;\n\t    padding = is.number(padding) ? padding : 0;\n\t\n\t    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n\t      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n\t\n\t      // crop zoom\n\t      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n\t      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\t\n\t      var pan = { // now pan to middle\n\t        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n\t        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n\t      };\n\t\n\t      return {\n\t        zoom: zoom,\n\t        pan: pan\n\t      };\n\t    }\n\t\n\t    return;\n\t  },\n\t\n\t  minZoom: function minZoom(zoom) {\n\t    if (zoom === undefined) {\n\t      return this._private.minZoom;\n\t    } else if (is.number(zoom)) {\n\t      this._private.minZoom = zoom;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  maxZoom: function maxZoom(zoom) {\n\t    if (zoom === undefined) {\n\t      return this._private.maxZoom;\n\t    } else if (is.number(zoom)) {\n\t      this._private.maxZoom = zoom;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  getZoomedViewport: function getZoomedViewport(params) {\n\t    var _p = this._private;\n\t    var currentPan = _p.pan;\n\t    var currentZoom = _p.zoom;\n\t    var pos = void 0; // in rendered px\n\t    var zoom = void 0;\n\t    var bail = false;\n\t\n\t    if (!_p.zoomingEnabled) {\n\t      // zooming disabled\n\t      bail = true;\n\t    }\n\t\n\t    if (is.number(params)) {\n\t      // then set the zoom\n\t      zoom = params;\n\t    } else if (is.plainObject(params)) {\n\t      // then zoom about a point\n\t      zoom = params.level;\n\t\n\t      if (params.position != null) {\n\t        pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);\n\t      } else if (params.renderedPosition != null) {\n\t        pos = params.renderedPosition;\n\t      }\n\t\n\t      if (pos != null && !_p.panningEnabled) {\n\t        // panning disabled\n\t        bail = true;\n\t      }\n\t    }\n\t\n\t    // crop zoom\n\t    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n\t    zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n\t\n\t    // can't zoom with invalid params\n\t    if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {\n\t      return null;\n\t    }\n\t\n\t    if (pos != null) {\n\t      // set zoom about position\n\t      var pan1 = currentPan;\n\t      var zoom1 = currentZoom;\n\t      var zoom2 = zoom;\n\t\n\t      var pan2 = {\n\t        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n\t        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n\t      };\n\t\n\t      return {\n\t        zoomed: true,\n\t        panned: true,\n\t        zoom: zoom2,\n\t        pan: pan2\n\t      };\n\t    } else {\n\t      // just set the zoom\n\t      return {\n\t        zoomed: true,\n\t        panned: false,\n\t        zoom: zoom,\n\t        pan: currentPan\n\t      };\n\t    }\n\t  },\n\t\n\t  zoom: function zoom(params) {\n\t    if (params === undefined) {\n\t      // get\n\t      return this._private.zoom;\n\t    } else {\n\t      // set\n\t      var vp = this.getZoomedViewport(params);\n\t      var _p = this._private;\n\t\n\t      if (vp == null || !vp.zoomed) {\n\t        return this;\n\t      }\n\t\n\t      _p.zoom = vp.zoom;\n\t\n\t      if (vp.panned) {\n\t        _p.pan.x = vp.pan.x;\n\t        _p.pan.y = vp.pan.y;\n\t      }\n\t\n\t      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n\t\n\t      this.notify({ // notify the renderer that the viewport changed\n\t        type: 'viewport'\n\t      });\n\t\n\t      return this; // chaining\n\t    }\n\t  },\n\t\n\t  viewport: function viewport(opts) {\n\t    var _p = this._private;\n\t    var zoomDefd = true;\n\t    var panDefd = true;\n\t    var events = []; // to trigger\n\t    var zoomFailed = false;\n\t    var panFailed = false;\n\t\n\t    if (!opts) {\n\t      return this;\n\t    }\n\t    if (!is.number(opts.zoom)) {\n\t      zoomDefd = false;\n\t    }\n\t    if (!is.plainObject(opts.pan)) {\n\t      panDefd = false;\n\t    }\n\t    if (!zoomDefd && !panDefd) {\n\t      return this;\n\t    }\n\t\n\t    if (zoomDefd) {\n\t      var z = opts.zoom;\n\t\n\t      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n\t        zoomFailed = true;\n\t      } else {\n\t        _p.zoom = z;\n\t\n\t        events.push('zoom');\n\t      }\n\t    }\n\t\n\t    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n\t      var p = opts.pan;\n\t\n\t      if (is.number(p.x)) {\n\t        _p.pan.x = p.x;\n\t        panFailed = false;\n\t      }\n\t\n\t      if (is.number(p.y)) {\n\t        _p.pan.y = p.y;\n\t        panFailed = false;\n\t      }\n\t\n\t      if (!panFailed) {\n\t        events.push('pan');\n\t      }\n\t    }\n\t\n\t    if (events.length > 0) {\n\t      events.push('viewport');\n\t      this.emit(events.join(' '));\n\t\n\t      this.notify({\n\t        type: 'viewport'\n\t      });\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  center: function center(elements) {\n\t    var pan = this.getCenterPan(elements);\n\t\n\t    if (pan) {\n\t      this._private.pan = pan;\n\t\n\t      this.emit('pan viewport');\n\t\n\t      this.notify({ // notify the renderer that the viewport changed\n\t        type: 'viewport'\n\t      });\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  getCenterPan: function getCenterPan(elements, zoom) {\n\t    if (!this._private.panningEnabled) {\n\t      return;\n\t    }\n\t\n\t    if (is.string(elements)) {\n\t      var selector = elements;\n\t      elements = this.mutableElements().filter(selector);\n\t    } else if (!is.elementOrCollection(elements)) {\n\t      elements = this.mutableElements();\n\t    }\n\t\n\t    if (elements.length === 0) {\n\t      return;\n\t    } // can't centre pan to nothing\n\t\n\t    var bb = elements.boundingBox();\n\t    var w = this.width();\n\t    var h = this.height();\n\t    zoom = zoom === undefined ? this._private.zoom : zoom;\n\t\n\t    var pan = { // middle\n\t      x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n\t      y: (h - zoom * (bb.y1 + bb.y2)) / 2\n\t    };\n\t\n\t    return pan;\n\t  },\n\t\n\t  reset: function reset() {\n\t    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n\t      return this;\n\t    }\n\t\n\t    this.viewport({\n\t      pan: { x: 0, y: 0 },\n\t      zoom: 1\n\t    });\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  invalidateSize: function invalidateSize() {\n\t    this._private.sizeCache = null;\n\t  },\n\t\n\t  size: function size() {\n\t    var _p = this._private;\n\t    var container = _p.container;\n\t\n\t    return _p.sizeCache = _p.sizeCache || (container ? function () {\n\t      var style = window.getComputedStyle(container);\n\t      var val = function val(name) {\n\t        return parseFloat(style.getPropertyValue(name));\n\t      };\n\t\n\t      return {\n\t        width: container.clientWidth - val('padding-left') - val('padding-right'),\n\t        height: container.clientHeight - val('padding-top') - val('padding-bottom')\n\t      };\n\t    }() : { // fallback if no container (not 0 b/c can be used for dividing etc)\n\t      width: 1,\n\t      height: 1\n\t    });\n\t  },\n\t\n\t  width: function width() {\n\t    return this.size().width;\n\t  },\n\t\n\t  height: function height() {\n\t    return this.size().height;\n\t  },\n\t\n\t  extent: function extent() {\n\t    var pan = this._private.pan;\n\t    var zoom = this._private.zoom;\n\t    var rb = this.renderedExtent();\n\t\n\t    var b = {\n\t      x1: (rb.x1 - pan.x) / zoom,\n\t      x2: (rb.x2 - pan.x) / zoom,\n\t      y1: (rb.y1 - pan.y) / zoom,\n\t      y2: (rb.y2 - pan.y) / zoom\n\t    };\n\t\n\t    b.w = b.x2 - b.x1;\n\t    b.h = b.y2 - b.y1;\n\t\n\t    return b;\n\t  },\n\t\n\t  renderedExtent: function renderedExtent() {\n\t    var width = this.width();\n\t    var height = this.height();\n\t\n\t    return {\n\t      x1: 0,\n\t      y1: 0,\n\t      x2: width,\n\t      y2: height,\n\t      w: width,\n\t      h: height\n\t    };\n\t  }\n\t};\n\t\n\t// aliases\n\tcorefn.centre = corefn.center;\n\t\n\t// backwards compatibility\n\tcorefn.autolockNodes = corefn.autolock;\n\tcorefn.autoungrabifyNodes = corefn.autoungrabify;\n\t\n\tmodule.exports = corefn;\n\t\n\t/***/ }),\n\t/* 72 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar Animation = __webpack_require__(23);\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\t\n\tvar define = {\n\t\n\t  animated: function animated() {\n\t    return function animatedImpl() {\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return false;\n\t      }\n\t\n\t      var ele = all[0];\n\t\n\t      if (ele) {\n\t        return ele._private.animation.current.length > 0;\n\t      }\n\t    };\n\t  }, // animated\n\t\n\t  clearQueue: function clearQueue() {\n\t    return function clearQueueImpl() {\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      for (var i = 0; i < all.length; i++) {\n\t        var ele = all[i];\n\t        ele._private.animation.queue = [];\n\t      }\n\t\n\t      return this;\n\t    };\n\t  }, // clearQueue\n\t\n\t  delay: function delay() {\n\t    return function delayImpl(time, complete) {\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      return this.animate({\n\t        delay: time,\n\t        duration: time,\n\t        complete: complete\n\t      });\n\t    };\n\t  }, // delay\n\t\n\t  delayAnimation: function delayAnimation() {\n\t    return function delayAnimationImpl(time, complete) {\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      return this.animation({\n\t        delay: time,\n\t        duration: time,\n\t        complete: complete\n\t      });\n\t    };\n\t  }, // delay\n\t\n\t  animation: function animation() {\n\t    return function animationImpl(properties, params) {\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t      var isCore = !selfIsArrayLike;\n\t      var isEles = !isCore;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      var style = cy.style();\n\t\n\t      properties = util.assign({}, properties, params);\n\t\n\t      var propertiesEmpty = Object.keys(properties).length === 0;\n\t\n\t      if (propertiesEmpty) {\n\t        return new Animation(all[0], properties); // nothing to animate\n\t      }\n\t\n\t      if (properties.duration === undefined) {\n\t        properties.duration = 400;\n\t      }\n\t\n\t      switch (properties.duration) {\n\t        case 'slow':\n\t          properties.duration = 600;\n\t          break;\n\t        case 'fast':\n\t          properties.duration = 200;\n\t          break;\n\t      }\n\t\n\t      if (isEles) {\n\t        properties.style = style.getPropsList(properties.style || properties.css);\n\t\n\t        properties.css = undefined;\n\t      }\n\t\n\t      if (isEles && properties.renderedPosition != null) {\n\t        var rpos = properties.renderedPosition;\n\t        var pan = cy.pan();\n\t        var zoom = cy.zoom();\n\t\n\t        properties.position = math.renderedToModelPosition(rpos, zoom, pan);\n\t      }\n\t\n\t      // override pan w/ panBy if set\n\t      if (isCore && properties.panBy != null) {\n\t        var panBy = properties.panBy;\n\t        var cyPan = cy.pan();\n\t\n\t        properties.pan = {\n\t          x: cyPan.x + panBy.x,\n\t          y: cyPan.y + panBy.y\n\t        };\n\t      }\n\t\n\t      // override pan w/ center if set\n\t      var center = properties.center || properties.centre;\n\t      if (isCore && center != null) {\n\t        var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n\t\n\t        if (centerPan != null) {\n\t          properties.pan = centerPan;\n\t        }\n\t      }\n\t\n\t      // override pan & zoom w/ fit if set\n\t      if (isCore && properties.fit != null) {\n\t        var fit = properties.fit;\n\t        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n\t\n\t        if (fitVp != null) {\n\t          properties.pan = fitVp.pan;\n\t          properties.zoom = fitVp.zoom;\n\t        }\n\t      }\n\t\n\t      // override zoom (& potentially pan) w/ zoom obj if set\n\t      if (isCore && is.plainObject(properties.zoom)) {\n\t        var vp = cy.getZoomedViewport(properties.zoom);\n\t\n\t        if (vp != null) {\n\t          if (vp.zoomed) {\n\t            properties.zoom = vp.zoom;\n\t          }\n\t\n\t          if (vp.panned) {\n\t            properties.pan = vp.pan;\n\t          }\n\t        }\n\t      }\n\t\n\t      return new Animation(all[0], properties);\n\t    };\n\t  }, // animate\n\t\n\t  animate: function animate() {\n\t    return function animateImpl(properties, params) {\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      if (params) {\n\t        properties = util.extend({}, properties, params);\n\t      }\n\t\n\t      // manually hook and run the animation\n\t      for (var i = 0; i < all.length; i++) {\n\t        var ele = all[i];\n\t        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n\t\n\t        var ani = ele.animation(properties, queue ? { queue: true } : undefined);\n\t\n\t        ani.play();\n\t      }\n\t\n\t      return this; // chaining\n\t    };\n\t  }, // animate\n\t\n\t  stop: function stop() {\n\t    return function stopImpl(clearQueue, jumpToEnd) {\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if (!cy.styleEnabled()) {\n\t        return this;\n\t      }\n\t\n\t      for (var i = 0; i < all.length; i++) {\n\t        var ele = all[i];\n\t        var _p = ele._private;\n\t        var anis = _p.animation.current;\n\t\n\t        for (var j = 0; j < anis.length; j++) {\n\t          var ani = anis[j];\n\t          var ani_p = ani._private;\n\t\n\t          if (jumpToEnd) {\n\t            // next iteration of the animation loop, the animation\n\t            // will go straight to the end and be removed\n\t            ani_p.duration = 0;\n\t          }\n\t        }\n\t\n\t        // clear the queue of future animations\n\t        if (clearQueue) {\n\t          _p.animation.queue = [];\n\t        }\n\t\n\t        if (!jumpToEnd) {\n\t          _p.animation.current = [];\n\t        }\n\t      }\n\t\n\t      // we have to notify (the animation loop doesn't do it for us on `stop`)\n\t      cy.notify({\n\t        eles: this,\n\t        type: 'draw'\n\t      });\n\t\n\t      return this;\n\t    };\n\t  } // stop\n\t\n\t}; // define\n\t\n\tmodule.exports = define;\n\t\n\t/***/ }),\n\t/* 73 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar define = {\n\t\n\t  // access data field\n\t  data: function data(params) {\n\t    var defaults = {\n\t      field: 'data',\n\t      bindingEvent: 'data',\n\t      allowBinding: false,\n\t      allowSetting: false,\n\t      allowGetting: false,\n\t      settingEvent: 'data',\n\t      settingTriggersEvent: false,\n\t      triggerFnName: 'trigger',\n\t      immutableKeys: {}, // key => true if immutable\n\t      updateStyle: false,\n\t      beforeGet: function beforeGet(self) {},\n\t      beforeSet: function beforeSet(self, obj) {},\n\t      onSet: function onSet(self) {},\n\t      canSet: function canSet(self) {\n\t        return true;\n\t      }\n\t    };\n\t    params = util.extend({}, defaults, params);\n\t\n\t    return function dataImpl(name, value) {\n\t      var p = params;\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t      var single = selfIsArrayLike ? self[0] : self;\n\t\n\t      // .data('foo', ...)\n\t      if (is.string(name)) {\n\t        // set or get property\n\t\n\t        // .data('foo')\n\t        if (p.allowGetting && value === undefined) {\n\t          // get\n\t\n\t          var ret = void 0;\n\t          if (single) {\n\t            p.beforeGet(single);\n\t\n\t            ret = single._private[p.field][name];\n\t          }\n\t          return ret;\n\t\n\t          // .data('foo', 'bar')\n\t        } else if (p.allowSetting && value !== undefined) {\n\t          // set\n\t          var valid = !p.immutableKeys[name];\n\t          if (valid) {\n\t            var change = _defineProperty({}, name, value);\n\t\n\t            p.beforeSet(self, change);\n\t\n\t            for (var i = 0, l = all.length; i < l; i++) {\n\t              var ele = all[i];\n\t\n\t              if (p.canSet(ele)) {\n\t                ele._private[p.field][name] = value;\n\t              }\n\t            }\n\t\n\t            // update mappers if asked\n\t            if (p.updateStyle) {\n\t              self.updateStyle();\n\t            }\n\t\n\t            // call onSet callback\n\t            p.onSet(self);\n\t\n\t            if (p.settingTriggersEvent) {\n\t              self[p.triggerFnName](p.settingEvent);\n\t            }\n\t          }\n\t        }\n\t\n\t        // .data({ 'foo': 'bar' })\n\t      } else if (p.allowSetting && is.plainObject(name)) {\n\t        // extend\n\t        var obj = name;\n\t        var k = void 0,\n\t            v = void 0;\n\t        var keys = Object.keys(obj);\n\t\n\t        p.beforeSet(self, obj);\n\t\n\t        for (var _i = 0; _i < keys.length; _i++) {\n\t          k = keys[_i];\n\t          v = obj[k];\n\t\n\t          var _valid = !p.immutableKeys[k];\n\t          if (_valid) {\n\t            for (var j = 0; j < all.length; j++) {\n\t              var _ele = all[j];\n\t\n\t              if (p.canSet(_ele)) {\n\t                _ele._private[p.field][k] = v;\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        // update mappers if asked\n\t        if (p.updateStyle) {\n\t          self.updateStyle();\n\t        }\n\t\n\t        // call onSet callback\n\t        p.onSet(self);\n\t\n\t        if (p.settingTriggersEvent) {\n\t          self[p.triggerFnName](p.settingEvent);\n\t        }\n\t\n\t        // .data(function(){ ... })\n\t      } else if (p.allowBinding && is.fn(name)) {\n\t        // bind to event\n\t        var fn = name;\n\t        self.on(p.bindingEvent, fn);\n\t\n\t        // .data()\n\t      } else if (p.allowGetting && name === undefined) {\n\t        // get whole object\n\t        var _ret = void 0;\n\t        if (single) {\n\t          p.beforeGet(single);\n\t\n\t          _ret = single._private[p.field];\n\t        }\n\t        return _ret;\n\t      }\n\t\n\t      return self; // maintain chainability\n\t    }; // function\n\t  }, // data\n\t\n\t  // remove data field\n\t  removeData: function removeData(params) {\n\t    var defaults = {\n\t      field: 'data',\n\t      event: 'data',\n\t      triggerFnName: 'trigger',\n\t      triggerEvent: false,\n\t      immutableKeys: {} // key => true if immutable\n\t    };\n\t    params = util.extend({}, defaults, params);\n\t\n\t    return function removeDataImpl(names) {\n\t      var p = params;\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\t\n\t      // .removeData('foo bar')\n\t      if (is.string(names)) {\n\t        // then get the list of keys, and delete them\n\t        var keys = names.split(/\\s+/);\n\t        var l = keys.length;\n\t\n\t        for (var i = 0; i < l; i++) {\n\t          // delete each non-empty key\n\t          var key = keys[i];\n\t          if (is.emptyString(key)) {\n\t            continue;\n\t          }\n\t\n\t          var valid = !p.immutableKeys[key]; // not valid if immutable\n\t          if (valid) {\n\t            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n\t              all[i_a]._private[p.field][key] = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (p.triggerEvent) {\n\t          self[p.triggerFnName](p.event);\n\t        }\n\t\n\t        // .removeData()\n\t      } else if (names === undefined) {\n\t        // then delete all keys\n\t\n\t        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n\t          var _privateFields = all[_i_a]._private[p.field];\n\t          var _keys = Object.keys(_privateFields);\n\t\n\t          for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n\t            var _key = _keys[_i2];\n\t            var validKeyToDelete = !p.immutableKeys[_key];\n\t\n\t            if (validKeyToDelete) {\n\t              _privateFields[_key] = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (p.triggerEvent) {\n\t          self[p.triggerFnName](p.event);\n\t        }\n\t      }\n\t\n\t      return self; // maintain chaining\n\t    }; // function\n\t  } // removeData\n\t}; // define\n\t\n\tmodule.exports = define;\n\t\n\t/***/ }),\n\t/* 74 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar Promise = __webpack_require__(5);\n\t\n\tvar define = {\n\t\n\t  eventAliasesOn: function eventAliasesOn(proto) {\n\t    var p = proto;\n\t\n\t    p.addListener = p.listen = p.bind = p.on;\n\t    p.unlisten = p.unbind = p.off = p.removeListener;\n\t    p.trigger = p.emit;\n\t\n\t    // this is just a wrapper alias of .on()\n\t    p.pon = p.promiseOn = function (events, selector) {\n\t      var self = this;\n\t      var args = Array.prototype.slice.call(arguments, 0);\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        var callback = function callback(e) {\n\t          self.off.apply(self, offArgs);\n\t\n\t          resolve(e);\n\t        };\n\t\n\t        var onArgs = args.concat([callback]);\n\t        var offArgs = onArgs.concat([]);\n\t\n\t        self.on.apply(self, onArgs);\n\t      });\n\t    };\n\t  }\n\t\n\t}; // define\n\t\n\tmodule.exports = define;\n\t\n\t/***/ }),\n\t/* 75 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = [{\n\t  type: 'layout',\n\t  extensions: __webpack_require__(81)\n\t}, {\n\t  type: 'renderer',\n\t  extensions: __webpack_require__(114)\n\t}];\n\t\n\t/***/ }),\n\t/* 76 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n\t  padding: 30, // padding on fit\n\t  circle: false, // put depths in concentric circles if true, put depths top down if false\n\t  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n\t  roots: undefined, // the roots of the trees\n\t  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled,\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\t};\n\t\n\tfunction BreadthFirstLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tBreadthFirstLayout.prototype.run = function () {\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not(':parent');\n\t  var graph = eles;\n\t\n\t  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  });\n\t\n\t  var roots = void 0;\n\t  if (is.elementOrCollection(options.roots)) {\n\t    roots = options.roots;\n\t  } else if (is.array(options.roots)) {\n\t    var rootsArray = [];\n\t\n\t    for (var i = 0; i < options.roots.length; i++) {\n\t      var id = options.roots[i];\n\t      var ele = cy.getElementById(id);\n\t      rootsArray.push(ele);\n\t    }\n\t\n\t    roots = cy.collection(rootsArray);\n\t  } else if (is.string(options.roots)) {\n\t    roots = cy.$(options.roots);\n\t  } else {\n\t    if (options.directed) {\n\t      roots = nodes.roots();\n\t    } else {\n\t      var components = [];\n\t      var unhandledNodes = nodes;\n\t\n\t      var _loop = function _loop() {\n\t        var currComp = cy.collection();\n\t\n\t        eles.bfs({\n\t          roots: unhandledNodes[0],\n\t          visit: function visit(node, edge, pNode, i, depth) {\n\t            currComp = currComp.add(node);\n\t          },\n\t          directed: false\n\t        });\n\t\n\t        unhandledNodes = unhandledNodes.not(currComp);\n\t        components.push(currComp);\n\t      };\n\t\n\t      while (unhandledNodes.length > 0) {\n\t        _loop();\n\t      }\n\t\n\t      roots = cy.collection();\n\t\n\t      var _loop2 = function _loop2(_i) {\n\t        var comp = components[_i];\n\t        var maxDegree = comp.maxDegree(false);\n\t        var compRoots = comp.filter(function (ele) {\n\t          return ele.degree(false) === maxDegree;\n\t        });\n\t\n\t        roots = roots.add(compRoots);\n\t      };\n\t\n\t      for (var _i = 0; _i < components.length; _i++) {\n\t        _loop2(_i);\n\t      }\n\t    }\n\t  }\n\t\n\t  var depths = [];\n\t  var foundByBfs = {};\n\t  var id2depth = {};\n\t  var prevNode = {};\n\t  var prevEdge = {};\n\t  var successors = {};\n\t\n\t  // find the depths of the nodes\n\t  graph.bfs({\n\t    roots: roots,\n\t    directed: options.directed,\n\t    visit: function visit(node, edge, pNode, i, depth) {\n\t      var ele = node[0];\n\t      var id = ele.id();\n\t\n\t      if (!depths[depth]) {\n\t        depths[depth] = [];\n\t      }\n\t\n\t      depths[depth].push(ele);\n\t      foundByBfs[id] = true;\n\t      id2depth[id] = depth;\n\t      prevNode[id] = pNode;\n\t      prevEdge[id] = edge;\n\t\n\t      if (pNode) {\n\t        var prevId = pNode.id();\n\t        var succ = successors[prevId] = successors[prevId] || [];\n\t\n\t        succ.push(node);\n\t      }\n\t    }\n\t  });\n\t\n\t  // check for nodes not found by bfs\n\t  var orphanNodes = [];\n\t  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n\t    var _ele = nodes[_i2];\n\t\n\t    if (foundByBfs[_ele.id()]) {\n\t      continue;\n\t    } else {\n\t      orphanNodes.push(_ele);\n\t    }\n\t  }\n\t\n\t  // assign orphan nodes a depth from their neighborhood\n\t  var maxChecks = orphanNodes.length * 3;\n\t  var checks = 0;\n\t  while (orphanNodes.length !== 0 && checks < maxChecks) {\n\t    var node = orphanNodes.shift();\n\t    var neighbors = node.neighborhood().nodes();\n\t    var assignedDepth = false;\n\t\n\t    for (var _i3 = 0; _i3 < neighbors.length; _i3++) {\n\t      var depth = id2depth[neighbors[_i3].id()];\n\t\n\t      if (depth !== undefined) {\n\t        depths[depth].push(node);\n\t        assignedDepth = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!assignedDepth) {\n\t      orphanNodes.push(node);\n\t    }\n\t\n\t    checks++;\n\t  }\n\t\n\t  // assign orphan nodes that are still left to the depth of their subgraph\n\t  while (orphanNodes.length !== 0) {\n\t    var _node = orphanNodes.shift();\n\t    //let subgraph = graph.bfs( node ).path;\n\t    var _assignedDepth = false;\n\t\n\t    // for( let i = 0; i < subgraph.length; i++ ){\n\t    //   let depth = id2depth[ subgraph[i].id() ];\n\t\n\t    //   if( depth !== undefined ){\n\t    //     depths[depth].push( node );\n\t    //     assignedDepth = true;\n\t    //     break;\n\t    //   }\n\t    // }\n\t\n\t    if (!_assignedDepth) {\n\t      // worst case if the graph really isn't tree friendly, then just dump it in 0\n\t      if (depths.length === 0) {\n\t        depths.push([]);\n\t      }\n\t\n\t      depths[0].push(_node);\n\t    }\n\t  }\n\t\n\t  // assign the nodes a depth and index\n\t  var assignDepthsToEles = function assignDepthsToEles() {\n\t    for (var _i4 = 0; _i4 < depths.length; _i4++) {\n\t      var _eles = depths[_i4];\n\t\n\t      for (var j = 0; j < _eles.length; j++) {\n\t        var _ele2 = _eles[j];\n\t\n\t        if (_ele2 == null) {\n\t          _eles.splice(j, 1);\n\t          j--;\n\t          continue;\n\t        }\n\t\n\t        _ele2._private.scratch.breadthfirst = {\n\t          depth: _i4,\n\t          index: j\n\t        };\n\t      }\n\t    }\n\t  };\n\t  assignDepthsToEles();\n\t\n\t  var intersectsDepth = function intersectsDepth(node) {\n\t    // returns true if has edges pointing in from a higher depth\n\t    var edges = node.connectedEdges(function (ele) {\n\t      return ele.data('target') === node.id();\n\t    });\n\t    var thisInfo = node._private.scratch.breadthfirst;\n\t    var highestDepthOfOther = 0;\n\t    var highestOther = void 0;\n\t    for (var _i5 = 0; _i5 < edges.length; _i5++) {\n\t      var edge = edges[_i5];\n\t      var otherNode = edge.source()[0];\n\t      var otherInfo = otherNode._private.scratch.breadthfirst;\n\t\n\t      if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {\n\t        highestDepthOfOther = otherInfo.depth;\n\t        highestOther = otherNode;\n\t      }\n\t    }\n\t\n\t    return highestOther;\n\t  };\n\t\n\t  // make maximal if so set by adjusting depths\n\t  for (var adj = 0; adj < options.maximalAdjustments; adj++) {\n\t\n\t    var nDepths = depths.length;\n\t    var elesToMove = [];\n\t    for (var _i6 = 0; _i6 < nDepths; _i6++) {\n\t      var _depth = depths[_i6];\n\t\n\t      var nDepth = _depth.length;\n\t      for (var j = 0; j < nDepth; j++) {\n\t        var _ele3 = _depth[j];\n\t        var info = _ele3._private.scratch.breadthfirst;\n\t        var intEle = intersectsDepth(_ele3);\n\t\n\t        if (intEle) {\n\t          info.intEle = intEle;\n\t          elesToMove.push(_ele3);\n\t        }\n\t      }\n\t    }\n\t\n\t    for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {\n\t      var _ele4 = elesToMove[_i7];\n\t      var _info = _ele4._private.scratch.breadthfirst;\n\t      var _intEle = _info.intEle;\n\t      var intInfo = _intEle._private.scratch.breadthfirst;\n\t\n\t      depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)\n\t\n\t      // add to end of new depth\n\t      var newDepth = intInfo.depth + 1;\n\t      while (newDepth > depths.length - 1) {\n\t        depths.push([]);\n\t      }\n\t      depths[newDepth].push(_ele4);\n\t\n\t      _info.depth = newDepth;\n\t      _info.index = depths[newDepth].length - 1;\n\t    }\n\t\n\t    assignDepthsToEles();\n\t  }\n\t\n\t  // find min distance we need to leave between nodes\n\t  var minDistance = 0;\n\t  if (options.avoidOverlap) {\n\t    for (var _i8 = 0; _i8 < nodes.length; _i8++) {\n\t      var n = nodes[_i8];\n\t      var nbb = n.layoutDimensions(options);\n\t      var w = nbb.w;\n\t      var h = nbb.h;\n\t\n\t      minDistance = Math.max(minDistance, w, h);\n\t    }\n\t  }\n\t\n\t  // get the weighted percent for an element based on its connectivity to other levels\n\t  var cachedWeightedPercent = {};\n\t  var getWeightedPercent = function getWeightedPercent(ele) {\n\t    if (cachedWeightedPercent[ele.id()]) {\n\t      return cachedWeightedPercent[ele.id()];\n\t    }\n\t\n\t    var eleDepth = ele._private.scratch.breadthfirst.depth;\n\t    var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);\n\t    var percent = 0;\n\t    var samples = 0;\n\t\n\t    for (var _i9 = 0; _i9 < neighbors.length; _i9++) {\n\t      var neighbor = neighbors[_i9];\n\t      var bf = neighbor._private.scratch.breadthfirst;\n\t      var index = bf.index;\n\t      var _depth2 = bf.depth;\n\t      var _nDepth = depths[_depth2].length;\n\t\n\t      if (eleDepth > _depth2 || eleDepth === 0) {\n\t        // only get influenced by elements above\n\t        percent += index / _nDepth;\n\t        samples++;\n\t      }\n\t    }\n\t\n\t    samples = Math.max(1, samples);\n\t    percent = percent / samples;\n\t\n\t    if (samples === 0) {\n\t      // so lone nodes have a \"don't care\" state in sorting\n\t      percent = undefined;\n\t    }\n\t\n\t    cachedWeightedPercent[ele.id()] = percent;\n\t    return percent;\n\t  };\n\t\n\t  // rearrange the indices in each depth level based on connectivity\n\t\n\t  var sortFn = function sortFn(a, b) {\n\t    var apct = getWeightedPercent(a);\n\t    var bpct = getWeightedPercent(b);\n\t\n\t    return apct - bpct;\n\t  };\n\t\n\t  for (var times = 0; times < 3; times++) {\n\t    // do it a few times b/c the depths are dynamic and we want a more stable result\n\t\n\t    for (var _i10 = 0; _i10 < depths.length; _i10++) {\n\t      depths[_i10] = depths[_i10].sort(sortFn);\n\t    }\n\t    assignDepthsToEles(); // and update\n\t  }\n\t\n\t  var biggestDepthSize = 0;\n\t  for (var _i11 = 0; _i11 < depths.length; _i11++) {\n\t    biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);\n\t  }\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.x1 + bb.h / 2\n\t  };\n\t\n\t  var getPosition = function getPosition(ele, isBottomDepth) {\n\t    var info = ele._private.scratch.breadthfirst;\n\t    var depth = info.depth;\n\t    var index = info.index;\n\t    var depthSize = depths[depth].length;\n\t\n\t    var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);\n\t    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n\t    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n\t    radiusStepSize = Math.max(radiusStepSize, minDistance);\n\t\n\t    if (!options.circle) {\n\t\n\t      var epos = {\n\t        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n\t        y: (depth + 1) * distanceY\n\t      };\n\t\n\t      if (isBottomDepth) {\n\t        return epos;\n\t      }\n\t\n\t      // let succs = successors[ ele.id() ];\n\t      // if( succs ){\n\t      //   epos.x = 0;\n\t      //\n\t      //   for( let i = 0 ; i < succs.length; i++ ){\n\t      //     let spos = pos[ succs[i].id() ];\n\t      //\n\t      //     epos.x += spos.x;\n\t      //   }\n\t      //\n\t      //   epos.x /= succs.length;\n\t      // } else {\n\t      //   //debugger;\n\t      // }\n\t\n\t      return epos;\n\t    } else {\n\t      if (options.circle) {\n\t        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n\t        var theta = 2 * Math.PI / depths[depth].length * index;\n\t\n\t        if (depth === 0 && depths[0].length === 1) {\n\t          radius = 1;\n\t        }\n\t\n\t        return {\n\t          x: center.x + radius * Math.cos(theta),\n\t          y: center.y + radius * Math.sin(theta)\n\t        };\n\t      } else {\n\t        return {\n\t          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n\t          y: (depth + 1) * distanceY\n\t        };\n\t      }\n\t    }\n\t  };\n\t\n\t  // get positions in reverse depth order\n\t  var pos = {};\n\t  for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {\n\t    var _depth3 = depths[_i12];\n\t\n\t    for (var _j = 0; _j < _depth3.length; _j++) {\n\t      var _node2 = _depth3[_j];\n\t\n\t      pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);\n\t    }\n\t  }\n\t\n\t  nodes.layoutPositions(this, options, function (node) {\n\t    return pos[node.id()];\n\t  });\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = BreadthFirstLayout;\n\t\n\t/***/ }),\n\t/* 77 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // the padding on fit\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n\t  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n\t  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n\t  radius: undefined, // the radius of the circle\n\t  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n\t  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n\t  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n\t  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\t\n\t};\n\t\n\tfunction CircleLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tCircleLayout.prototype.run = function () {\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t\n\t  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\t\n\t  var nodes = eles.nodes().not(':parent');\n\t\n\t  if (options.sort) {\n\t    nodes = nodes.sort(options.sort);\n\t  }\n\t\n\t  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  });\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.y1 + bb.h / 2\n\t  };\n\t\n\t  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n\t  var dTheta = sweep / Math.max(1, nodes.length - 1);\n\t  var r = void 0;\n\t\n\t  var minDistance = 0;\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    var n = nodes[i];\n\t    var nbb = n.layoutDimensions(options);\n\t    var w = nbb.w;\n\t    var h = nbb.h;\n\t\n\t    minDistance = Math.max(minDistance, w, h);\n\t  }\n\t\n\t  if (is.number(options.radius)) {\n\t    r = options.radius;\n\t  } else if (nodes.length <= 1) {\n\t    r = 0;\n\t  } else {\n\t    r = Math.min(bb.h, bb.w) / 2 - minDistance;\n\t  }\n\t\n\t  // calculate the radius\n\t  if (nodes.length > 1 && options.avoidOverlap) {\n\t    // but only if more than one node (can't overlap)\n\t    minDistance *= 1.75; // just to have some nice spacing\n\t\n\t    var dcos = Math.cos(dTheta) - Math.cos(0);\n\t    var dsin = Math.sin(dTheta) - Math.sin(0);\n\t    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\t    r = Math.max(rMin, r);\n\t  }\n\t\n\t  var getPos = function getPos(ele, i) {\n\t    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n\t\n\t    var rx = r * Math.cos(theta);\n\t    var ry = r * Math.sin(theta);\n\t    var pos = {\n\t      x: center.x + rx,\n\t      y: center.y + ry\n\t    };\n\t\n\t    return pos;\n\t  };\n\t\n\t  nodes.layoutPositions(this, options, getPos);\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = CircleLayout;\n\t\n\t/***/ }),\n\t/* 78 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // the padding on fit\n\t  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n\t  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n\t  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n\t  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n\t  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n\t  height: undefined, // height of layout area (overrides container height)\n\t  width: undefined, // width of layout area (overrides container width)\n\t  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n\t  concentric: function concentric(node) {\n\t    // returns numeric value for each node, placing higher nodes in levels towards the centre\n\t    return node.degree();\n\t  },\n\t  levelWidth: function levelWidth(nodes) {\n\t    // the letiation of concentric values in each level\n\t    return nodes.maxDegree() / 4;\n\t  },\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\t};\n\t\n\tfunction ConcentricLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tConcentricLayout.prototype.run = function () {\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\t\n\t  var cy = params.cy;\n\t\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not(':parent');\n\t\n\t  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  });\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.y1 + bb.h / 2\n\t  };\n\t\n\t  var nodeValues = []; // { node, value }\n\t  var theta = options.startAngle;\n\t  var maxNodeSize = 0;\n\t\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    var node = nodes[i];\n\t    var value = void 0;\n\t\n\t    // calculate the node value\n\t    value = options.concentric(node);\n\t    nodeValues.push({\n\t      value: value,\n\t      node: node\n\t    });\n\t\n\t    // for style mapping\n\t    node._private.scratch.concentric = value;\n\t  }\n\t\n\t  // in case we used the `concentric` in style\n\t  nodes.updateStyle();\n\t\n\t  // calculate max size now based on potentially updated mappers\n\t  for (var _i = 0; _i < nodes.length; _i++) {\n\t    var _node = nodes[_i];\n\t    var nbb = _node.layoutDimensions(options);\n\t\n\t    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n\t  }\n\t\n\t  // sort node values in descreasing order\n\t  nodeValues.sort(function (a, b) {\n\t    return b.value - a.value;\n\t  });\n\t\n\t  var levelWidth = options.levelWidth(nodes);\n\t\n\t  // put the values into levels\n\t  var levels = [[]];\n\t  var currentLevel = levels[0];\n\t  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n\t    var val = nodeValues[_i2];\n\t\n\t    if (currentLevel.length > 0) {\n\t      var diff = Math.abs(currentLevel[0].value - val.value);\n\t\n\t      if (diff >= levelWidth) {\n\t        currentLevel = [];\n\t        levels.push(currentLevel);\n\t      }\n\t    }\n\t\n\t    currentLevel.push(val);\n\t  }\n\t\n\t  // create positions from levels\n\t\n\t  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\t\n\t  if (!options.avoidOverlap) {\n\t    // then strictly constrain to bb\n\t    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n\t    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n\t    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n\t\n\t    minDist = Math.min(minDist, rStep);\n\t  }\n\t\n\t  // find the metrics for each level\n\t  var r = 0;\n\t  for (var _i3 = 0; _i3 < levels.length; _i3++) {\n\t    var level = levels[_i3];\n\t    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n\t    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n\t\n\t    // calculate the radius\n\t    if (level.length > 1 && options.avoidOverlap) {\n\t      // but only if more than one node (can't overlap)\n\t      var dcos = Math.cos(dTheta) - Math.cos(0);\n\t      var dsin = Math.sin(dTheta) - Math.sin(0);\n\t      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\t\n\t      r = Math.max(rMin, r);\n\t    }\n\t\n\t    level.r = r;\n\t\n\t    r += minDist;\n\t  }\n\t\n\t  if (options.equidistant) {\n\t    var rDeltaMax = 0;\n\t    var _r = 0;\n\t\n\t    for (var _i4 = 0; _i4 < levels.length; _i4++) {\n\t      var _level = levels[_i4];\n\t      var rDelta = _level.r - _r;\n\t\n\t      rDeltaMax = Math.max(rDeltaMax, rDelta);\n\t    }\n\t\n\t    _r = 0;\n\t    for (var _i5 = 0; _i5 < levels.length; _i5++) {\n\t      var _level2 = levels[_i5];\n\t\n\t      if (_i5 === 0) {\n\t        _r = _level2.r;\n\t      }\n\t\n\t      _level2.r = _r;\n\t\n\t      _r += rDeltaMax;\n\t    }\n\t  }\n\t\n\t  // calculate the node positions\n\t  var pos = {}; // id => position\n\t  for (var _i6 = 0; _i6 < levels.length; _i6++) {\n\t    var _level3 = levels[_i6];\n\t    var _dTheta = _level3.dTheta;\n\t    var _r2 = _level3.r;\n\t\n\t    for (var j = 0; j < _level3.length; j++) {\n\t      var _val = _level3[j];\n\t      var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n\t\n\t      var p = {\n\t        x: center.x + _r2 * Math.cos(_theta),\n\t        y: center.y + _r2 * Math.sin(_theta)\n\t      };\n\t\n\t      pos[_val.node.id()] = p;\n\t    }\n\t  }\n\t\n\t  // position the nodes\n\t  nodes.layoutPositions(this, options, function (ele) {\n\t    var id = ele.id();\n\t\n\t    return pos[id];\n\t  });\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = ConcentricLayout;\n\t\n\t/***/ }),\n\t/* 79 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\tThe CoSE layout was written by Gerardo Huck.\n\thttps://www.linkedin.com/in/gerardohuck/\n\t\n\tBased on the following article:\n\thttp://dl.acm.org/citation.cfm?id=1498047\n\t\n\tModifications tracked on Github.\n\t*/\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\tvar Promise = __webpack_require__(5);\n\t\n\tvar DEBUG;\n\t\n\t/**\n\t * @brief :  default layout options\n\t */\n\tvar defaults = {\n\t  // Called on `layoutready`\n\t  ready: function ready() {},\n\t\n\t  // Called on `layoutstop`\n\t  stop: function stop() {},\n\t\n\t  // Whether to animate while running the layout\n\t  // true : Animate continuously as the layout is running\n\t  // false : Just show the end result\n\t  // 'end' : Animate with the end result, from the initial positions to the end positions\n\t  animate: true,\n\t\n\t  // Easing of the animation for animate:'end'\n\t  animationEasing: undefined,\n\t\n\t  // The duration of the animation for animate:'end'\n\t  animationDuration: undefined,\n\t\n\t  // A function that determines whether the node should be animated\n\t  // All nodes animated by default on animate enabled\n\t  // Non-animated nodes are positioned immediately when the layout starts\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  },\n\t\n\t  // The layout animates only after this many milliseconds for animate:true\n\t  // (prevents flashing on fast runs)\n\t  animationThreshold: 250,\n\t\n\t  // Number of iterations between consecutive screen positions update\n\t  // (0 -> only updated on the end)\n\t  refresh: 20,\n\t\n\t  // Whether to fit the network view after when done\n\t  fit: true,\n\t\n\t  // Padding on fit\n\t  padding: 30,\n\t\n\t  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  boundingBox: undefined,\n\t\n\t  // Excludes the label when calculating node bounding boxes for the layout algorithm\n\t  nodeDimensionsIncludeLabels: false,\n\t\n\t  // Randomize the initial positions of the nodes (true) or use existing positions (false)\n\t  randomize: false,\n\t\n\t  // Extra spacing between components in non-compound graphs\n\t  componentSpacing: 40,\n\t\n\t  // Node repulsion (non overlapping) multiplier\n\t  nodeRepulsion: function nodeRepulsion(node) {\n\t    return 2048;\n\t  },\n\t\n\t  // Node repulsion (overlapping) multiplier\n\t  nodeOverlap: 4,\n\t\n\t  // Ideal edge (non nested) length\n\t  idealEdgeLength: function idealEdgeLength(edge) {\n\t    return 32;\n\t  },\n\t\n\t  // Divisor to compute edge forces\n\t  edgeElasticity: function edgeElasticity(edge) {\n\t    return 32;\n\t  },\n\t\n\t  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n\t  nestingFactor: 1.2,\n\t\n\t  // Gravity force (constant)\n\t  gravity: 1,\n\t\n\t  // Maximum number of iterations to perform\n\t  numIter: 1000,\n\t\n\t  // Initial temperature (maximum node displacement)\n\t  initialTemp: 1000,\n\t\n\t  // Cooling factor (how the temperature is reduced between consecutive iterations\n\t  coolingFactor: 0.99,\n\t\n\t  // Lower temperature threshold (below this point the layout will end)\n\t  minTemp: 1.0,\n\t\n\t  // Pass a reference to weaver to use threads for calculations\n\t  weaver: false\n\t};\n\t\n\t/**\n\t * @brief       : constructor\n\t * @arg options : object containing layout options\n\t */\n\tfunction CoseLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t\n\t  this.options.layout = this;\n\t}\n\t\n\t/**\n\t * @brief : runs the layout\n\t */\n\tCoseLayout.prototype.run = function () {\n\t  var options = this.options;\n\t  var cy = options.cy;\n\t  var layout = this;\n\t  var thread = this.thread;\n\t  var Thread = options.weaver ? options.weaver.Thread : null;\n\t\n\t  var falseThread = { // use false thread as polyfill\n\t    listeners: [],\n\t    on: function on(e, cb) {\n\t      this.listeners.push({ event: e, callback: cb });\n\t\n\t      return this;\n\t    },\n\t    trigger: function trigger(e) {\n\t      if (is.string(e)) {\n\t        e = { type: e };\n\t      }\n\t\n\t      var matchesEvent = function matchesEvent(l) {\n\t        return l.event === e.type;\n\t      };\n\t      var trigger = function trigger(l) {\n\t        l.callback(e);\n\t      };\n\t\n\t      this.listeners.filter(matchesEvent).forEach(trigger);\n\t\n\t      return this;\n\t    },\n\t    pass: function pass(data) {\n\t      this.pass = data;\n\t\n\t      return this;\n\t    },\n\t    run: function run(cb) {\n\t      var pass = this.pass;\n\t\n\t      return new Promise(function (resolve) {\n\t        resolve(cb(pass));\n\t      });\n\t    },\n\t    stop: function stop() {\n\t      return this;\n\t    }\n\t  };\n\t\n\t  function broadcast(message) {\n\t    // for false thread\n\t    var e = { type: 'message', message: message };\n\t\n\t    falseThread.trigger(e);\n\t  }\n\t\n\t  if (!thread || thread.stopped()) {\n\t    thread = this.thread = Thread ? new Thread() : falseThread;\n\t  }\n\t\n\t  layout.stopped = false;\n\t\n\t  if (options.animate === true || options.animate === false) {\n\t    layout.emit({ type: 'layoutstart', layout: layout });\n\t  }\n\t\n\t  // Set DEBUG - Global variable\n\t  if (true === options.debug) {\n\t    DEBUG = true;\n\t  } else {\n\t    DEBUG = false;\n\t  }\n\t\n\t  // Initialize layout info\n\t  var layoutInfo = createLayoutInfo(cy, layout, options);\n\t\n\t  // Show LayoutInfo contents if debugging\n\t  if (DEBUG) {\n\t    printLayoutInfo(layoutInfo);\n\t  }\n\t\n\t  // If required, randomize node positions\n\t  if (options.randomize) {\n\t    randomizePositions(layoutInfo, cy);\n\t  }\n\t\n\t  var startTime = Date.now();\n\t  var refreshRequested = false;\n\t  var refresh = function refresh(rOpts) {\n\t    rOpts = rOpts || {};\n\t\n\t    if (refreshRequested && !rOpts.next) {\n\t      return;\n\t    }\n\t\n\t    if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {\n\t      return;\n\t    }\n\t\n\t    refreshRequested = true;\n\t\n\t    util.requestAnimationFrame(function () {\n\t      refreshPositions(layoutInfo, cy, options);\n\t\n\t      // Fit the graph if necessary\n\t      if (true === options.fit) {\n\t        cy.fit(options.padding);\n\t      }\n\t\n\t      refreshRequested = false;\n\t\n\t      if (rOpts.next) {\n\t        rOpts.next();\n\t      }\n\t    });\n\t  };\n\t\n\t  thread.on('message', function (e) {\n\t    var layoutNodes = e.message;\n\t\n\t    layoutInfo.layoutNodes = layoutNodes;\n\t    refresh();\n\t  });\n\t\n\t  thread.pass({\n\t    layoutInfo: layoutInfo,\n\t    options: {\n\t      animate: options.animate,\n\t      refresh: options.refresh,\n\t      componentSpacing: options.componentSpacing,\n\t      nodeOverlap: options.nodeOverlap,\n\t      nestingFactor: options.nestingFactor,\n\t      gravity: options.gravity,\n\t      numIter: options.numIter,\n\t      initialTemp: options.initialTemp,\n\t      coolingFactor: options.coolingFactor,\n\t      minTemp: options.minTemp\n\t    }\n\t  }).run(function (pass) {\n\t    var layoutInfo = pass.layoutInfo;\n\t    var options = pass.options;\n\t    var stopped = false;\n\t\n\t    /**\n\t     * @brief          : Performs one iteration of the physical simulation\n\t     * @arg layoutInfo : LayoutInfo object already initialized\n\t     * @arg cy         : Cytoscape object\n\t     * @arg options    : Layout options\n\t     */\n\t    var step = function step(layoutInfo, options, _step) {\n\t      // var s = \"\\n\\n###############################\";\n\t      // s += \"\\nSTEP: \" + step;\n\t      // s += \"\\n###############################\\n\";\n\t      // logDebug(s);\n\t\n\t      // Calculate node repulsions\n\t      calculateNodeForces(layoutInfo, options);\n\t      // Calculate edge forces\n\t      calculateEdgeForces(layoutInfo, options);\n\t      // Calculate gravity forces\n\t      calculateGravityForces(layoutInfo, options);\n\t      // Propagate forces from parent to child\n\t      propagateForces(layoutInfo, options);\n\t      // Update positions based on calculated forces\n\t      updatePositions(layoutInfo, options);\n\t    };\n\t\n\t    /**\n\t     * @brief : Computes the node repulsion forces\n\t     */\n\t    var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n\t      // Go through each of the graphs in graphSet\n\t      // Nodes only repel each other if they belong to the same graph\n\t      // var s = 'calculateNodeForces';\n\t      // logDebug(s);\n\t      for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n\t        var graph = layoutInfo.graphSet[i];\n\t        var numNodes = graph.length;\n\t\n\t        // s = \"Set: \" + graph.toString();\n\t        // logDebug(s);\n\t\n\t        // Now get all the pairs of nodes\n\t        // Only get each pair once, (A, B) = (B, A)\n\t        for (var j = 0; j < numNodes; j++) {\n\t          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\t\n\t          for (var k = j + 1; k < numNodes; k++) {\n\t            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n\t\n\t            nodeRepulsion(node1, node2, layoutInfo, options);\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var randomDistance = function randomDistance(max) {\n\t      return -max + 2 * max * Math.random();\n\t    };\n\t\n\t    /**\n\t     * @brief : Compute the node repulsion forces between a pair of nodes\n\t     */\n\t    var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n\t      // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\t\n\t      var cmptId1 = node1.cmptId;\n\t      var cmptId2 = node2.cmptId;\n\t\n\t      if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n\t        return;\n\t      }\n\t\n\t      // Get direction of line connecting both node centers\n\t      var directionX = node2.positionX - node1.positionX;\n\t      var directionY = node2.positionY - node1.positionY;\n\t      var maxRandDist = 1;\n\t      // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\t\n\t      // If both centers are the same, apply a random force\n\t      if (0 === directionX && 0 === directionY) {\n\t        directionX = randomDistance(maxRandDist);\n\t        directionY = randomDistance(maxRandDist);\n\t      }\n\t\n\t      var overlap = nodesOverlap(node1, node2, directionX, directionY);\n\t\n\t      if (overlap > 0) {\n\t        // s += \"\\nNodes DO overlap.\";\n\t        // s += \"\\nOverlap: \" + overlap;\n\t        // If nodes overlap, repulsion force is proportional\n\t        // to the overlap\n\t        var force = options.nodeOverlap * overlap;\n\t\n\t        // Compute the module and components of the force vector\n\t        var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n\t        // s += \"\\nDistance: \" + distance;\n\t        var forceX = force * directionX / distance;\n\t        var forceY = force * directionY / distance;\n\t      } else {\n\t        // s += \"\\nNodes do NOT overlap.\";\n\t        // If there's no overlap, force is inversely proportional\n\t        // to squared distance\n\t\n\t        // Get clipping points for both nodes\n\t        var point1 = findClippingPoint(node1, directionX, directionY);\n\t        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n\t\n\t        // Use clipping points to compute distance\n\t        var distanceX = point2.x - point1.x;\n\t        var distanceY = point2.y - point1.y;\n\t        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n\t        var distance = Math.sqrt(distanceSqr);\n\t        // s += \"\\nDistance: \" + distance;\n\t\n\t        // Compute the module and components of the force vector\n\t        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n\t        var forceX = force * distanceX / distance;\n\t        var forceY = force * distanceY / distance;\n\t      }\n\t\n\t      // Apply force\n\t      if (!node1.isLocked) {\n\t        node1.offsetX -= forceX;\n\t        node1.offsetY -= forceY;\n\t      }\n\t\n\t      if (!node2.isLocked) {\n\t        node2.offsetX += forceX;\n\t        node2.offsetY += forceY;\n\t      }\n\t\n\t      // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n\t      // logDebug(s);\n\t\n\t      return;\n\t    };\n\t\n\t    /**\n\t     * @brief  : Determines whether two nodes overlap or not\n\t     * @return : Amount of overlapping (0 => no overlap)\n\t     */\n\t    var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n\t\n\t      if (dX > 0) {\n\t        var overlapX = node1.maxX - node2.minX;\n\t      } else {\n\t        var overlapX = node2.maxX - node1.minX;\n\t      }\n\t\n\t      if (dY > 0) {\n\t        var overlapY = node1.maxY - node2.minY;\n\t      } else {\n\t        var overlapY = node2.maxY - node1.minY;\n\t      }\n\t\n\t      if (overlapX >= 0 && overlapY >= 0) {\n\t        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n\t      } else {\n\t        return 0;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Finds the point in which an edge (direction dX, dY) intersects\n\t     *          the rectangular bounding box of it's source/target node\n\t     */\n\t    var findClippingPoint = function findClippingPoint(node, dX, dY) {\n\t\n\t      // Shorcuts\n\t      var X = node.positionX;\n\t      var Y = node.positionY;\n\t      var H = node.height || 1;\n\t      var W = node.width || 1;\n\t      var dirSlope = dY / dX;\n\t      var nodeSlope = H / W;\n\t\n\t      // var s = 'Computing clipping point of node ' + node.id +\n\t      //   \" . Height:  \" + H + \", Width: \" + W +\n\t      //   \"\\nDirection \" + dX + \", \" + dY;\n\t      //\n\t      // Compute intersection\n\t      var res = {};\n\t\n\t      // Case: Vertical direction (up)\n\t      if (0 === dX && 0 < dY) {\n\t        res.x = X;\n\t        // s += \"\\nUp direction\";\n\t        res.y = Y + H / 2;\n\t\n\t        return res;\n\t      }\n\t\n\t      // Case: Vertical direction (down)\n\t      if (0 === dX && 0 > dY) {\n\t        res.x = X;\n\t        res.y = Y + H / 2;\n\t        // s += \"\\nDown direction\";\n\t\n\t        return res;\n\t      }\n\t\n\t      // Case: Intersects the right border\n\t      if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n\t        res.x = X + W / 2;\n\t        res.y = Y + W * dY / 2 / dX;\n\t        // s += \"\\nRightborder\";\n\t\n\t        return res;\n\t      }\n\t\n\t      // Case: Intersects the left border\n\t      if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n\t        res.x = X - W / 2;\n\t        res.y = Y - W * dY / 2 / dX;\n\t        // s += \"\\nLeftborder\";\n\t\n\t        return res;\n\t      }\n\t\n\t      // Case: Intersects the top border\n\t      if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n\t        res.x = X + H * dX / 2 / dY;\n\t        res.y = Y + H / 2;\n\t        // s += \"\\nTop border\";\n\t\n\t        return res;\n\t      }\n\t\n\t      // Case: Intersects the bottom border\n\t      if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n\t        res.x = X - H * dX / 2 / dY;\n\t        res.y = Y - H / 2;\n\t        // s += \"\\nBottom border\";\n\t\n\t        return res;\n\t      }\n\t\n\t      // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n\t      // logDebug(s);\n\t      return res;\n\t    };\n\t\n\t    /**\n\t     * @brief : Calculates all edge forces\n\t     */\n\t    var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n\t      // Iterate over all edges\n\t      for (var i = 0; i < layoutInfo.edgeSize; i++) {\n\t        // Get edge, source & target nodes\n\t        var edge = layoutInfo.layoutEdges[i];\n\t        var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n\t        var source = layoutInfo.layoutNodes[sourceIx];\n\t        var targetIx = layoutInfo.idToIndex[edge.targetId];\n\t        var target = layoutInfo.layoutNodes[targetIx];\n\t\n\t        // Get direction of line connecting both node centers\n\t        var directionX = target.positionX - source.positionX;\n\t        var directionY = target.positionY - source.positionY;\n\t\n\t        // If both centers are the same, do nothing.\n\t        // A random force has already been applied as node repulsion\n\t        if (0 === directionX && 0 === directionY) {\n\t          continue;\n\t        }\n\t\n\t        // Get clipping points for both nodes\n\t        var point1 = findClippingPoint(source, directionX, directionY);\n\t        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n\t\n\t        var lx = point2.x - point1.x;\n\t        var ly = point2.y - point1.y;\n\t        var l = Math.sqrt(lx * lx + ly * ly);\n\t\n\t        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n\t\n\t        if (0 !== l) {\n\t          var forceX = force * lx / l;\n\t          var forceY = force * ly / l;\n\t        } else {\n\t          var forceX = 0;\n\t          var forceY = 0;\n\t        }\n\t\n\t        // Add this force to target and source nodes\n\t        if (!source.isLocked) {\n\t          source.offsetX += forceX;\n\t          source.offsetY += forceY;\n\t        }\n\t\n\t        if (!target.isLocked) {\n\t          target.offsetX -= forceX;\n\t          target.offsetY -= forceY;\n\t        }\n\t\n\t        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n\t        // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n\t        // logDebug(s);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Computes gravity forces for all nodes\n\t     */\n\t    var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n\t      var distThreshold = 1;\n\t\n\t      // var s = 'calculateGravityForces';\n\t      // logDebug(s);\n\t      for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n\t        var graph = layoutInfo.graphSet[i];\n\t        var numNodes = graph.length;\n\t\n\t        // s = \"Set: \" + graph.toString();\n\t        // logDebug(s);\n\t\n\t        // Compute graph center\n\t        if (0 === i) {\n\t          var centerX = layoutInfo.clientHeight / 2;\n\t          var centerY = layoutInfo.clientWidth / 2;\n\t        } else {\n\t          // Get Parent node for this graph, and use its position as center\n\t          var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n\t          var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n\t          var centerX = parent.positionX;\n\t          var centerY = parent.positionY;\n\t        }\n\t        // s = \"Center found at: \" + centerX + \", \" + centerY;\n\t        // logDebug(s);\n\t\n\t        // Apply force to all nodes in graph\n\t        for (var j = 0; j < numNodes; j++) {\n\t          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\t          // s = \"Node: \" + node.id;\n\t\n\t          if (node.isLocked) {\n\t            continue;\n\t          }\n\t\n\t          var dx = centerX - node.positionX;\n\t          var dy = centerY - node.positionY;\n\t          var d = Math.sqrt(dx * dx + dy * dy);\n\t          if (d > distThreshold) {\n\t            var fx = options.gravity * dx / d;\n\t            var fy = options.gravity * dy / d;\n\t            node.offsetX += fx;\n\t            node.offsetY += fy;\n\t            // s += \": Applied force: \" + fx + \", \" + fy;\n\t          } else {}\n\t            // s += \": skypped since it's too close to center\";\n\t\n\t            // logDebug(s);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief          : This function propagates the existing offsets from\n\t     *                   parent nodes to its descendents.\n\t     * @arg layoutInfo : layoutInfo Object\n\t     * @arg cy         : cytoscape Object\n\t     * @arg options    : Layout options\n\t     */\n\t    var propagateForces = function propagateForces(layoutInfo, options) {\n\t      // Inline implementation of a queue, used for traversing the graph in BFS order\n\t      var queue = [];\n\t      var start = 0; // Points to the start the queue\n\t      var end = -1; // Points to the end of the queue\n\t\n\t      // logDebug('propagateForces');\n\t\n\t      // Start by visiting the nodes in the root graph\n\t      queue.push.apply(queue, layoutInfo.graphSet[0]);\n\t      end += layoutInfo.graphSet[0].length;\n\t\n\t      // Traverse the graph, level by level,\n\t      while (start <= end) {\n\t        // Get the node to visit and remove it from queue\n\t        var nodeId = queue[start++];\n\t        var nodeIndex = layoutInfo.idToIndex[nodeId];\n\t        var node = layoutInfo.layoutNodes[nodeIndex];\n\t        var children = node.children;\n\t\n\t        // We only need to process the node if it's compound\n\t        if (0 < children.length && !node.isLocked) {\n\t          var offX = node.offsetX;\n\t          var offY = node.offsetY;\n\t\n\t          // var s = \"Propagating offset from parent node : \" + node.id +\n\t          //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n\t          // s += \"\\n Children: \" + children.toString();\n\t          // logDebug(s);\n\t\n\t          for (var i = 0; i < children.length; i++) {\n\t            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n\t            // Propagate offset\n\t            childNode.offsetX += offX;\n\t            childNode.offsetY += offY;\n\t            // Add children to queue to be visited\n\t            queue[++end] = children[i];\n\t          }\n\t\n\t          // Reset parent offsets\n\t          node.offsetX = 0;\n\t          node.offsetY = 0;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Updates the layout model positions, based on\n\t     *          the accumulated forces\n\t     */\n\t    var updatePositions = function updatePositions(layoutInfo, options) {\n\t      // var s = 'Updating positions';\n\t      // logDebug(s);\n\t\n\t      // Reset boundaries for compound nodes\n\t      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t        var n = layoutInfo.layoutNodes[i];\n\t        if (0 < n.children.length) {\n\t          // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n\t          n.maxX = undefined;\n\t          n.minX = undefined;\n\t          n.maxY = undefined;\n\t          n.minY = undefined;\n\t        }\n\t      }\n\t\n\t      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t        var n = layoutInfo.layoutNodes[i];\n\t        if (0 < n.children.length || n.isLocked) {\n\t          // No need to set compound or locked node position\n\t          // logDebug(\"Skipping position update of node: \" + n.id);\n\t          continue;\n\t        }\n\t        // s = \"Node: \" + n.id + \" Previous position: (\" +\n\t        // n.positionX + \", \" + n.positionY + \").\";\n\t\n\t        // Limit displacement in order to improve stability\n\t        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n\t        n.positionX += tempForce.x;\n\t        n.positionY += tempForce.y;\n\t        n.offsetX = 0;\n\t        n.offsetY = 0;\n\t        n.minX = n.positionX - n.width;\n\t        n.maxX = n.positionX + n.width;\n\t        n.minY = n.positionY - n.height;\n\t        n.maxY = n.positionY + n.height;\n\t        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n\t        // logDebug(s);\n\t\n\t        // Update ancestry boudaries\n\t        updateAncestryBoundaries(n, layoutInfo);\n\t      }\n\t\n\t      // Update size, position of compund nodes\n\t      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t        var n = layoutInfo.layoutNodes[i];\n\t        if (0 < n.children.length && !n.isLocked) {\n\t          n.positionX = (n.maxX + n.minX) / 2;\n\t          n.positionY = (n.maxY + n.minY) / 2;\n\t          n.width = n.maxX - n.minX;\n\t          n.height = n.maxY - n.minY;\n\t          // s = \"Updating position, size of compound node \" + n.id;\n\t          // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n\t          // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n\t          // logDebug(s);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Limits a force (forceX, forceY) to be not\n\t     *          greater (in modulo) than max.\n\t     8          Preserves force direction.\n\t     */\n\t    var limitForce = function limitForce(forceX, forceY, max) {\n\t      // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n\t      var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\t\n\t      if (force > max) {\n\t        var res = {\n\t          x: max * forceX / force,\n\t          y: max * forceY / force\n\t        };\n\t      } else {\n\t        var res = {\n\t          x: forceX,\n\t          y: forceY\n\t        };\n\t      }\n\t\n\t      // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n\t      // logDebug(s);\n\t\n\t      return res;\n\t    };\n\t\n\t    /**\n\t     * @brief : Function used for keeping track of compound node\n\t     *          sizes, since they should bound all their subnodes.\n\t     */\n\t    var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n\t      // var s = \"Propagating new position/size of node \" + node.id;\n\t      var parentId = node.parentId;\n\t      if (null == parentId) {\n\t        // If there's no parent, we are done\n\t        // s += \". No parent node.\";\n\t        // logDebug(s);\n\t        return;\n\t      }\n\t\n\t      // Get Parent Node\n\t      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n\t      var flag = false;\n\t\n\t      // MaxX\n\t      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n\t        p.maxX = node.maxX + p.padRight;\n\t        flag = true;\n\t        // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n\t      }\n\t\n\t      // MinX\n\t      if (null == p.minX || node.minX - p.padLeft < p.minX) {\n\t        p.minX = node.minX - p.padLeft;\n\t        flag = true;\n\t        // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n\t      }\n\t\n\t      // MaxY\n\t      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n\t        p.maxY = node.maxY + p.padBottom;\n\t        flag = true;\n\t        // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n\t      }\n\t\n\t      // MinY\n\t      if (null == p.minY || node.minY - p.padTop < p.minY) {\n\t        p.minY = node.minY - p.padTop;\n\t        flag = true;\n\t        // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n\t      }\n\t\n\t      // If updated boundaries, propagate changes upward\n\t      if (flag) {\n\t        // logDebug(s);\n\t        return updateAncestryBoundaries(p, layoutInfo);\n\t      }\n\t\n\t      // s += \". No changes in boundaries/position of parent node \" + p.id;\n\t      // logDebug(s);\n\t      return;\n\t    };\n\t\n\t    var separateComponents = function separateComponents(layutInfo, options) {\n\t      var nodes = layoutInfo.layoutNodes;\n\t      var components = [];\n\t\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        var node = nodes[i];\n\t        var cid = node.cmptId;\n\t        var component = components[cid] = components[cid] || [];\n\t\n\t        component.push(node);\n\t      }\n\t\n\t      var totalA = 0;\n\t\n\t      for (var i = 0; i < components.length; i++) {\n\t        var c = components[i];\n\t\n\t        if (!c) {\n\t          continue;\n\t        }\n\t\n\t        c.x1 = Infinity;\n\t        c.x2 = -Infinity;\n\t        c.y1 = Infinity;\n\t        c.y2 = -Infinity;\n\t\n\t        for (var j = 0; j < c.length; j++) {\n\t          var n = c[j];\n\t\n\t          c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n\t          c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n\t          c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n\t          c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n\t        }\n\t\n\t        c.w = c.x2 - c.x1;\n\t        c.h = c.y2 - c.y1;\n\t\n\t        totalA += c.w * c.h;\n\t      }\n\t\n\t      components.sort(function (c1, c2) {\n\t        return c2.w * c2.h - c1.w * c1.h;\n\t      });\n\t\n\t      var x = 0;\n\t      var y = 0;\n\t      var usedW = 0;\n\t      var rowH = 0;\n\t      var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\t\n\t      for (var i = 0; i < components.length; i++) {\n\t        var c = components[i];\n\t\n\t        if (!c) {\n\t          continue;\n\t        }\n\t\n\t        for (var j = 0; j < c.length; j++) {\n\t          var n = c[j];\n\t\n\t          if (!n.isLocked) {\n\t            n.positionX += x;\n\t            n.positionY += y;\n\t          }\n\t        }\n\t\n\t        x += c.w + options.componentSpacing;\n\t        usedW += c.w + options.componentSpacing;\n\t        rowH = Math.max(rowH, c.h);\n\t\n\t        if (usedW > maxRowW) {\n\t          y += rowH + options.componentSpacing;\n\t          x = 0;\n\t          usedW = 0;\n\t          rowH = 0;\n\t        }\n\t      }\n\t    };\n\t\n\t    var mainLoop = function mainLoop(i) {\n\t      if (stopped) {\n\t        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n\t        return false;\n\t      }\n\t\n\t      // Do one step in the phisical simulation\n\t      step(layoutInfo, options, i);\n\t\n\t      // Update temperature\n\t      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n\t      // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\t\n\t      if (layoutInfo.temperature < options.minTemp) {\n\t        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n\t        return false;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    var i = 0;\n\t    var loopRet;\n\t\n\t    do {\n\t      var f = 0;\n\t\n\t      while (f < options.refresh && i < options.numIter) {\n\t        var loopRet = mainLoop(i);\n\t        if (!loopRet) {\n\t          break;\n\t        }\n\t\n\t        f++;\n\t        i++;\n\t      }\n\t\n\t      if (options.animate === true) {\n\t        broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef\n\t      }\n\t    } while (loopRet && i + 1 < options.numIter);\n\t\n\t    separateComponents(layoutInfo, options);\n\t\n\t    return layoutInfo;\n\t  }).then(function (layoutInfoUpdated) {\n\t    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions\n\t\n\t    thread.stop();\n\t    done();\n\t  });\n\t\n\t  var done = function done() {\n\t    if (options.animate === true || options.animate === false) {\n\t      refresh({\n\t        force: true,\n\t        next: function next() {\n\t          // Layout has finished\n\t          layout.one('layoutstop', options.stop);\n\t          layout.emit({ type: 'layoutstop', layout: layout });\n\t        }\n\t      });\n\t    } else {\n\t      options.eles.nodes().layoutPositions(layout, options, function (node) {\n\t        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\t\n\t        return { x: lnode.positionX, y: lnode.positionY };\n\t      });\n\t    }\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t/**\n\t * @brief : called on continuous layouts to stop them before they finish\n\t */\n\tCoseLayout.prototype.stop = function () {\n\t  this.stopped = true;\n\t\n\t  if (this.thread) {\n\t    this.thread.stop();\n\t  }\n\t\n\t  this.emit('layoutstop');\n\t\n\t  return this; // chaining\n\t};\n\t\n\tCoseLayout.prototype.destroy = function () {\n\t  if (this.thread) {\n\t    this.thread.stop();\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\t/**\n\t * @brief     : Creates an object which is contains all the data\n\t *              used in the layout process\n\t * @arg cy    : cytoscape.js object\n\t * @return    : layoutInfo object initialized\n\t */\n\tvar createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n\t  // Shortcut\n\t  var edges = options.eles.edges();\n\t  var nodes = options.eles.nodes();\n\t\n\t  var layoutInfo = {\n\t    isCompound: cy.hasCompoundNodes(),\n\t    layoutNodes: [],\n\t    idToIndex: {},\n\t    nodeSize: nodes.size(),\n\t    graphSet: [],\n\t    indexToGraph: [],\n\t    layoutEdges: [],\n\t    edgeSize: edges.size(),\n\t    temperature: options.initialTemp,\n\t    clientWidth: cy.width(),\n\t    clientHeight: cy.width(),\n\t    boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t    })\n\t  };\n\t\n\t  var components = options.eles.components();\n\t  var id2cmptId = {};\n\t\n\t  for (var i = 0; i < components.length; i++) {\n\t    var component = components[i];\n\t\n\t    for (var j = 0; j < component.length; j++) {\n\t      var node = component[j];\n\t\n\t      id2cmptId[node.id()] = i;\n\t    }\n\t  }\n\t\n\t  // Iterate over all nodes, creating layout nodes\n\t  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t    var n = nodes[i];\n\t    var nbb = n.layoutDimensions(options);\n\t\n\t    var tempNode = {};\n\t    tempNode.isLocked = n.locked();\n\t    tempNode.id = n.data('id');\n\t    tempNode.parentId = n.data('parent');\n\t    tempNode.cmptId = id2cmptId[n.id()];\n\t    tempNode.children = [];\n\t    tempNode.positionX = n.position('x');\n\t    tempNode.positionY = n.position('y');\n\t    tempNode.offsetX = 0;\n\t    tempNode.offsetY = 0;\n\t    tempNode.height = nbb.w;\n\t    tempNode.width = nbb.h;\n\t    tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n\t    tempNode.minX = tempNode.positionX - tempNode.width / 2;\n\t    tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n\t    tempNode.minY = tempNode.positionY - tempNode.height / 2;\n\t    tempNode.padLeft = parseFloat(n.style('padding'));\n\t    tempNode.padRight = parseFloat(n.style('padding'));\n\t    tempNode.padTop = parseFloat(n.style('padding'));\n\t    tempNode.padBottom = parseFloat(n.style('padding'));\n\t\n\t    // forces\n\t    tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n\t\n\t    // Add new node\n\t    layoutInfo.layoutNodes.push(tempNode);\n\t    // Add entry to id-index map\n\t    layoutInfo.idToIndex[tempNode.id] = i;\n\t  }\n\t\n\t  // Inline implementation of a queue, used for traversing the graph in BFS order\n\t  var queue = [];\n\t  var start = 0; // Points to the start the queue\n\t  var end = -1; // Points to the end of the queue\n\t\n\t  var tempGraph = [];\n\t\n\t  // Second pass to add child information and\n\t  // initialize queue for hierarchical traversal\n\t  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t    var n = layoutInfo.layoutNodes[i];\n\t    var p_id = n.parentId;\n\t    // Check if node n has a parent node\n\t    if (null != p_id) {\n\t      // Add node Id to parent's list of children\n\t      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n\t    } else {\n\t      // If a node doesn't have a parent, then it's in the root graph\n\t      queue[++end] = n.id;\n\t      tempGraph.push(n.id);\n\t    }\n\t  }\n\t\n\t  // Add root graph to graphSet\n\t  layoutInfo.graphSet.push(tempGraph);\n\t\n\t  // Traverse the graph, level by level,\n\t  while (start <= end) {\n\t    // Get the node to visit and remove it from queue\n\t    var node_id = queue[start++];\n\t    var node_ix = layoutInfo.idToIndex[node_id];\n\t    var node = layoutInfo.layoutNodes[node_ix];\n\t    var children = node.children;\n\t    if (children.length > 0) {\n\t      // Add children nodes as a new graph to graph set\n\t      layoutInfo.graphSet.push(children);\n\t      // Add children to que queue to be visited\n\t      for (var i = 0; i < children.length; i++) {\n\t        queue[++end] = children[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  // Create indexToGraph map\n\t  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n\t    var graph = layoutInfo.graphSet[i];\n\t    for (var j = 0; j < graph.length; j++) {\n\t      var index = layoutInfo.idToIndex[graph[j]];\n\t      layoutInfo.indexToGraph[index] = i;\n\t    }\n\t  }\n\t\n\t  // Iterate over all edges, creating Layout Edges\n\t  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n\t    var e = edges[i];\n\t    var tempEdge = {};\n\t    tempEdge.id = e.data('id');\n\t    tempEdge.sourceId = e.data('source');\n\t    tempEdge.targetId = e.data('target');\n\t\n\t    // Compute ideal length\n\t    var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n\t    var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n\t\n\t    // Check if it's an inter graph edge\n\t    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n\t    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n\t    var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n\t    var targetGraph = layoutInfo.indexToGraph[targetIx];\n\t\n\t    if (sourceGraph != targetGraph) {\n\t      // Find lowest common graph ancestor\n\t      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n\t\n\t      // Compute sum of node depths, relative to lca graph\n\t      var lcaGraph = layoutInfo.graphSet[lca];\n\t      var depth = 0;\n\t\n\t      // Source depth\n\t      var tempNode = layoutInfo.layoutNodes[sourceIx];\n\t      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n\t        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n\t        depth++;\n\t      }\n\t\n\t      // Target depth\n\t      tempNode = layoutInfo.layoutNodes[targetIx];\n\t      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n\t        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n\t        depth++;\n\t      }\n\t\n\t      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n\t      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n\t      //  \". Depth: \" + depth);\n\t\n\t      // Update idealLength\n\t      idealLength *= depth * options.nestingFactor;\n\t    }\n\t\n\t    tempEdge.idealLength = idealLength;\n\t    tempEdge.elasticity = elasticity;\n\t\n\t    layoutInfo.layoutEdges.push(tempEdge);\n\t  }\n\t\n\t  // Finally, return layoutInfo object\n\t  return layoutInfo;\n\t};\n\t\n\t/**\n\t * @brief : This function finds the index of the lowest common\n\t *          graph ancestor between 2 nodes in the subtree\n\t *          (from the graph hierarchy induced tree) whose\n\t *          root is graphIx\n\t *\n\t * @arg node1: node1's ID\n\t * @arg node2: node2's ID\n\t * @arg layoutInfo: layoutInfo object\n\t *\n\t */\n\tvar findLCA = function findLCA(node1, node2, layoutInfo) {\n\t  // Find their common ancester, starting from the root graph\n\t  var res = findLCA_aux(node1, node2, 0, layoutInfo);\n\t  if (2 > res.count) {\n\t    // If aux function couldn't find the common ancester,\n\t    // then it is the root graph\n\t    return 0;\n\t  } else {\n\t    return res.graph;\n\t  }\n\t};\n\t\n\t/**\n\t * @brief          : Auxiliary function used for LCA computation\n\t *\n\t * @arg node1      : node1's ID\n\t * @arg node2      : node2's ID\n\t * @arg graphIx    : subgraph index\n\t * @arg layoutInfo : layoutInfo object\n\t *\n\t * @return         : object of the form {count: X, graph: Y}, where:\n\t *                   X is the number of ancesters (max: 2) found in\n\t *                   graphIx (and it's subgraphs),\n\t *                   Y is the graph index of the lowest graph containing\n\t *                   all X nodes\n\t */\n\tvar findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n\t  var graph = layoutInfo.graphSet[graphIx];\n\t  // If both nodes belongs to graphIx\n\t  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n\t    return { count: 2, graph: graphIx };\n\t  }\n\t\n\t  // Make recursive calls for all subgraphs\n\t  var c = 0;\n\t  for (var i = 0; i < graph.length; i++) {\n\t    var nodeId = graph[i];\n\t    var nodeIx = layoutInfo.idToIndex[nodeId];\n\t    var children = layoutInfo.layoutNodes[nodeIx].children;\n\t\n\t    // If the node has no child, skip it\n\t    if (0 === children.length) {\n\t      continue;\n\t    }\n\t\n\t    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n\t    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n\t    if (0 === result.count) {\n\t      // Neither node1 nor node2 are present in this subgraph\n\t      continue;\n\t    } else if (1 === result.count) {\n\t      // One of (node1, node2) is present in this subgraph\n\t      c++;\n\t      if (2 === c) {\n\t        // We've already found both nodes, no need to keep searching\n\t        break;\n\t      }\n\t    } else {\n\t      // Both nodes are present in this subgraph\n\t      return result;\n\t    }\n\t  }\n\t\n\t  return { count: c, graph: graphIx };\n\t};\n\t\n\t/**\n\t * @brief: printsLayoutInfo into js console\n\t *         Only used for debbuging\n\t */\n\tvar printLayoutInfo = function printLayoutInfo(layoutInfo) {\n\t  /* eslint-disable */\n\t\n\t  if (!DEBUG) {\n\t    return;\n\t  }\n\t  console.debug('layoutNodes:');\n\t  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t    var n = layoutInfo.layoutNodes[i];\n\t    var s = '\\nindex: ' + i + '\\nId: ' + n.id + '\\nChildren: ' + n.children.toString() + '\\nparentId: ' + n.parentId + '\\npositionX: ' + n.positionX + '\\npositionY: ' + n.positionY + '\\nOffsetX: ' + n.offsetX + '\\nOffsetY: ' + n.offsetY + '\\npadLeft: ' + n.padLeft + '\\npadRight: ' + n.padRight + '\\npadTop: ' + n.padTop + '\\npadBottom: ' + n.padBottom;\n\t\n\t    console.debug(s);\n\t  }\n\t\n\t  console.debug('idToIndex');\n\t  for (var i in layoutInfo.idToIndex) {\n\t    console.debug('Id: ' + i + '\\nIndex: ' + layoutInfo.idToIndex[i]);\n\t  }\n\t\n\t  console.debug('Graph Set');\n\t  var set = layoutInfo.graphSet;\n\t  for (var i = 0; i < set.length; i++) {\n\t    console.debug('Set : ' + i + ': ' + set[i].toString());\n\t  }\n\t\n\t  var s = 'IndexToGraph';\n\t  for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {\n\t    s += '\\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];\n\t  }\n\t  console.debug(s);\n\t\n\t  s = 'Layout Edges';\n\t  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {\n\t    var e = layoutInfo.layoutEdges[i];\n\t    s += '\\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;\n\t  }\n\t  console.debug(s);\n\t\n\t  s = 'nodeSize: ' + layoutInfo.nodeSize;\n\t  s += '\\nedgeSize: ' + layoutInfo.edgeSize;\n\t  s += '\\ntemperature: ' + layoutInfo.temperature;\n\t  console.debug(s);\n\t\n\t  return;\n\t  /* eslint-enable */\n\t};\n\t\n\t/**\n\t * @brief : Randomizes the position of all nodes\n\t */\n\tvar randomizePositions = function randomizePositions(layoutInfo, cy) {\n\t  var width = layoutInfo.clientWidth;\n\t  var height = layoutInfo.clientHeight;\n\t\n\t  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n\t    var n = layoutInfo.layoutNodes[i];\n\t\n\t    // No need to randomize compound nodes or locked nodes\n\t    if (0 === n.children.length && !n.isLocked) {\n\t      n.positionX = Math.random() * width;\n\t      n.positionY = Math.random() * height;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * @brief          : Updates the positions of nodes in the network\n\t * @arg layoutInfo : LayoutInfo object\n\t * @arg cy         : Cytoscape object\n\t * @arg options    : Layout options\n\t */\n\tvar refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n\t  // var s = 'Refreshing positions';\n\t  // logDebug(s);\n\t\n\t  var layout = options.layout;\n\t  var nodes = options.eles.nodes();\n\t  var bb = layoutInfo.boundingBox;\n\t  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n\t\n\t  if (options.boundingBox) {\n\t    nodes.forEach(function (node) {\n\t      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\t\n\t      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n\t      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n\t\n\t      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n\t      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n\t    });\n\t\n\t    coseBB.w = coseBB.x2 - coseBB.x1;\n\t    coseBB.h = coseBB.y2 - coseBB.y1;\n\t  }\n\t\n\t  nodes.positions(function (ele, i) {\n\t    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n\t    // s = \"Node: \" + lnode.id + \". Refreshed position: (\" +\n\t    // lnode.positionX + \", \" + lnode.positionY + \").\";\n\t    // logDebug(s);\n\t\n\t    if (options.boundingBox) {\n\t      // then add extra bounding box constraint\n\t      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n\t      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\t\n\t      return {\n\t        x: bb.x1 + pctX * bb.w,\n\t        y: bb.y1 + pctY * bb.h\n\t      };\n\t    } else {\n\t      return {\n\t        x: lnode.positionX,\n\t        y: lnode.positionY\n\t      };\n\t    }\n\t  });\n\t\n\t  // Trigger layoutReady only on first call\n\t  if (true !== layoutInfo.ready) {\n\t    // s = 'Triggering layoutready';\n\t    // logDebug(s);\n\t    layoutInfo.ready = true;\n\t    layout.one('layoutready', options.ready);\n\t    layout.emit({ type: 'layoutready', layout: this });\n\t  }\n\t};\n\t\n\t/**\n\t * @brief : Logs a debug message in JS console, if DEBUG is ON\n\t */\n\t// var logDebug = function(text) {\n\t//   if (DEBUG) {\n\t//     console.debug(text);\n\t//   }\n\t// };\n\t\n\tmodule.exports = CoseLayout;\n\t\n\t/***/ }),\n\t/* 80 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // padding used on fit\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true\n\t  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n\t  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n\t  condense: false, // uses all available space on false, uses minimal space on true\n\t  rows: undefined, // force num of rows in the grid\n\t  cols: undefined, // force num of columns in the grid\n\t  position: function position(node) {}, // returns { row, col } for element\n\t  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\t};\n\t\n\tfunction GridLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tGridLayout.prototype.run = function () {\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not(':parent');\n\t\n\t  if (options.sort) {\n\t    nodes = nodes.sort(options.sort);\n\t  }\n\t\n\t  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  });\n\t\n\t  if (bb.h === 0 || bb.w === 0) {\n\t    nodes.layoutPositions(this, options, function (ele) {\n\t      return { x: bb.x1, y: bb.y1 };\n\t    });\n\t  } else {\n\t\n\t    // width/height * splits^2 = cells where splits is number of times to split width\n\t    var cells = nodes.size();\n\t    var splits = Math.sqrt(cells * bb.h / bb.w);\n\t    var rows = Math.round(splits);\n\t    var cols = Math.round(bb.w / bb.h * splits);\n\t\n\t    var small = function small(val) {\n\t      if (val == null) {\n\t        return Math.min(rows, cols);\n\t      } else {\n\t        var min = Math.min(rows, cols);\n\t        if (min == rows) {\n\t          rows = val;\n\t        } else {\n\t          cols = val;\n\t        }\n\t      }\n\t    };\n\t\n\t    var large = function large(val) {\n\t      if (val == null) {\n\t        return Math.max(rows, cols);\n\t      } else {\n\t        var max = Math.max(rows, cols);\n\t        if (max == rows) {\n\t          rows = val;\n\t        } else {\n\t          cols = val;\n\t        }\n\t      }\n\t    };\n\t\n\t    var oRows = options.rows;\n\t    var oCols = options.cols != null ? options.cols : options.columns;\n\t\n\t    // if rows or columns were set in options, use those values\n\t    if (oRows != null && oCols != null) {\n\t      rows = oRows;\n\t      cols = oCols;\n\t    } else if (oRows != null && oCols == null) {\n\t      rows = oRows;\n\t      cols = Math.ceil(cells / rows);\n\t    } else if (oRows == null && oCols != null) {\n\t      cols = oCols;\n\t      rows = Math.ceil(cells / cols);\n\t    }\n\t\n\t    // otherwise use the automatic values and adjust accordingly\n\t\n\t    // if rounding was up, see if we can reduce rows or columns\n\t    else if (cols * rows > cells) {\n\t        var sm = small();\n\t        var lg = large();\n\t\n\t        // reducing the small side takes away the most cells, so try it first\n\t        if ((sm - 1) * lg >= cells) {\n\t          small(sm - 1);\n\t        } else if ((lg - 1) * sm >= cells) {\n\t          large(lg - 1);\n\t        }\n\t      } else {\n\t\n\t        // if rounding was too low, add rows or columns\n\t        while (cols * rows < cells) {\n\t          var _sm = small();\n\t          var _lg = large();\n\t\n\t          // try to add to larger side first (adds less in multiplication)\n\t          if ((_lg + 1) * _sm >= cells) {\n\t            large(_lg + 1);\n\t          } else {\n\t            small(_sm + 1);\n\t          }\n\t        }\n\t      }\n\t\n\t    var cellWidth = bb.w / cols;\n\t    var cellHeight = bb.h / rows;\n\t\n\t    if (options.condense) {\n\t      cellWidth = 0;\n\t      cellHeight = 0;\n\t    }\n\t\n\t    if (options.avoidOverlap) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        var node = nodes[i];\n\t        var pos = node._private.position;\n\t\n\t        if (pos.x == null || pos.y == null) {\n\t          // for bb\n\t          pos.x = 0;\n\t          pos.y = 0;\n\t        }\n\t\n\t        var nbb = node.layoutDimensions(options);\n\t        var p = options.avoidOverlapPadding;\n\t\n\t        var w = nbb.w + p;\n\t        var h = nbb.h + p;\n\t\n\t        cellWidth = Math.max(cellWidth, w);\n\t        cellHeight = Math.max(cellHeight, h);\n\t      }\n\t    }\n\t\n\t    var cellUsed = {}; // e.g. 'c-0-2' => true\n\t\n\t    var used = function used(row, col) {\n\t      return cellUsed['c-' + row + '-' + col] ? true : false;\n\t    };\n\t\n\t    var use = function use(row, col) {\n\t      cellUsed['c-' + row + '-' + col] = true;\n\t    };\n\t\n\t    // to keep track of current cell position\n\t    var row = 0;\n\t    var col = 0;\n\t    var moveToNextCell = function moveToNextCell() {\n\t      col++;\n\t      if (col >= cols) {\n\t        col = 0;\n\t        row++;\n\t      }\n\t    };\n\t\n\t    // get a cache of all the manual positions\n\t    var id2manPos = {};\n\t    for (var _i = 0; _i < nodes.length; _i++) {\n\t      var _node = nodes[_i];\n\t      var rcPos = options.position(_node);\n\t\n\t      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n\t        // must have at least row or col def'd\n\t        var _pos = {\n\t          row: rcPos.row,\n\t          col: rcPos.col\n\t        };\n\t\n\t        if (_pos.col === undefined) {\n\t          // find unused col\n\t          _pos.col = 0;\n\t\n\t          while (used(_pos.row, _pos.col)) {\n\t            _pos.col++;\n\t          }\n\t        } else if (_pos.row === undefined) {\n\t          // find unused row\n\t          _pos.row = 0;\n\t\n\t          while (used(_pos.row, _pos.col)) {\n\t            _pos.row++;\n\t          }\n\t        }\n\t\n\t        id2manPos[_node.id()] = _pos;\n\t        use(_pos.row, _pos.col);\n\t      }\n\t    }\n\t\n\t    var getPos = function getPos(element, i) {\n\t      var x = void 0,\n\t          y = void 0;\n\t\n\t      if (element.locked() || element.isParent()) {\n\t        return false;\n\t      }\n\t\n\t      // see if we have a manual position set\n\t      var rcPos = id2manPos[element.id()];\n\t      if (rcPos) {\n\t        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n\t        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n\t      } else {\n\t        // otherwise set automatically\n\t\n\t        while (used(row, col)) {\n\t          moveToNextCell();\n\t        }\n\t\n\t        x = col * cellWidth + cellWidth / 2 + bb.x1;\n\t        y = row * cellHeight + cellHeight / 2 + bb.y1;\n\t        use(row, col);\n\t\n\t        moveToNextCell();\n\t      }\n\t\n\t      return { x: x, y: y };\n\t    };\n\t\n\t    nodes.layoutPositions(this, options, getPos);\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = GridLayout;\n\t\n\t/***/ }),\n\t/* 81 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = [{ name: 'breadthfirst', impl: __webpack_require__(76) }, { name: 'circle', impl: __webpack_require__(77) }, { name: 'concentric', impl: __webpack_require__(78) }, { name: 'cose', impl: __webpack_require__(79) }, { name: 'grid', impl: __webpack_require__(80) }, { name: 'null', impl: __webpack_require__(82) }, { name: 'preset', impl: __webpack_require__(83) }, { name: 'random', impl: __webpack_require__(84) }];\n\t\n\t/***/ }),\n\t/* 82 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\t// default layout options\n\tvar defaults = {\n\t  ready: function ready() {}, // on layoutready\n\t  stop: function stop() {} // on layoutstop\n\t};\n\t\n\t// constructor\n\t// options : object containing layout options\n\tfunction NullLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\t// runs the layout\n\tNullLayout.prototype.run = function () {\n\t  var options = this.options;\n\t  var eles = options.eles; // elements to consider in the layout\n\t  var layout = this;\n\t\n\t  // cy is automatically populated for us in the constructor\n\t  var cy = options.cy; // jshint ignore:line\n\t\n\t  layout.emit('layoutstart');\n\t\n\t  // puts all nodes at (0, 0)\n\t  eles.nodes().positions(function () {\n\t    return {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t  });\n\t\n\t  // trigger layoutready when each node has had its position set at least once\n\t  layout.one('layoutready', options.ready);\n\t  layout.emit('layoutready');\n\t\n\t  // trigger layoutstop when the layout stops (e.g. finishes)\n\t  layout.one('layoutstop', options.stop);\n\t  layout.emit('layoutstop');\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// called on continuous layouts to stop them before they finish\n\tNullLayout.prototype.stop = function () {\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = NullLayout;\n\t\n\t/***/ }),\n\t/* 83 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar defaults = {\n\t  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n\t  zoom: undefined, // the zoom level to set (prob want fit = false if set)\n\t  pan: undefined, // the pan level to set (prob want fit = false if set)\n\t  fit: true, // whether to fit to viewport\n\t  padding: 30, // padding on fit\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\t};\n\t\n\tfunction PresetLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tPresetLayout.prototype.run = function () {\n\t  var options = this.options;\n\t  var eles = options.eles;\n\t\n\t  var nodes = eles.nodes();\n\t  var posIsFn = is.fn(options.positions);\n\t\n\t  function getPosition(node) {\n\t    if (options.positions == null) {\n\t      return null;\n\t    }\n\t\n\t    if (posIsFn) {\n\t      return options.positions(node);\n\t    }\n\t\n\t    var pos = options.positions[node._private.data.id];\n\t\n\t    if (pos == null) {\n\t      return null;\n\t    }\n\t\n\t    return pos;\n\t  }\n\t\n\t  nodes.layoutPositions(this, options, function (node, i) {\n\t    var position = getPosition(node);\n\t\n\t    if (node.locked() || position == null) {\n\t      return false;\n\t    }\n\t\n\t    return position;\n\t  });\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = PresetLayout;\n\t\n\t/***/ }),\n\t/* 84 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit to viewport\n\t  padding: 30, // fit padding\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  animateFilter: function animateFilter(node, i) {\n\t    return true;\n\t  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined, // callback on layoutstop\n\t  transform: function transform(node, position) {\n\t    return position;\n\t  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\t};\n\t\n\tfunction RandomLayout(options) {\n\t  this.options = util.extend({}, defaults, options);\n\t}\n\t\n\tRandomLayout.prototype.run = function () {\n\t  var options = this.options;\n\t  var cy = options.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not(':parent');\n\t\n\t  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  });\n\t\n\t  var getPos = function getPos(node, i) {\n\t    return {\n\t      x: bb.x1 + Math.round(Math.random() * bb.w),\n\t      y: bb.y1 + Math.round(Math.random() * bb.h)\n\t    };\n\t  };\n\t\n\t  nodes.layoutPositions(this, options, getPos);\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = RandomLayout;\n\t\n\t/***/ }),\n\t/* 85 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\t\n\tvar BRp = {};\n\t\n\tBRp.arrowShapeWidth = 0.3;\n\t\n\tBRp.registerArrowShapes = function () {\n\t  var arrowShapes = this.arrowShapes = {};\n\t  var renderer = this;\n\t\n\t  // Contract for arrow shapes:\n\t  // 0, 0 is arrow tip\n\t  // (0, 1) is direction towards node\n\t  // (1, 0) is right\n\t  //\n\t  // functional api:\n\t  // collide: check x, y in shape\n\t  // roughCollide: called before collide, no false negatives\n\t  // draw: draw\n\t  // spacing: dist(arrowTip, nodeBoundary)\n\t  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\t\n\t  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n\t    var x1 = translation.x - size / 2 - padding;\n\t    var x2 = translation.x + size / 2 + padding;\n\t    var y1 = translation.y - size / 2 - padding;\n\t    var y2 = translation.y + size / 2 + padding;\n\t\n\t    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t\n\t    return inside;\n\t  };\n\t\n\t  var transform = function transform(x, y, size, angle, translation) {\n\t    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n\t    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n\t\n\t    var xScaled = xRotated * size;\n\t    var yScaled = yRotated * size;\n\t\n\t    var xTranslated = xScaled + translation.x;\n\t    var yTranslated = yScaled + translation.y;\n\t\n\t    return {\n\t      x: xTranslated,\n\t      y: yTranslated\n\t    };\n\t  };\n\t\n\t  var transformPoints = function transformPoints(pts, size, angle, translation) {\n\t    var retPts = [];\n\t\n\t    for (var i = 0; i < pts.length; i += 2) {\n\t      var x = pts[i];\n\t      var y = pts[i + 1];\n\t\n\t      retPts.push(transform(x, y, size, angle, translation));\n\t    }\n\t\n\t    return retPts;\n\t  };\n\t\n\t  var pointsToArr = function pointsToArr(pts) {\n\t    var ret = [];\n\t\n\t    for (var i = 0; i < pts.length; i++) {\n\t      var p = pts[i];\n\t\n\t      ret.push(p.x, p.y);\n\t    }\n\t\n\t    return ret;\n\t  };\n\t\n\t  var standardGap = function standardGap(edge) {\n\t    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n\t  };\n\t\n\t  var defineArrowShape = function defineArrowShape(name, defn) {\n\t    if (is.string(defn)) {\n\t      defn = arrowShapes[defn];\n\t    }\n\t\n\t    arrowShapes[name] = util.extend({\n\t      name: name,\n\t\n\t      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n\t\n\t      collide: function collide(x, y, size, angle, translation, padding) {\n\t        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n\t        var inside = math.pointInsidePolygonPoints(x, y, points);\n\t\n\t        return inside;\n\t      },\n\t\n\t      roughCollide: bbCollide,\n\t\n\t      draw: function draw(context, size, angle, translation) {\n\t        var points = transformPoints(this.points, size, angle, translation);\n\t\n\t        renderer.arrowShapeImpl('polygon')(context, points);\n\t      },\n\t\n\t      spacing: function spacing(edge) {\n\t        return 0;\n\t      },\n\t\n\t      gap: standardGap\n\t    }, defn);\n\t  };\n\t\n\t  defineArrowShape('none', {\n\t    collide: util.falsify,\n\t\n\t    roughCollide: util.falsify,\n\t\n\t    draw: util.noop,\n\t\n\t    spacing: util.zeroify,\n\t\n\t    gap: util.zeroify\n\t  });\n\t\n\t  defineArrowShape('triangle', {\n\t    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n\t  });\n\t\n\t  defineArrowShape('arrow', 'triangle');\n\t\n\t  defineArrowShape('triangle-backcurve', {\n\t    points: arrowShapes['triangle'].points,\n\t\n\t    controlPoint: [0, -0.15],\n\t\n\t    roughCollide: bbCollide,\n\t\n\t    draw: function draw(context, size, angle, translation, edgeWidth) {\n\t      var ptsTrans = transformPoints(this.points, size, angle, translation);\n\t      var ctrlPt = this.controlPoint;\n\t      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n\t\n\t      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n\t    },\n\t\n\t    gap: function gap(edge) {\n\t      return standardGap(edge) * 0.985;\n\t    }\n\t  });\n\t\n\t  defineArrowShape('triangle-tee', {\n\t    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],\n\t\n\t    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n\t\n\t    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n\t      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n\t      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n\t\n\t      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);\n\t\n\t      return inside;\n\t    },\n\t\n\t    draw: function draw(context, size, angle, translation, edgeWidth) {\n\t      var triPts = transformPoints(this.points, size, angle, translation);\n\t      var teePts = transformPoints(this.pointsTee, size, angle, translation);\n\t\n\t      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n\t    }\n\t  });\n\t\n\t  defineArrowShape('triangle-cross', {\n\t    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],\n\t\n\t    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle\n\t    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle\n\t    0.15, -0.4],\n\t\n\t    crossLinePts: function crossLinePts(size, edgeWidth) {\n\t      // shift points so that the distance between the cross points matches edge width\n\t      var p = this.baseCrossLinePts.slice();\n\t      var shiftFactor = edgeWidth / size;\n\t      var y0 = 3;\n\t      var y1 = 5;\n\t\n\t      p[y0] = p[y0] - shiftFactor;\n\t      p[y1] = p[y1] - shiftFactor;\n\t\n\t      return p;\n\t    },\n\t\n\t    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n\t      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n\t      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n\t      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);\n\t\n\t      return inside;\n\t    },\n\t\n\t    draw: function draw(context, size, angle, translation, edgeWidth) {\n\t      var triPts = transformPoints(this.points, size, angle, translation);\n\t      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n\t\n\t      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n\t    }\n\t  });\n\t\n\t  defineArrowShape('vee', {\n\t    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n\t\n\t    gap: function gap(edge) {\n\t      return standardGap(edge) * 0.985;\n\t    }\n\t  });\n\t\n\t  defineArrowShape('circle', {\n\t    radius: 0.15,\n\t\n\t    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n\t      var t = translation;\n\t      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n\t\n\t      return inside;\n\t    },\n\t\n\t    draw: function draw(context, size, angle, translation, edgeWidth) {\n\t      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n\t    },\n\t\n\t    spacing: function spacing(edge) {\n\t      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n\t    }\n\t  });\n\t\n\t  defineArrowShape('tee', {\n\t    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n\t\n\t    spacing: function spacing(edge) {\n\t      return 1;\n\t    },\n\t\n\t    gap: function gap(edge) {\n\t      return 1;\n\t    }\n\t  });\n\t\n\t  defineArrowShape('square', {\n\t    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n\t  });\n\t\n\t  defineArrowShape('diamond', {\n\t    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n\t\n\t    gap: function gap(edge) {\n\t      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 86 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar window = __webpack_require__(4);\n\tvar math = __webpack_require__(2);\n\tvar util = __webpack_require__(1);\n\tvar window = __webpack_require__(4);\n\t\n\tvar BRp = {};\n\t\n\t// Project mouse\n\tBRp.projectIntoViewport = function (clientX, clientY) {\n\t  var cy = this.cy;\n\t  var offsets = this.findContainerClientCoords();\n\t  var offsetLeft = offsets[0];\n\t  var offsetTop = offsets[1];\n\t  var scale = offsets[4];\n\t  var pan = cy.pan();\n\t  var zoom = cy.zoom();\n\t\n\t  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n\t  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n\t\n\t  return [x, y];\n\t};\n\t\n\tBRp.findContainerClientCoords = function () {\n\t  if (this.containerBB) {\n\t    return this.containerBB;\n\t  }\n\t\n\t  var container = this.container;\n\t  var rect = container.getBoundingClientRect();\n\t  var style = window.getComputedStyle(container);\n\t  var styleValue = function styleValue(name) {\n\t    return parseFloat(style.getPropertyValue(name));\n\t  };\n\t\n\t  var padding = {\n\t    left: styleValue('padding-left'),\n\t    right: styleValue('padding-right'),\n\t    top: styleValue('padding-top'),\n\t    bottom: styleValue('padding-bottom')\n\t  };\n\t\n\t  var border = {\n\t    left: styleValue('border-left-width'),\n\t    right: styleValue('border-right-width'),\n\t    top: styleValue('border-top-width'),\n\t    bottom: styleValue('border-bottom-width')\n\t  };\n\t\n\t  var clientWidth = container.clientWidth;\n\t  var clientHeight = container.clientHeight;\n\t\n\t  var paddingHor = padding.left + padding.right;\n\t  var paddingVer = padding.top + padding.bottom;\n\t\n\t  var borderHor = border.left + border.right;\n\t  var borderVer = border.top + border.bottom;\n\t\n\t  var scale = rect.width / (clientWidth + borderHor);\n\t\n\t  var unscaledW = clientWidth - paddingHor;\n\t  var unscaledH = clientHeight - paddingVer;\n\t\n\t  var scaledW = rect.width - (paddingHor + borderHor) * scale;\n\t  var scaledH = rect.height - (paddingVer + borderVer) * scale;\n\t\n\t  var left = rect.left + padding.left + border.left;\n\t  var top = rect.top + padding.top + border.top;\n\t\n\t  return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n\t};\n\t\n\tBRp.invalidateContainerClientCoordsCache = function () {\n\t  this.containerBB = null;\n\t};\n\t\n\tBRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n\t  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n\t};\n\t\n\tBRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n\t  var self = this;\n\t  var r = this;\n\t  var eles = r.getCachedZSortedEles();\n\t  var near = []; // 1 node max, 1 edge max\n\t  var zoom = r.cy.zoom();\n\t  var hasCompounds = r.cy.hasCompoundNodes();\n\t  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n\t  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n\t  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n\t  var minSqDist = Infinity;\n\t  var nearEdge;\n\t  var nearNode;\n\t\n\t  if (interactiveElementsOnly) {\n\t    eles = eles.interactive;\n\t  }\n\t\n\t  function addEle(ele, sqDist) {\n\t    if (ele.isNode()) {\n\t      if (nearNode) {\n\t        return; // can't replace node\n\t      } else {\n\t        nearNode = ele;\n\t        near.push(ele);\n\t      }\n\t    }\n\t\n\t    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n\t      if (nearEdge) {\n\t        // then replace existing edge\n\t        // can replace only if same z-index\n\t        if (nearEdge.pstyle('z-index').value === ele.pstyle('z-index').value) {\n\t          for (var i = 0; i < near.length; i++) {\n\t            if (near[i].isEdge()) {\n\t              near[i] = ele;\n\t              nearEdge = ele;\n\t              minSqDist = sqDist != null ? sqDist : minSqDist;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        near.push(ele);\n\t        nearEdge = ele;\n\t        minSqDist = sqDist != null ? sqDist : minSqDist;\n\t      }\n\t    }\n\t  }\n\t\n\t  function checkNode(node) {\n\t    var width = node.outerWidth() + 2 * nodeThreshold;\n\t    var height = node.outerHeight() + 2 * nodeThreshold;\n\t    var hw = width / 2;\n\t    var hh = height / 2;\n\t    var pos = node.position();\n\t\n\t    if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n\t    && pos.y - hh <= y && y <= pos.y + hh // bb check y\n\t    ) {\n\t        var shape = r.nodeShapes[self.getNodeShape(node)];\n\t\n\t        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n\t          addEle(node, 0);\n\t          return true;\n\t        }\n\t      }\n\t  }\n\t\n\t  function checkEdge(edge) {\n\t    var _p = edge._private;\n\t\n\t    var rs = _p.rscratch;\n\t    var styleWidth = edge.pstyle('width').pfValue;\n\t    var scale = edge.pstyle('arrow-scale').value;\n\t    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n\t    var widthSq = width * width;\n\t    var width2 = width * 2;\n\t    var src = _p.source;\n\t    var tgt = _p.target;\n\t    var inEdgeBB = false;\n\t    var sqDist;\n\t\n\t    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n\t      var pts = rs.allpts;\n\t\n\t      for (var i = 0; i + 3 < pts.length; i += 2) {\n\t        if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n\t          addEle(edge, sqDist);\n\t          return true;\n\t        }\n\t      }\n\t    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n\t      var pts = rs.allpts;\n\t      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n\t        if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n\t          addEle(edge, sqDist);\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\t\n\t    var src = src || _p.source;\n\t    var tgt = tgt || _p.target;\n\t\n\t    var arSize = self.getArrowWidth(styleWidth, scale);\n\t\n\t    var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];\n\t\n\t    for (var i = 0; i < arrows.length; i++) {\n\t      var ar = arrows[i];\n\t      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n\t      var edgeWidth = edge.pstyle('width').pfValue;\n\t      if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {\n\t        addEle(edge);\n\t        return true;\n\t      }\n\t    }\n\t\n\t    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n\t    if (hasCompounds && near.length > 0) {\n\t      checkNode(src);\n\t      checkNode(tgt);\n\t    }\n\t  }\n\t\n\t  function preprop(obj, name, pre) {\n\t    return util.getPrefixedProperty(obj, name, pre);\n\t  }\n\t\n\t  function checkLabel(ele, prefix) {\n\t    var _p = ele._private;\n\t    var th = labelThreshold;\n\t\n\t    var prefixDash;\n\t    if (prefix) {\n\t      prefixDash = prefix + '-';\n\t    } else {\n\t      prefixDash = '';\n\t    }\n\t\n\t    var text = ele.pstyle(prefixDash + 'label').value;\n\t    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n\t\n\t    if (!eventsEnabled || !text) {\n\t      return;\n\t    }\n\t\n\t    var rstyle = _p.rstyle;\n\t    var bw = ele.pstyle('text-border-width').pfValue;\n\t    var pw = ele.pstyle('text-background-padding').pfValue;\n\t    var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;\n\t    var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;\n\t    var lx = preprop(rstyle, 'labelX', prefix);\n\t    var ly = preprop(rstyle, 'labelY', prefix);\n\t\n\t    var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n\t\n\t    var lx1 = lx - lw / 2;\n\t    var lx2 = lx + lw / 2;\n\t    var ly1 = ly - lh / 2;\n\t    var ly2 = ly + lh / 2;\n\t\n\t    if (theta) {\n\t      var cos = Math.cos(theta);\n\t      var sin = Math.sin(theta);\n\t\n\t      var rotate = function rotate(x, y) {\n\t        x = x - lx;\n\t        y = y - ly;\n\t\n\t        return {\n\t          x: x * cos - y * sin + lx,\n\t          y: x * sin + y * cos + ly\n\t        };\n\t      };\n\t\n\t      var px1y1 = rotate(lx1, ly1);\n\t      var px1y2 = rotate(lx1, ly2);\n\t      var px2y1 = rotate(lx2, ly1);\n\t      var px2y2 = rotate(lx2, ly2);\n\t\n\t      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];\n\t\n\t      if (math.pointInsidePolygonPoints(x, y, points)) {\n\t        addEle(ele);\n\t        return true;\n\t      }\n\t    } else {\n\t      // do a cheaper bb check\n\t      var bb = {\n\t        w: lw,\n\t        h: lh,\n\t        x1: lx1,\n\t        x2: lx2,\n\t        y1: ly1,\n\t        y2: ly2\n\t      };\n\t\n\t      if (math.inBoundingBox(bb, x, y)) {\n\t        addEle(ele);\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t\n\t  for (var i = eles.length - 1; i >= 0; i--) {\n\t    // reverse order for precedence\n\t    var ele = eles[i];\n\t\n\t    if (ele.isNode()) {\n\t      checkNode(ele) || checkLabel(ele);\n\t    } else {\n\t      // then edge\n\t      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n\t    }\n\t  }\n\t\n\t  return near;\n\t};\n\t\n\t// 'Give me everything from this box'\n\tBRp.getAllInBox = function (x1, y1, x2, y2) {\n\t  var eles = this.getCachedZSortedEles().interactive;\n\t  var box = [];\n\t\n\t  var x1c = Math.min(x1, x2);\n\t  var x2c = Math.max(x1, x2);\n\t  var y1c = Math.min(y1, y2);\n\t  var y2c = Math.max(y1, y2);\n\t\n\t  x1 = x1c;\n\t  x2 = x2c;\n\t  y1 = y1c;\n\t  y2 = y2c;\n\t\n\t  var boxBb = math.makeBoundingBox({\n\t    x1: x1, y1: y1,\n\t    x2: x2, y2: y2\n\t  });\n\t\n\t  for (var e = 0; e < eles.length; e++) {\n\t    var ele = eles[e];\n\t\n\t    if (ele.isNode()) {\n\t      var node = ele;\n\t      var nodeBb = node.boundingBox({\n\t        includeNodes: true,\n\t        includeEdges: false,\n\t        includeLabels: false\n\t      });\n\t\n\t      if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {\n\t        box.push(node);\n\t      }\n\t    } else {\n\t      var edge = ele;\n\t      var _p = edge._private;\n\t      var rs = _p.rscratch;\n\t\n\t      if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {\n\t        continue;\n\t      }\n\t      if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {\n\t        continue;\n\t      }\n\t\n\t      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n\t\n\t        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n\t        var allInside = true;\n\t\n\t        for (var i = 0; i < pts.length; i++) {\n\t          if (!math.pointInBoundingBox(boxBb, pts[i])) {\n\t            allInside = false;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (allInside) {\n\t          box.push(edge);\n\t        }\n\t      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n\t        box.push(edge);\n\t      }\n\t    }\n\t  }\n\t\n\t  return box;\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 87 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\t\n\tvar BRp = {};\n\t\n\tBRp.calculateArrowAngles = function (edge) {\n\t  var rs = edge._private.rscratch;\n\t  var isHaystack = rs.edgeType === 'haystack';\n\t  var isBezier = rs.edgeType === 'bezier';\n\t  var isMultibezier = rs.edgeType === 'multibezier';\n\t  var isSegments = rs.edgeType === 'segments';\n\t  var isCompound = rs.edgeType === 'compound';\n\t  var isSelf = rs.edgeType === 'self';\n\t\n\t  // Displacement gives direction for arrowhead orientation\n\t  var dispX, dispY;\n\t  var startX, startY, endX, endY, midX, midY;\n\t\n\t  if (isHaystack) {\n\t    startX = rs.haystackPts[0];\n\t    startY = rs.haystackPts[1];\n\t    endX = rs.haystackPts[2];\n\t    endY = rs.haystackPts[3];\n\t  } else {\n\t    startX = rs.arrowStartX;\n\t    startY = rs.arrowStartY;\n\t    endX = rs.arrowEndX;\n\t    endY = rs.arrowEndY;\n\t  }\n\t\n\t  midX = rs.midX;\n\t  midY = rs.midY;\n\t\n\t  // source\n\t  //\n\t\n\t  if (isSegments) {\n\t    dispX = startX - rs.segpts[0];\n\t    dispY = startY - rs.segpts[1];\n\t  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n\t    var pts = rs.allpts;\n\t    var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);\n\t    var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);\n\t\n\t    dispX = startX - bX;\n\t    dispY = startY - bY;\n\t  } else {\n\t    dispX = startX - midX;\n\t    dispY = startY - midY;\n\t  }\n\t\n\t  rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\t\n\t  // mid target\n\t  //\n\t\n\t  var midX = rs.midX;\n\t  var midY = rs.midY;\n\t\n\t  if (isHaystack) {\n\t    midX = (startX + endX) / 2;\n\t    midY = (startY + endY) / 2;\n\t  }\n\t\n\t  dispX = endX - startX;\n\t  dispY = endY - startY;\n\t\n\t  if (isSegments) {\n\t    var pts = rs.allpts;\n\t\n\t    if (pts.length / 2 % 2 === 0) {\n\t      var i2 = pts.length / 2;\n\t      var i1 = i2 - 2;\n\t\n\t      dispX = pts[i2] - pts[i1];\n\t      dispY = pts[i2 + 1] - pts[i1 + 1];\n\t    } else {\n\t      var i2 = pts.length / 2 - 1;\n\t      var i1 = i2 - 2;\n\t      var i3 = i2 + 2;\n\t\n\t      dispX = pts[i2] - pts[i1];\n\t      dispY = pts[i2 + 1] - pts[i1 + 1];\n\t    }\n\t  } else if (isMultibezier || isCompound || isSelf) {\n\t    var pts = rs.allpts;\n\t    var cpts = rs.ctrlpts;\n\t    var bp0x, bp0y;\n\t    var bp1x, bp1y;\n\t\n\t    if (cpts.length / 2 % 2 === 0) {\n\t      var p0 = pts.length / 2 - 1; // startpt\n\t      var ic = p0 + 2;\n\t      var p1 = ic + 2;\n\t\n\t      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n\t      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n\t\n\t      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n\t      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n\t    } else {\n\t      var ic = pts.length / 2 - 1; // ctrpt\n\t      var p0 = ic - 2; // startpt\n\t      var p1 = ic + 2; // endpt\n\t\n\t      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n\t      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n\t\n\t      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n\t      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n\t    }\n\t\n\t    dispX = bp1x - bp0x;\n\t    dispY = bp1y - bp0y;\n\t  }\n\t\n\t  rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\t\n\t  rs.midDispX = dispX;\n\t  rs.midDispY = dispY;\n\t\n\t  // mid source\n\t  //\n\t\n\t  dispX *= -1;\n\t  dispY *= -1;\n\t\n\t  if (isSegments) {\n\t    var pts = rs.allpts;\n\t\n\t    if (pts.length / 2 % 2 === 0) {\n\t      // already ok\n\t    } else {\n\t      var i2 = pts.length / 2 - 1;\n\t      var i3 = i2 + 2;\n\t\n\t      dispX = -(pts[i3] - pts[i2]);\n\t      dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n\t    }\n\t  }\n\t\n\t  rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\t\n\t  // target\n\t  //\n\t\n\t  if (isSegments) {\n\t    dispX = endX - rs.segpts[rs.segpts.length - 2];\n\t    dispY = endY - rs.segpts[rs.segpts.length - 1];\n\t  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n\t    var pts = rs.allpts;\n\t    var l = pts.length;\n\t    var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n\t    var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n\t\n\t    dispX = endX - bX;\n\t    dispY = endY - bY;\n\t  } else {\n\t    dispX = endX - midX;\n\t    dispY = endY - midY;\n\t  }\n\t\n\t  rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\t};\n\t\n\tBRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {\n\t  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\t\n\t  var cachedVal = cache[edgeWidth + ', ' + scale];\n\t  if (cachedVal) {\n\t    return cachedVal;\n\t  }\n\t\n\t  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n\t  cache[edgeWidth + ', ' + scale] = cachedVal;\n\t\n\t  return cachedVal;\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 88 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\t\n\tvar BRp = {};\n\t\n\tBRp.findEdgeControlPoints = function (edges) {\n\t  if (!edges || edges.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var r = this;\n\t  var cy = r.cy;\n\t  var hasCompounds = cy.hasCompoundNodes();\n\t  var hashTable = {};\n\t  var pairIds = [];\n\t  var haystackEdges = [];\n\t\n\t  // create a table of edge (src, tgt) => list of edges between them\n\t  var pairId;\n\t  for (var i = 0; i < edges.length; i++) {\n\t    var edge = edges[i];\n\t    var _p = edge._private;\n\t    var data = _p.data;\n\t    var curveStyle = edge.pstyle('curve-style').value;\n\t    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\t    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n\t\n\t    // ignore edges who are not to be displayed\n\t    // they shouldn't take up space\n\t    if (edge.pstyle('display').value === 'none') {\n\t      continue;\n\t    }\n\t\n\t    if (curveStyle === 'haystack') {\n\t      haystackEdges.push(edge);\n\t      continue;\n\t    }\n\t\n\t    var srcId = data.source;\n\t    var tgtId = data.target;\n\t\n\t    pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;\n\t\n\t    if (edgeIsUnbundled) {\n\t      pairId = 'unbundled' + '$-$' + data.id;\n\t    }\n\t\n\t    var tableEntry = hashTable[pairId];\n\t\n\t    if (tableEntry == null) {\n\t      tableEntry = hashTable[pairId] = [];\n\t      pairIds.push(pairId);\n\t    }\n\t\n\t    tableEntry.push(edge);\n\t\n\t    if (edgeIsUnbundled) {\n\t      tableEntry.hasUnbundled = true;\n\t    }\n\t\n\t    if (edgeIsBezier) {\n\t      tableEntry.hasBezier = true;\n\t    }\n\t  }\n\t\n\t  var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;\n\t  var vectorNormInverse;\n\t  var badBezier;\n\t\n\t  // for each pair (src, tgt), create the ctrl pts\n\t  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n\t  for (var p = 0; p < pairIds.length; p++) {\n\t    pairId = pairIds[p];\n\t    var pairEdges = hashTable[pairId];\n\t\n\t    // for each pair id, the edges should be sorted by index\n\t    pairEdges.sort(function (edge1, edge2) {\n\t      return edge1.poolIndex() - edge2.poolIndex();\n\t    });\n\t\n\t    src = pairEdges[0]._private.source;\n\t    tgt = pairEdges[0]._private.target;\n\t\n\t    // make sure src/tgt distinction is consistent for bundled edges\n\t    if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {\n\t      var temp = src;\n\t      src = tgt;\n\t      tgt = temp;\n\t    }\n\t\n\t    srcPos = src.position();\n\t    tgtPos = tgt.position();\n\t\n\t    srcW = src.outerWidth();\n\t    srcH = src.outerHeight();\n\t\n\t    tgtW = tgt.outerWidth();\n\t    tgtH = tgt.outerHeight();\n\t\n\t    srcShape = r.nodeShapes[this.getNodeShape(src)];\n\t    tgtShape = r.nodeShapes[this.getNodeShape(tgt)];\n\t\n\t    badBezier = false;\n\t\n\t    var edge;\n\t    var edge_p;\n\t    var rs;\n\t\n\t    var dirCounts = {\n\t      'north': 0,\n\t      'west': 0,\n\t      'south': 0,\n\t      'east': 0,\n\t      'northwest': 0,\n\t      'southwest': 0,\n\t      'northeast': 0,\n\t      'southeast': 0\n\t    };\n\t\n\t    var srcX2 = srcPos.x;\n\t    var srcY2 = srcPos.y;\n\t    var srcW2 = srcW;\n\t    var srcH2 = srcH;\n\t\n\t    var tgtX2 = tgtPos.x;\n\t    var tgtY2 = tgtPos.y;\n\t    var tgtW2 = tgtW;\n\t    var tgtH2 = tgtH;\n\t\n\t    var numEdges2 = pairEdges.length;\n\t\n\t    for (var i = 0; i < pairEdges.length; i++) {\n\t      edge = pairEdges[i];\n\t      edge_p = edge._private;\n\t      rs = edge_p.rscratch;\n\t\n\t      var edgeIndex1 = rs.lastEdgeIndex;\n\t      var edgeIndex2 = i;\n\t\n\t      var numEdges1 = rs.lastNumEdges;\n\t\n\t      var curveStyle = edge.pstyle('curve-style').value;\n\t\n\t      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\t\n\t      // whether the normalised pair order is the reverse of the edge's src-tgt order\n\t      var edgeIsSwapped = src.id() !== edge.source().id();\n\t\n\t      var ctrlptDists = edge.pstyle('control-point-distances');\n\t      var loopDir = edge.pstyle('loop-direction').pfValue;\n\t      var loopSwp = edge.pstyle('loop-sweep').pfValue;\n\t      var ctrlptWs = edge.pstyle('control-point-weights');\n\t      var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n\t      var stepSize = edge.pstyle('control-point-step-size').pfValue;\n\t      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n\t      var ctrlptWeight = ctrlptWs.value[0];\n\t      var edgeDistances = edge.pstyle('edge-distances').value;\n\t      var segmentWs = edge.pstyle('segment-weights');\n\t      var segmentDs = edge.pstyle('segment-distances');\n\t      var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n\t      var srcEndpt = edge.pstyle('source-endpoint').value;\n\t      var tgtEndpt = edge.pstyle('target-endpoint').value;\n\t      var srcArrShape = edge.pstyle('source-arrow-shape').value;\n\t      var tgtArrShape = edge.pstyle('target-arrow-shape').value;\n\t      var arrowScale = edge.pstyle('arrow-scale').value;\n\t      var lineWidth = edge.pstyle('width').pfValue;\n\t\n\t      var srcX1 = rs.lastSrcCtlPtX;\n\t      var srcY1 = rs.lastSrcCtlPtY;\n\t      var srcW1 = rs.lastSrcCtlPtW;\n\t      var srcH1 = rs.lastSrcCtlPtH;\n\t\n\t      var tgtX1 = rs.lastTgtCtlPtX;\n\t      var tgtY1 = rs.lastTgtCtlPtY;\n\t      var tgtW1 = rs.lastTgtCtlPtW;\n\t      var tgtH1 = rs.lastTgtCtlPtH;\n\t\n\t      var curveStyle1 = rs.lastCurveStyle;\n\t      var curveStyle2 = curveStyle;\n\t\n\t      var ctrlptDists1 = rs.lastCtrlptDists;\n\t      var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;\n\t\n\t      var ctrlptWs1 = rs.lastCtrlptWs;\n\t      var ctrlptWs2 = ctrlptWs.strValue;\n\t\n\t      var segmentWs1 = rs.lastSegmentWs;\n\t      var segmentWs2 = segmentWs.strValue;\n\t\n\t      var segmentDs1 = rs.lastSegmentDs;\n\t      var segmentDs2 = segmentDs.strValue;\n\t\n\t      var stepSize1 = rs.lastStepSize;\n\t      var stepSize2 = stepSize;\n\t\n\t      var loopDir1 = rs.lastLoopDir;\n\t      var loopDir2 = loopDir;\n\t\n\t      var loopSwp1 = rs.lastLoopSwp;\n\t      var loopSwp2 = loopSwp;\n\t\n\t      var edgeDistances1 = rs.lastEdgeDistances;\n\t      var edgeDistances2 = edgeDistances;\n\t\n\t      var srcEndpt1 = rs.lastSrcEndpt;\n\t      var srcEndpt2 = srcEndpt;\n\t\n\t      var tgtEndpt1 = rs.lastTgtEndpt;\n\t      var tgtEndpt2 = tgtEndpt;\n\t\n\t      var srcArr1 = rs.lastSrcArr;\n\t      var srcArr2 = srcArrShape;\n\t\n\t      var tgtArr1 = rs.lastTgtArr;\n\t      var tgtArr2 = tgtArrShape;\n\t\n\t      var lineW1 = rs.lastLineW;\n\t      var lineW2 = lineWidth;\n\t\n\t      var arrScl1 = rs.lastArrScl;\n\t      var arrScl2 = arrowScale;\n\t\n\t      if (badBezier) {\n\t        rs.badBezier = true;\n\t      } else {\n\t        rs.badBezier = false;\n\t      }\n\t\n\t      var ptCacheHit;\n\t\n\t      if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {\n\t        ptCacheHit = true; // then the control points haven't changed and we can skip calculating them\n\t      } else {\n\t        ptCacheHit = false;\n\t\n\t        rs.lastSrcCtlPtX = srcX2;\n\t        rs.lastSrcCtlPtY = srcY2;\n\t        rs.lastSrcCtlPtW = srcW2;\n\t        rs.lastSrcCtlPtH = srcH2;\n\t        rs.lastTgtCtlPtX = tgtX2;\n\t        rs.lastTgtCtlPtY = tgtY2;\n\t        rs.lastTgtCtlPtW = tgtW2;\n\t        rs.lastTgtCtlPtH = tgtH2;\n\t        rs.lastEdgeIndex = edgeIndex2;\n\t        rs.lastNumEdges = numEdges2;\n\t        rs.lastCurveStyle = curveStyle2;\n\t        rs.lastCtrlptDists = ctrlptDists2;\n\t        rs.lastCtrlptWs = ctrlptWs2;\n\t        rs.lastSegmentDs = segmentDs2;\n\t        rs.lastSegmentWs = segmentWs2;\n\t        rs.lastStepSize = stepSize2;\n\t        rs.lastLoopDir = loopDir2;\n\t        rs.lastLoopSwp = loopSwp2;\n\t        rs.lastEdgeDistances = edgeDistances2;\n\t        rs.lastSrcEndpt = srcEndpt2;\n\t        rs.lastTgtEndpt = tgtEndpt2;\n\t        rs.lastSrcArr = srcArr2;\n\t        rs.lastTgtArr = tgtArr2;\n\t        rs.lastLineW = lineW2;\n\t        rs.lastArrScl = arrScl2;\n\t      }\n\t\n\t      if (!ptCacheHit) {\n\t\n\t        if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {\n\t\n\t          pairEdges.calculatedIntersection = true;\n\t\n\t          // pt outside src shape to calc distance/displacement from src to tgt\n\t          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n\t\n\t          pairEdges.srcIntn = srcOutside;\n\t\n\t          // pt outside tgt shape to calc distance/displacement from src to tgt\n\t          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n\t\n\t          pairEdges.tgtIntn = tgtOutside;\n\t\n\t          var midptSrcPts = {\n\t            x1: srcOutside[0],\n\t            x2: tgtOutside[0],\n\t            y1: srcOutside[1],\n\t            y2: tgtOutside[1]\n\t          };\n\t\n\t          var posPts = {\n\t            x1: srcPos.x,\n\t            x2: tgtPos.x,\n\t            y1: srcPos.y,\n\t            y2: tgtPos.y\n\t          };\n\t\n\t          var dy = tgtOutside[1] - srcOutside[1];\n\t          var dx = tgtOutside[0] - srcOutside[0];\n\t          var l = Math.sqrt(dx * dx + dy * dy);\n\t\n\t          var vector = {\n\t            x: dx,\n\t            y: dy\n\t          };\n\t\n\t          var vectorNorm = {\n\t            x: vector.x / l,\n\t            y: vector.y / l\n\t          };\n\t          vectorNormInverse = {\n\t            x: -vectorNorm.y,\n\t            y: vectorNorm.x\n\t          };\n\t\n\t          // if node shapes overlap, then no ctrl pts to draw\n\t          if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {\n\t            vectorNormInverse = {};\n\t            badBezier = true;\n\t          }\n\t        }\n\t\n\t        if (!edgeIsSwapped) {\n\t          rs.srcIntn = pairEdges.srcIntn;\n\t          rs.tgtIntn = pairEdges.tgtIntn;\n\t        } else {\n\t          // ensure that the per-edge cached value for intersections are correct for swapped bundled edges\n\t          rs.srcIntn = pairEdges.tgtIntn;\n\t          rs.tgtIntn = pairEdges.srcIntn;\n\t        }\n\t\n\t        if (src === tgt) {\n\t          // Self-edge\n\t\n\t          rs.edgeType = 'self';\n\t\n\t          var j = i;\n\t          var loopDist = stepSize;\n\t\n\t          if (edgeIsUnbundled) {\n\t            j = 0;\n\t            loopDist = ctrlptDist;\n\t          }\n\t\n\t          var loopAngle = loopDir - Math.PI / 2;\n\t          var outAngle = loopAngle - loopSwp / 2;\n\t          var inAngle = loopAngle + loopSwp / 2;\n\t\n\t          // increase by step size for overlapping loops, keyed on direction and sweep values\n\t          var dc = String(loopDir + '_' + loopSwp);\n\t          j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n\t\n\t          rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n\t        } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {\n\t          // Compound edge\n\t\n\t          rs.edgeType = 'compound';\n\t\n\t          // because the line approximation doesn't apply for compound beziers\n\t          // (loop/self edges are already elided b/c of cheap src==tgt check)\n\t          rs.badBezier = false;\n\t\n\t          var j = i;\n\t          var loopDist = stepSize;\n\t\n\t          if (edgeIsUnbundled) {\n\t            j = 0;\n\t            loopDist = ctrlptDist;\n\t          }\n\t\n\t          var loopW = 50;\n\t\n\t          var loopaPos = {\n\t            x: srcPos.x - srcW / 2,\n\t            y: srcPos.y - srcH / 2\n\t          };\n\t\n\t          var loopbPos = {\n\t            x: tgtPos.x - tgtW / 2,\n\t            y: tgtPos.y - tgtH / 2\n\t          };\n\t\n\t          var loopPos = {\n\t            x: Math.min(loopaPos.x, loopbPos.x),\n\t            y: Math.min(loopaPos.y, loopbPos.y)\n\t          };\n\t\n\t          // avoids cases with impossible beziers\n\t          var minCompoundStretch = 0.5;\n\t          var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n\t          var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n\t\n\t          rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n\t        } else if (curveStyle === 'segments') {\n\t          // Segments (multiple straight lines)\n\t\n\t          rs.edgeType = 'segments';\n\t          rs.segpts = [];\n\t\n\t          for (var s = 0; s < segmentsN; s++) {\n\t            var w = segmentWs.pfValue[s];\n\t            var d = segmentDs.pfValue[s];\n\t\n\t            var w1 = 1 - w;\n\t            var w2 = w;\n\t\n\t            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\t\n\t            var adjustedMidpt = {\n\t              x: midptPts.x1 * w1 + midptPts.x2 * w2,\n\t              y: midptPts.y1 * w1 + midptPts.y2 * w2\n\t            };\n\t\n\t            rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n\t          }\n\t\n\t          // Straight edge\n\t        } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {\n\t\n\t          rs.edgeType = 'straight';\n\t        } else {\n\t          // (Multi)bezier\n\t\n\t          var multi = edgeIsUnbundled;\n\t\n\t          rs.edgeType = multi ? 'multibezier' : 'bezier';\n\t          rs.ctrlpts = [];\n\t\n\t          for (var b = 0; b < bezierN; b++) {\n\t            var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n\t            var manctrlptDist;\n\t            var sign = math.signum(normctrlptDist);\n\t\n\t            if (multi) {\n\t              ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n\t              ctrlptWeight = ctrlptWs.value[b];\n\t            }\n\t\n\t            if (edgeIsUnbundled) {\n\t              // multi or single unbundled\n\t              manctrlptDist = ctrlptDist;\n\t            } else {\n\t              manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n\t            }\n\t\n\t            var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n\t\n\t            var w1 = 1 - ctrlptWeight;\n\t            var w2 = ctrlptWeight;\n\t\n\t            if (edgeIsSwapped) {\n\t              var temp = w1;\n\t              w1 = w2;\n\t              w2 = temp;\n\t            }\n\t\n\t            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\t\n\t            var adjustedMidpt = {\n\t              x: midptPts.x1 * w1 + midptPts.x2 * w2,\n\t              y: midptPts.y1 * w1 + midptPts.y2 * w2\n\t            };\n\t\n\t            rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n\t          }\n\t        }\n\t\n\t        // find endpts for edge\n\t        this.findEndpoints(edge);\n\t\n\t        var badStart = !is.number(rs.startX) || !is.number(rs.startY);\n\t        var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);\n\t        var badEnd = !is.number(rs.endX) || !is.number(rs.endY);\n\t        var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);\n\t\n\t        var minCpADistFactor = 3;\n\t        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n\t        var minCpADist = minCpADistFactor * arrowW;\n\t\n\t        if (rs.edgeType === 'bezier') {\n\t          var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });\n\t          var closeStartACp = startACpDist < minCpADist;\n\t          var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });\n\t          var closeEndACp = endACpDist < minCpADist;\n\t\n\t          var overlapping = false;\n\t\n\t          if (badStart || badAStart || closeStartACp) {\n\t            overlapping = true;\n\t\n\t            // project control point along line from src centre to outside the src shape\n\t            // (otherwise intersection will yield nothing)\n\t            var cpD = { // delta\n\t              x: rs.ctrlpts[0] - srcPos.x,\n\t              y: rs.ctrlpts[1] - srcPos.y\n\t            };\n\t            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n\t            var cpM = { // normalised delta\n\t              x: cpD.x / cpL,\n\t              y: cpD.y / cpL\n\t            };\n\t            var radius = Math.max(srcW, srcH);\n\t            var cpProj = { // *2 radius guarantees outside shape\n\t              x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n\t              y: rs.ctrlpts[1] + cpM.y * 2 * radius\n\t            };\n\t\n\t            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n\t\n\t            if (closeStartACp) {\n\t              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n\t              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n\t            } else {\n\t              rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n\t              rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n\t            }\n\t          }\n\t\n\t          if (badEnd || badAEnd || closeEndACp) {\n\t            overlapping = true;\n\t\n\t            // project control point along line from tgt centre to outside the tgt shape\n\t            // (otherwise intersection will yield nothing)\n\t            var cpD = { // delta\n\t              x: rs.ctrlpts[0] - tgtPos.x,\n\t              y: rs.ctrlpts[1] - tgtPos.y\n\t            };\n\t            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n\t            var cpM = { // normalised delta\n\t              x: cpD.x / cpL,\n\t              y: cpD.y / cpL\n\t            };\n\t            var radius = Math.max(srcW, srcH);\n\t            var cpProj = { // *2 radius guarantees outside shape\n\t              x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n\t              y: rs.ctrlpts[1] + cpM.y * 2 * radius\n\t            };\n\t\n\t            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);\n\t\n\t            if (closeEndACp) {\n\t              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);\n\t              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);\n\t            } else {\n\t              rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;\n\t              rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n\t            }\n\t          }\n\t\n\t          if (overlapping) {\n\t            // recalc endpts\n\t            this.findEndpoints(edge);\n\t          }\n\t        }\n\t\n\t        if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n\t          rs.allpts = [];\n\t\n\t          rs.allpts.push(rs.startX, rs.startY);\n\t\n\t          for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n\t            // ctrl pt itself\n\t            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n\t\n\t            // the midpt between ctrlpts as intermediate destination pts\n\t            if (b + 3 < rs.ctrlpts.length) {\n\t              rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n\t            }\n\t          }\n\t\n\t          rs.allpts.push(rs.endX, rs.endY);\n\t\n\t          var m, mt;\n\t          if (rs.ctrlpts.length / 2 % 2 === 0) {\n\t            m = rs.allpts.length / 2 - 1;\n\t\n\t            rs.midX = rs.allpts[m];\n\t            rs.midY = rs.allpts[m + 1];\n\t          } else {\n\t            m = rs.allpts.length / 2 - 3;\n\t            mt = 0.5;\n\t\n\t            rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n\t            rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n\t          }\n\t        } else if (rs.edgeType === 'straight') {\n\t          // need to calc these after endpts\n\t          rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];\n\t\n\t          // default midpt for labels etc\n\t          rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n\t          rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n\t        } else if (rs.edgeType === 'segments') {\n\t          rs.allpts = [];\n\t          rs.allpts.push(rs.startX, rs.startY);\n\t          rs.allpts.push.apply(rs.allpts, rs.segpts);\n\t          rs.allpts.push(rs.endX, rs.endY);\n\t\n\t          if (rs.segpts.length % 4 === 0) {\n\t            var i2 = rs.segpts.length / 2;\n\t            var i1 = i2 - 2;\n\t\n\t            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n\t            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n\t          } else {\n\t            var i1 = rs.segpts.length / 2 - 1;\n\t\n\t            rs.midX = rs.segpts[i1];\n\t            rs.midY = rs.segpts[i1 + 1];\n\t          }\n\t        }\n\t\n\t        this.storeEdgeProjections(edge);\n\t        this.calculateArrowAngles(edge);\n\t      } // if point cache miss\n\t\n\t      this.recalculateEdgeLabelProjections(edge);\n\t      this.calculateLabelAngles(edge);\n\t    } // for pair edges\n\t  } // for pair ids\n\t\n\t  for (var i = 0; i < haystackEdges.length; i++) {\n\t    var edge = haystackEdges[i];\n\t    var _p = edge._private;\n\t    var rscratch = _p.rscratch;\n\t    var rs = rscratch;\n\t\n\t    if (!rscratch.haystack) {\n\t      var angle = Math.random() * 2 * Math.PI;\n\t\n\t      rscratch.source = {\n\t        x: Math.cos(angle),\n\t        y: Math.sin(angle)\n\t      };\n\t\n\t      var angle = Math.random() * 2 * Math.PI;\n\t\n\t      rscratch.target = {\n\t        x: Math.cos(angle),\n\t        y: Math.sin(angle)\n\t      };\n\t    }\n\t\n\t    var src = _p.source;\n\t    var tgt = _p.target;\n\t    var srcPos = src.position();\n\t    var tgtPos = tgt.position();\n\t    var srcW = src.width();\n\t    var tgtW = tgt.width();\n\t    var srcH = src.height();\n\t    var tgtH = tgt.height();\n\t    var radius = edge.pstyle('haystack-radius').value;\n\t    var halfRadius = radius / 2; // b/c have to half width/height\n\t\n\t    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n\t\n\t    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n\t    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n\t\n\t    // always override as haystack in case set to different type previously\n\t    rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';\n\t    rscratch.haystack = true;\n\t\n\t    this.storeEdgeProjections(edge);\n\t    this.calculateArrowAngles(edge);\n\t    this.recalculateEdgeLabelProjections(edge);\n\t    this.calculateLabelAngles(edge);\n\t  }\n\t};\n\t\n\tfunction getPts(pts) {\n\t  var retPts = [];\n\t\n\t  if (pts == null) {\n\t    return;\n\t  }\n\t\n\t  for (var i = 0; i < pts.length; i += 2) {\n\t    var x = pts[i];\n\t    var y = pts[i + 1];\n\t\n\t    retPts.push({ x: x, y: y });\n\t  }\n\t\n\t  return retPts;\n\t}\n\t\n\tBRp.getSegmentPoints = function (edge) {\n\t  var rs = edge[0]._private.rscratch;\n\t  var type = rs.edgeType;\n\t\n\t  if (type === 'segments') {\n\t    return getPts(rs.segpts);\n\t  }\n\t};\n\t\n\tBRp.getControlPoints = function (edge) {\n\t  var rs = edge[0]._private.rscratch;\n\t  var type = rs.edgeType;\n\t\n\t  if (type === 'bezier' || type === 'multibezier') {\n\t    return getPts(rs.ctrlpts);\n\t  }\n\t};\n\t\n\tBRp.getEdgeMidpoint = function (edge) {\n\t  var rs = edge[0]._private.rscratch;\n\t\n\t  return {\n\t    x: rs.midX,\n\t    y: rs.midY\n\t  };\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 89 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\t\n\tvar BRp = {};\n\t\n\tBRp.manualEndptToPx = function (node, prop) {\n\t  var r = this;\n\t  var npos = node.position();\n\t  var w = node.outerWidth();\n\t  var h = node.outerHeight();\n\t\n\t  if (prop.value.length === 2) {\n\t    var p = [prop.pfValue[0], prop.pfValue[1]];\n\t\n\t    if (prop.units[0] === '%') {\n\t      p[0] = p[0] * w;\n\t    }\n\t\n\t    if (prop.units[1] === '%') {\n\t      p[1] = p[1] * h;\n\t    }\n\t\n\t    p[0] += npos.x;\n\t    p[1] += npos.y;\n\t\n\t    return p;\n\t  } else {\n\t    var angle = prop.pfValue[0];\n\t\n\t    angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\t\n\t    var l = 2 * Math.max(w, h);\n\t\n\t    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n\t\n\t    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n\t  }\n\t};\n\t\n\tBRp.findEndpoints = function (edge) {\n\t  var r = this;\n\t  var intersect = void 0;\n\t\n\t  var source = edge.source()[0];\n\t  var target = edge.target()[0];\n\t\n\t  var srcPos = source.position();\n\t  var tgtPos = target.position();\n\t\n\t  var tgtArShape = edge.pstyle('target-arrow-shape').value;\n\t  var srcArShape = edge.pstyle('source-arrow-shape').value;\n\t\n\t  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n\t  var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n\t\n\t  var rs = edge._private.rscratch;\n\t\n\t  var et = rs.edgeType;\n\t  var self = et === 'self' || et === 'compound';\n\t  var bezier = et === 'bezier' || et === 'multibezier' || self;\n\t  var multi = et !== 'bezier';\n\t  var lines = et === 'straight' || et === 'segments';\n\t  var segments = et === 'segments';\n\t  var hasEndpts = bezier || multi || lines;\n\t  var srcManEndpt = edge.pstyle('source-endpoint');\n\t  var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;\n\t  var tgtManEndpt = edge.pstyle('target-endpoint');\n\t  var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;\n\t\n\t  rs.srcManEndpt = srcManEndpt;\n\t  rs.tgtManEndpt = tgtManEndpt;\n\t\n\t  var p1 = void 0; // last known point of edge on target side\n\t  var p2 = void 0; // last known point of edge on source side\n\t\n\t  var p1_i = void 0; // point to intersect with target shape\n\t  var p2_i = void 0; // point to intersect with source shape\n\t\n\t  if (bezier) {\n\t    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n\t    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n\t\n\t    p1 = cpEnd;\n\t    p2 = cpStart;\n\t  } else if (lines) {\n\t    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n\t    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n\t\n\t    p1 = tgtArrowFromPt;\n\t    p2 = srcArrowFromPt;\n\t  }\n\t\n\t  if (tgtManEndptVal === 'inside-to-node') {\n\t    intersect = [tgtPos.x, tgtPos.y];\n\t  } else if (tgtManEndpt.units) {\n\t    intersect = this.manualEndptToPx(target, tgtManEndpt);\n\t  } else if (tgtManEndptVal === 'outside-to-line') {\n\t    intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n\t  } else {\n\t    if (tgtManEndptVal === 'outside-to-node') {\n\t      p1_i = p1;\n\t    } else if (tgtManEndptVal === 'outside-to-line') {\n\t      p1_i = [srcPos.x, srcPos.y];\n\t    }\n\t\n\t    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n\t  }\n\t\n\t  var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n\t  var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n\t\n\t  rs.endX = edgeEnd[0];\n\t  rs.endY = edgeEnd[1];\n\t\n\t  rs.arrowEndX = arrowEnd[0];\n\t  rs.arrowEndY = arrowEnd[1];\n\t\n\t  if (srcManEndptVal === 'inside-to-node') {\n\t    intersect = [srcPos.x, srcPos.y];\n\t  } else if (srcManEndpt.units) {\n\t    intersect = this.manualEndptToPx(source, srcManEndpt);\n\t  } else if (srcManEndptVal === 'outside-to-line') {\n\t    intersect = rs.srcIntn; // use cached value from ctrlpt calc\n\t  } else {\n\t    if (srcManEndptVal === 'outside-to-node') {\n\t      p2_i = p2;\n\t    } else if (srcManEndptVal === 'outside-to-line') {\n\t      p2_i = [tgtPos.x, tgtPos.y];\n\t    }\n\t\n\t    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n\t  }\n\t\n\t  var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n\t  var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n\t\n\t  rs.startX = edgeStart[0];\n\t  rs.startY = edgeStart[1];\n\t\n\t  rs.arrowStartX = arrowStart[0];\n\t  rs.arrowStartY = arrowStart[1];\n\t\n\t  if (hasEndpts) {\n\t    if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {\n\t      rs.badLine = true;\n\t    } else {\n\t      rs.badLine = false;\n\t    }\n\t  }\n\t};\n\t\n\tBRp.getSourceEndpoint = function (edge) {\n\t  var rs = edge[0]._private.rscratch;\n\t\n\t  switch (rs.edgeType) {\n\t    case 'haystack':\n\t      return {\n\t        x: rs.haystackPts[0],\n\t        y: rs.haystackPts[1]\n\t      };\n\t    default:\n\t      return {\n\t        x: rs.arrowStartX,\n\t        y: rs.arrowStartY\n\t      };\n\t  }\n\t};\n\t\n\tBRp.getTargetEndpoint = function (edge) {\n\t  var rs = edge[0]._private.rscratch;\n\t\n\t  switch (rs.edgeType) {\n\t    case 'haystack':\n\t      return {\n\t        x: rs.haystackPts[2],\n\t        y: rs.haystackPts[3]\n\t      };\n\t    default:\n\t      return {\n\t        x: rs.arrowEndX,\n\t        y: rs.arrowEndY\n\t      };\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 90 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\t\n\tvar BRp = {};\n\t\n\tfunction pushBezierPts(r, edge, pts) {\n\t  var qbezierAt = function qbezierAt(p1, p2, p3, t) {\n\t    return math.qbezierAt(p1, p2, p3, t);\n\t  };\n\t  var _p = edge._private;\n\t  var bpts = _p.rstyle.bezierPts;\n\t\n\t  for (var i = 0; i < r.bezierProjPcts.length; i++) {\n\t    var p = r.bezierProjPcts[i];\n\t\n\t    bpts.push({\n\t      x: qbezierAt(pts[0], pts[2], pts[4], p),\n\t      y: qbezierAt(pts[1], pts[3], pts[5], p)\n\t    });\n\t  }\n\t}\n\t\n\tBRp.storeEdgeProjections = function (edge) {\n\t  var _p = edge._private;\n\t  var rs = _p.rscratch;\n\t  var et = rs.edgeType;\n\t\n\t  // clear the cached points state\n\t  _p.rstyle.bezierPts = null;\n\t  _p.rstyle.linePts = null;\n\t  _p.rstyle.haystackPts = null;\n\t\n\t  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n\t    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line\n\t\n\t    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n\t      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n\t    }\n\t  } else if (et === 'segments') {\n\t    var lpts = _p.rstyle.linePts = [];\n\t\n\t    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n\t      lpts.push({\n\t        x: rs.allpts[i],\n\t        y: rs.allpts[i + 1]\n\t      });\n\t    }\n\t  } else if (et === 'haystack') {\n\t    var hpts = rs.haystackPts;\n\t\n\t    _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];\n\t  }\n\t\n\t  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n\t};\n\t\n\tBRp.recalculateEdgeProjections = function (edges) {\n\t  this.findEdgeControlPoints(edges);\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 91 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar BRp = {};\n\t\n\t[__webpack_require__(86), __webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(92), __webpack_require__(93), __webpack_require__(94), __webpack_require__(95)].forEach(function (props) {\n\t  util.extend(BRp, props);\n\t});\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 92 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\t\n\tvar BRp = {};\n\t\n\tBRp.recalculateNodeLabelProjection = function (node) {\n\t  var content = node.pstyle('label').strValue;\n\t\n\t  if (is.emptyString(content)) {\n\t    return;\n\t  }\n\t\n\t  var textX, textY;\n\t  var _p = node._private;\n\t  var nodeWidth = node.width();\n\t  var nodeHeight = node.height();\n\t  var padding = node.padding();\n\t  var nodePos = node.position();\n\t  var textHalign = node.pstyle('text-halign').strValue;\n\t  var textValign = node.pstyle('text-valign').strValue;\n\t  var rs = _p.rscratch;\n\t  var rstyle = _p.rstyle;\n\t\n\t  switch (textHalign) {\n\t    case 'left':\n\t      textX = nodePos.x - nodeWidth / 2 - padding;\n\t      break;\n\t\n\t    case 'right':\n\t      textX = nodePos.x + nodeWidth / 2 + padding;\n\t      break;\n\t\n\t    default:\n\t      // e.g. center\n\t      textX = nodePos.x;\n\t  }\n\t\n\t  switch (textValign) {\n\t    case 'top':\n\t      textY = nodePos.y - nodeHeight / 2 - padding;\n\t      break;\n\t\n\t    case 'bottom':\n\t      textY = nodePos.y + nodeHeight / 2 + padding;\n\t      break;\n\t\n\t    default:\n\t      // e.g. middle\n\t      textY = nodePos.y;\n\t  }\n\t\n\t  rs.labelX = textX;\n\t  rs.labelY = textY;\n\t  rstyle.labelX = textX;\n\t  rstyle.labelY = textY;\n\t\n\t  this.applyLabelDimensions(node);\n\t};\n\t\n\tBRp.recalculateEdgeLabelProjections = function (edge) {\n\t  var p;\n\t  var _p = edge._private;\n\t  var rs = _p.rscratch;\n\t  var r = this;\n\t  var content = {\n\t    mid: edge.pstyle('label').strValue,\n\t    source: edge.pstyle('source-label').strValue,\n\t    target: edge.pstyle('target-label').strValue\n\t  };\n\t\n\t  if (content.mid || content.source || content.target) {\n\t    // then we have to calculate...\n\t  } else {\n\t      return; // no labels => no calcs\n\t    }\n\t\n\t  // add center point to style so bounding box calculations can use it\n\t  //\n\t  p = {\n\t    x: rs.midX,\n\t    y: rs.midY\n\t  };\n\t\n\t  var setRs = function setRs(propName, prefix, value) {\n\t    util.setPrefixedProperty(_p.rscratch, propName, prefix, value);\n\t    util.setPrefixedProperty(_p.rstyle, propName, prefix, value);\n\t  };\n\t\n\t  setRs('labelX', null, p.x);\n\t  setRs('labelY', null, p.y);\n\t\n\t  var createControlPointInfo = function createControlPointInfo() {\n\t    if (createControlPointInfo.cache) {\n\t      return createControlPointInfo.cache;\n\t    } // use cache so only 1x per edge\n\t\n\t    var ctrlpts = [];\n\t\n\t    // store each ctrlpt info init\n\t    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n\t      var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };\n\t      var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt\n\t      var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };\n\t\n\t      ctrlpts.push({\n\t        p0: p0,\n\t        p1: p1,\n\t        p2: p2,\n\t        startDist: 0,\n\t        length: 0,\n\t        segments: []\n\t      });\n\t    }\n\t\n\t    var bpts = _p.rstyle.bezierPts;\n\t    var nProjs = r.bezierProjPcts.length;\n\t\n\t    function addSegment(cp, p0, p1, t0, t1) {\n\t      var length = math.dist(p0, p1);\n\t      var prevSegment = cp.segments[cp.segments.length - 1];\n\t      var segment = {\n\t        p0: p0,\n\t        p1: p1,\n\t        t0: t0,\n\t        t1: t1,\n\t        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n\t        length: length\n\t      };\n\t\n\t      cp.segments.push(segment);\n\t\n\t      cp.length += length;\n\t    }\n\t\n\t    // update each ctrlpt with segment info\n\t    for (var i = 0; i < ctrlpts.length; i++) {\n\t      var cp = ctrlpts[i];\n\t      var prevCp = ctrlpts[i - 1];\n\t\n\t      if (prevCp) {\n\t        cp.startDist = prevCp.startDist + prevCp.length;\n\t      }\n\t\n\t      addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first\n\t\n\t      for (var j = 0; j < nProjs - 1; j++) {\n\t        addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n\t      }\n\t\n\t      addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n\t    }\n\t\n\t    return createControlPointInfo.cache = ctrlpts;\n\t  };\n\t\n\t  var calculateEndProjection = function calculateEndProjection(prefix) {\n\t    var angle;\n\t    var isSrc = prefix === 'source';\n\t\n\t    if (!content[prefix]) {\n\t      return;\n\t    }\n\t\n\t    var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n\t\n\t    var lineAngle = function lineAngle(p0, p1) {\n\t      var dx = p1.x - p0.x;\n\t      var dy = p1.y - p0.y;\n\t\n\t      return Math.atan(dy / dx);\n\t    };\n\t\n\t    var bezierAngle = function bezierAngle(p0, p1, p2, t) {\n\t      var t0 = math.bound(0, t - 0.001, 1);\n\t      var t1 = math.bound(0, t + 0.001, 1);\n\t\n\t      var lp0 = math.qbezierPtAt(p0, p1, p2, t0);\n\t      var lp1 = math.qbezierPtAt(p0, p1, p2, t1);\n\t\n\t      return lineAngle(lp0, lp1);\n\t    };\n\t\n\t    switch (rs.edgeType) {\n\t      case 'self':\n\t      case 'compound':\n\t      case 'bezier':\n\t      case 'multibezier':\n\t        var cps = createControlPointInfo();\n\t        var selected;\n\t        var startDist = 0;\n\t        var totalDist = 0;\n\t\n\t        // find the segment we're on\n\t        for (var i = 0; i < cps.length; i++) {\n\t          var cp = cps[isSrc ? i : cps.length - 1 - i];\n\t\n\t          for (var j = 0; j < cp.segments.length; j++) {\n\t            var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];\n\t            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;\n\t\n\t            startDist = totalDist;\n\t            totalDist += seg.length;\n\t\n\t            if (totalDist >= offset || lastSeg) {\n\t              selected = { cp: cp, segment: seg };\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (selected) {\n\t            break;\n\t          }\n\t        }\n\t\n\t        var cp = selected.cp;\n\t        var seg = selected.segment;\n\t        var tSegment = (offset - startDist) / seg.length;\n\t        var segDt = seg.t1 - seg.t0;\n\t        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n\t\n\t        t = math.bound(0, t, 1);\n\t        p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n\t        angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);\n\t\n\t        break;\n\t\n\t      case 'straight':\n\t      case 'segments':\n\t      case 'haystack':\n\t        var d = 0,\n\t            di,\n\t            d0;\n\t        var p0, p1;\n\t        var l = rs.allpts.length;\n\t\n\t        for (var i = 0; i + 3 < l; i += 2) {\n\t          if (isSrc) {\n\t            p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };\n\t            p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };\n\t          } else {\n\t            p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };\n\t            p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };\n\t          }\n\t\n\t          di = math.dist(p0, p1);\n\t          d0 = d;\n\t          d += di;\n\t\n\t          if (d >= offset) {\n\t            break;\n\t          }\n\t        }\n\t\n\t        var pD = offset - d0;\n\t        var t = pD / di;\n\t\n\t        t = math.bound(0, t, 1);\n\t        p = math.lineAt(p0, p1, t);\n\t        angle = lineAngle(p0, p1);\n\t\n\t        break;\n\t    }\n\t\n\t    setRs('labelX', prefix, p.x);\n\t    setRs('labelY', prefix, p.y);\n\t    setRs('labelAutoAngle', prefix, angle);\n\t  };\n\t\n\t  calculateEndProjection('source');\n\t  calculateEndProjection('target');\n\t\n\t  this.applyLabelDimensions(edge);\n\t};\n\t\n\tBRp.applyLabelDimensions = function (ele) {\n\t  this.applyPrefixedLabelDimensions(ele);\n\t\n\t  if (ele.isEdge()) {\n\t    this.applyPrefixedLabelDimensions(ele, 'source');\n\t    this.applyPrefixedLabelDimensions(ele, 'target');\n\t  }\n\t};\n\t\n\tBRp.applyPrefixedLabelDimensions = function (ele, prefix) {\n\t  var _p = ele._private;\n\t\n\t  var text = this.getLabelText(ele, prefix);\n\t  var labelDims = this.calculateLabelDimensions(ele, text);\n\t\n\t  util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);\n\t  util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);\n\t\n\t  util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);\n\t  util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);\n\t};\n\t\n\tBRp.getLabelText = function (ele, prefix) {\n\t  var _p = ele._private;\n\t  var pfd = prefix ? prefix + '-' : '';\n\t  var text = ele.pstyle(pfd + 'label').strValue;\n\t  var textTransform = ele.pstyle('text-transform').value;\n\t  var rscratch = function rscratch(propName, value) {\n\t    if (value) {\n\t      util.setPrefixedProperty(_p.rscratch, propName, prefix, value);\n\t      return value;\n\t    } else {\n\t      return util.getPrefixedProperty(_p.rscratch, propName, prefix);\n\t    }\n\t  };\n\t\n\t  if (textTransform == 'none') {\n\t    // passthrough\n\t  } else if (textTransform == 'uppercase') {\n\t    text = text.toUpperCase();\n\t  } else if (textTransform == 'lowercase') {\n\t    text = text.toLowerCase();\n\t  }\n\t\n\t  var wrapStyle = ele.pstyle('text-wrap').value;\n\t\n\t  if (wrapStyle === 'wrap') {\n\t    //console.log('wrap');\n\t\n\t    var labelKey = rscratch('labelKey');\n\t\n\t    // save recalc if the label is the same as before\n\t    if (labelKey && rscratch('labelWrapKey') === labelKey) {\n\t      // console.log('wrap cache hit');\n\t      return rscratch('labelWrapCachedText');\n\t    }\n\t    // console.log('wrap cache miss');\n\t\n\t    var lines = text.split('\\n');\n\t    var maxW = ele.pstyle('text-max-width').pfValue;\n\t    var wrappedLines = [];\n\t\n\t    for (var l = 0; l < lines.length; l++) {\n\t      var line = lines[l];\n\t      var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);\n\t      var lineW = lineDims.width;\n\t\n\t      if (lineW > maxW) {\n\t        // line is too long\n\t        var words = line.split(/\\s+/); // NB: assume collapsed whitespace into single space\n\t        var subline = '';\n\t\n\t        for (var w = 0; w < words.length; w++) {\n\t          var word = words[w];\n\t          var testLine = subline.length === 0 ? word : subline + ' ' + word;\n\t          var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);\n\t          var testW = testDims.width;\n\t\n\t          if (testW <= maxW) {\n\t            // word fits on current line\n\t            subline += word + ' ';\n\t          } else {\n\t            // word starts new line\n\t            wrappedLines.push(subline);\n\t            subline = word + ' ';\n\t          }\n\t        }\n\t\n\t        // if there's remaining text, put it in a wrapped line\n\t        if (!subline.match(/^\\s+$/)) {\n\t          wrappedLines.push(subline);\n\t        }\n\t      } else {\n\t        // line is already short enough\n\t        wrappedLines.push(line);\n\t      }\n\t    } // for\n\t\n\t    rscratch('labelWrapCachedLines', wrappedLines);\n\t    text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n\t    rscratch('labelWrapKey', labelKey);\n\t\n\t    // console.log(text)\n\t  } else if (wrapStyle === 'ellipsis') {\n\t    var maxW = ele.pstyle('text-max-width').pfValue;\n\t    var ellipsized = '';\n\t    var ellipsis = '\\u2026';\n\t    var incLastCh = false;\n\t\n\t    for (var i = 0; i < text.length; i++) {\n\t      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n\t\n\t      if (widthWithNextCh > maxW) {\n\t        break;\n\t      }\n\t\n\t      ellipsized += text[i];\n\t\n\t      if (i === text.length - 1) {\n\t        incLastCh = true;\n\t      }\n\t    }\n\t\n\t    if (!incLastCh) {\n\t      ellipsized += ellipsis;\n\t    }\n\t\n\t    return ellipsized;\n\t  } // if ellipsize\n\t\n\t  return text;\n\t};\n\t\n\tBRp.calculateLabelDimensions = function (ele, text, extraKey) {\n\t  var r = this;\n\t\n\t  var cacheKey = ele._private.labelStyleKey + '$@$' + text;\n\t\n\t  if (extraKey) {\n\t    cacheKey += '$@$' + extraKey;\n\t  }\n\t\n\t  var cache = r.labelDimCache || (r.labelDimCache = {});\n\t\n\t  if (cache[cacheKey]) {\n\t    return cache[cacheKey];\n\t  }\n\t\n\t  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text\n\t  var fStyle = ele.pstyle('font-style').strValue;\n\t  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';\n\t  var family = ele.pstyle('font-family').strValue;\n\t  var weight = ele.pstyle('font-weight').strValue;\n\t\n\t  var div = this.labelCalcDiv;\n\t\n\t  if (!div) {\n\t    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef\n\t    document.body.appendChild(div); // eslint-disable-line no-undef\n\t  }\n\t\n\t  var ds = div.style;\n\t\n\t  // from ele style\n\t  ds.fontFamily = family;\n\t  ds.fontStyle = fStyle;\n\t  ds.fontSize = size;\n\t  ds.fontWeight = weight;\n\t\n\t  // forced style\n\t  ds.position = 'absolute';\n\t  ds.left = '-9999px';\n\t  ds.top = '-9999px';\n\t  ds.zIndex = '-1';\n\t  ds.visibility = 'hidden';\n\t  ds.pointerEvents = 'none';\n\t  ds.padding = '0';\n\t  ds.lineHeight = '1';\n\t\n\t  if (ele.pstyle('text-wrap').value === 'wrap') {\n\t    ds.whiteSpace = 'pre'; // so newlines are taken into account\n\t  } else {\n\t    ds.whiteSpace = 'normal';\n\t  }\n\t\n\t  // put label content in div\n\t  div.textContent = text;\n\t\n\t  cache[cacheKey] = {\n\t    width: Math.ceil(div.clientWidth / sizeMult),\n\t    height: Math.ceil(div.clientHeight / sizeMult)\n\t  };\n\t\n\t  return cache[cacheKey];\n\t};\n\t\n\tBRp.calculateLabelAngles = function (ele) {\n\t  var _p = ele._private;\n\t  var rs = _p.rscratch;\n\t  var isEdge = ele.isEdge();\n\t  var rot = ele.pstyle('text-rotation');\n\t  var rotStr = rot.strValue;\n\t\n\t  if (rotStr === 'none') {\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n\t  } else if (isEdge && rotStr === 'autorotate') {\n\t    rs.labelAngle = Math.atan(rs.midDispY / rs.midDispX);\n\t    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;\n\t    rs.targetLabelAngle = rs.targetLabelAutoAngle;\n\t  } else if (rotStr === 'autorotate') {\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n\t  } else {\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 93 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar BRp = {};\n\t\n\tBRp.getNodeShape = function (node) {\n\t  var r = this;\n\t  var shape = node.pstyle('shape').value;\n\t\n\t  if (node.isParent()) {\n\t    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {\n\t      return shape;\n\t    } else {\n\t      return 'rectangle';\n\t    }\n\t  }\n\t\n\t  if (shape === 'polygon') {\n\t    var points = node.pstyle('shape-polygon-points').value;\n\t\n\t    return r.nodeShapes.makePolygon(points).name;\n\t  }\n\t\n\t  return shape;\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 94 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar BRp = {};\n\t\n\tBRp.registerCalculationListeners = function () {\n\t  var cy = this.cy;\n\t  var elesToUpdate = cy.collection();\n\t  var r = this;\n\t\n\t  var enqueue = function enqueue(eles, e, dirtyStyleCaches) {\n\t    elesToUpdate.merge(eles);\n\t\n\t    if (dirtyStyleCaches === true || dirtyStyleCaches === undefined) {\n\t      for (var i = 0; i < eles.length; i++) {\n\t        var ele = eles[i];\n\t        var _p = ele._private;\n\t        var rstyle = _p.rstyle;\n\t\n\t        rstyle.clean = false;\n\t        _p.bbCache = null;\n\t\n\t        var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };\n\t\n\t        if (!evts[e.type]) {\n\t          evts[e.type] = true;\n\t          evts.length++;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  r.binder(cy)\n\t  // nodes\n\t\n\t  .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {\n\t    var node = e.target;\n\t\n\t    enqueue(node, e);\n\t    enqueue(node.connectedEdges(), e);\n\t  }).on('add.*', 'node', function onDirtyAddNode(e) {\n\t    var ele = e.target;\n\t\n\t    enqueue(ele, e);\n\t  }).on('background.*', 'node', function onDirtyBgNode(e) {\n\t    var ele = e.target;\n\t\n\t    enqueue(ele, e, false);\n\t  })\n\t\n\t  // edges\n\t\n\t  .on('add.* style.*', 'edge', function onDirtyEdge(e) {\n\t    var edge = e.target;\n\t\n\t    enqueue(edge, e);\n\t    enqueue(edge.parallelEdges(), e);\n\t  }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {\n\t    var edge = e.target;\n\t    var pEdges = edge.parallelEdges();\n\t\n\t    for (var i = 0; i < pEdges.length; i++) {\n\t      var pEdge = pEdges[i];\n\t\n\t      if (!pEdge.removed()) {\n\t        enqueue(pEdge, e);\n\t      }\n\t    }\n\t  })\n\t\n\t  // manual dirtying\n\t\n\t  .on('dirty.*', 'node', function onDirtyEle(e) {\n\t    var ele = e.target;\n\t\n\t    enqueue(ele, e);\n\t  });\n\t\n\t  var updateEleCalcs = function updateEleCalcs(willDraw) {\n\t    if (willDraw) {\n\t      var fns = r.onUpdateEleCalcsFns;\n\t\n\t      if (fns) {\n\t        for (var i = 0; i < fns.length; i++) {\n\t          var fn = fns[i];\n\t\n\t          fn(willDraw, elesToUpdate);\n\t        }\n\t      }\n\t\n\t      r.recalculateRenderedStyle(elesToUpdate, false);\n\t\n\t      for (var i = 0; i < elesToUpdate.length; i++) {\n\t        elesToUpdate[i]._private.rstyle.dirtyEvents = null;\n\t      }\n\t\n\t      elesToUpdate = cy.collection();\n\t    }\n\t  };\n\t\n\t  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n\t};\n\t\n\tBRp.onUpdateEleCalcs = function (fn) {\n\t  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n\t\n\t  fns.push(fn);\n\t};\n\t\n\tBRp.recalculateRenderedStyle = function (eles, useCache) {\n\t  var edges = [];\n\t  var nodes = [];\n\t\n\t  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n\t  if (this.destroyed) {\n\t    return;\n\t  }\n\t\n\t  // use cache by default for perf\n\t  if (useCache === undefined) {\n\t    useCache = true;\n\t  }\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t    var _p = ele._private;\n\t    var rstyle = _p.rstyle;\n\t\n\t    // only update if dirty and in graph\n\t    if (useCache && rstyle.clean || ele.removed()) {\n\t      continue;\n\t    }\n\t\n\t    // only update if not display: none\n\t    if (ele.pstyle('display').value === 'none') {\n\t      continue;\n\t    }\n\t\n\t    if (_p.group === 'nodes') {\n\t      nodes.push(ele);\n\t    } else {\n\t      // edges\n\t      edges.push(ele);\n\t    }\n\t\n\t    rstyle.clean = true;\n\t    // rstyle.dirtyEvents = null;\n\t  }\n\t\n\t  // update node data from projections\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    var ele = nodes[i];\n\t    var _p = ele._private;\n\t    var rstyle = _p.rstyle;\n\t    var pos = ele.position();\n\t\n\t    this.recalculateNodeLabelProjection(ele);\n\t\n\t    rstyle.nodeX = pos.x;\n\t    rstyle.nodeY = pos.y;\n\t    rstyle.nodeW = ele.pstyle('width').pfValue;\n\t    rstyle.nodeH = ele.pstyle('height').pfValue;\n\t  }\n\t\n\t  this.recalculateEdgeProjections(edges);\n\t\n\t  // update edge data from projections\n\t  for (var i = 0; i < edges.length; i++) {\n\t    var ele = edges[i];\n\t    var _p = ele._private;\n\t    var rstyle = _p.rstyle;\n\t    var rs = _p.rscratch;\n\t\n\t    this.recalculateEdgeLabelProjections(ele);\n\t\n\t    // update rstyle positions\n\t    rstyle.srcX = rs.arrowStartX;\n\t    rstyle.srcY = rs.arrowStartY;\n\t    rstyle.tgtX = rs.arrowEndX;\n\t    rstyle.tgtY = rs.arrowEndY;\n\t    rstyle.midX = rs.midX;\n\t    rstyle.midY = rs.midY;\n\t    rstyle.labelAngle = rs.labelAngle;\n\t    rstyle.sourceLabelAngle = rs.sourceLabelAngle;\n\t    rstyle.targetLabelAngle = rs.targetLabelAngle;\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 95 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar zIndexSort = __webpack_require__(14);\n\t\n\tvar BRp = {};\n\t\n\tBRp.updateCachedGrabbedEles = function () {\n\t  var eles = this.cachedZSortedEles;\n\t\n\t  if (!eles) {\n\t    // just let this be recalculated on the next z sort tick\n\t    return;\n\t  }\n\t\n\t  eles.drag = [];\n\t  eles.nondrag = [];\n\t\n\t  var grabTargets = [];\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t    var rs = ele._private.rscratch;\n\t\n\t    if (ele.grabbed() && !ele.isParent()) {\n\t      grabTargets.push(ele);\n\t    } else if (rs.inDragLayer) {\n\t      eles.drag.push(ele);\n\t    } else {\n\t      eles.nondrag.push(ele);\n\t    }\n\t  }\n\t\n\t  // put the grab target nodes last so it's on top of its neighbourhood\n\t  for (var i = 0; i < grabTargets.length; i++) {\n\t    var ele = grabTargets[i];\n\t\n\t    eles.drag.push(ele);\n\t  }\n\t};\n\t\n\tBRp.invalidateCachedZSortedEles = function () {\n\t  this.cachedZSortedEles = null;\n\t};\n\t\n\tBRp.getCachedZSortedEles = function (forceRecalc) {\n\t  if (forceRecalc || !this.cachedZSortedEles) {\n\t    //console.time('cachezorder')\n\t\n\t    var eles = this.cy.mutableElements().toArray();\n\t\n\t    eles.sort(zIndexSort);\n\t\n\t    eles.interactive = eles.filter(function (ele) {\n\t      return ele.interactive();\n\t    });\n\t\n\t    this.cachedZSortedEles = eles;\n\t\n\t    this.updateCachedGrabbedEles();\n\t  } else {\n\t    eles = this.cachedZSortedEles;\n\t  }\n\t\n\t  return eles;\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 96 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar BRp = {};\n\t\n\tBRp.getCachedImage = function (url, crossOrigin, onLoad) {\n\t  var r = this;\n\t  var imageCache = r.imageCache = r.imageCache || {};\n\t  var cache = imageCache[url];\n\t\n\t  if (cache) {\n\t    if (!cache.image.complete) {\n\t      cache.image.addEventListener('load', onLoad);\n\t    }\n\t\n\t    return cache.image;\n\t  } else {\n\t    cache = imageCache[url] = imageCache[url] || {};\n\t\n\t    var image = cache.image = new Image(); // eslint-disable-line no-undef\n\t\n\t    image.addEventListener('load', onLoad);\n\t    image.addEventListener('error', function () {\n\t      image.error = true;\n\t    });\n\t\n\t    // #1582 safari doesn't load data uris with crossOrigin properly\n\t    // https://bugs.webkit.org/show_bug.cgi?id=123978\n\t    var dataUriPrefix = 'data:';\n\t    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n\t    if (!isDataUri) {\n\t      image.crossOrigin = crossOrigin; // prevent tainted canvas\n\t    }\n\t\n\t    image.src = url;\n\t\n\t    return image;\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 97 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar window = __webpack_require__(4);\n\t\n\tvar BaseRenderer = function BaseRenderer(options) {\n\t  this.init(options);\n\t};\n\tvar BR = BaseRenderer;\n\tvar BRp = BR.prototype;\n\t\n\tBRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\n\t\n\tBRp.init = function (options) {\n\t  var r = this;\n\t\n\t  r.options = options;\n\t\n\t  r.cy = options.cy;\n\t\n\t  var ctr = r.container = options.cy.container();\n\t\n\t  // prepend a stylesheet in the head such that\n\t  if (window) {\n\t    var document = window.document;\n\t    var head = document.head;\n\t    var stylesheetId = '__________cytoscape_stylesheet';\n\t    var className = '__________cytoscape_container';\n\t    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n\t\n\t    if (ctr.className.indexOf(className) < 0) {\n\t      ctr.className = (ctr.className || '') + ' ' + className;\n\t    }\n\t\n\t    if (!stylesheetAlreadyExists) {\n\t      var stylesheet = document.createElement('style');\n\t\n\t      stylesheet.id = stylesheetId;\n\t      stylesheet.innerHTML = '.' + className + ' { position: relative; }';\n\t\n\t      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n\t    }\n\t\n\t    var computedStyle = window.getComputedStyle(ctr);\n\t    var position = computedStyle.getPropertyValue('position');\n\t\n\t    if (position === 'static') {\n\t      util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');\n\t    }\n\t  }\n\t\n\t  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\t\n\t  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];\n\t\n\t  //--Pointer-related data\n\t  r.hoverData = { down: null, last: null,\n\t    downTime: null, triggerMode: null,\n\t    dragging: false,\n\t    initialPan: [null, null], capture: false };\n\t\n\t  r.dragData = { possibleDragElements: [] };\n\t\n\t  r.touchData = {\n\t    start: null, capture: false,\n\t\n\t    // These 3 fields related to tap, taphold events\n\t    startPosition: [null, null, null, null, null, null],\n\t    singleTouchStartTime: null,\n\t    singleTouchMoved: true,\n\t\n\t    now: [null, null, null, null, null, null],\n\t    earlier: [null, null, null, null, null, null]\n\t  };\n\t\n\t  r.redraws = 0;\n\t  r.showFps = options.showFps;\n\t  r.debug = options.debug;\n\t\n\t  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n\t  r.hideLabelsOnViewport = options.hideLabelsOnViewport;\n\t  r.textureOnViewport = options.textureOnViewport;\n\t  r.wheelSensitivity = options.wheelSensitivity;\n\t  r.motionBlurEnabled = options.motionBlur; // on by default\n\t  r.forcedPixelRatio = options.pixelRatio;\n\t  r.motionBlur = options.motionBlur; // for initial kick off\n\t  r.motionBlurOpacity = options.motionBlurOpacity;\n\t  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n\t  r.motionBlurPxRatio = 1;\n\t  r.mbPxRBlurry = 1; //0.8;\n\t  r.minMbLowQualFrames = 4;\n\t  r.fullQualityMb = false;\n\t  r.clearedForMotionBlur = [];\n\t  r.desktopTapThreshold = options.desktopTapThreshold;\n\t  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n\t  r.touchTapThreshold = options.touchTapThreshold;\n\t  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n\t  r.tapholdDuration = 500;\n\t\n\t  r.bindings = [];\n\t  r.beforeRenderCallbacks = [];\n\t  r.beforeRenderPriorities = { // higher priority execs before lower one\n\t    animations: 400,\n\t    eleCalcs: 300,\n\t    eleTxrDeq: 200,\n\t    lyrTxrDeq: 100\n\t  };\n\t\n\t  r.registerNodeShapes();\n\t  r.registerArrowShapes();\n\t  r.registerCalculationListeners();\n\t};\n\t\n\tBRp.notify = function (params) {\n\t  var types;\n\t  var r = this;\n\t\n\t  // the renderer can't be notified after it's destroyed\n\t  if (this.destroyed) {\n\t    return;\n\t  }\n\t\n\t  if (is.array(params.type)) {\n\t    types = params.type;\n\t  } else {\n\t    types = [params.type];\n\t  }\n\t\n\t  var has = {};\n\t  for (var i = 0; i < types.length; i++) {\n\t    var type = types[i];\n\t\n\t    has[type] = true;\n\t  } // for\n\t\n\t  if (has['init']) {\n\t    r.load();\n\t    return;\n\t  }\n\t\n\t  if (has['destroy']) {\n\t    r.destroy();\n\t    return;\n\t  }\n\t\n\t  if (has['add'] || has['remove'] || has['load'] || has['zorder']) {\n\t    r.invalidateCachedZSortedEles();\n\t  }\n\t\n\t  if (has['viewport']) {\n\t    r.redrawHint('select', true);\n\t  }\n\t\n\t  if (has['load'] || has['resize']) {\n\t    r.invalidateContainerClientCoordsCache();\n\t    r.matchCanvasSize(r.container);\n\t  }\n\t\n\t  r.redrawHint('eles', true);\n\t  r.redrawHint('drag', true);\n\t\n\t  this.startRenderLoop();\n\t\n\t  this.redraw();\n\t};\n\t\n\tBRp.destroy = function () {\n\t  var r = this;\n\t\n\t  r.destroyed = true;\n\t\n\t  r.cy.stopAnimationLoop();\n\t\n\t  for (var i = 0; i < r.bindings.length; i++) {\n\t    var binding = r.bindings[i];\n\t    var b = binding;\n\t    var tgt = b.target;\n\t\n\t    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n\t  }\n\t\n\t  r.bindings = [];\n\t  r.beforeRenderCallbacks = [];\n\t  r.onUpdateEleCalcsFns = [];\n\t\n\t  if (r.removeObserver) {\n\t    r.removeObserver.disconnect();\n\t  }\n\t\n\t  if (r.styleObserver) {\n\t    r.styleObserver.disconnect();\n\t  }\n\t\n\t  if (r.labelCalcDiv) {\n\t    try {\n\t      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n\t    } catch (e) {\n\t      // ie10 issue #1014\n\t    }\n\t  }\n\t};\n\t\n\t[__webpack_require__(85), __webpack_require__(91), __webpack_require__(96), __webpack_require__(98), __webpack_require__(99), __webpack_require__(100)].forEach(function (props) {\n\t  util.extend(BRp, props);\n\t});\n\t\n\tmodule.exports = BR;\n\t\n\t/***/ }),\n\t/* 98 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar Event = __webpack_require__(15);\n\t\n\tvar BRp = {};\n\t\n\tBRp.registerBinding = function (target, event, handler, useCapture) {\n\t  var args = Array.prototype.slice.apply(arguments, [1]); // copy\n\t  var b = this.binder(target);\n\t\n\t  return b.on.apply(b, args);\n\t};\n\t\n\tBRp.binder = function (tgt) {\n\t  var r = this;\n\t\n\t  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);\n\t\n\t  if (r.supportsPassiveEvents == null) {\n\t\n\t    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n\t    var supportsPassive = false;\n\t    try {\n\t      var opts = Object.defineProperty({}, 'passive', {\n\t        get: function get() {\n\t          supportsPassive = true;\n\t        }\n\t      });\n\t\n\t      window.addEventListener('test', null, opts);\n\t    } catch (err) {}\n\t\n\t    r.supportsPassiveEvents = supportsPassive;\n\t  }\n\t\n\t  var on = function on(event, handler, useCapture) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    if (tgtIsDom && r.supportsPassiveEvents) {\n\t      // replace useCapture w/ opts obj\n\t      args[2] = {\n\t        capture: useCapture != null ? useCapture : false,\n\t        passive: false,\n\t        once: false\n\t      };\n\t    }\n\t\n\t    r.bindings.push({\n\t      target: tgt,\n\t      args: args\n\t    });\n\t\n\t    (tgt.addEventListener || tgt.on).apply(tgt, args);\n\t\n\t    return this;\n\t  };\n\t\n\t  return {\n\t    on: on,\n\t    addEventListener: on,\n\t    addListener: on,\n\t    bind: on\n\t  };\n\t};\n\t\n\tBRp.nodeIsDraggable = function (node) {\n\t  return node && node.isNode() && !node.locked() && node.grabbable();\n\t};\n\t\n\tBRp.nodeIsGrabbable = function (node) {\n\t  return this.nodeIsDraggable(node) && node.interactive();\n\t};\n\t\n\tBRp.load = function () {\n\t  var r = this;\n\t\n\t  var triggerEvents = function triggerEvents(target, names, e, props) {\n\t    if (target == null) {\n\t      target = r.cy;\n\t    }\n\t\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t\n\t      target.emit(util.extend({ originalEvent: e, type: name }, props));\n\t    }\n\t  };\n\t\n\t  var isMultSelKeyDown = function isMultSelKeyDown(e) {\n\t    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n\t  };\n\t\n\t  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n\t    var allowPassthrough = true;\n\t\n\t    if (r.cy.hasCompoundNodes() && down && down.isEdge()) {\n\t      // a compound node below the edge => no passthrough panning\n\t      for (var i = 0; downs && i < downs.length; i++) {\n\t        var down = downs[i];\n\t\n\t        if (down.isNode() && down.isParent()) {\n\t          allowPassthrough = false;\n\t          break;\n\t        }\n\t      }\n\t    } else {\n\t      allowPassthrough = true;\n\t    }\n\t\n\t    return allowPassthrough;\n\t  };\n\t\n\t  var getDragListIds = function getDragListIds(opts) {\n\t    var listHasId;\n\t\n\t    if (opts.addToList && r.cy.hasCompoundNodes()) {\n\t      // only needed for compound graphs\n\t      if (!opts.addToList.hasId) {\n\t        // build ids lookup if doesn't already exist\n\t        opts.addToList.hasId = {};\n\t\n\t        for (var i = 0; i < opts.addToList.length; i++) {\n\t          var ele = opts.addToList[i];\n\t\n\t          opts.addToList.hasId[ele.id()] = true;\n\t        }\n\t      }\n\t\n\t      listHasId = opts.addToList.hasId;\n\t    }\n\t\n\t    return listHasId || {};\n\t  };\n\t\n\t  var setGrabbed = function setGrabbed(ele) {\n\t    ele[0]._private.grabbed = true;\n\t  };\n\t\n\t  var setFreed = function setFreed(ele) {\n\t    ele[0]._private.grabbed = false;\n\t  };\n\t\n\t  var setInDragLayer = function setInDragLayer(ele) {\n\t    ele[0]._private.rscratch.inDragLayer = true;\n\t  };\n\t\n\t  var setOutDragLayer = function setOutDragLayer(ele) {\n\t    ele[0]._private.rscratch.inDragLayer = false;\n\t  };\n\t\n\t  var setGrabTarget = function setGrabTarget(ele) {\n\t    ele[0]._private.rscratch.isGrabTarget = true;\n\t  };\n\t\n\t  var removeGrabTarget = function removeGrabTarget(ele) {\n\t    ele[0]._private.rscratch.isGrabTarget = false;\n\t  };\n\t\n\t  var addToDragList = function addToDragList(ele, opts) {\n\t    var listHasId = getDragListIds(opts);\n\t\n\t    if (!listHasId[ele.id()]) {\n\t      opts.addToList.push(ele);\n\t      listHasId[ele.id()] = true;\n\t\n\t      setGrabbed(ele);\n\t    }\n\t  };\n\t\n\t  // helper function to determine which child nodes and inner edges\n\t  // of a compound node to be dragged as well as the grabbed and selected nodes\n\t  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n\t    if (!node.cy().hasCompoundNodes()) {\n\t      return;\n\t    }\n\t\n\t    if (opts.inDragLayer == null && opts.addToList == null) {\n\t      return;\n\t    } // nothing to do\n\t\n\t    var innerNodes = node.descendants();\n\t\n\t    if (opts.inDragLayer) {\n\t      innerNodes.forEach(setInDragLayer);\n\t      innerNodes.connectedEdges().forEach(setInDragLayer);\n\t    }\n\t\n\t    if (opts.addToList) {\n\t      innerNodes.forEach(function (ele) {\n\t        addToDragList(ele, opts);\n\t      });\n\t    }\n\t  };\n\t\n\t  // adds the given nodes and its neighbourhood to the drag layer\n\t  var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n\t    opts = opts || {};\n\t\n\t    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\t\n\t    if (opts.inDragLayer) {\n\t      nodes.forEach(setInDragLayer);\n\t\n\t      nodes.neighborhood().stdFilter(function (ele) {\n\t        return !hasCompoundNodes || ele.isEdge();\n\t      }).forEach(setInDragLayer);\n\t    }\n\t\n\t    if (opts.addToList) {\n\t      nodes.forEach(function (ele) {\n\t        addToDragList(ele, opts);\n\t      });\n\t    }\n\t\n\t    addDescendantsToDrag(nodes, opts); // always add to drag\n\t\n\t    // also add nodes and edges related to the topmost ancestor\n\t    updateAncestorsInDragLayer(nodes, {\n\t      inDragLayer: opts.inDragLayer\n\t    });\n\t\n\t    r.updateCachedGrabbedEles();\n\t  };\n\t\n\t  var addNodeToDrag = addNodesToDrag;\n\t\n\t  var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n\t    if (!grabbedEles) {\n\t      return;\n\t    }\n\t\n\t    grabbedEles.hasId = {}; // clear the id list\n\t\n\t    // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n\t    r.getCachedZSortedEles().forEach(function (ele) {\n\t      setFreed(ele);\n\t      setOutDragLayer(ele);\n\t      removeGrabTarget(ele);\n\t    });\n\t\n\t    r.updateCachedGrabbedEles();\n\t  };\n\t\n\t  // helper function to determine which ancestor nodes and edges should go\n\t  // to the drag layer (or should be removed from drag layer).\n\t  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n\t\n\t    if (opts.inDragLayer == null && opts.addToList == null) {\n\t      return;\n\t    } // nothing to do\n\t\n\t    if (!node.cy().hasCompoundNodes()) {\n\t      return;\n\t    }\n\t\n\t    // find top-level parent\n\t    var parent = node.ancestors().orphans();\n\t\n\t    // no parent node: no nodes to add to the drag layer\n\t    if (parent.same(node)) {\n\t      return;\n\t    }\n\t\n\t    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n\t\n\t    var edges = nodes.connectedEdges();\n\t\n\t    if (opts.inDragLayer) {\n\t      edges.forEach(setInDragLayer);\n\t      nodes.forEach(setInDragLayer);\n\t    }\n\t\n\t    if (opts.addToList) {\n\t      nodes.forEach(function (ele) {\n\t        addToDragList(ele, opts);\n\t      });\n\t    }\n\t  };\n\t\n\t  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n\t\n\t  // watch for when the cy container is removed from the dom\n\t  if (haveMutationsApi) {\n\t    r.removeObserver = new MutationObserver(function (mutns) {\n\t      // eslint-disable-line no-undef\n\t      for (var i = 0; i < mutns.length; i++) {\n\t        var mutn = mutns[i];\n\t        var rNodes = mutn.removedNodes;\n\t\n\t        if (rNodes) {\n\t          for (var j = 0; j < rNodes.length; j++) {\n\t            var rNode = rNodes[j];\n\t\n\t            if (rNode === r.container) {\n\t              r.destroy();\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    if (r.container.parentNode) {\n\t      r.removeObserver.observe(r.container.parentNode, { childList: true });\n\t    }\n\t  } else {\n\t    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n\t      r.destroy();\n\t    });\n\t  }\n\t\n\t  var onResize = util.debounce(function () {\n\t    r.cy.resize();\n\t  }, 100);\n\t\n\t  if (haveMutationsApi) {\n\t    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\t\n\t    r.styleObserver.observe(r.container, { attributes: true });\n\t  }\n\t\n\t  // auto resize\n\t  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef\n\t\n\t  var forEachUp = function forEachUp(domEle, fn) {\n\t    while (domEle != null) {\n\t      fn(domEle);\n\t\n\t      domEle = domEle.parentNode;\n\t    }\n\t  };\n\t\n\t  var invalidateCoords = function invalidateCoords() {\n\t    r.invalidateContainerClientCoordsCache();\n\t  };\n\t\n\t  forEachUp(r.container, function (domEle) {\n\t    r.registerBinding(domEle, 'transitionend', invalidateCoords);\n\t    r.registerBinding(domEle, 'animationend', invalidateCoords);\n\t    r.registerBinding(domEle, 'scroll', invalidateCoords);\n\t  });\n\t\n\t  // stop right click menu from appearing on cy\n\t  r.registerBinding(r.container, 'contextmenu', function (e) {\n\t    e.preventDefault();\n\t  });\n\t\n\t  var inBoxSelection = function inBoxSelection() {\n\t    return r.selection[4] !== 0;\n\t  };\n\t\n\t  var eventInContainer = function eventInContainer(e) {\n\t    // save cycles if mouse events aren't to be captured\n\t    var containerPageCoords = r.findContainerClientCoords();\n\t    var x = containerPageCoords[0];\n\t    var y = containerPageCoords[1];\n\t    var width = containerPageCoords[2];\n\t    var height = containerPageCoords[3];\n\t\n\t    var positions = e.touches ? e.touches : [e];\n\t    var atLeastOnePosInside = false;\n\t\n\t    for (var i = 0; i < positions.length; i++) {\n\t      var p = positions[i];\n\t\n\t      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n\t        atLeastOnePosInside = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!atLeastOnePosInside) {\n\t      return false;\n\t    }\n\t\n\t    var container = r.container;\n\t    var target = e.target;\n\t    var tParent = target.parentNode;\n\t    var containerIsTarget = false;\n\t\n\t    while (tParent) {\n\t      if (tParent === container) {\n\t        containerIsTarget = true;\n\t        break;\n\t      }\n\t\n\t      tParent = tParent.parentNode;\n\t    }\n\t\n\t    if (!containerIsTarget) {\n\t      return false;\n\t    } // if target is outisde cy container, then this event is not for us\n\t\n\t    return true;\n\t  };\n\t\n\t  // Primary key\n\t  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n\t    if (!eventInContainer(e)) {\n\t      return;\n\t    }\n\t\n\t    e.preventDefault();\n\t    r.hoverData.capture = true;\n\t    r.hoverData.which = e.which;\n\t\n\t    var cy = r.cy;\n\t    var gpos = [e.clientX, e.clientY];\n\t    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n\t    var select = r.selection;\n\t    var nears = r.findNearestElements(pos[0], pos[1], true, false);\n\t    var near = nears[0];\n\t    var draggedElements = r.dragData.possibleDragElements;\n\t\n\t    r.hoverData.mdownPos = pos;\n\t    r.hoverData.mdownGPos = gpos;\n\t\n\t    var checkForTaphold = function checkForTaphold() {\n\t      r.hoverData.tapholdCancelled = false;\n\t\n\t      clearTimeout(r.hoverData.tapholdTimeout);\n\t\n\t      r.hoverData.tapholdTimeout = setTimeout(function () {\n\t\n\t        if (r.hoverData.tapholdCancelled) {\n\t          return;\n\t        } else {\n\t          var ele = r.hoverData.down;\n\t\n\t          if (ele) {\n\t            ele.emit({\n\t              originalEvent: e,\n\t              type: 'taphold',\n\t              position: { x: pos[0], y: pos[1] }\n\t            });\n\t          } else {\n\t            cy.emit({\n\t              originalEvent: e,\n\t              type: 'taphold',\n\t              position: { x: pos[0], y: pos[1] }\n\t            });\n\t          }\n\t        }\n\t      }, r.tapholdDuration);\n\t    };\n\t\n\t    // Right click button\n\t    if (e.which == 3) {\n\t\n\t      r.hoverData.cxtStarted = true;\n\t\n\t      var cxtEvt = {\n\t        originalEvent: e,\n\t        type: 'cxttapstart',\n\t        position: { x: pos[0], y: pos[1] }\n\t      };\n\t\n\t      if (near) {\n\t        near.activate();\n\t        near.emit(cxtEvt);\n\t\n\t        r.hoverData.down = near;\n\t      } else {\n\t        cy.emit(cxtEvt);\n\t      }\n\t\n\t      r.hoverData.downTime = new Date().getTime();\n\t      r.hoverData.cxtDragged = false;\n\t\n\t      // Primary button\n\t    } else if (e.which == 1) {\n\t\n\t      if (near) {\n\t        near.activate();\n\t      }\n\t\n\t      // Element dragging\n\t      {\n\t        // If something is under the cursor and it is draggable, prepare to grab it\n\t        if (near != null) {\n\t\n\t          if (r.nodeIsGrabbable(near)) {\n\t\n\t            var makeEvent = function makeEvent(type) {\n\t              return {\n\t                originalEvent: e,\n\t                type: type,\n\t                position: { x: pos[0], y: pos[1] }\n\t              };\n\t            };\n\t\n\t            var triggerGrab = function triggerGrab(ele) {\n\t              ele.emit(makeEvent('grab'));\n\t            };\n\t\n\t            setGrabTarget(near);\n\t\n\t            if (!near.selected()) {\n\t\n\t              draggedElements = r.dragData.possibleDragElements = [];\n\t              addNodeToDrag(near, { addToList: draggedElements });\n\t\n\t              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n\t            } else {\n\t              draggedElements = r.dragData.possibleDragElements = [];\n\t\n\t              var selectedNodes = cy.$(function (ele) {\n\t                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n\t              });\n\t\n\t              addNodesToDrag(selectedNodes, { addToList: draggedElements });\n\t\n\t              near.emit(makeEvent('grabon'));\n\t\n\t              selectedNodes.forEach(triggerGrab);\n\t            }\n\t\n\t            r.redrawHint('eles', true);\n\t            r.redrawHint('drag', true);\n\t          }\n\t        }\n\t\n\t        r.hoverData.down = near;\n\t        r.hoverData.downs = nears;\n\t        r.hoverData.downTime = new Date().getTime();\n\t      }\n\t\n\t      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n\t        position: { x: pos[0], y: pos[1] }\n\t      });\n\t\n\t      if (near == null) {\n\t        select[4] = 1;\n\t\n\t        r.data.bgActivePosistion = {\n\t          x: pos[0],\n\t          y: pos[1]\n\t        };\n\t\n\t        r.redrawHint('select', true);\n\t\n\t        r.redraw();\n\t      } else if (near.isEdge()) {\n\t        select[4] = 1; // for future pan\n\t      }\n\t\n\t      checkForTaphold();\n\t    }\n\t\n\t    // Initialize selection box coordinates\n\t    select[0] = select[2] = pos[0];\n\t    select[1] = select[3] = pos[1];\n\t  }, false);\n\t\n\t  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    var capture = r.hoverData.capture;\n\t\n\t    if (!capture && !eventInContainer(e)) {\n\t      return;\n\t    }\n\t\n\t    var preventDefault = false;\n\t    var cy = r.cy;\n\t    var zoom = cy.zoom();\n\t    var gpos = [e.clientX, e.clientY];\n\t    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n\t    var mdownPos = r.hoverData.mdownPos;\n\t    var mdownGPos = r.hoverData.mdownGPos;\n\t    var select = r.selection;\n\t\n\t    var near = null;\n\t    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n\t      near = r.findNearestElement(pos[0], pos[1], true, false);\n\t    }\n\t    var last = r.hoverData.last;\n\t    var down = r.hoverData.down;\n\t\n\t    var disp = [pos[0] - select[2], pos[1] - select[3]];\n\t\n\t    var draggedElements = r.dragData.possibleDragElements;\n\t\n\t    var isOverThresholdDrag;\n\t\n\t    if (mdownGPos) {\n\t      var dx = gpos[0] - mdownGPos[0];\n\t      var dx2 = dx * dx;\n\t      var dy = gpos[1] - mdownGPos[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t\n\t      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n\t    }\n\t\n\t    var multSelKeyDown = isMultSelKeyDown(e);\n\t\n\t    if (isOverThresholdDrag) {\n\t      r.hoverData.tapholdCancelled = true;\n\t    }\n\t\n\t    var updateDragDelta = function updateDragDelta() {\n\t      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\t\n\t      if (dragDelta.length === 0) {\n\t        dragDelta.push(disp[0]);\n\t        dragDelta.push(disp[1]);\n\t      } else {\n\t        dragDelta[0] += disp[0];\n\t        dragDelta[1] += disp[1];\n\t      }\n\t    };\n\t\n\t    preventDefault = true;\n\t\n\t    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n\t      position: { x: pos[0], y: pos[1] }\n\t    });\n\t\n\t    var goIntoBoxMode = function goIntoBoxMode() {\n\t      r.data.bgActivePosistion = undefined;\n\t\n\t      if (!r.hoverData.selecting) {\n\t        cy.emit('boxstart');\n\t      }\n\t\n\t      select[4] = 1;\n\t      r.hoverData.selecting = true;\n\t\n\t      r.redrawHint('select', true);\n\t      r.redraw();\n\t    };\n\t\n\t    // trigger context drag if rmouse down\n\t    if (r.hoverData.which === 3) {\n\t      // but only if over threshold\n\t      if (isOverThresholdDrag) {\n\t        var cxtEvt = {\n\t          originalEvent: e,\n\t          type: 'cxtdrag',\n\t          position: { x: pos[0], y: pos[1] }\n\t        };\n\t\n\t        if (down) {\n\t          down.emit(cxtEvt);\n\t        } else {\n\t          cy.emit(cxtEvt);\n\t        }\n\t\n\t        r.hoverData.cxtDragged = true;\n\t\n\t        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n\t\n\t          if (r.hoverData.cxtOver) {\n\t            r.hoverData.cxtOver.emit({\n\t              originalEvent: e,\n\t              type: 'cxtdragout',\n\t              position: { x: pos[0], y: pos[1] }\n\t            });\n\t          }\n\t\n\t          r.hoverData.cxtOver = near;\n\t\n\t          if (near) {\n\t            near.emit({\n\t              originalEvent: e,\n\t              type: 'cxtdragover',\n\t              position: { x: pos[0], y: pos[1] }\n\t            });\n\t          }\n\t        }\n\t      }\n\t\n\t      // Check if we are drag panning the entire graph\n\t    } else if (r.hoverData.dragging) {\n\t      preventDefault = true;\n\t\n\t      if (cy.panningEnabled() && cy.userPanningEnabled()) {\n\t        var deltaP;\n\t\n\t        if (r.hoverData.justStartedPan) {\n\t          var mdPos = r.hoverData.mdownPos;\n\t\n\t          deltaP = {\n\t            x: (pos[0] - mdPos[0]) * zoom,\n\t            y: (pos[1] - mdPos[1]) * zoom\n\t          };\n\t\n\t          r.hoverData.justStartedPan = false;\n\t        } else {\n\t          deltaP = {\n\t            x: disp[0] * zoom,\n\t            y: disp[1] * zoom\n\t          };\n\t        }\n\t\n\t        cy.panBy(deltaP);\n\t\n\t        r.hoverData.dragged = true;\n\t      }\n\t\n\t      // Needs reproject due to pan changing viewport\n\t      pos = r.projectIntoViewport(e.clientX, e.clientY);\n\t\n\t      // Checks primary button down & out of time & mouse not moved much\n\t    } else if (select[4] == 1 && (down == null || down.isEdge())) {\n\t\n\t      if (isOverThresholdDrag) {\n\t\n\t        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n\t          goIntoBoxMode();\n\t        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n\t          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n\t\n\t          if (allowPassthrough) {\n\t            r.hoverData.dragging = true;\n\t            r.hoverData.justStartedPan = true;\n\t            select[4] = 0;\n\t\n\t            r.data.bgActivePosistion = math.array2point(mdownPos);\n\t\n\t            r.redrawHint('select', true);\n\t            r.redraw();\n\t          }\n\t        }\n\t\n\t        if (down && down.isEdge() && down.active()) {\n\t          down.unactivate();\n\t        }\n\t      }\n\t    } else {\n\t      if (down && down.isEdge() && down.active()) {\n\t        down.unactivate();\n\t      }\n\t\n\t      if ((!down || !down.grabbed()) && near != last) {\n\t\n\t        if (last) {\n\t          triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n\t            position: { x: pos[0], y: pos[1] }\n\t          });\n\t        }\n\t\n\t        if (near) {\n\t          triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n\t            position: { x: pos[0], y: pos[1] }\n\t          });\n\t        }\n\t\n\t        r.hoverData.last = near;\n\t      }\n\t\n\t      if (down) {\n\t\n\t        if (isOverThresholdDrag) {\n\t          // then we can take action\n\t\n\t          if (cy.boxSelectionEnabled() && multSelKeyDown) {\n\t            // then selection overrides\n\t            if (down && down.grabbed()) {\n\t              freeDraggedElements(draggedElements);\n\t\n\t              down.emit('free');\n\t            }\n\t\n\t            goIntoBoxMode();\n\t          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n\t            // drag node\n\t            var justStartedDrag = !r.dragData.didDrag;\n\t\n\t            if (justStartedDrag) {\n\t              r.redrawHint('eles', true);\n\t            }\n\t\n\t            r.dragData.didDrag = true; // indicate that we actually did drag the node\n\t\n\t            var toTrigger = [];\n\t\n\t            // now, add the elements to the drag layer if not done already\n\t            if (!r.hoverData.draggingEles) {\n\t              addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });\n\t            }\n\t\n\t            for (var i = 0; i < draggedElements.length; i++) {\n\t              var dEle = draggedElements[i];\n\t\n\t              // Locked nodes not draggable, as well as non-visible nodes\n\t              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {\n\t                var dPos = dEle.position();\n\t\n\t                toTrigger.push(dEle);\n\t\n\t                if (is.number(disp[0]) && is.number(disp[1])) {\n\t                  dPos.x += disp[0];\n\t                  dPos.y += disp[1];\n\t\n\t                  if (justStartedDrag) {\n\t                    var dragDelta = r.hoverData.dragDelta;\n\t\n\t                    if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {\n\t                      dPos.x += dragDelta[0];\n\t                      dPos.y += dragDelta[1];\n\t                    }\n\t                  }\n\t                }\n\t              }\n\t            }\n\t\n\t            r.hoverData.draggingEles = true;\n\t\n\t            var tcol = cy.collection(toTrigger);\n\t\n\t            tcol.dirtyCompoundBoundsCache();\n\t            tcol.emit('position drag');\n\t\n\t            r.redrawHint('drag', true);\n\t            r.redraw();\n\t          }\n\t        } else {\n\t          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n\t          updateDragDelta();\n\t        }\n\t      }\n\t\n\t      // prevent the dragging from triggering text selection on the page\n\t      preventDefault = true;\n\t    }\n\t\n\t    select[2] = pos[0];select[3] = pos[1];\n\t\n\t    if (preventDefault) {\n\t      if (e.stopPropagation) e.stopPropagation();\n\t      if (e.preventDefault) e.preventDefault();\n\t      return false;\n\t    }\n\t  }, false);\n\t\n\t  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    var capture = r.hoverData.capture;\n\t    if (!capture) {\n\t      return;\n\t    }\n\t    r.hoverData.capture = false;\n\t\n\t    var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;\n\t    var near = r.findNearestElement(pos[0], pos[1], true, false);\n\t    var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;\n\t    var multSelKeyDown = isMultSelKeyDown(e);\n\t\n\t    if (r.data.bgActivePosistion) {\n\t      r.redrawHint('select', true);\n\t      r.redraw();\n\t    }\n\t\n\t    r.hoverData.tapholdCancelled = true;\n\t\n\t    r.data.bgActivePosistion = undefined; // not active bg now\n\t\n\t    if (down) {\n\t      down.unactivate();\n\t    }\n\t\n\t    if (r.hoverData.which === 3) {\n\t      var cxtEvt = {\n\t        originalEvent: e,\n\t        type: 'cxttapend',\n\t        position: { x: pos[0], y: pos[1] }\n\t      };\n\t\n\t      if (down) {\n\t        down.emit(cxtEvt);\n\t      } else {\n\t        cy.emit(cxtEvt);\n\t      }\n\t\n\t      if (!r.hoverData.cxtDragged) {\n\t        var cxtTap = {\n\t          originalEvent: e,\n\t          type: 'cxttap',\n\t          position: { x: pos[0], y: pos[1] }\n\t        };\n\t\n\t        if (down) {\n\t          down.emit(cxtTap);\n\t        } else {\n\t          cy.emit(cxtTap);\n\t        }\n\t      }\n\t\n\t      r.hoverData.cxtDragged = false;\n\t      r.hoverData.which = null;\n\t    } else if (r.hoverData.which === 1) {\n\t\n\t      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n\t      if (down == null && // not mousedown on node\n\t      !r.dragData.didDrag // didn't move the node around\n\t      && !r.hoverData.selecting // not box selection\n\t      && !r.hoverData.dragged // didn't pan\n\t      && !isMultSelKeyDown(e)) {\n\t\n\t        cy.$(function (ele) {\n\t          return ele.selected();\n\t        }).unselect();\n\t\n\t        if (draggedElements.length > 0) {\n\t          r.redrawHint('eles', true);\n\t        }\n\t\n\t        r.dragData.possibleDragElements = draggedElements = [];\n\t      }\n\t\n\t      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n\t        position: { x: pos[0], y: pos[1] }\n\t      });\n\t\n\t      if (!r.dragData.didDrag // didn't move a node around\n\t      && !r.hoverData.dragged // didn't pan\n\t      && !r.hoverData.selecting // not box selection\n\t      && !r.hoverData.isOverThresholdDrag // didn't move too much\n\t      ) {\n\t          triggerEvents(down, ['click', 'tap', 'vclick'], e, {\n\t            position: { x: pos[0], y: pos[1] }\n\t          });\n\t        }\n\t\n\t      // Single selection\n\t      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n\t        if (near != null && near._private.selectable) {\n\t\n\t          if (r.hoverData.dragging) {\n\t            // if panning, don't change selection state\n\t          } else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n\t            if (near.selected()) {\n\t              near.unselect();\n\t            } else {\n\t              near.select();\n\t            }\n\t          } else {\n\t            if (!multSelKeyDown) {\n\t              cy.$(':selected').unmerge(near).unselect();\n\t              near.select();\n\t            }\n\t          }\n\t\n\t          r.redrawHint('eles', true);\n\t        }\n\t      }\n\t\n\t      if (r.hoverData.selecting) {\n\t        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n\t\n\t        r.redrawHint('select', true);\n\t\n\t        if (box.length > 0) {\n\t          r.redrawHint('eles', true);\n\t        }\n\t\n\t        cy.emit('boxend');\n\t\n\t        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n\t          return ele.selectable() && !ele.selected();\n\t        };\n\t\n\t        if (cy.selectionType() === 'additive') {\n\t          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\t        } else {\n\t          if (!multSelKeyDown) {\n\t            cy.$(':selected').unmerge(box).unselect();\n\t          }\n\t\n\t          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\t        }\n\t\n\t        // always need redraw in case eles unselectable\n\t        r.redraw();\n\t      }\n\t\n\t      // Cancel drag pan\n\t      if (r.hoverData.dragging) {\n\t        r.hoverData.dragging = false;\n\t\n\t        r.redrawHint('select', true);\n\t        r.redrawHint('eles', true);\n\t\n\t        r.redraw();\n\t      }\n\t\n\t      if (!select[4]) {\n\t        r.redrawHint('drag', true);\n\t        r.redrawHint('eles', true);\n\t\n\t        var downWasGrabbed = down && down.grabbed();\n\t\n\t        freeDraggedElements(draggedElements);\n\t\n\t        if (downWasGrabbed) {\n\t          down.emit('free');\n\t        }\n\t      }\n\t    } // else not right mouse\n\t\n\t    select[4] = 0;r.hoverData.down = null;\n\t\n\t    r.hoverData.cxtStarted = false;\n\t    r.hoverData.draggingEles = false;\n\t    r.hoverData.selecting = false;\n\t    r.hoverData.isOverThresholdDrag = false;\n\t    r.dragData.didDrag = false;\n\t    r.hoverData.dragged = false;\n\t    r.hoverData.dragDelta = [];\n\t    r.hoverData.mdownPos = null;\n\t    r.hoverData.mdownGPos = null;\n\t  }, false);\n\t\n\t  var wheelHandler = function wheelHandler(e) {\n\t\n\t    if (r.scrollingPage) {\n\t      return;\n\t    } // while scrolling, ignore wheel-to-zoom\n\t\n\t    var cy = r.cy;\n\t    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\t    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];\n\t\n\t    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n\t      // if pan dragging or cxt dragging, wheel movements make no zoom\n\t      e.preventDefault();\n\t      return;\n\t    }\n\t\n\t    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n\t      e.preventDefault();\n\t\n\t      r.data.wheelZooming = true;\n\t      clearTimeout(r.data.wheelTimeout);\n\t      r.data.wheelTimeout = setTimeout(function () {\n\t        r.data.wheelZooming = false;\n\t\n\t        r.redrawHint('eles', true);\n\t        r.redraw();\n\t      }, 150);\n\t\n\t      var diff;\n\t\n\t      if (e.deltaY != null) {\n\t        diff = e.deltaY / -250;\n\t      } else if (e.wheelDeltaY != null) {\n\t        diff = e.wheelDeltaY / 1000;\n\t      } else {\n\t        diff = e.wheelDelta / 1000;\n\t      }\n\t\n\t      diff = diff * r.wheelSensitivity;\n\t\n\t      var needsWheelFix = e.deltaMode === 1;\n\t      if (needsWheelFix) {\n\t        // fixes slow wheel events on ff/linux and ff/windows\n\t        diff *= 33;\n\t      }\n\t\n\t      cy.zoom({\n\t        level: cy.zoom() * Math.pow(10, diff),\n\t        renderedPosition: { x: rpos[0], y: rpos[1] }\n\t      });\n\t    }\n\t  };\n\t\n\t  // Functions to help with whether mouse wheel should trigger zooming\n\t  // --\n\t  r.registerBinding(r.container, 'wheel', wheelHandler, true);\n\t\n\t  // disable nonstandard wheel events\n\t  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n\t  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n\t  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\t\n\t  r.registerBinding(window, 'scroll', function scrollHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    r.scrollingPage = true;\n\t\n\t    clearTimeout(r.scrollingPageTimeout);\n\t    r.scrollingPageTimeout = setTimeout(function () {\n\t      r.scrollingPage = false;\n\t    }, 250);\n\t  }, true);\n\t\n\t  // Functions to help with handling mouseout/mouseover on the Cytoscape container\n\t  // Handle mouseout on Cytoscape container\n\t  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n\t    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\t\n\t    r.cy.emit({\n\t      originalEvent: e,\n\t      type: 'mouseout',\n\t      position: { x: pos[0], y: pos[1] }\n\t    });\n\t  }, false);\n\t\n\t  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n\t    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\t\n\t    r.cy.emit({\n\t      originalEvent: e,\n\t      type: 'mouseover',\n\t      position: { x: pos[0], y: pos[1] }\n\t    });\n\t  }, false);\n\t\n\t  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n\t  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n\t  var center1, modelCenter1; // center point on start pinch to zoom\n\t  var offsetLeft, offsetTop;\n\t  var containerWidth, containerHeight;\n\t  var twoFingersStartInside;\n\t\n\t  var distance = function distance(x1, y1, x2, y2) {\n\t    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\t  };\n\t\n\t  var distanceSq = function distanceSq(x1, y1, x2, y2) {\n\t    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t  };\n\t\n\t  var touchstartHandler;\n\t  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n\t    if (!eventInContainer(e)) {\n\t      return;\n\t    }\n\t\n\t    r.touchData.capture = true;\n\t    r.data.bgActivePosistion = undefined;\n\t\n\t    var cy = r.cy;\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t\n\t    if (e.touches[0]) {\n\t      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n\t    }\n\t    if (e.touches[1]) {\n\t      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n\t    }\n\t    if (e.touches[2]) {\n\t      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n\t    }\n\t\n\t    // record starting points for pinch-to-zoom\n\t    if (e.touches[1]) {\n\t\n\t      freeDraggedElements(r.dragData.touchDragEles);\n\t\n\t      var offsets = r.findContainerClientCoords();\n\t      offsetLeft = offsets[0];\n\t      offsetTop = offsets[1];\n\t      containerWidth = offsets[2];\n\t      containerHeight = offsets[3];\n\t\n\t      f1x1 = e.touches[0].clientX - offsetLeft;\n\t      f1y1 = e.touches[0].clientY - offsetTop;\n\t\n\t      f2x1 = e.touches[1].clientX - offsetLeft;\n\t      f2y1 = e.touches[1].clientY - offsetTop;\n\t\n\t      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n\t\n\t      var pan = cy.pan();\n\t      var zoom = cy.zoom();\n\t\n\t      distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n\t      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n\t      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n\t      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];\n\t\n\t      // consider context tap\n\t      var cxtDistThreshold = 200;\n\t      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n\t      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n\t\n\t        var near1 = r.findNearestElement(now[0], now[1], true, true);\n\t        var near2 = r.findNearestElement(now[2], now[3], true, true);\n\t\n\t        if (near1 && near1.isNode()) {\n\t          near1.activate().emit({\n\t            originalEvent: e,\n\t            type: 'cxttapstart',\n\t            position: { x: now[0], y: now[1] }\n\t          });\n\t          r.touchData.start = near1;\n\t        } else if (near2 && near2.isNode()) {\n\t          near2.activate().emit({\n\t            originalEvent: e,\n\t            type: 'cxttapstart',\n\t            position: { x: now[0], y: now[1] }\n\t          });\n\t          r.touchData.start = near2;\n\t        } else {\n\t          cy.emit({\n\t            originalEvent: e,\n\t            type: 'cxttapstart',\n\t            position: { x: now[0], y: now[1] }\n\t          });\n\t        }\n\t\n\t        if (r.touchData.start) {\n\t          r.touchData.start._private.grabbed = false;\n\t        }\n\t        r.touchData.cxt = true;\n\t        r.touchData.cxtDragged = false;\n\t        r.data.bgActivePosistion = undefined;\n\t\n\t        r.redraw();\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (e.touches[2]) {\n\t      // ignore\n\t    } else if (e.touches[1]) {\n\t      // ignore\n\t    } else if (e.touches[0]) {\n\t      var nears = r.findNearestElements(now[0], now[1], true, true);\n\t      var near = nears[0];\n\t\n\t      if (near != null) {\n\t        near.activate();\n\t\n\t        r.touchData.start = near;\n\t        r.touchData.starts = nears;\n\t\n\t        if (r.nodeIsGrabbable(near)) {\n\t\n\t          var draggedEles = r.dragData.touchDragEles = [];\n\t          var selectedNodes = null;\n\t\n\t          r.redrawHint('eles', true);\n\t          r.redrawHint('drag', true);\n\t\n\t          if (near.selected()) {\n\t            // reset drag elements, since near will be added again\n\t\n\t            selectedNodes = cy.$(function (ele) {\n\t              return ele.selected() && r.nodeIsGrabbable(ele);\n\t            });\n\t\n\t            addNodesToDrag(selectedNodes, { addToList: draggedEles });\n\t          } else {\n\t            addNodeToDrag(near, { addToList: draggedEles });\n\t          }\n\t\n\t          setGrabTarget(near);\n\t\n\t          var makeEvent = function makeEvent(type) {\n\t            return {\n\t              originalEvent: e,\n\t              type: type,\n\t              position: { x: now[0], y: now[1] }\n\t            };\n\t          };\n\t\n\t          near.emit(makeEvent('grabon'));\n\t\n\t          if (selectedNodes) {\n\t            selectedNodes.forEach(function (n) {\n\t              n.emit(makeEvent('grab'));\n\t            });\n\t          } else {\n\t            near.emit(makeEvent('grab'));\n\t          }\n\t        }\n\t      }\n\t\n\t      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n\t        position: { x: now[0], y: now[1] }\n\t      });\n\t\n\t      if (near == null) {\n\t        r.data.bgActivePosistion = {\n\t          x: pos[0],\n\t          y: pos[1]\n\t        };\n\t\n\t        r.redrawHint('select', true);\n\t        r.redraw();\n\t      }\n\t\n\t      // Tap, taphold\n\t      // -----\n\t\n\t      r.touchData.singleTouchMoved = false;\n\t      r.touchData.singleTouchStartTime = +new Date();\n\t\n\t      clearTimeout(r.touchData.tapholdTimeout);\n\t      r.touchData.tapholdTimeout = setTimeout(function () {\n\t        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n\t        && !r.touchData.selecting // box selection shouldn't allow taphold through\n\t        ) {\n\t            triggerEvents(r.touchData.start, ['taphold'], e, {\n\t              position: { x: now[0], y: now[1] }\n\t            });\n\t\n\t            if (!r.touchData.start) {\n\t              cy.$(':selected').unselect();\n\t            }\n\t          }\n\t      }, r.tapholdDuration);\n\t    }\n\t\n\t    if (e.touches.length >= 1) {\n\t      var sPos = r.touchData.startPosition = [];\n\t\n\t      for (var i = 0; i < now.length; i++) {\n\t        sPos[i] = earlier[i] = now[i];\n\t      }\n\t\n\t      var touch0 = e.touches[0];\n\t\n\t      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n\t    }\n\t  }, false);\n\t\n\t  var touchmoveHandler;\n\t  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    var capture = r.touchData.capture;\n\t\n\t    if (!capture && !eventInContainer(e)) {\n\t      return;\n\t    }\n\t\n\t    var select = r.selection;\n\t    var cy = r.cy;\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t    var zoom = cy.zoom();\n\t\n\t    if (e.touches[0]) {\n\t      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n\t    }\n\t    if (e.touches[1]) {\n\t      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n\t    }\n\t    if (e.touches[2]) {\n\t      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n\t    }\n\t\n\t    var startGPos = r.touchData.startGPosition;\n\t    var isOverThresholdDrag;\n\t\n\t    if (capture && e.touches[0] && startGPos) {\n\t      var disp = [];for (var j = 0; j < now.length; j++) {\n\t        disp[j] = now[j] - earlier[j];\n\t      }\n\t      var dx = e.touches[0].clientX - startGPos[0];\n\t      var dx2 = dx * dx;\n\t      var dy = e.touches[0].clientY - startGPos[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t\n\t      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n\t    }\n\t\n\t    // context swipe cancelling\n\t    if (capture && r.touchData.cxt) {\n\t      e.preventDefault();\n\t\n\t      var f1x2 = e.touches[0].clientX - offsetLeft,\n\t          f1y2 = e.touches[0].clientY - offsetTop;\n\t      var f2x2 = e.touches[1].clientX - offsetLeft,\n\t          f2y2 = e.touches[1].clientY - offsetTop;\n\t      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\t      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n\t      var factorSq = distance2Sq / distance1Sq;\n\t\n\t      var distThreshold = 150;\n\t      var distThresholdSq = distThreshold * distThreshold;\n\t      var factorThreshold = 1.5;\n\t      var factorThresholdSq = factorThreshold * factorThreshold;\n\t\n\t      // cancel ctx gestures if the distance b/t the fingers increases\n\t      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n\t        r.touchData.cxt = false;\n\t\n\t        r.data.bgActivePosistion = undefined;\n\t\n\t        r.redrawHint('select', true);\n\t\n\t        var cxtEvt = {\n\t          originalEvent: e,\n\t          type: 'cxttapend',\n\t          position: { x: now[0], y: now[1] }\n\t        };\n\t\n\t        if (r.touchData.start) {\n\t          r.touchData.start.unactivate().emit(cxtEvt);\n\t\n\t          r.touchData.start = null;\n\t        } else {\n\t          cy.emit(cxtEvt);\n\t        }\n\t      }\n\t    }\n\t\n\t    // context swipe\n\t    if (capture && r.touchData.cxt) {\n\t      var cxtEvt = {\n\t        originalEvent: e,\n\t        type: 'cxtdrag',\n\t        position: { x: now[0], y: now[1] }\n\t      };\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint('select', true);\n\t\n\t      if (r.touchData.start) {\n\t        r.touchData.start.emit(cxtEvt);\n\t      } else {\n\t        cy.emit(cxtEvt);\n\t      }\n\t\n\t      if (r.touchData.start) {\n\t        r.touchData.start._private.grabbed = false;\n\t      }\n\t      r.touchData.cxtDragged = true;\n\t\n\t      var near = r.findNearestElement(now[0], now[1], true, true);\n\t\n\t      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n\t\n\t        if (r.touchData.cxtOver) {\n\t          r.touchData.cxtOver.emit({\n\t            originalEvent: e,\n\t            type: 'cxtdragout',\n\t            position: { x: now[0], y: now[1] }\n\t          });\n\t        }\n\t\n\t        r.touchData.cxtOver = near;\n\t\n\t        if (near) {\n\t          near.emit({\n\t            originalEvent: e,\n\t            type: 'cxtdragover',\n\t            position: { x: now[0], y: now[1] }\n\t          });\n\t        }\n\t      }\n\t\n\t      // box selection\n\t    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n\t      e.preventDefault();\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t\n\t      this.lastThreeTouch = +new Date();\n\t\n\t      if (!r.touchData.selecting) {\n\t        cy.emit('boxstart');\n\t      }\n\t\n\t      r.touchData.selecting = true;\n\t\n\t      r.redrawHint('select', true);\n\t\n\t      if (!select || select.length === 0 || select[0] === undefined) {\n\t        select[0] = (now[0] + now[2] + now[4]) / 3;\n\t        select[1] = (now[1] + now[3] + now[5]) / 3;\n\t        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n\t        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n\t      } else {\n\t        select[2] = (now[0] + now[2] + now[4]) / 3;\n\t        select[3] = (now[1] + now[3] + now[5]) / 3;\n\t      }\n\t\n\t      select[4] = 1;\n\t      r.touchData.selecting = true;\n\t\n\t      r.redraw();\n\t\n\t      // pinch to zoom\n\t    } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n\t      // two fingers => pinch to zoom\n\t      e.preventDefault();\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint('select', true);\n\t\n\t      var draggedEles = r.dragData.touchDragEles;\n\t      if (draggedEles) {\n\t        r.redrawHint('drag', true);\n\t\n\t        for (var i = 0; i < draggedEles.length; i++) {\n\t          var de_p = draggedEles[i]._private;\n\t\n\t          de_p.grabbed = false;\n\t          de_p.rscratch.inDragLayer = false;\n\t        }\n\t      }\n\t\n\t      // (x2, y2) for fingers 1 and 2\n\t      var f1x2 = e.touches[0].clientX - offsetLeft,\n\t          f1y2 = e.touches[0].clientY - offsetTop;\n\t      var f2x2 = e.touches[1].clientX - offsetLeft,\n\t          f2y2 = e.touches[1].clientY - offsetTop;\n\t\n\t      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n\t      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n\t      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n\t      var factor = distance2 / distance1;\n\t\n\t      if (twoFingersStartInside) {\n\t        // delta finger1\n\t        var df1x = f1x2 - f1x1;\n\t        var df1y = f1y2 - f1y1;\n\t\n\t        // delta finger 2\n\t        var df2x = f2x2 - f2x1;\n\t        var df2y = f2y2 - f2y1;\n\t\n\t        // translation is the normalised vector of the two fingers movement\n\t        // i.e. so pinching cancels out and moving together pans\n\t        var tx = (df1x + df2x) / 2;\n\t        var ty = (df1y + df2y) / 2;\n\t\n\t        // adjust factor by the speed multiplier\n\t        // var speed = 1.5;\n\t        // if( factor > 1 ){\n\t        //   factor = (factor - 1) * speed + 1;\n\t        // } else {\n\t        //   factor = 1 - (1 - factor) * speed;\n\t        // }\n\t\n\t        // now calculate the zoom\n\t        var zoom1 = cy.zoom();\n\t        var zoom2 = zoom1 * factor;\n\t        var pan1 = cy.pan();\n\t\n\t        // the model center point converted to the current rendered pos\n\t        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n\t        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\t\n\t        var pan2 = {\n\t          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n\t          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n\t        };\n\t\n\t        // remove dragged eles\n\t        if (r.touchData.start && r.touchData.start.active()) {\n\t          var draggedEles = r.dragData.touchDragEles;\n\t\n\t          freeDraggedElements(draggedEles);\n\t\n\t          r.redrawHint('drag', true);\n\t          r.redrawHint('eles', true);\n\t\n\t          r.touchData.start.unactivate().emit('free');\n\t        }\n\t\n\t        cy.viewport({\n\t          zoom: zoom2,\n\t          pan: pan2,\n\t          cancelOnFailedZoom: true\n\t        });\n\t\n\t        distance1 = distance2;\n\t        f1x1 = f1x2;\n\t        f1y1 = f1y2;\n\t        f2x1 = f2x2;\n\t        f2y1 = f2y2;\n\t\n\t        r.pinching = true;\n\t      }\n\t\n\t      // Re-project\n\t      if (e.touches[0]) {\n\t        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n\t      }\n\t      if (e.touches[1]) {\n\t        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n\t      }\n\t      if (e.touches[2]) {\n\t        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n\t      }\n\t    } else if (e.touches[0]) {\n\t      var start = r.touchData.start;\n\t      var last = r.touchData.last;\n\t      var near;\n\t\n\t      if (!r.hoverData.draggingEles && !r.swipePanning) {\n\t        near = r.findNearestElement(now[0], now[1], true, true);\n\t      }\n\t\n\t      if (capture && start != null) {\n\t        e.preventDefault();\n\t      }\n\t\n\t      // dragging nodes\n\t      if (capture && start != null && r.nodeIsDraggable(start)) {\n\t\n\t        if (isOverThresholdDrag) {\n\t          // then dragging can happen\n\t          var draggedEles = r.dragData.touchDragEles;\n\t          var justStartedDrag = !r.dragData.didDrag;\n\t\n\t          if (justStartedDrag) {\n\t            addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });\n\t          }\n\t\n\t          for (var k = 0; k < draggedEles.length; k++) {\n\t            var draggedEle = draggedEles[k];\n\t\n\t            if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {\n\t              r.dragData.didDrag = true;\n\t              var dPos = draggedEle.position();\n\t\n\t              if (is.number(disp[0]) && is.number(disp[1])) {\n\t                dPos.x += disp[0];\n\t                dPos.y += disp[1];\n\t              }\n\t\n\t              if (justStartedDrag) {\n\t                r.redrawHint('eles', true);\n\t\n\t                var dragDelta = r.touchData.dragDelta;\n\t\n\t                if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {\n\t                  dPos.x += dragDelta[0];\n\t                  dPos.y += dragDelta[1];\n\t                }\n\t              }\n\t            }\n\t          }\n\t\n\t          var tcol = cy.collection(draggedEles);\n\t\n\t          tcol.dirtyCompoundBoundsCache();\n\t          tcol.emit('position drag');\n\t\n\t          r.hoverData.draggingEles = true;\n\t\n\t          r.redrawHint('drag', true);\n\t\n\t          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n\t\n\t            r.redrawHint('eles', true);\n\t          }\n\t\n\t          r.redraw();\n\t        } else {\n\t          // otherise keep track of drag delta for later\n\t          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\t\n\t          if (dragDelta.length === 0) {\n\t            dragDelta.push(disp[0]);\n\t            dragDelta.push(disp[1]);\n\t          } else {\n\t            dragDelta[0] += disp[0];\n\t            dragDelta[1] += disp[1];\n\t          }\n\t        }\n\t      }\n\t\n\t      // touchmove\n\t      {\n\t        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n\t          position: { x: now[0], y: now[1] }\n\t        });\n\t\n\t        if ((!start || !start.grabbed()) && near != last) {\n\t          if (last) {\n\t            last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });\n\t          }\n\t          if (near) {\n\t            near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });\n\t          }\n\t        }\n\t\n\t        r.touchData.last = near;\n\t      }\n\t\n\t      // check to cancel taphold\n\t      if (capture) {\n\t        for (var i = 0; i < now.length; i++) {\n\t          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n\t\n\t            r.touchData.singleTouchMoved = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      // panning\n\t      if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n\t\n\t        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n\t\n\t        if (allowPassthrough) {\n\t          e.preventDefault();\n\t\n\t          if (r.swipePanning) {\n\t            cy.panBy({\n\t              x: disp[0] * zoom,\n\t              y: disp[1] * zoom\n\t            });\n\t          } else if (isOverThresholdDrag) {\n\t            r.swipePanning = true;\n\t\n\t            cy.panBy({\n\t              x: dx * zoom,\n\t              y: dy * zoom\n\t            });\n\t\n\t            if (start) {\n\t              start.unactivate();\n\t\n\t              if (!r.data.bgActivePosistion) {\n\t                r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);\n\t              }\n\t\n\t              r.redrawHint('select', true);\n\t\n\t              r.touchData.start = null;\n\t            }\n\t          }\n\t        }\n\t\n\t        // Re-project\n\t        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n\t        now[0] = pos[0];now[1] = pos[1];\n\t      }\n\t    }\n\t\n\t    for (var j = 0; j < now.length; j++) {\n\t      earlier[j] = now[j];\n\t    }\n\t    //r.redraw();\n\t  }, false);\n\t\n\t  var touchcancelHandler;\n\t  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    var start = r.touchData.start;\n\t\n\t    r.touchData.capture = false;\n\t\n\t    if (start) {\n\t      start.unactivate();\n\t    }\n\t  });\n\t\n\t  var touchendHandler;\n\t  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {\n\t    // eslint-disable-line no-undef\n\t    var start = r.touchData.start;\n\t\n\t    var capture = r.touchData.capture;\n\t\n\t    if (capture) {\n\t      r.touchData.capture = false;\n\t\n\t      e.preventDefault();\n\t    } else {\n\t      return;\n\t    }\n\t\n\t    var select = r.selection;\n\t\n\t    r.swipePanning = false;\n\t    r.hoverData.draggingEles = false;\n\t\n\t    var cy = r.cy;\n\t    var zoom = cy.zoom();\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t\n\t    if (e.touches[0]) {\n\t      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n\t    }\n\t    if (e.touches[1]) {\n\t      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n\t    }\n\t    if (e.touches[2]) {\n\t      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n\t    }\n\t\n\t    if (start) {\n\t      start.unactivate();\n\t    }\n\t\n\t    var ctxTapend;\n\t    if (r.touchData.cxt) {\n\t      ctxTapend = {\n\t        originalEvent: e,\n\t        type: 'cxttapend',\n\t        position: { x: now[0], y: now[1] }\n\t      };\n\t\n\t      if (start) {\n\t        start.emit(ctxTapend);\n\t      } else {\n\t        cy.emit(ctxTapend);\n\t      }\n\t\n\t      if (!r.touchData.cxtDragged) {\n\t        var ctxTap = {\n\t          originalEvent: e,\n\t          type: 'cxttap',\n\t          position: { x: now[0], y: now[1] }\n\t        };\n\t\n\t        if (start) {\n\t          start.emit(ctxTap);\n\t        } else {\n\t          cy.emit(ctxTap);\n\t        }\n\t      }\n\t\n\t      if (r.touchData.start) {\n\t        r.touchData.start._private.grabbed = false;\n\t      }\n\t      r.touchData.cxt = false;\n\t      r.touchData.start = null;\n\t\n\t      r.redraw();\n\t      return;\n\t    }\n\t\n\t    // no more box selection if we don't have three fingers\n\t    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n\t      r.touchData.selecting = false;\n\t\n\t      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n\t\n\t      select[0] = undefined;\n\t      select[1] = undefined;\n\t      select[2] = undefined;\n\t      select[3] = undefined;\n\t      select[4] = 0;\n\t\n\t      r.redrawHint('select', true);\n\t\n\t      cy.emit('boxend');\n\t\n\t      var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n\t        return ele.selectable() && !ele.selected();\n\t      };\n\t\n\t      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\t\n\t      if (box.nonempty()) {\n\t        r.redrawHint('eles', true);\n\t      }\n\t\n\t      r.redraw();\n\t    }\n\t\n\t    if (start != null) {\n\t      start.unactivate();\n\t    }\n\t\n\t    if (e.touches[2]) {\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint('select', true);\n\t    } else if (e.touches[1]) {\n\t      // ignore\n\t    } else if (e.touches[0]) {\n\t      // ignore\n\t\n\t      // Last touch released\n\t    } else if (!e.touches[0]) {\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint('select', true);\n\t\n\t      var draggedEles = r.dragData.touchDragEles;\n\t\n\t      if (start != null) {\n\t\n\t        var startWasGrabbed = start._private.grabbed;\n\t\n\t        freeDraggedElements(draggedEles);\n\t\n\t        r.redrawHint('drag', true);\n\t        r.redrawHint('eles', true);\n\t\n\t        if (startWasGrabbed) {\n\t          start.emit('free');\n\t        }\n\t\n\t        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n\t          position: { x: now[0], y: now[1] }\n\t        });\n\t\n\t        start.unactivate();\n\t\n\t        r.touchData.start = null;\n\t      } else {\n\t        var near = r.findNearestElement(now[0], now[1], true, true);\n\t\n\t        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n\t          position: { x: now[0], y: now[1] }\n\t        });\n\t      }\n\t\n\t      var dx = r.touchData.startPosition[0] - now[0];\n\t      var dx2 = dx * dx;\n\t      var dy = r.touchData.startPosition[1] - now[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t      var rdist2 = dist2 * zoom * zoom;\n\t\n\t      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n\t      if (start != null && !r.dragData.didDrag // didn't drag nodes around\n\t      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n\t      ) {\n\t\n\t          if (cy.selectionType() === 'single') {\n\t            cy.$(':selected').unmerge(start).unselect();\n\t            start.select();\n\t          } else {\n\t            if (start.selected()) {\n\t              start.unselect();\n\t            } else {\n\t              start.select();\n\t            }\n\t          }\n\t\n\t          r.redrawHint('eles', true);\n\t        }\n\t\n\t      // Tap event, roughly same as mouse click event for touch\n\t      if (!r.touchData.singleTouchMoved) {\n\t        triggerEvents(start, ['tap', 'vclick'], e, {\n\t          position: { x: now[0], y: now[1] }\n\t        });\n\t      }\n\t\n\t      r.touchData.singleTouchMoved = true;\n\t    }\n\t\n\t    for (var j = 0; j < now.length; j++) {\n\t      earlier[j] = now[j];\n\t    }\n\t\n\t    r.dragData.didDrag = false; // reset for next mousedown\n\t\n\t    if (e.touches.length === 0) {\n\t      r.touchData.dragDelta = [];\n\t      r.touchData.startPosition = null;\n\t      r.touchData.startGPosition = null;\n\t    }\n\t\n\t    if (e.touches.length < 2) {\n\t      r.pinching = false;\n\t      r.redrawHint('eles', true);\n\t      r.redraw();\n\t    }\n\t\n\t    //r.redraw();\n\t  }, false);\n\t\n\t  // fallback compatibility layer for ms pointer events\n\t  if (typeof TouchEvent === 'undefined') {\n\t\n\t    var pointers = [];\n\t\n\t    var makeTouch = function makeTouch(e) {\n\t      return {\n\t        clientX: e.clientX,\n\t        clientY: e.clientY,\n\t        force: 1,\n\t        identifier: e.pointerId,\n\t        pageX: e.pageX,\n\t        pageY: e.pageY,\n\t        radiusX: e.width / 2,\n\t        radiusY: e.height / 2,\n\t        screenX: e.screenX,\n\t        screenY: e.screenY,\n\t        target: e.target\n\t      };\n\t    };\n\t\n\t    var makePointer = function makePointer(e) {\n\t      return {\n\t        event: e,\n\t        touch: makeTouch(e)\n\t      };\n\t    };\n\t\n\t    var addPointer = function addPointer(e) {\n\t      pointers.push(makePointer(e));\n\t    };\n\t\n\t    var removePointer = function removePointer(e) {\n\t      for (var i = 0; i < pointers.length; i++) {\n\t        var p = pointers[i];\n\t\n\t        if (p.event.pointerId === e.pointerId) {\n\t          pointers.splice(i, 1);\n\t          return;\n\t        }\n\t      }\n\t    };\n\t\n\t    var updatePointer = function updatePointer(e) {\n\t      var p = pointers.filter(function (p) {\n\t        return p.event.pointerId === e.pointerId;\n\t      })[0];\n\t\n\t      p.event = e;\n\t      p.touch = makeTouch(e);\n\t    };\n\t\n\t    var addTouchesToEvent = function addTouchesToEvent(e) {\n\t      e.touches = pointers.map(function (p) {\n\t        return p.touch;\n\t      });\n\t    };\n\t\n\t    var pointerIsMouse = function pointerIsMouse(e) {\n\t      return e.pointerType === 'mouse' || e.pointerType === 4;\n\t    };\n\t\n\t    r.registerBinding(r.container, 'pointerdown', function (e) {\n\t      if (pointerIsMouse(e)) {\n\t        return;\n\t      } // mouse already handled\n\t\n\t      e.preventDefault();\n\t\n\t      addPointer(e);\n\t\n\t      addTouchesToEvent(e);\n\t      touchstartHandler(e);\n\t    });\n\t\n\t    r.registerBinding(r.container, 'pointerup', function (e) {\n\t      if (pointerIsMouse(e)) {\n\t        return;\n\t      } // mouse already handled\n\t\n\t      removePointer(e);\n\t\n\t      addTouchesToEvent(e);\n\t      touchendHandler(e);\n\t    });\n\t\n\t    r.registerBinding(r.container, 'pointercancel', function (e) {\n\t      if (pointerIsMouse(e)) {\n\t        return;\n\t      } // mouse already handled\n\t\n\t      removePointer(e);\n\t\n\t      addTouchesToEvent(e);\n\t      touchcancelHandler(e);\n\t    });\n\t\n\t    r.registerBinding(r.container, 'pointermove', function (e) {\n\t      if (pointerIsMouse(e)) {\n\t        return;\n\t      } // mouse already handled\n\t\n\t      e.preventDefault();\n\t\n\t      updatePointer(e);\n\t\n\t      addTouchesToEvent(e);\n\t      touchmoveHandler(e);\n\t    });\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 99 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\t\n\tvar BRp = {};\n\t\n\tBRp.generatePolygon = function (name, points) {\n\t  return this.nodeShapes[name] = {\n\t    renderer: this,\n\t\n\t    name: name,\n\t\n\t    points: points,\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t      return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n\t    }\n\t  };\n\t};\n\t\n\tBRp.generateEllipse = function () {\n\t  return this.nodeShapes['ellipse'] = {\n\t    renderer: this,\n\t\n\t    name: 'ellipse',\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t      return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);\n\t    }\n\t  };\n\t};\n\t\n\tBRp.generateRoundRectangle = function () {\n\t  return this.nodeShapes['roundrectangle'] = {\n\t    renderer: this,\n\t\n\t    name: 'roundrectangle',\n\t\n\t    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t\n\t      var cornerRadius = math.getRoundRectangleRadius(width, height);\n\t      var diam = cornerRadius * 2;\n\t\n\t      // Check hBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // Check vBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // Check top left quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check top right quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check bottom right quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check bottom left quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t  };\n\t};\n\t\n\tBRp.generateCutRectangle = function () {\n\t  return this.nodeShapes['cutrectangle'] = {\n\t    renderer: this,\n\t\n\t    name: 'cutrectangle',\n\t\n\t    cornerLength: math.getCutRectangleCornerLength(),\n\t\n\t    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n\t    },\n\t\n\t    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n\t      var cl = this.cornerLength;\n\t      var hh = height / 2;\n\t      var hw = width / 2;\n\t      var xBegin = centerX - hw;\n\t      var xEnd = centerX + hw;\n\t      var yBegin = centerY - hh;\n\t      var yEnd = centerY + hh;\n\t\n\t      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n\t      return {\n\t        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n\t        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n\t        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n\t        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n\t      };\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\t      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n\t\n\t      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t      // Check hBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // Check vBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n\t      return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n\t    }\n\t\n\t  };\n\t};\n\t\n\tBRp.generateBarrel = function () {\n\t  return this.nodeShapes['barrel'] = {\n\t    renderer: this,\n\t\n\t    name: 'barrel',\n\t\n\t    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\t\n\t      var pts = [].concat(bPts.topLeft, bPts.topRight, bPts.bottomRight, bPts.bottomLeft);\n\t\n\t      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);\n\t    },\n\t\n\t    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n\t      var hh = height / 2;\n\t      var hw = width / 2;\n\t      var xBegin = centerX - hw;\n\t      var xEnd = centerX + hw;\n\t      var yBegin = centerY - hh;\n\t      var yEnd = centerY + hh;\n\t\n\t      var curveConstants = math.getBarrelCurveConstants(width, height);\n\t      var hOffset = curveConstants.heightOffset;\n\t      var wOffset = curveConstants.widthOffset;\n\t      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n\t\n\t      // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n\t      var pts = {\n\t        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n\t        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n\t        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n\t        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n\t      };\n\t\n\t      pts.topLeft.isTop = true;\n\t      pts.topRight.isTop = true;\n\t      pts.bottomLeft.isBottom = true;\n\t      pts.bottomRight.isBottom = true;\n\t\n\t      return pts;\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t\n\t      var curveConstants = math.getBarrelCurveConstants(width, height);\n\t      var hOffset = curveConstants.heightOffset;\n\t      var wOffset = curveConstants.widthOffset;\n\t\n\t      // Check hBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // Check vBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n\t\n\t      var getCurveT = function getCurveT(x, y, curvePts) {\n\t        var x0 = curvePts[4];\n\t        var x1 = curvePts[2];\n\t        var x2 = curvePts[0];\n\t        var y0 = curvePts[5];\n\t        // var y1 = curvePts[ 3 ];\n\t        var y2 = curvePts[1];\n\t\n\t        var xMin = Math.min(x0, x2);\n\t        var xMax = Math.max(x0, x2);\n\t        var yMin = Math.min(y0, y2);\n\t        var yMax = Math.max(y0, y2);\n\t\n\t        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n\t          var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);\n\t          var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n\t\n\t          var validRoots = roots.filter(function (r) {\n\t            return 0 <= r && r <= 1;\n\t          });\n\t\n\t          if (validRoots.length > 0) {\n\t            return validRoots[0];\n\t          }\n\t        }\n\t        return null;\n\t      };\n\t\n\t      var curveRegions = Object.keys(barrelCurvePts);\n\t      for (var i = 0; i < curveRegions.length; i++) {\n\t        var corner = curveRegions[i];\n\t        var cornerPts = barrelCurvePts[corner];\n\t        var t = getCurveT(x, y, cornerPts);\n\t\n\t        if (t == null) {\n\t          continue;\n\t        }\n\t\n\t        var y0 = cornerPts[5];\n\t        var y1 = cornerPts[3];\n\t        var y2 = cornerPts[1];\n\t        var bezY = math.qbezierAt(y0, y1, y2, t);\n\t\n\t        if (cornerPts.isTop && bezY <= y) {\n\t          return true;\n\t        }\n\t        if (cornerPts.isBottom && y <= bezY) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t  };\n\t};\n\t\n\tBRp.generateBottomRoundrectangle = function () {\n\t  return this.nodeShapes['bottomroundrectangle'] = {\n\t    renderer: this,\n\t\n\t    name: 'bottomroundrectangle',\n\t\n\t    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\t\n\t    draw: function draw(context, centerX, centerY, width, height) {\n\t      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n\t    },\n\t\n\t    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n\t      var topStartX = nodeX - (width / 2 + padding);\n\t      var topStartY = nodeY - (height / 2 + padding);\n\t      var topEndY = topStartY;\n\t      var topEndX = nodeX + (width / 2 + padding);\n\t\n\t      var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\t      if (topIntersections.length > 0) {\n\t        return topIntersections;\n\t      }\n\t\n\t      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n\t    },\n\t\n\t    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\t\n\t      var cornerRadius = math.getRoundRectangleRadius(width, height);\n\t      var diam = 2 * cornerRadius;\n\t\n\t      // Check hBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // Check vBox\n\t      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n\t        return true;\n\t      }\n\t\n\t      // check non-rounded top side\n\t      var outerWidth = width / 2 + 2 * padding;\n\t      var outerHeight = height / 2 + 2 * padding;\n\t      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n\t      if (math.pointInsidePolygonPoints(x, y, points)) {\n\t        return true;\n\t      }\n\t\n\t      // Check bottom right quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check bottom left quarter circle\n\t      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\t\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t  };\n\t};\n\t\n\tBRp.registerNodeShapes = function () {\n\t  var nodeShapes = this.nodeShapes = {};\n\t  var renderer = this;\n\t\n\t  this.generateEllipse();\n\t\n\t  this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));\n\t\n\t  this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));\n\t  nodeShapes['square'] = nodeShapes['rectangle'];\n\t\n\t  this.generateRoundRectangle();\n\t\n\t  this.generateCutRectangle();\n\t\n\t  this.generateBarrel();\n\t\n\t  this.generateBottomRoundrectangle();\n\t\n\t  this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);\n\t\n\t  this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));\n\t\n\t  this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));\n\t\n\t  this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));\n\t\n\t  this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));\n\t\n\t  var star5Points = new Array(20);\n\t  {\n\t    var outerPoints = math.generateUnitNgonPoints(5, 0);\n\t    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);\n\t\n\t    // Outer radius is 1; inner radius of star is smaller\n\t    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n\t    innerRadius *= 1.57;\n\t\n\t    for (var i = 0; i < innerPoints.length / 2; i++) {\n\t      innerPoints[i * 2] *= innerRadius;\n\t      innerPoints[i * 2 + 1] *= innerRadius;\n\t    }\n\t\n\t    for (var i = 0; i < 20 / 4; i++) {\n\t      star5Points[i * 4] = outerPoints[i * 2];\n\t      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n\t\n\t      star5Points[i * 4 + 2] = innerPoints[i * 2];\n\t      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n\t    }\n\t  }\n\t\n\t  star5Points = math.fitPolygonToSquare(star5Points);\n\t\n\t  this.generatePolygon('star', star5Points);\n\t\n\t  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n\t\n\t  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n\t\n\t  this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n\t\n\t  this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);\n\t\n\t  nodeShapes.makePolygon = function (points) {\n\t\n\t    // use caching on user-specified polygons so they are as fast as native shapes\n\t\n\t    var key = points.join('$');\n\t    var name = 'polygon-' + key;\n\t    var shape;\n\t\n\t    if (shape = this[name]) {\n\t      // got cached shape\n\t      return shape;\n\t    }\n\t\n\t    // create and cache new shape\n\t    return renderer.generatePolygon(name, points);\n\t  };\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 100 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar BRp = {};\n\t\n\tBRp.timeToRender = function () {\n\t  return this.redrawTotalTime / this.redrawCount;\n\t};\n\t\n\tBRp.redraw = function (options) {\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var r = this;\n\t\n\t  if (r.averageRedrawTime === undefined) {\n\t    r.averageRedrawTime = 0;\n\t  }\n\t  if (r.lastRedrawTime === undefined) {\n\t    r.lastRedrawTime = 0;\n\t  }\n\t  if (r.lastDrawTime === undefined) {\n\t    r.lastDrawTime = 0;\n\t  }\n\t\n\t  r.requestedFrame = true;\n\t  r.renderOptions = options;\n\t};\n\t\n\tBRp.beforeRender = function (fn, priority) {\n\t  // the renderer can't add tick callbacks when destroyed\n\t  if (this.destroyed) {\n\t    return;\n\t  }\n\t\n\t  priority = priority || 0;\n\t\n\t  var cbs = this.beforeRenderCallbacks;\n\t\n\t  cbs.push({ fn: fn, priority: priority });\n\t\n\t  // higher priority callbacks executed first\n\t  cbs.sort(function (a, b) {\n\t    return b.priority - a.priority;\n\t  });\n\t};\n\t\n\tvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n\t  var cbs = r.beforeRenderCallbacks;\n\t\n\t  for (var i = 0; i < cbs.length; i++) {\n\t    cbs[i].fn(willDraw, startTime);\n\t  }\n\t};\n\t\n\tBRp.startRenderLoop = function () {\n\t  var r = this;\n\t\n\t  if (r.renderLoopStarted) {\n\t    return;\n\t  } else {\n\t    r.renderLoopStarted = true;\n\t  }\n\t\n\t  var renderFn = function renderFn(requestTime) {\n\t    if (r.destroyed) {\n\t      return;\n\t    }\n\t\n\t    if (r.requestedFrame && !r.skipFrame) {\n\t      beforeRenderCallbacks(r, true, requestTime);\n\t\n\t      var startTime = util.performanceNow();\n\t\n\t      r.render(r.renderOptions);\n\t\n\t      var endTime = r.lastDrawTime = util.performanceNow();\n\t\n\t      if (r.averageRedrawTime === undefined) {\n\t        r.averageRedrawTime = endTime - startTime;\n\t      }\n\t\n\t      if (r.redrawCount === undefined) {\n\t        r.redrawCount = 0;\n\t      }\n\t\n\t      r.redrawCount++;\n\t\n\t      if (r.redrawTotalTime === undefined) {\n\t        r.redrawTotalTime = 0;\n\t      }\n\t\n\t      var duration = endTime - startTime;\n\t\n\t      r.redrawTotalTime += duration;\n\t      r.lastRedrawTime = duration;\n\t\n\t      // use a weighted average with a bias from the previous average so we don't spike so easily\n\t      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n\t\n\t      r.requestedFrame = false;\n\t    } else {\n\t      beforeRenderCallbacks(r, false, requestTime);\n\t    }\n\t\n\t    r.skipFrame = false;\n\t\n\t    util.requestAnimationFrame(renderFn);\n\t  };\n\t\n\t  util.requestAnimationFrame(renderFn);\n\t};\n\t\n\tmodule.exports = BRp;\n\t\n\t/***/ }),\n\t/* 101 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar CRp = {};\n\t\n\tvar impl;\n\t\n\tCRp.arrowShapeImpl = function (name) {\n\t  return (impl || (impl = {\n\t    'polygon': function polygon(context, points) {\n\t      for (var i = 0; i < points.length; i++) {\n\t        var pt = points[i];\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t    },\n\t\n\t    'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {\n\t      var firstPt;\n\t\n\t      for (var i = 0; i < points.length; i++) {\n\t        var pt = points[i];\n\t\n\t        if (i === 0) {\n\t          firstPt = pt;\n\t        }\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t\n\t      context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n\t    },\n\t\n\t    'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {\n\t      if (context.beginPath) {\n\t        context.beginPath();\n\t      }\n\t\n\t      var triPts = trianglePoints;\n\t      for (var i = 0; i < triPts.length; i++) {\n\t        var pt = triPts[i];\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t\n\t      if (context.closePath) {\n\t        context.closePath();\n\t      }\n\t\n\t      if (context.beginPath) {\n\t        context.beginPath();\n\t      }\n\t\n\t      var teePts = teePoints;\n\t      var firstTeePt = teePoints[0];\n\t      context.moveTo(firstTeePt.x, firstTeePt.y);\n\t\n\t      for (var i = 0; i < teePts.length; i++) {\n\t        var pt = teePts[i];\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t      if (context.closePath) {\n\t        context.closePath();\n\t      }\n\t    },\n\t\n\t    'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {\n\t      if (context.beginPath) {\n\t        context.beginPath();\n\t      }\n\t\n\t      var triPts = trianglePoints;\n\t      for (var i = 0; i < triPts.length; i++) {\n\t        var pt = triPts[i];\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t\n\t      if (context.closePath) {\n\t        context.closePath();\n\t      }\n\t\n\t      if (context.beginPath) {\n\t        context.beginPath();\n\t      }\n\t\n\t      var teePts = crossLinePoints;\n\t      var firstTeePt = crossLinePoints[0];\n\t      context.moveTo(firstTeePt.x, firstTeePt.y);\n\t\n\t      for (var i = 0; i < teePts.length; i++) {\n\t        var pt = teePts[i];\n\t\n\t        context.lineTo(pt.x, pt.y);\n\t      }\n\t      if (context.closePath) {\n\t        context.closePath();\n\t      }\n\t    },\n\t\n\t    'circle': function circle(context, rx, ry, r) {\n\t      context.arc(rx, ry, r, 0, Math.PI * 2, false);\n\t    }\n\t  }))[name];\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 102 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {\n\t  var r = this;\n\t  var rs = edge._private.rscratch;\n\t  var usePaths = r.usePaths();\n\t\n\t  // if bezier ctrl pts can not be calculated, then die\n\t  if (rs.badLine || isNaN(rs.allpts[0])) {\n\t    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n\t    return;\n\t  }\n\t\n\t  if (!edge.visible()) {\n\t    return;\n\t  }\n\t\n\t  var bb = void 0;\n\t  if (shiftToOriginWithBb) {\n\t    bb = shiftToOriginWithBb;\n\t\n\t    context.translate(-bb.x1, -bb.y1);\n\t  }\n\t\n\t  var overlayPadding = edge.pstyle('overlay-padding').pfValue;\n\t  var overlayWidth = 2 * overlayPadding;\n\t  var overlayOpacity = edge.pstyle('overlay-opacity').value;\n\t  var overlayColor = edge.pstyle('overlay-color').value;\n\t  var lineColor = edge.pstyle('line-color').value;\n\t  var opacity = edge.pstyle('opacity').value;\n\t  var lineStyle = edge.pstyle('line-style').value;\n\t  var edgeWidth = edge.pstyle('width').pfValue;\n\t\n\t  var drawLine = function drawLine() {\n\t    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;\n\t\n\t    context.lineWidth = edgeWidth;\n\t    context.lineCap = 'butt';\n\t\n\t    r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);\n\t\n\t    r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n\t  };\n\t\n\t  var drawOverlay = function drawOverlay() {\n\t    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;\n\t\n\t    context.lineWidth = overlayWidth;\n\t\n\t    if (rs.edgeType === 'self' && !usePaths) {\n\t      context.lineCap = 'butt';\n\t    } else {\n\t      context.lineCap = 'round';\n\t    }\n\t\n\t    r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);\n\t\n\t    r.drawEdgePath(edge, context, rs.allpts, 'solid');\n\t  };\n\t\n\t  var drawArrows = function drawArrows() {\n\t    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;\n\t\n\t    r.drawArrowheads(context, edge, arrowOpacity);\n\t  };\n\t\n\t  var drawText = function drawText() {\n\t    r.drawElementText(context, edge, drawLabel);\n\t  };\n\t\n\t  context.lineJoin = 'round';\n\t\n\t  var ghost = edge.pstyle('ghost').value === 'yes';\n\t\n\t  if (ghost) {\n\t    var gx = edge.pstyle('ghost-offset-x').pfValue;\n\t    var gy = edge.pstyle('ghost-offset-y').pfValue;\n\t    var ghostOpacity = edge.pstyle('ghost-opacity').value;\n\t    var effectiveGhostOpacity = opacity * ghostOpacity;\n\t\n\t    context.translate(gx, gy);\n\t\n\t    drawLine(effectiveGhostOpacity);\n\t    drawArrows(effectiveGhostOpacity);\n\t\n\t    context.translate(-gx, -gy);\n\t  }\n\t\n\t  drawLine();\n\t  drawArrows();\n\t  drawOverlay();\n\t  drawText();\n\t\n\t  if (shiftToOriginWithBb) {\n\t    context.translate(bb.x1, bb.y1);\n\t  }\n\t};\n\t\n\tCRp.drawEdgePath = function (edge, context, pts, type) {\n\t  var rs = edge._private.rscratch;\n\t  var canvasCxt = context;\n\t  var path = void 0;\n\t  var pathCacheHit = false;\n\t  var usePaths = this.usePaths();\n\t\n\t  if (usePaths) {\n\t    var pathCacheKey = pts.join('$');\n\t    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\t\n\t    if (keyMatches) {\n\t      path = context = rs.pathCache;\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = context = new Path2D(); // eslint-disable-line no-undef\n\t      rs.pathCacheKey = pathCacheKey;\n\t      rs.pathCache = path;\n\t    }\n\t  }\n\t\n\t  if (canvasCxt.setLineDash) {\n\t    // for very outofdate browsers\n\t    switch (type) {\n\t      case 'dotted':\n\t        canvasCxt.setLineDash([1, 1]);\n\t        break;\n\t\n\t      case 'dashed':\n\t        canvasCxt.setLineDash([6, 3]);\n\t        break;\n\t\n\t      case 'solid':\n\t        canvasCxt.setLineDash([]);\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!pathCacheHit && !rs.badLine) {\n\t    if (context.beginPath) {\n\t      context.beginPath();\n\t    }\n\t    context.moveTo(pts[0], pts[1]);\n\t\n\t    switch (rs.edgeType) {\n\t      case 'bezier':\n\t      case 'self':\n\t      case 'compound':\n\t      case 'multibezier':\n\t        for (var i = 2; i + 3 < pts.length; i += 4) {\n\t          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n\t        }\n\t        break;\n\t\n\t      case 'straight':\n\t      case 'segments':\n\t      case 'haystack':\n\t        for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n\t          context.lineTo(pts[_i], pts[_i + 1]);\n\t        }\n\t        break;\n\t    }\n\t  }\n\t\n\t  context = canvasCxt;\n\t  if (usePaths) {\n\t    context.stroke(path);\n\t  } else {\n\t    context.stroke();\n\t  }\n\t\n\t  // reset any line dashes\n\t  if (context.setLineDash) {\n\t    // for very outofdate browsers\n\t    context.setLineDash([]);\n\t  }\n\t};\n\t\n\tCRp.drawArrowheads = function (context, edge, opacity) {\n\t  var rs = edge._private.rscratch;\n\t  var isHaystack = rs.edgeType === 'haystack';\n\t\n\t  if (!isHaystack) {\n\t    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n\t  }\n\t\n\t  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n\t\n\t  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n\t\n\t  if (!isHaystack) {\n\t    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n\t  }\n\t};\n\t\n\tCRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n\t  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n\t    return;\n\t  }\n\t\n\t  var self = this;\n\t  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n\t  if (arrowShape === 'none') {\n\t    return;\n\t  }\n\t\n\t  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n\t  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n\t  var edgeWidth = edge.pstyle('width').pfValue;\n\t  var edgeOpacity = edge.pstyle('opacity').value;\n\t\n\t  if (opacity === undefined) {\n\t    opacity = edgeOpacity;\n\t  }\n\t\n\t  var gco = context.globalCompositeOperation;\n\t\n\t  if (opacity !== 1 || arrowFill === 'hollow') {\n\t    // then extra clear is needed\n\t    context.globalCompositeOperation = 'destination-out';\n\t\n\t    self.fillStyle(context, 255, 255, 255, 1);\n\t    self.strokeStyle(context, 255, 255, 255, 1);\n\t\n\t    self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n\t\n\t    context.globalCompositeOperation = gco;\n\t  } // otherwise, the opaque arrow clears it for free :)\n\t\n\t  var color = edge.pstyle(prefix + '-arrow-color').value;\n\t  self.fillStyle(context, color[0], color[1], color[2], opacity);\n\t  self.strokeStyle(context, color[0], color[1], color[2], opacity);\n\t\n\t  self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n\t};\n\t\n\tCRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {\n\t  var r = this;\n\t  var usePaths = this.usePaths();\n\t  var rs = edge._private.rscratch;\n\t  var pathCacheHit = false;\n\t  var path = void 0;\n\t  var canvasContext = context;\n\t  var translation = { x: x, y: y };\n\t  var scale = edge.pstyle('arrow-scale').value;\n\t  var size = this.getArrowWidth(edgeWidth, scale);\n\t  var shapeImpl = r.arrowShapes[shape];\n\t\n\t  if (usePaths) {\n\t    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n\t    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n\t    rs.arrowPathCache = rs.arrowPathCache || {};\n\t\n\t    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;\n\t    if (alreadyCached) {\n\t      path = context = rs.arrowPathCache[arrowType];\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = context = new Path2D(); // eslint-disable-line no-undef\n\t      rs.arrowPathCacheKey[arrowType] = pathCacheKey;\n\t      rs.arrowPathCache[arrowType] = path;\n\t    }\n\t  }\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  if (!pathCacheHit) {\n\t    shapeImpl.draw(context, size, angle, translation, edgeWidth);\n\t  }\n\t\n\t  if (!shapeImpl.leavePathOpen && context.closePath) {\n\t    context.closePath();\n\t  }\n\t\n\t  context = canvasContext;\n\t\n\t  if (fill === 'filled' || fill === 'both') {\n\t    if (usePaths) {\n\t      context.fill(path);\n\t    } else {\n\t      context.fill();\n\t    }\n\t  }\n\t\n\t  if (fill === 'hollow' || fill === 'both') {\n\t    context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;\n\t    context.lineJoin = 'miter';\n\t\n\t    if (usePaths) {\n\t      context.stroke(path);\n\t    } else {\n\t      context.stroke();\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 103 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {\n\t  var r = this;\n\t\n\t  if (ele.isNode()) {\n\t    r.drawNode(context, ele, shiftToOriginWithBb, showLabel);\n\t  } else {\n\t    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);\n\t  }\n\t};\n\t\n\tCRp.drawCachedElement = function (context, ele, pxRatio, extent) {\n\t  var r = this;\n\t  var bb = ele.boundingBox();\n\t\n\t  if (bb.w === 0 || bb.h === 0) {\n\t    return;\n\t  }\n\t\n\t  if (!extent || math.boundingBoxesIntersect(bb, extent)) {\n\t    var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);\n\t\n\t    if (cache != null) {\n\t      context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);\n\t    } else {\n\t      // if the element is not cacheable, then draw directly\n\t      r.drawElement(context, ele);\n\t    }\n\t  }\n\t};\n\t\n\tCRp.drawElements = function (context, eles) {\n\t  var r = this;\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    r.drawElement(context, ele);\n\t  }\n\t};\n\t\n\tCRp.drawCachedElements = function (context, eles, pxRatio, extent) {\n\t  var r = this;\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    r.drawCachedElement(context, ele, pxRatio, extent);\n\t  }\n\t};\n\t\n\tCRp.drawCachedNodes = function (context, eles, pxRatio, extent) {\n\t  var r = this;\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    if (!ele.isNode()) {\n\t      continue;\n\t    }\n\t\n\t    r.drawCachedElement(context, ele, pxRatio, extent);\n\t  }\n\t};\n\t\n\tCRp.drawLayeredElements = function (context, eles, pxRatio, extent) {\n\t  var r = this;\n\t\n\t  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n\t\n\t  if (layers) {\n\t    for (var i = 0; i < layers.length; i++) {\n\t      var layer = layers[i];\n\t      var bb = layer.bb;\n\t\n\t      if (bb.w === 0 || bb.h === 0) {\n\t        continue;\n\t      }\n\t\n\t      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n\t    }\n\t  } else {\n\t    // fall back on plain caching if no layers\n\t    r.drawCachedElements(context, eles, pxRatio, extent);\n\t  }\n\t};\n\t\n\tCRp.drawDebugPoints = function (context, eles) {\n\t  var draw = function draw(x, y, color) {\n\t    context.fillStyle = color;\n\t    context.fillRect(x - 1, y - 1, 3, 3);\n\t  };\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t    var rs = ele._private.rscratch;\n\t\n\t    if (ele.isNode()) {\n\t      var p = ele.position();\n\t\n\t      draw(p.x, p.y, 'magenta');\n\t    } else {\n\t      var pts = rs.allpts;\n\t\n\t      for (var j = 0; j + 1 < pts.length; j += 2) {\n\t        var x = pts[j];\n\t        var y = pts[j + 1];\n\t\n\t        draw(x, y, 'cyan');\n\t      }\n\t\n\t      draw(rs.midX, rs.midY, 'yellow');\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 104 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar CRp = {};\n\t\n\tCRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n\t  var r = this;\n\t\n\t  // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n\t  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n\t    return;\n\t  }\n\t\n\t  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n\t};\n\t\n\tCRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n\t  var r = this;\n\t  var pos = node.position();\n\t  var nodeX = pos.x;\n\t  var nodeY = pos.y;\n\t  var styleObj = node.cy().style();\n\t  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n\t  var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n\t  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n\t  var nodeW = node.width();\n\t  var nodeH = node.height();\n\t  var paddingX2 = node.padding() * 2;\n\t  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n\t  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n\t  var rs = node._private.rscratch;\n\t  var clip = node.pstyle('background-clip').value;\n\t  var shouldClip = clip === 'node';\n\t  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n\t\n\t  var imgW = img.width || img.cachedW;\n\t  var imgH = img.height || img.cachedH;\n\t\n\t  // workaround for broken browsers like ie\n\t  if (null == imgW || null == imgH) {\n\t    document.body.appendChild(img); // eslint-disable-line no-undef\n\t\n\t    imgW = img.cachedW = img.width || img.offsetWidth;\n\t    imgH = img.cachedH = img.height || img.offsetHeight;\n\t\n\t    document.body.removeChild(img); // eslint-disable-line no-undef\n\t  }\n\t\n\t  var w = imgW;\n\t  var h = imgH;\n\t\n\t  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n\t    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n\t      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n\t    } else {\n\t      w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n\t    }\n\t  }\n\t\n\t  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n\t    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n\t      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n\t    } else {\n\t      h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n\t    }\n\t  }\n\t\n\t  if (w === 0 || h === 0) {\n\t    return; // no point in drawing empty image (and chrome is broken in this case)\n\t  }\n\t\n\t  if (fit === 'contain') {\n\t    var scale = Math.min(nodeTW / w, nodeTH / h);\n\t\n\t    w *= scale;\n\t    h *= scale;\n\t  } else if (fit === 'cover') {\n\t    var scale = Math.max(nodeTW / w, nodeTH / h);\n\t\n\t    w *= scale;\n\t    h *= scale;\n\t  }\n\t\n\t  var x = nodeX - nodeTW / 2; // left\n\t  if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {\n\t    x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n\t  } else {\n\t    x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n\t  }\n\t\n\t  var y = nodeY - nodeTH / 2; // top\n\t  if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {\n\t    y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n\t  } else {\n\t    y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n\t  }\n\t\n\t  if (rs.pathCache) {\n\t    x -= nodeX;\n\t    y -= nodeY;\n\t\n\t    nodeX = 0;\n\t    nodeY = 0;\n\t  }\n\t\n\t  var gAlpha = context.globalAlpha;\n\t\n\t  context.globalAlpha = imgOpacity;\n\t\n\t  if (repeat === 'no-repeat') {\n\t\n\t    if (shouldClip) {\n\t      context.save();\n\t\n\t      if (rs.pathCache) {\n\t        context.clip(rs.pathCache);\n\t      } else {\n\t        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n\t\n\t        context.clip();\n\t      }\n\t    }\n\t\n\t    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n\t\n\t    if (shouldClip) {\n\t      context.restore();\n\t    }\n\t  } else {\n\t    var pattern = context.createPattern(img, repeat);\n\t    context.fillStyle = pattern;\n\t\n\t    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n\t\n\t    context.translate(x, y);\n\t    context.fill();\n\t    context.translate(-x, -y);\n\t  }\n\t\n\t  context.globalAlpha = gAlpha;\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 105 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\t\n\tvar CRp = {};\n\t\n\tCRp.eleTextBiggerThanMin = function (ele, scale) {\n\t  if (!scale) {\n\t    var zoom = ele.cy().zoom();\n\t    var pxRatio = this.getPixelRatio();\n\t    var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level\n\t\n\t    scale = Math.pow(2, lvl);\n\t  }\n\t\n\t  var computedSize = ele.pstyle('font-size').pfValue * scale;\n\t  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n\t\n\t  if (computedSize < minSize) {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tCRp.drawElementText = function (context, ele, force) {\n\t  var r = this;\n\t\n\t  if (force === undefined) {\n\t    if (!r.eleTextBiggerThanMin(ele)) {\n\t      return;\n\t    }\n\t  } else {\n\t    if (!force) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  if (ele.isNode()) {\n\t    var label = ele.pstyle('label');\n\t\n\t    if (!label || !label.value) {\n\t      return;\n\t    }\n\t\n\t    var textHalign = ele.pstyle('text-halign').strValue;\n\t    var textValign = ele.pstyle('text-valign').strValue;\n\t\n\t    switch (textHalign) {\n\t      case 'left':\n\t        context.textAlign = 'right';\n\t        break;\n\t\n\t      case 'right':\n\t        context.textAlign = 'left';\n\t        break;\n\t\n\t      default:\n\t        // e.g. center\n\t        context.textAlign = 'center';\n\t    }\n\t\n\t    context.textBaseline = 'bottom';\n\t  } else {\n\t    var label = ele.pstyle('label');\n\t    var srcLabel = ele.pstyle('source-label');\n\t    var tgtLabel = ele.pstyle('target-label');\n\t\n\t    if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n\t      return;\n\t    }\n\t\n\t    context.textAlign = 'center';\n\t    context.textBaseline = 'bottom';\n\t  }\n\t\n\t  r.drawText(context, ele);\n\t\n\t  if (ele.isEdge()) {\n\t    r.drawText(context, ele, 'source');\n\t\n\t    r.drawText(context, ele, 'target');\n\t  }\n\t};\n\t\n\tCRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;\n\t\n\tCRp.getFontCache = function (context) {\n\t  var cache;\n\t\n\t  this.fontCaches = this.fontCaches || [];\n\t\n\t  for (var i = 0; i < this.fontCaches.length; i++) {\n\t    cache = this.fontCaches[i];\n\t\n\t    if (cache.context === context) {\n\t      return cache;\n\t    }\n\t  }\n\t\n\t  cache = {\n\t    context: context\n\t  };\n\t  this.fontCaches.push(cache);\n\t\n\t  return cache;\n\t};\n\t\n\t// set up canvas context with font\n\t// returns transformed text string\n\tCRp.setupTextStyle = function (context, ele) {\n\t  // Font style\n\t  var parentOpacity = ele.effectiveOpacity();\n\t  var labelStyle = ele.pstyle('font-style').strValue;\n\t  var labelSize = ele.pstyle('font-size').pfValue + 'px';\n\t  var labelFamily = ele.pstyle('font-family').strValue;\n\t  var labelWeight = ele.pstyle('font-weight').strValue;\n\t  var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;\n\t  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n\t  var color = ele.pstyle('color').value;\n\t  var outlineColor = ele.pstyle('text-outline-color').value;\n\t\n\t  var fontCacheKey = ele._private.fontKey;\n\t  var cache = this.getFontCache(context);\n\t\n\t  if (cache.key !== fontCacheKey) {\n\t    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\t\n\t    cache.key = fontCacheKey;\n\t  }\n\t\n\t  // Calculate text draw position based on text alignment\n\t\n\t  // so text outlines aren't jagged\n\t  context.lineJoin = 'round';\n\t\n\t  this.fillStyle(context, color[0], color[1], color[2], opacity);\n\t\n\t  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n\t};\n\t\n\tfunction roundRect(ctx, x, y, width, height, radius) {\n\t  var radius = radius || 5;\n\t  ctx.beginPath();\n\t  ctx.moveTo(x + radius, y);\n\t  ctx.lineTo(x + width - radius, y);\n\t  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t  ctx.lineTo(x + width, y + height - radius);\n\t  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t  ctx.lineTo(x + radius, y + height);\n\t  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t  ctx.lineTo(x, y + radius);\n\t  ctx.quadraticCurveTo(x, y, x + radius, y);\n\t  ctx.closePath();\n\t  ctx.fill();\n\t}\n\t\n\t// Draw text\n\tCRp.drawText = function (context, ele, prefix) {\n\t  var _p = ele._private;\n\t  var rscratch = _p.rscratch;\n\t  var parentOpacity = ele.effectiveOpacity();\n\t  if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {\n\t    return;\n\t  }\n\t\n\t  var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);\n\t  var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);\n\t  var text = this.getLabelText(ele, prefix);\n\t\n\t  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n\t    this.setupTextStyle(context, ele);\n\t\n\t    var pdash = prefix ? prefix + '-' : '';\n\t    var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);\n\t    var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);\n\t    var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);\n\t    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n\t    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n\t\n\t    var isEdge = ele.isEdge();\n\t    var isNode = ele.isNode();\n\t\n\t    var halign = ele.pstyle('text-halign').value;\n\t    var valign = ele.pstyle('text-valign').value;\n\t\n\t    if (isEdge) {\n\t      halign = 'center';\n\t      valign = 'center';\n\t    }\n\t\n\t    textX += marginX;\n\t    textY += marginY;\n\t\n\t    var rotation = ele.pstyle('text-rotation');\n\t    var theta;\n\t\n\t    if (rotation.strValue === 'autorotate') {\n\t      theta = isEdge ? textAngle : 0;\n\t    } else if (rotation.strValue === 'none') {\n\t      theta = 0;\n\t    } else {\n\t      theta = rotation.pfValue;\n\t    }\n\t\n\t    if (theta !== 0) {\n\t      var orgTextX = textX;\n\t      var orgTextY = textY;\n\t\n\t      context.translate(orgTextX, orgTextY);\n\t      context.rotate(theta);\n\t\n\t      textX = 0;\n\t      textY = 0;\n\t    }\n\t\n\t    switch (valign) {\n\t      case 'top':\n\t        break;\n\t      case 'center':\n\t        textY += textH / 2;\n\t        break;\n\t      case 'bottom':\n\t        textY += textH;\n\t        break;\n\t    }\n\t\n\t    var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n\t    var borderOpacity = ele.pstyle('text-border-opacity').value;\n\t    var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n\t    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n\t\n\t    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n\t      var bgX = textX - backgroundPadding;\n\t\n\t      switch (halign) {\n\t        case 'left':\n\t          bgX -= textW;\n\t          break;\n\t        case 'center':\n\t          bgX -= textW / 2;\n\t          break;\n\t        case 'right':\n\t          break;\n\t      }\n\t\n\t      var bgY = textY - textH - backgroundPadding;\n\t      var bgW = textW + 2 * backgroundPadding;\n\t      var bgH = textH + 2 * backgroundPadding;\n\t\n\t      if (backgroundOpacity > 0) {\n\t        var textFill = context.fillStyle;\n\t        var textBackgroundColor = ele.pstyle('text-background-color').value;\n\t\n\t        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n\t        var styleShape = ele.pstyle('text-background-shape').strValue;\n\t        if (styleShape == 'roundrectangle') {\n\t          roundRect(context, bgX, bgY, bgW, bgH, 2);\n\t        } else {\n\t          context.fillRect(bgX, bgY, bgW, bgH);\n\t        }\n\t        context.fillStyle = textFill;\n\t      }\n\t\n\t      if (textBorderWidth > 0 && borderOpacity > 0) {\n\t        var textStroke = context.strokeStyle;\n\t        var textLineWidth = context.lineWidth;\n\t        var textBorderColor = ele.pstyle('text-border-color').value;\n\t        var textBorderStyle = ele.pstyle('text-border-style').value;\n\t\n\t        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n\t        context.lineWidth = textBorderWidth;\n\t\n\t        if (context.setLineDash) {\n\t          // for very outofdate browsers\n\t          switch (textBorderStyle) {\n\t            case 'dotted':\n\t              context.setLineDash([1, 1]);\n\t              break;\n\t            case 'dashed':\n\t              context.setLineDash([4, 2]);\n\t              break;\n\t            case 'double':\n\t              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n\t              context.setLineDash([]);\n\t              break;\n\t            case 'solid':\n\t              context.setLineDash([]);\n\t              break;\n\t          }\n\t        }\n\t\n\t        context.strokeRect(bgX, bgY, bgW, bgH);\n\t\n\t        if (textBorderStyle === 'double') {\n\t          var whiteWidth = textBorderWidth / 2;\n\t\n\t          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n\t        }\n\t\n\t        if (context.setLineDash) {\n\t          // for very outofdate browsers\n\t          context.setLineDash([]);\n\t        }\n\t        context.lineWidth = textLineWidth;\n\t        context.strokeStyle = textStroke;\n\t      }\n\t    }\n\t\n\t    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\t\n\t    if (lineWidth > 0) {\n\t      context.lineWidth = lineWidth;\n\t    }\n\t\n\t    if (ele.pstyle('text-wrap').value === 'wrap') {\n\t      var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n\t      var lineHeight = textH / lines.length;\n\t\n\t      switch (valign) {\n\t        case 'top':\n\t          textY -= (lines.length - 1) * lineHeight;\n\t          break;\n\t        case 'center':\n\t        case 'bottom':\n\t          textY -= (lines.length - 1) * lineHeight;\n\t          break;\n\t      }\n\t\n\t      for (var l = 0; l < lines.length; l++) {\n\t        if (lineWidth > 0) {\n\t          context.strokeText(lines[l], textX, textY);\n\t        }\n\t\n\t        context.fillText(lines[l], textX, textY);\n\t\n\t        textY += lineHeight;\n\t      }\n\t    } else {\n\t      if (lineWidth > 0) {\n\t        context.strokeText(text, textX, textY);\n\t      }\n\t\n\t      context.fillText(text, textX, textY);\n\t    }\n\t\n\t    if (theta !== 0) {\n\t      context.rotate(-theta);\n\t      context.translate(-orgTextX, -orgTextY);\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 106 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/* global Path2D */\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {\n\t  var r = this;\n\t  var nodeWidth = void 0,\n\t      nodeHeight = void 0;\n\t  var _p = node._private;\n\t  var rs = _p.rscratch;\n\t  var pos = node.position();\n\t\n\t  if (!is.number(pos.x) || !is.number(pos.y)) {\n\t    return; // can't draw node with undefined position\n\t  }\n\t\n\t  if (!node.visible()) {\n\t    return;\n\t  }\n\t\n\t  var parentOpacity = node.effectiveOpacity();\n\t\n\t  var usePaths = r.usePaths();\n\t  var path = void 0;\n\t  var pathCacheHit = false;\n\t\n\t  var padding = node.padding();\n\t\n\t  nodeWidth = node.width() + 2 * padding;\n\t  nodeHeight = node.height() + 2 * padding;\n\t\n\t  context.lineWidth = node.pstyle('border-width').pfValue;\n\t\n\t  //\n\t  // setup shift\n\t\n\t  var bb = void 0;\n\t  if (shiftToOriginWithBb) {\n\t    bb = shiftToOriginWithBb;\n\t\n\t    context.translate(-bb.x1, -bb.y1);\n\t  }\n\t\n\t  //\n\t  // load bg image\n\t\n\t  var bgImgProp = node.pstyle('background-image');\n\t  var urls = bgImgProp.value;\n\t  var url = void 0;\n\t  var urlDefined = [];\n\t  var image = [];\n\t  var numImages = urls.length;\n\t  for (var i = 0; i < numImages; i++) {\n\t    url = urls[i];\n\t    urlDefined[i] = url != null && url !== 'none';\n\t    if (urlDefined[i]) {\n\t      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n\t\n\t      // get image, and if not loaded then ask to redraw when later loaded\n\t      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n\t        node.emitAndNotify('background');\n\t      });\n\t    }\n\t  }\n\t\n\t  //\n\t  // setup styles\n\t\n\t  var darkness = node.pstyle('background-blacken').value;\n\t  var borderWidth = node.pstyle('border-width').pfValue;\n\t  var bgColor = node.pstyle('background-color').value;\n\t  var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;\n\t  var borderColor = node.pstyle('border-color').value;\n\t  var borderStyle = node.pstyle('border-style').value;\n\t  var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;\n\t\n\t  context.lineJoin = 'miter'; // so borders are square with the node shape\n\t\n\t  if (context.setLineDash) {\n\t    // for very outofdate browsers\n\t    switch (borderStyle) {\n\t      case 'dotted':\n\t        context.setLineDash([1, 1]);\n\t        break;\n\t\n\t      case 'dashed':\n\t        context.setLineDash([4, 2]);\n\t        break;\n\t\n\t      case 'solid':\n\t      case 'double':\n\t        context.setLineDash([]);\n\t        break;\n\t    }\n\t  }\n\t\n\t  var setupShapeColor = function setupShapeColor() {\n\t    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n\t\n\t    r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);\n\t  };\n\t\n\t  var setupBorderColor = function setupBorderColor() {\n\t    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n\t\n\t    r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n\t  };\n\t\n\t  //\n\t  // setup shape\n\t\n\t  var styleShape = node.pstyle('shape').strValue;\n\t  var shapePts = node.pstyle('shape-polygon-points').pfValue;\n\t\n\t  if (usePaths) {\n\t    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');\n\t\n\t    context.translate(pos.x, pos.y);\n\t\n\t    if (rs.pathCacheKey === pathCacheKey) {\n\t      path = rs.pathCache;\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = new Path2D();\n\t      rs.pathCacheKey = pathCacheKey;\n\t      rs.pathCache = path;\n\t    }\n\t  }\n\t\n\t  var drawShape = function drawShape() {\n\t    if (!pathCacheHit) {\n\t\n\t      var npos = pos;\n\t\n\t      if (usePaths) {\n\t        npos = {\n\t          x: 0,\n\t          y: 0\n\t        };\n\t      }\n\t\n\t      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n\t    }\n\t\n\t    if (usePaths) {\n\t      context.fill(path);\n\t    } else {\n\t      context.fill();\n\t    }\n\t  };\n\t\n\t  var drawImages = function drawImages() {\n\t    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;\n\t\n\t    var prevBging = _p.backgrounding;\n\t    var totalCompleted = 0;\n\t\n\t    for (var _i = 0; _i < numImages; _i++) {\n\t      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n\t        totalCompleted++;\n\t        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n\t      }\n\t    }\n\t\n\t    _p.backgrounding = !(totalCompleted === numImages);\n\t    if (prevBging !== _p.backgrounding) {\n\t      // update style b/c :backgrounding state changed\n\t      node.updateStyle(false);\n\t    }\n\t  };\n\t\n\t  var drawPie = function drawPie() {\n\t    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;\n\t\n\t    if (r.hasPie(node)) {\n\t      r.drawPie(context, node, pieOpacity);\n\t\n\t      // redraw/restore path if steps after pie need it\n\t      if (redrawShape) {\n\t\n\t        if (!usePaths) {\n\t          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  var darken = function darken() {\n\t    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;\n\t\n\t    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n\t    var c = darkness > 0 ? 0 : 255;\n\t\n\t    if (darkness !== 0) {\n\t      r.fillStyle(context, c, c, c, opacity);\n\t\n\t      if (usePaths) {\n\t        context.fill(path);\n\t      } else {\n\t        context.fill();\n\t      }\n\t    }\n\t  };\n\t\n\t  var drawBorder = function drawBorder() {\n\t    if (borderWidth > 0) {\n\t\n\t      if (usePaths) {\n\t        context.stroke(path);\n\t      } else {\n\t        context.stroke();\n\t      }\n\t\n\t      if (borderStyle === 'double') {\n\t        context.lineWidth = borderWidth / 3;\n\t\n\t        var gco = context.globalCompositeOperation;\n\t        context.globalCompositeOperation = 'destination-out';\n\t\n\t        if (usePaths) {\n\t          context.stroke(path);\n\t        } else {\n\t          context.stroke();\n\t        }\n\t\n\t        context.globalCompositeOperation = gco;\n\t      }\n\t    }\n\t  };\n\t\n\t  var drawOverlay = function drawOverlay() {\n\t    var overlayPadding = node.pstyle('overlay-padding').pfValue;\n\t    var overlayOpacity = node.pstyle('overlay-opacity').value;\n\t    var overlayColor = node.pstyle('overlay-color').value;\n\t\n\t    if (overlayOpacity > 0) {\n\t      r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n\t\n\t      r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);\n\t\n\t      context.fill();\n\t    }\n\t  };\n\t\n\t  var drawText = function drawText() {\n\t    r.drawElementText(context, node, drawLabel);\n\t  };\n\t\n\t  var ghost = node.pstyle('ghost').value === 'yes';\n\t\n\t  if (ghost) {\n\t    var gx = node.pstyle('ghost-offset-x').pfValue;\n\t    var gy = node.pstyle('ghost-offset-y').pfValue;\n\t    var ghostOpacity = node.pstyle('ghost-opacity').value;\n\t    var effGhostOpacity = ghostOpacity * parentOpacity;\n\t\n\t    context.translate(gx, gy);\n\t\n\t    setupShapeColor(ghostOpacity * bgOpacity);\n\t    drawShape();\n\t    drawImages(effGhostOpacity);\n\t    drawPie(darkness !== 0 || borderWidth !== 0);\n\t    darken(effGhostOpacity);\n\t    setupBorderColor(ghostOpacity * borderOpacity);\n\t    drawBorder();\n\t\n\t    context.translate(-gx, -gy);\n\t  }\n\t\n\t  setupShapeColor();\n\t  drawShape();\n\t  drawImages();\n\t  drawPie(darkness !== 0 || borderWidth !== 0);\n\t  darken();\n\t  setupBorderColor();\n\t  drawBorder();\n\t\n\t  if (usePaths) {\n\t    context.translate(-pos.x, -pos.y);\n\t  }\n\t\n\t  drawText();\n\t  drawOverlay();\n\t\n\t  // reset in case we changed the border style\n\t  if (context.setLineDash) {\n\t    // for very outofdate browsers\n\t    context.setLineDash([]);\n\t  }\n\t\n\t  //\n\t  // clean up shift\n\t\n\t  if (shiftToOriginWithBb) {\n\t    context.translate(bb.x1, bb.y1);\n\t  }\n\t};\n\t\n\t// does the node have at least one pie piece?\n\tCRp.hasPie = function (node) {\n\t  node = node[0]; // ensure ele ref\n\t\n\t  return node._private.hasPie;\n\t};\n\t\n\tCRp.drawPie = function (context, node, nodeOpacity, pos) {\n\t  node = node[0]; // ensure ele ref\n\t  pos = pos || node.position();\n\t\n\t  var cyStyle = node.cy().style();\n\t  var pieSize = node.pstyle('pie-size');\n\t  var x = pos.x;\n\t  var y = pos.y;\n\t  var nodeW = node.width();\n\t  var nodeH = node.height();\n\t  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n\t  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n\t  var usePaths = this.usePaths();\n\t\n\t  if (usePaths) {\n\t    x = 0;\n\t    y = 0;\n\t  }\n\t\n\t  if (pieSize.units === '%') {\n\t    radius = radius * pieSize.pfValue;\n\t  } else if (pieSize.pfValue !== undefined) {\n\t    radius = pieSize.pfValue / 2;\n\t  }\n\t\n\t  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n\t    // 1..N\n\t    var size = node.pstyle('pie-' + i + '-background-size').value;\n\t    var color = node.pstyle('pie-' + i + '-background-color').value;\n\t    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n\t    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n\t\n\t    // percent can't push beyond 1\n\t    if (percent + lastPercent > 1) {\n\t      percent = 1 - lastPercent;\n\t    }\n\t\n\t    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n\t    var angleDelta = 2 * Math.PI * percent;\n\t    var angleEnd = angleStart + angleDelta;\n\t\n\t    // ignore if\n\t    // - zero size\n\t    // - we're already beyond the full circle\n\t    // - adding the current slice would go beyond the full circle\n\t    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n\t      continue;\n\t    }\n\t\n\t    context.beginPath();\n\t    context.moveTo(x, y);\n\t    context.arc(x, y, radius, angleStart, angleEnd);\n\t    context.closePath();\n\t\n\t    this.fillStyle(context, color[0], color[1], color[2], opacity);\n\t\n\t    context.fill();\n\t\n\t    lastPercent += percent;\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 107 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar CRp = {};\n\t\n\tvar util = __webpack_require__(1);\n\t\n\tvar motionBlurDelay = 100;\n\t\n\t// var isFirefox = typeof InstallTrigger !== 'undefined';\n\t\n\tCRp.getPixelRatio = function () {\n\t  var context = this.data.contexts[0];\n\t\n\t  if (this.forcedPixelRatio != null) {\n\t    return this.forcedPixelRatio;\n\t  }\n\t\n\t  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n\t\n\t  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n\t};\n\t\n\tCRp.paintCache = function (context) {\n\t  var caches = this.paintCaches = this.paintCaches || [];\n\t  var needToCreateCache = true;\n\t  var cache;\n\t\n\t  for (var i = 0; i < caches.length; i++) {\n\t    cache = caches[i];\n\t\n\t    if (cache.context === context) {\n\t      needToCreateCache = false;\n\t      break;\n\t    }\n\t  }\n\t\n\t  if (needToCreateCache) {\n\t    cache = {\n\t      context: context\n\t    };\n\t    caches.push(cache);\n\t  }\n\t\n\t  return cache;\n\t};\n\t\n\tCRp.fillStyle = function (context, r, g, b, a) {\n\t  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // turn off for now, seems context does its own caching\n\t\n\t  // var cache = this.paintCache(context);\n\t\n\t  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // if( cache.fillStyle !== fillStyle ){\n\t  //   context.fillStyle = cache.fillStyle = fillStyle;\n\t  // }\n\t};\n\t\n\tCRp.strokeStyle = function (context, r, g, b, a) {\n\t  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // turn off for now, seems context does its own caching\n\t\n\t  // var cache = this.paintCache(context);\n\t\n\t  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // if( cache.strokeStyle !== strokeStyle ){\n\t  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n\t  // }\n\t};\n\t\n\t// Resize canvas\n\tCRp.matchCanvasSize = function (container) {\n\t  var r = this;\n\t  var data = r.data;\n\t  var bb = r.findContainerClientCoords();\n\t  var width = bb[2];\n\t  var height = bb[3];\n\t  var pixelRatio = r.getPixelRatio();\n\t  var mbPxRatio = r.motionBlurPxRatio;\n\t\n\t  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n\t    pixelRatio = mbPxRatio;\n\t  }\n\t\n\t  var canvasWidth = width * pixelRatio;\n\t  var canvasHeight = height * pixelRatio;\n\t  var canvas;\n\t\n\t  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n\t    return; // save cycles if same\n\t  }\n\t\n\t  r.fontCaches = null; // resizing resets the style\n\t\n\t  var canvasContainer = data.canvasContainer;\n\t  canvasContainer.style.width = width + 'px';\n\t  canvasContainer.style.height = height + 'px';\n\t\n\t  for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n\t    canvas = data.canvases[i];\n\t\n\t    canvas.width = canvasWidth;\n\t    canvas.height = canvasHeight;\n\t\n\t    canvas.style.width = width + 'px';\n\t    canvas.style.height = height + 'px';\n\t  }\n\t\n\t  for (var i = 0; i < r.BUFFER_COUNT; i++) {\n\t    canvas = data.bufferCanvases[i];\n\t\n\t    canvas.width = canvasWidth;\n\t    canvas.height = canvasHeight;\n\t\n\t    canvas.style.width = width + 'px';\n\t    canvas.style.height = height + 'px';\n\t  }\n\t\n\t  r.textureMult = 1;\n\t  if (pixelRatio <= 1) {\n\t    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n\t\n\t    r.textureMult = 2;\n\t    canvas.width = canvasWidth * r.textureMult;\n\t    canvas.height = canvasHeight * r.textureMult;\n\t  }\n\t\n\t  r.canvasWidth = canvasWidth;\n\t  r.canvasHeight = canvasHeight;\n\t};\n\t\n\tCRp.renderTo = function (cxt, zoom, pan, pxRatio) {\n\t  this.render({\n\t    forcedContext: cxt,\n\t    forcedZoom: zoom,\n\t    forcedPan: pan,\n\t    drawAllLayers: true,\n\t    forcedPxRatio: pxRatio\n\t  });\n\t};\n\t\n\tCRp.render = function (options) {\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var forcedContext = options.forcedContext;\n\t  var drawAllLayers = options.drawAllLayers;\n\t  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n\t  var forcedZoom = options.forcedZoom;\n\t  var forcedPan = options.forcedPan;\n\t  var r = this;\n\t  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n\t  var cy = r.cy;var data = r.data;\n\t  var needDraw = data.canvasNeedsRedraw;\n\t  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n\t  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n\t  var mbPxRatio = r.motionBlurPxRatio;\n\t  var hasCompoundNodes = cy.hasCompoundNodes();\n\t  var inNodeDragGesture = r.hoverData.draggingEles;\n\t  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n\t  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n\t  var motionBlurFadeEffect = motionBlur;\n\t\n\t  if (!forcedContext) {\n\t    if (r.prevPxRatio !== pixelRatio) {\n\t      r.invalidateContainerClientCoordsCache();\n\t      r.matchCanvasSize(r.container);\n\t\n\t      r.redrawHint('eles', true);\n\t      r.redrawHint('drag', true);\n\t    }\n\t\n\t    r.prevPxRatio = pixelRatio;\n\t  }\n\t\n\t  if (!forcedContext && r.motionBlurTimeout) {\n\t    clearTimeout(r.motionBlurTimeout);\n\t  }\n\t\n\t  if (motionBlur) {\n\t    if (r.mbFrames == null) {\n\t      r.mbFrames = 0;\n\t    }\n\t\n\t    r.mbFrames++;\n\t\n\t    if (r.mbFrames < 3) {\n\t      // need several frames before even high quality motionblur\n\t      motionBlurFadeEffect = false;\n\t    }\n\t\n\t    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n\t    if (r.mbFrames > r.minMbLowQualFrames) {\n\t      //r.fullQualityMb = false;\n\t      r.motionBlurPxRatio = r.mbPxRBlurry;\n\t    }\n\t  }\n\t\n\t  if (r.clearingMotionBlur) {\n\t    r.motionBlurPxRatio = 1;\n\t  }\n\t\n\t  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n\t  // because a rogue async texture frame would clear needDraw\n\t  if (r.textureDrawLastFrame && !textureDraw) {\n\t    needDraw[r.NODE] = true;\n\t    needDraw[r.SELECT_BOX] = true;\n\t  }\n\t\n\t  var coreStyle = cy.style()._private.coreStyle;\n\t\n\t  var zoom = cy.zoom();\n\t  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n\t  var pan = cy.pan();\n\t  var effectivePan = {\n\t    x: pan.x,\n\t    y: pan.y\n\t  };\n\t\n\t  var vp = {\n\t    zoom: zoom,\n\t    pan: {\n\t      x: pan.x,\n\t      y: pan.y\n\t    }\n\t  };\n\t  var prevVp = r.prevViewport;\n\t  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n\t\n\t  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n\t  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n\t    r.motionBlurPxRatio = 1;\n\t  }\n\t\n\t  if (forcedPan) {\n\t    effectivePan = forcedPan;\n\t  }\n\t\n\t  // apply pixel ratio\n\t\n\t  effectiveZoom *= pixelRatio;\n\t  effectivePan.x *= pixelRatio;\n\t  effectivePan.y *= pixelRatio;\n\t\n\t  var eles = r.getCachedZSortedEles();\n\t\n\t  function mbclear(context, x, y, w, h) {\n\t    var gco = context.globalCompositeOperation;\n\t\n\t    context.globalCompositeOperation = 'destination-out';\n\t    r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n\t    context.fillRect(x, y, w, h);\n\t\n\t    context.globalCompositeOperation = gco;\n\t  }\n\t\n\t  function setContextTransform(context, clear) {\n\t    var ePan, eZoom, w, h;\n\t\n\t    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n\t      ePan = {\n\t        x: pan.x * mbPxRatio,\n\t        y: pan.y * mbPxRatio\n\t      };\n\t\n\t      eZoom = zoom * mbPxRatio;\n\t\n\t      w = r.canvasWidth * mbPxRatio;\n\t      h = r.canvasHeight * mbPxRatio;\n\t    } else {\n\t      ePan = effectivePan;\n\t      eZoom = effectiveZoom;\n\t\n\t      w = r.canvasWidth;\n\t      h = r.canvasHeight;\n\t    }\n\t\n\t    context.setTransform(1, 0, 0, 1, 0, 0);\n\t\n\t    if (clear === 'motionBlur') {\n\t      mbclear(context, 0, 0, w, h);\n\t    } else if (!forcedContext && (clear === undefined || clear)) {\n\t      context.clearRect(0, 0, w, h);\n\t    }\n\t\n\t    if (!drawAllLayers) {\n\t      context.translate(ePan.x, ePan.y);\n\t      context.scale(eZoom, eZoom);\n\t    }\n\t    if (forcedPan) {\n\t      context.translate(forcedPan.x, forcedPan.y);\n\t    }\n\t    if (forcedZoom) {\n\t      context.scale(forcedZoom, forcedZoom);\n\t    }\n\t  }\n\t\n\t  if (!textureDraw) {\n\t    r.textureDrawLastFrame = false;\n\t  }\n\t\n\t  if (textureDraw) {\n\t    r.textureDrawLastFrame = true;\n\t\n\t    var bb;\n\t\n\t    if (!r.textureCache) {\n\t      r.textureCache = {};\n\t\n\t      bb = r.textureCache.bb = cy.mutableElements().boundingBox();\n\t\n\t      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n\t\n\t      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n\t\n\t      cxt.setTransform(1, 0, 0, 1, 0, 0);\n\t      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n\t\n\t      r.render({\n\t        forcedContext: cxt,\n\t        drawOnlyNodeLayer: true,\n\t        forcedPxRatio: pixelRatio * r.textureMult\n\t      });\n\t\n\t      var vp = r.textureCache.viewport = {\n\t        zoom: cy.zoom(),\n\t        pan: cy.pan(),\n\t        width: r.canvasWidth,\n\t        height: r.canvasHeight\n\t      };\n\t\n\t      vp.mpan = {\n\t        x: (0 - vp.pan.x) / vp.zoom,\n\t        y: (0 - vp.pan.y) / vp.zoom\n\t      };\n\t    }\n\t\n\t    needDraw[r.DRAG] = false;\n\t    needDraw[r.NODE] = false;\n\t\n\t    var context = data.contexts[r.NODE];\n\t\n\t    var texture = r.textureCache.texture;\n\t    var vp = r.textureCache.viewport;\n\t    bb = r.textureCache.bb;\n\t\n\t    context.setTransform(1, 0, 0, 1, 0, 0);\n\t\n\t    if (motionBlur) {\n\t      mbclear(context, 0, 0, vp.width, vp.height);\n\t    } else {\n\t      context.clearRect(0, 0, vp.width, vp.height);\n\t    }\n\t\n\t    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;\n\t    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;\n\t    r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n\t    context.fillRect(0, 0, vp.width, vp.height);\n\t\n\t    var zoom = cy.zoom();\n\t\n\t    setContextTransform(context, false);\n\t\n\t    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n\t    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n\t  } else if (r.textureOnViewport && !forcedContext) {\n\t    // clear the cache since we don't need it\n\t    r.textureCache = null;\n\t  }\n\t\n\t  var extent = cy.extent();\n\t  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;\n\t  var hideEdges = r.hideEdgesOnViewport && vpManip;\n\t\n\t  var needMbClear = [];\n\t\n\t  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n\t  if (needMbClear[r.NODE]) {\n\t    r.clearedForMotionBlur[r.NODE] = true;\n\t  }\n\t\n\t  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n\t  if (needMbClear[r.DRAG]) {\n\t    r.clearedForMotionBlur[r.DRAG] = true;\n\t  }\n\t\n\t  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n\t    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n\t    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n\t    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n\t\n\t    setContextTransform(context, clear);\n\t\n\t    if (hideEdges) {\n\t      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n\t    } else {\n\t      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n\t    }\n\t\n\t    if (r.debug) {\n\t      r.drawDebugPoints(context, eles.nondrag);\n\t    }\n\t\n\t    if (!drawAllLayers && !motionBlur) {\n\t      needDraw[r.NODE] = false;\n\t    }\n\t  }\n\t\n\t  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n\t    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n\t    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n\t\n\t    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n\t\n\t    if (hideEdges) {\n\t      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n\t    } else {\n\t      r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n\t    }\n\t\n\t    if (r.debug) {\n\t      r.drawDebugPoints(context, eles.drag);\n\t    }\n\t\n\t    if (!drawAllLayers && !motionBlur) {\n\t      needDraw[r.DRAG] = false;\n\t    }\n\t  }\n\t\n\t  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n\t    var context = forcedContext || data.contexts[r.SELECT_BOX];\n\t\n\t    setContextTransform(context);\n\t\n\t    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n\t      var zoom = r.cy.zoom();\n\t      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;\n\t\n\t      context.lineWidth = borderWidth;\n\t      context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';\n\t\n\t      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\t\n\t      if (borderWidth > 0) {\n\t        context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';\n\t\n\t        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\t      }\n\t    }\n\t\n\t    if (data.bgActivePosistion && !r.hoverData.selecting) {\n\t      var zoom = r.cy.zoom();\n\t      var pos = data.bgActivePosistion;\n\t\n\t      context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';\n\t\n\t      context.beginPath();\n\t      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);\n\t      context.fill();\n\t    }\n\t\n\t    var timeToRender = r.lastRedrawTime;\n\t    if (r.showFps && timeToRender) {\n\t      timeToRender = Math.round(timeToRender);\n\t      var fps = Math.round(1000 / timeToRender);\n\t\n\t      context.setTransform(1, 0, 0, 1, 0, 0);\n\t\n\t      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n\t      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n\t      context.lineWidth = 1;\n\t      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n\t\n\t      var maxFps = 60;\n\t      context.strokeRect(0, 30, 250, 20);\n\t      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n\t    }\n\t\n\t    if (!drawAllLayers) {\n\t      needDraw[r.SELECT_BOX] = false;\n\t    }\n\t  }\n\t\n\t  // motionblur: blit rendered blurry frames\n\t  if (motionBlur && mbPxRatio !== 1) {\n\t    var cxtNode = data.contexts[r.NODE];\n\t    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n\t\n\t    var cxtDrag = data.contexts[r.DRAG];\n\t    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n\t\n\t    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n\t      cxt.setTransform(1, 0, 0, 1, 0, 0);\n\t\n\t      if (needClear || !motionBlurFadeEffect) {\n\t        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n\t      } else {\n\t        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n\t      }\n\t\n\t      var pxr = mbPxRatio;\n\t\n\t      cxt.drawImage(txt, // img\n\t      0, 0, // sx, sy\n\t      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n\t      0, 0, // x, y\n\t      r.canvasWidth, r.canvasHeight // w, h\n\t      );\n\t    };\n\t\n\t    if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n\t      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n\t      needDraw[r.NODE] = false;\n\t    }\n\t\n\t    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n\t      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n\t      needDraw[r.DRAG] = false;\n\t    }\n\t  }\n\t\n\t  r.prevViewport = vp;\n\t\n\t  if (r.clearingMotionBlur) {\n\t    r.clearingMotionBlur = false;\n\t    r.motionBlurCleared = true;\n\t    r.motionBlur = true;\n\t  }\n\t\n\t  if (motionBlur) {\n\t    r.motionBlurTimeout = setTimeout(function () {\n\t      r.motionBlurTimeout = null;\n\t\n\t      r.clearedForMotionBlur[r.NODE] = false;\n\t      r.clearedForMotionBlur[r.DRAG] = false;\n\t      r.motionBlur = false;\n\t      r.clearingMotionBlur = !textureDraw;\n\t      r.mbFrames = 0;\n\t\n\t      needDraw[r.NODE] = true;\n\t      needDraw[r.DRAG] = true;\n\t\n\t      r.redraw();\n\t    }, motionBlurDelay);\n\t  }\n\t\n\t  if (!forcedContext) {\n\t    cy.emit('render');\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 108 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\t\n\tvar CRp = {};\n\t\n\t// @O Polygon drawing\n\tCRp.drawPolygonPath = function (context, x, y, width, height, points) {\n\t\n\t  var halfW = width / 2;\n\t  var halfH = height / 2;\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n\t\n\t  for (var i = 1; i < points.length / 2; i++) {\n\t    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n\t  }\n\t\n\t  context.closePath();\n\t};\n\t\n\t// Round rectangle drawing\n\tCRp.drawRoundRectanglePath = function (context, x, y, width, height) {\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t  var cornerRadius = math.getRoundRectangleRadius(width, height);\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  // Start at top middle\n\t  context.moveTo(x, y - halfHeight);\n\t  // Arc from middle top to right side\n\t  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n\t  // Arc from right side to bottom\n\t  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n\t  // Arc from bottom to left side\n\t  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n\t  // Arc from left side to topBorder\n\t  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n\t  // Join line\n\t  context.lineTo(x, y - halfHeight);\n\t\n\t  context.closePath();\n\t};\n\t\n\tCRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t  var cornerRadius = math.getRoundRectangleRadius(width, height);\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  // Start at top middle\n\t  context.moveTo(x, y - halfHeight);\n\t  context.lineTo(x + halfWidth, y - halfHeight);\n\t  context.lineTo(x + halfWidth, y);\n\t\n\t  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n\t  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n\t\n\t  context.lineTo(x - halfWidth, y - halfHeight);\n\t  context.lineTo(x, y - halfHeight);\n\t\n\t  context.closePath();\n\t};\n\t\n\tCRp.drawCutRectanglePath = function (context, x, y, width, height) {\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t  var cornerLength = math.getCutRectangleCornerLength();\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n\t\n\t  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n\t  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n\t  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n\t  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n\t  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n\t  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n\t  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n\t\n\t  context.closePath();\n\t};\n\t\n\tCRp.drawBarrelPath = function (context, x, y, width, height) {\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t\n\t  var xBegin = x - halfWidth;\n\t  var xEnd = x + halfWidth;\n\t  var yBegin = y - halfHeight;\n\t  var yEnd = y + halfHeight;\n\t\n\t  var barrelCurveConstants = math.getBarrelCurveConstants(width, height);\n\t  var wOffset = barrelCurveConstants.widthOffset;\n\t  var hOffset = barrelCurveConstants.heightOffset;\n\t  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n\t\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  context.moveTo(xBegin, yBegin + hOffset);\n\t\n\t  context.lineTo(xBegin, yEnd - hOffset);\n\t  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n\t\n\t  context.lineTo(xEnd - wOffset, yEnd);\n\t  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n\t\n\t  context.lineTo(xEnd, yBegin + hOffset);\n\t  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n\t\n\t  context.lineTo(xBegin + wOffset, yBegin);\n\t  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n\t\n\t  context.closePath();\n\t};\n\t\n\tvar sin0 = Math.sin(0);\n\tvar cos0 = Math.cos(0);\n\t\n\tvar sin = {};\n\tvar cos = {};\n\t\n\tvar ellipseStepSize = Math.PI / 40;\n\t\n\tfor (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n\t  sin[i] = Math.sin(i);\n\t  cos[i] = Math.cos(i);\n\t}\n\t\n\tCRp.drawEllipsePath = function (context, centerX, centerY, width, height) {\n\t  if (context.beginPath) {\n\t    context.beginPath();\n\t  }\n\t\n\t  if (context.ellipse) {\n\t    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n\t  } else {\n\t    var xPos, yPos;\n\t    var rw = width / 2;\n\t    var rh = height / 2;\n\t    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n\t      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n\t      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n\t\n\t      if (i === 0) {\n\t        context.moveTo(xPos, yPos);\n\t      } else {\n\t        context.lineTo(xPos, yPos);\n\t      }\n\t    }\n\t  }\n\t\n\t  context.closePath();\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 109 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar math = __webpack_require__(2);\n\tvar util = __webpack_require__(1);\n\tvar Heap = __webpack_require__(8);\n\tvar defs = __webpack_require__(16);\n\t\n\tvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\n\tvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n\tvar minLvl = -4; // when scaling smaller than that we don't need to re-render\n\tvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\tvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\tvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n\tvar defTxrWidth = 1024; // default/minimum texture width\n\tvar maxTxrW = 1024; // the maximum width of a texture\n\tvar maxTxrH = 1024; // the maximum height of a texture\n\tvar minUtility = 0.5; // if usage of texture is less than this, it is retired\n\tvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\n\tvar maxFullnessChecks = 10; // dequeued after this many checks\n\tvar allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)\n\tvar allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)\n\tvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\tvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\tvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\tvar deqFastCost = 0.9; // % of frame time to be used when >60fps\n\tvar deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\tvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\t\n\tvar getTxrReasons = {\n\t  dequeue: 'dequeue',\n\t  downscale: 'downscale',\n\t  highQuality: 'highQuality'\n\t};\n\t\n\tvar ElementTextureCache = function ElementTextureCache(renderer) {\n\t  var self = this;\n\t\n\t  self.renderer = renderer;\n\t  self.onDequeues = [];\n\t\n\t  self.setupDequeueing();\n\t};\n\t\n\tvar ETCp = ElementTextureCache.prototype;\n\t\n\tETCp.reasons = getTxrReasons;\n\t\n\t// the list of textures in which new subtextures for elements can be placed\n\tETCp.getTextureQueue = function (txrH) {\n\t  var self = this;\n\t  self.eleImgCaches = self.eleImgCaches || {};\n\t\n\t  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n\t};\n\t\n\t// the list of usused textures which can be recycled (in use in texture queue)\n\tETCp.getRetiredTextureQueue = function (txrH) {\n\t  var self = this;\n\t\n\t  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n\t  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n\t\n\t  return rtxtrQ;\n\t};\n\t\n\t// queue of element draw requests at different scale levels\n\tETCp.getElementQueue = function () {\n\t  var self = this;\n\t\n\t  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {\n\t    return b.reqs - a.reqs;\n\t  });\n\t\n\t  return q;\n\t};\n\t\n\t// queue of element draw requests at different scale levels (element id lookup)\n\tETCp.getElementIdToQueue = function () {\n\t  var self = this;\n\t\n\t  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};\n\t\n\t  return id2q;\n\t};\n\t\n\tETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n\t  var self = this;\n\t  var r = this.renderer;\n\t  var rs = ele._private.rscratch;\n\t  var zoom = r.cy.zoom();\n\t\n\t  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n\t    return null;\n\t  }\n\t\n\t  if (lvl == null) {\n\t    lvl = Math.ceil(math.log2(zoom * pxRatio));\n\t  }\n\t\n\t  if (lvl < minLvl) {\n\t    lvl = minLvl;\n\t  } else if (zoom >= maxZoom || lvl > maxLvl) {\n\t    return null;\n\t  }\n\t\n\t  var scale = Math.pow(2, lvl);\n\t  var eleScaledH = bb.h * scale;\n\t  var eleScaledW = bb.w * scale;\n\t  var caches = rs.imgCaches = rs.imgCaches || {};\n\t  var eleCache = caches[lvl];\n\t\n\t  if (eleCache) {\n\t    return eleCache;\n\t  }\n\t\n\t  var txrH; // which texture height this ele belongs to\n\t\n\t  if (eleScaledH <= minTxrH) {\n\t    txrH = minTxrH;\n\t  } else if (eleScaledH <= txrStepH) {\n\t    txrH = txrStepH;\n\t  } else {\n\t    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n\t  }\n\t\n\t  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {\n\t    return null; // caching large elements is not efficient\n\t  }\n\t\n\t  var txrQ = self.getTextureQueue(txrH);\n\t\n\t  // first try the second last one in case it has space at the end\n\t  var txr = txrQ[txrQ.length - 2];\n\t\n\t  var addNewTxr = function addNewTxr() {\n\t    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n\t  };\n\t\n\t  // try the last one if there is no second last one\n\t  if (!txr) {\n\t    txr = txrQ[txrQ.length - 1];\n\t  }\n\t\n\t  // if the last one doesn't exist, we need a first one\n\t  if (!txr) {\n\t    txr = addNewTxr();\n\t  }\n\t\n\t  // if there's no room in the current texture, we need a new one\n\t  if (txr.width - txr.usedWidth < eleScaledW) {\n\t    txr = addNewTxr();\n\t  }\n\t\n\t  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n\t  var scalableFrom = function scalableFrom(otherCache) {\n\t    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n\t  };\n\t\n\t  var deqing = reason && reason === getTxrReasons.dequeue;\n\t  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n\t  var downscaleReq = reason && reason === getTxrReasons.downscale;\n\t\n\t  var higherCache; // the nearest cache with a higher level\n\t  for (var l = lvl + 1; l <= maxLvl; l++) {\n\t    var c = caches[l];\n\t\n\t    if (c) {\n\t      higherCache = c;break;\n\t    }\n\t  }\n\t\n\t  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\t\n\t  var downscale = function downscale() {\n\t    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n\t  };\n\t\n\t  // reset ele area in texture\n\t  txr.context.setTransform(1, 0, 0, 1, 0, 0);\n\t  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n\t\n\t  if (scalableFrom(oneUpCache)) {\n\t    // then we can relatively cheaply rescale the existing image w/o rerendering\n\t    downscale();\n\t  } else if (scalableFrom(higherCache)) {\n\t    // then use the higher cache for now and queue the next level down\n\t    // to cheaply scale towards the smaller level\n\t\n\t    if (highQualityReq) {\n\t      for (var l = higherCache.level; l > lvl; l--) {\n\t        oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);\n\t      }\n\t\n\t      downscale();\n\t    } else {\n\t      self.queueElement(ele, bb, higherCache.level - 1);\n\t\n\t      return higherCache;\n\t    }\n\t  } else {\n\t\n\t    var lowerCache; // the nearest cache with a lower level\n\t    if (!deqing && !highQualityReq && !downscaleReq) {\n\t      for (var l = lvl - 1; l >= minLvl; l--) {\n\t        var c = caches[l];\n\t\n\t        if (c) {\n\t          lowerCache = c;break;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (scalableFrom(lowerCache)) {\n\t      // then use the lower quality cache for now and queue the better one for later\n\t\n\t      self.queueElement(ele, bb, lvl);\n\t\n\t      return lowerCache;\n\t    }\n\t\n\t    txr.context.translate(txr.usedWidth, 0);\n\t    txr.context.scale(scale, scale);\n\t\n\t    r.drawElement(txr.context, ele, bb, scaledLabelShown);\n\t\n\t    txr.context.scale(1 / scale, 1 / scale);\n\t    txr.context.translate(-txr.usedWidth, 0);\n\t  }\n\t\n\t  eleCache = caches[lvl] = {\n\t    ele: ele,\n\t    x: txr.usedWidth,\n\t    texture: txr,\n\t    level: lvl,\n\t    scale: scale,\n\t    width: eleScaledW,\n\t    height: eleScaledH,\n\t    scaledLabelShown: scaledLabelShown\n\t  };\n\t\n\t  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n\t\n\t  txr.eleCaches.push(eleCache);\n\t\n\t  self.checkTextureFullness(txr);\n\t\n\t  return eleCache;\n\t};\n\t\n\tETCp.invalidateElement = function (ele) {\n\t  var self = this;\n\t  var caches = ele._private.rscratch.imgCaches;\n\t\n\t  if (caches) {\n\t    for (var lvl = minLvl; lvl <= maxLvl; lvl++) {\n\t      var cache = caches[lvl];\n\t\n\t      if (cache) {\n\t        var txr = cache.texture;\n\t\n\t        // remove space from the texture it belongs to\n\t        txr.invalidatedWidth += cache.width;\n\t\n\t        // remove refs with the element\n\t        caches[lvl] = null;\n\t        util.removeFromArray(txr.eleCaches, cache);\n\t\n\t        // might have to remove the entire texture if it's not efficiently using its space\n\t        self.checkTextureUtility(txr);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tETCp.checkTextureUtility = function (txr) {\n\t  // invalidate all entries in the cache if the cache size is small\n\t  if (txr.invalidatedWidth >= minUtility * txr.width) {\n\t    this.retireTexture(txr);\n\t  }\n\t};\n\t\n\tETCp.checkTextureFullness = function (txr) {\n\t  // if texture has been mostly filled and passed over several times, remove\n\t  // it from the queue so we don't need to waste time looking at it to put new things\n\t\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue(txr.height);\n\t\n\t  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n\t    util.removeFromArray(txrQ, txr);\n\t  } else {\n\t    txr.fullnessChecks++;\n\t  }\n\t};\n\t\n\tETCp.retireTexture = function (txr) {\n\t  var self = this;\n\t  var txrH = txr.height;\n\t  var txrQ = self.getTextureQueue(txrH);\n\t\n\t  // retire the texture from the active / searchable queue:\n\t\n\t  util.removeFromArray(txrQ, txr);\n\t\n\t  txr.retired = true;\n\t\n\t  // remove the refs from the eles to the caches:\n\t\n\t  var eleCaches = txr.eleCaches;\n\t\n\t  for (var i = 0; i < eleCaches.length; i++) {\n\t    var eleCache = eleCaches[i];\n\t    var ele = eleCache.ele;\n\t    var lvl = eleCache.level;\n\t    var imgCaches = ele._private.rscratch.imgCaches;\n\t\n\t    if (imgCaches) {\n\t      imgCaches[lvl] = null;\n\t    }\n\t  }\n\t\n\t  util.clearArray(eleCaches);\n\t\n\t  // add the texture to a retired queue so it can be recycled in future:\n\t\n\t  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\t\n\t  rtxtrQ.push(txr);\n\t};\n\t\n\tETCp.addTexture = function (txrH, minW) {\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue(txrH);\n\t  var txr = {};\n\t\n\t  txrQ.push(txr);\n\t\n\t  txr.eleCaches = [];\n\t\n\t  txr.height = txrH;\n\t  txr.width = Math.max(defTxrWidth, minW);\n\t  txr.usedWidth = 0;\n\t  txr.invalidatedWidth = 0;\n\t  txr.fullnessChecks = 0;\n\t\n\t  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\t  txr.canvas.width = txr.width;\n\t  txr.canvas.height = txr.height;\n\t\n\t  txr.context = txr.canvas.getContext('2d');\n\t\n\t  return txr;\n\t};\n\t\n\tETCp.recycleTexture = function (txrH, minW) {\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue(txrH);\n\t  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\t\n\t  for (var i = 0; i < rtxtrQ.length; i++) {\n\t    var txr = rtxtrQ[i];\n\t\n\t    if (txr.width >= minW) {\n\t      txr.retired = false;\n\t\n\t      txr.usedWidth = 0;\n\t      txr.invalidatedWidth = 0;\n\t      txr.fullnessChecks = 0;\n\t\n\t      util.clearArray(txr.eleCaches);\n\t\n\t      txr.context.setTransform(1, 0, 0, 1, 0, 0);\n\t      txr.context.clearRect(0, 0, txr.width, txr.height);\n\t\n\t      util.removeFromArray(rtxtrQ, txr);\n\t      txrQ.push(txr);\n\t\n\t      return txr;\n\t    }\n\t  }\n\t};\n\t\n\tETCp.queueElement = function (ele, bb, lvl) {\n\t  var self = this;\n\t  var q = self.getElementQueue();\n\t  var id2q = self.getElementIdToQueue();\n\t  var id = ele.id();\n\t  var existingReq = id2q[id];\n\t\n\t  if (existingReq) {\n\t    // use the max lvl b/c in between lvls are cheap to make\n\t    existingReq.level = Math.max(existingReq.level, lvl);\n\t    existingReq.reqs++;\n\t\n\t    q.updateItem(existingReq);\n\t  } else {\n\t    var req = {\n\t      ele: ele,\n\t      bb: bb,\n\t      position: math.copyPosition(ele.position()),\n\t      level: lvl,\n\t      reqs: 1\n\t    };\n\t\n\t    if (ele.isEdge()) {\n\t      req.positions = {\n\t        source: math.copyPosition(ele.source().position()),\n\t        target: math.copyPosition(ele.target().position())\n\t      };\n\t    }\n\t\n\t    q.push(req);\n\t\n\t    id2q[id] = req;\n\t  }\n\t};\n\t\n\tETCp.dequeue = function (pxRatio /*, extent*/) {\n\t  var self = this;\n\t  var q = self.getElementQueue();\n\t  var id2q = self.getElementIdToQueue();\n\t  var dequeued = [];\n\t\n\t  for (var i = 0; i < maxDeqSize; i++) {\n\t    if (q.size() > 0) {\n\t      var req = q.pop();\n\t\n\t      id2q[req.ele.id()] = null;\n\t\n\t      dequeued.push(req);\n\t\n\t      var ele = req.ele;\n\t      var bb;\n\t\n\t      if (ele.isEdge() && (!math.arePositionsSame(ele.source().position(), req.positions.source) || !math.arePositionsSame(ele.target().position(), req.positions.target)) || !math.arePositionsSame(ele.position(), req.position)) {\n\t        bb = ele.boundingBox();\n\t      } else {\n\t        bb = req.bb;\n\t      }\n\t\n\t      self.getElement(req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\t\n\t  return dequeued;\n\t};\n\t\n\tETCp.onDequeue = function (fn) {\n\t  this.onDequeues.push(fn);\n\t};\n\tETCp.offDequeue = function (fn) {\n\t  util.removeFromArray(this.onDequeues, fn);\n\t};\n\t\n\tETCp.setupDequeueing = defs.setupDequeueing({\n\t  deqRedrawThreshold: deqRedrawThreshold,\n\t  deqCost: deqCost,\n\t  deqAvgCost: deqAvgCost,\n\t  deqNoDrawCost: deqNoDrawCost,\n\t  deqFastCost: deqFastCost,\n\t  deq: function deq(self, pxRatio, extent) {\n\t    return self.dequeue(pxRatio, extent);\n\t  },\n\t  onDeqd: function onDeqd(self, deqd) {\n\t    for (var i = 0; i < self.onDequeues.length; i++) {\n\t      var fn = self.onDequeues[i];\n\t\n\t      fn(deqd);\n\t    }\n\t  },\n\t  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n\t    for (var i = 0; i < deqd.length; i++) {\n\t      var bb = deqd[i].bb;\n\t\n\t      if (math.boundingBoxesIntersect(bb, extent)) {\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t  priority: function priority(self) {\n\t    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n\t  }\n\t});\n\t\n\tmodule.exports = ElementTextureCache;\n\t\n\t/***/ }),\n\t/* 110 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tvar CRp = {};\n\t\n\tCRp.createBuffer = function (w, h) {\n\t  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n\t  buffer.width = w;\n\t  buffer.height = h;\n\t\n\t  return [buffer, buffer.getContext('2d')];\n\t};\n\t\n\tCRp.bufferCanvasImage = function (options) {\n\t  var cy = this.cy;\n\t  var eles = cy.mutableElements();\n\t  var bb = eles.boundingBox();\n\t  var ctrRect = this.findContainerClientCoords();\n\t  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n\t  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n\t  var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);\n\t  var pxRatio = this.getPixelRatio();\n\t  var scale = 1;\n\t\n\t  if (options.scale !== undefined) {\n\t    width *= options.scale;\n\t    height *= options.scale;\n\t\n\t    scale = options.scale;\n\t  } else if (specdMaxDims) {\n\t    var maxScaleW = Infinity;\n\t    var maxScaleH = Infinity;\n\t\n\t    if (is.number(options.maxWidth)) {\n\t      maxScaleW = scale * options.maxWidth / width;\n\t    }\n\t\n\t    if (is.number(options.maxHeight)) {\n\t      maxScaleH = scale * options.maxHeight / height;\n\t    }\n\t\n\t    scale = Math.min(maxScaleW, maxScaleH);\n\t\n\t    width *= scale;\n\t    height *= scale;\n\t  }\n\t\n\t  if (!specdMaxDims) {\n\t    width *= pxRatio;\n\t    height *= pxRatio;\n\t    scale *= pxRatio;\n\t  }\n\t\n\t  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\t\n\t  buffCanvas.width = width;\n\t  buffCanvas.height = height;\n\t\n\t  buffCanvas.style.width = width + 'px';\n\t  buffCanvas.style.height = height + 'px';\n\t\n\t  var buffCxt = buffCanvas.getContext('2d');\n\t\n\t  // Rasterize the layers, but only if container has nonzero size\n\t  if (width > 0 && height > 0) {\n\t\n\t    buffCxt.clearRect(0, 0, width, height);\n\t\n\t    buffCxt.globalCompositeOperation = 'source-over';\n\t\n\t    var zsortedEles = this.getCachedZSortedEles();\n\t\n\t    if (options.full) {\n\t      // draw the full bounds of the graph\n\t      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n\t      buffCxt.scale(scale, scale);\n\t\n\t      this.drawElements(buffCxt, zsortedEles);\n\t\n\t      buffCxt.scale(1 / scale, 1 / scale);\n\t      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n\t    } else {\n\t      // draw the current view\n\t      var pan = cy.pan();\n\t\n\t      var translation = {\n\t        x: pan.x * scale,\n\t        y: pan.y * scale\n\t      };\n\t\n\t      scale *= cy.zoom();\n\t\n\t      buffCxt.translate(translation.x, translation.y);\n\t      buffCxt.scale(scale, scale);\n\t\n\t      this.drawElements(buffCxt, zsortedEles);\n\t\n\t      buffCxt.scale(1 / scale, 1 / scale);\n\t      buffCxt.translate(-translation.x, -translation.y);\n\t    }\n\t\n\t    // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n\t    if (options.bg) {\n\t      buffCxt.globalCompositeOperation = 'destination-over';\n\t\n\t      buffCxt.fillStyle = options.bg;\n\t      buffCxt.rect(0, 0, width, height);\n\t      buffCxt.fill();\n\t    }\n\t  }\n\t\n\t  return buffCanvas;\n\t};\n\t\n\tfunction b64ToBlob(b64, mimeType) {\n\t  var bytes = atob(b64);\n\t  var buff = new ArrayBuffer(bytes.length);\n\t  var buffUint8 = new Uint8Array(buff);\n\t\n\t  for (var i = 0; i < bytes.length; i++) {\n\t    buffUint8[i] = bytes.charCodeAt(i);\n\t  }\n\t\n\t  return new Blob([buff], { type: mimeType });\n\t}\n\t\n\tfunction b64UriToB64(b64uri) {\n\t  var i = b64uri.indexOf(',');\n\t\n\t  return b64uri.substr(i + 1);\n\t};\n\t\n\tfunction output(options, canvas, mimeType) {\n\t  var b64Uri = canvas.toDataURL(mimeType, options.quality);\n\t\n\t  switch (options.output) {\n\t    case 'blob':\n\t      return b64ToBlob(b64UriToB64(b64Uri), mimeType);\n\t\n\t    case 'base64':\n\t      return b64UriToB64(b64Uri);\n\t\n\t    case 'base64uri':\n\t    default:\n\t      return b64Uri;\n\t  }\n\t}\n\t\n\tCRp.png = function (options) {\n\t  return output(options, this.bufferCanvasImage(options), 'image/png');\n\t};\n\t\n\tCRp.jpg = function (options) {\n\t  return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 111 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\t/*\n\tThe canvas renderer was written by Yue Dong.\n\t\n\tModifications tracked on Github.\n\t*/\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar ElementTextureCache = __webpack_require__(109);\n\tvar LayeredTextureCache = __webpack_require__(112);\n\t\n\tvar CR = CanvasRenderer;\n\tvar CRp = CanvasRenderer.prototype;\n\t\n\tCRp.CANVAS_LAYERS = 3;\n\t//\n\tCRp.SELECT_BOX = 0;\n\tCRp.DRAG = 1;\n\tCRp.NODE = 2;\n\t\n\tCRp.BUFFER_COUNT = 3;\n\t//\n\tCRp.TEXTURE_BUFFER = 0;\n\tCRp.MOTIONBLUR_BUFFER_NODE = 1;\n\tCRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\t\n\tfunction CanvasRenderer(options) {\n\t  var r = this;\n\t\n\t  r.data = {\n\t    canvases: new Array(CRp.CANVAS_LAYERS),\n\t    contexts: new Array(CRp.CANVAS_LAYERS),\n\t    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n\t\n\t    bufferCanvases: new Array(CRp.BUFFER_COUNT),\n\t    bufferContexts: new Array(CRp.CANVAS_LAYERS)\n\t  };\n\t\n\t  var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';\n\t\n\t  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n\t  var containerStyle = r.data.canvasContainer.style;\n\t  r.data.canvasContainer.setAttribute('style', tapHlOff);\n\t  containerStyle.position = 'relative';\n\t  containerStyle.zIndex = '0';\n\t  containerStyle.overflow = 'hidden';\n\t\n\t  var container = options.cy.container();\n\t  container.appendChild(r.data.canvasContainer);\n\t\n\t  if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {\n\t    container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);\n\t  }\n\t\n\t  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n\t    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\t    r.data.contexts[i] = canvas.getContext('2d');\n\t    canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));\n\t    canvas.style.position = 'absolute';\n\t    canvas.setAttribute('data-id', 'layer' + i);\n\t    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n\t    r.data.canvasContainer.appendChild(canvas);\n\t\n\t    r.data.canvasNeedsRedraw[i] = false;\n\t  }\n\t  r.data.topCanvas = r.data.canvases[0];\n\t\n\t  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n\t  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n\t  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n\t\n\t  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n\t    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\t    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n\t    r.data.bufferCanvases[i].style.position = 'absolute';\n\t    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n\t    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n\t    r.data.bufferCanvases[i].style.visibility = 'hidden';\n\t    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n\t  }\n\t\n\t  r.pathsEnabled = true;\n\t\n\t  r.data.eleTxrCache = new ElementTextureCache(r);\n\t  r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);\n\t\n\t  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n\t    for (var i = 0; i < eles.length; i++) {\n\t      var ele = eles[i];\n\t      var rs = ele._private.rstyle;\n\t      var de = rs.dirtyEvents;\n\t\n\t      if (ele.isNode() && de && de.length === 1 && de['position']) {\n\t        // then keep cached ele texture\n\t      } else {\n\t        r.data.eleTxrCache.invalidateElement(ele);\n\t      }\n\t    }\n\t\n\t    if (eles.length > 0) {\n\t      r.data.lyrTxrCache.invalidateElements(eles);\n\t    }\n\t  });\n\t}\n\t\n\tCRp.redrawHint = function (group, bool) {\n\t  var r = this;\n\t\n\t  switch (group) {\n\t    case 'eles':\n\t      r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n\t      break;\n\t    case 'drag':\n\t      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n\t      break;\n\t    case 'select':\n\t      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n\t      break;\n\t  }\n\t};\n\t\n\t// whether to use Path2D caching for drawing\n\tvar pathsImpld = typeof Path2D !== 'undefined';\n\t\n\tCRp.path2dEnabled = function (on) {\n\t  if (on === undefined) {\n\t    return this.pathsEnabled;\n\t  }\n\t\n\t  this.pathsEnabled = on ? true : false;\n\t};\n\t\n\tCRp.usePaths = function () {\n\t  return pathsImpld && this.pathsEnabled;\n\t};\n\t\n\t[__webpack_require__(101), __webpack_require__(103), __webpack_require__(102), __webpack_require__(104), __webpack_require__(105), __webpack_require__(106), __webpack_require__(107), __webpack_require__(108), __webpack_require__(110), __webpack_require__(113)].forEach(function (props) {\n\t  util.extend(CRp, props);\n\t});\n\t\n\tmodule.exports = CR;\n\t\n\t/***/ }),\n\t/* 112 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar math = __webpack_require__(2);\n\tvar Heap = __webpack_require__(8);\n\tvar is = __webpack_require__(0);\n\tvar defs = __webpack_require__(16);\n\t\n\tvar defNumLayers = 1; // default number of layers to use\n\tvar minLvl = -4; // when scaling smaller than that we don't need to re-render\n\tvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\tvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\tvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\tvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n\tvar disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true\n\tvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\tvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\tvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\tvar deqFastCost = 0.9; // % of frame time to be used when >60fps\n\tvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\tvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n\tvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n\tvar alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued\n\tvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n\t\n\tvar useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache\n\t\n\t// var log = function(){ console.log.apply( console, arguments ); };\n\t\n\tvar LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {\n\t  var self = this;\n\t\n\t  var r = self.renderer = renderer;\n\t\n\t  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\t\n\t  self.firstGet = true;\n\t\n\t  self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;\n\t\n\t  self.skipping = false;\n\t\n\t  r.beforeRender(function (willDraw, now) {\n\t    if (now - self.lastInvalidationTime <= invalidThreshold) {\n\t      self.skipping = true;\n\t    } else {\n\t      self.skipping = false;\n\t    }\n\t  });\n\t\n\t  var qSort = function qSort(a, b) {\n\t    return b.reqs - a.reqs;\n\t  };\n\t\n\t  self.layersQueue = new Heap(qSort);\n\t\n\t  self.eleTxrCache = eleTxrCache;\n\t\n\t  self.setupEleCacheInvalidation();\n\t\n\t  self.setupDequeueing();\n\t};\n\t\n\tvar LTCp = LayeredTextureCache.prototype;\n\t\n\tvar layerIdPool = 0;\n\tvar MAX_INT = Math.pow(2, 53) - 1;\n\t\n\tLTCp.makeLayer = function (bb, lvl) {\n\t  var scale = Math.pow(2, lvl);\n\t\n\t  var w = Math.ceil(bb.w * scale);\n\t  var h = Math.ceil(bb.h * scale);\n\t\n\t  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\t\n\t  canvas.width = w;\n\t  canvas.height = h;\n\t\n\t  var layer = {\n\t    id: layerIdPool = ++layerIdPool % MAX_INT,\n\t    bb: bb,\n\t    level: lvl,\n\t    width: w,\n\t    height: h,\n\t    canvas: canvas,\n\t    context: canvas.getContext('2d'),\n\t    eles: [],\n\t    elesQueue: [],\n\t    reqs: 0\n\t  };\n\t\n\t  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\t\n\t  var cxt = layer.context;\n\t  var dx = -layer.bb.x1;\n\t  var dy = -layer.bb.y1;\n\t\n\t  // do the transform on creation to save cycles (it's the same for all eles)\n\t  cxt.scale(scale, scale);\n\t  cxt.translate(dx, dy);\n\t\n\t  return layer;\n\t};\n\t\n\tLTCp.getLayers = function (eles, pxRatio, lvl) {\n\t  var self = this;\n\t  var r = self.renderer;\n\t  var cy = r.cy;\n\t  var zoom = cy.zoom();\n\t  var firstGet = self.firstGet;\n\t\n\t  self.firstGet = false;\n\t\n\t  // log('--\\nget layers with %s eles', eles.length);\n\t  //log eles.map(function(ele){ return ele.id() }) );\n\t\n\t  if (lvl == null) {\n\t    lvl = Math.ceil(math.log2(zoom * pxRatio));\n\t\n\t    if (lvl < minLvl) {\n\t      lvl = minLvl;\n\t    } else if (zoom >= maxZoom || lvl > maxLvl) {\n\t      return null;\n\t    }\n\t  }\n\t\n\t  self.validateLayersElesOrdering(lvl, eles);\n\t\n\t  var layersByLvl = self.layersByLevel;\n\t  var scale = Math.pow(2, lvl);\n\t  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n\t  var bb;\n\t\n\t  var lvlComplete = self.levelIsComplete(lvl, eles);\n\t  var tmpLayers;\n\t\n\t  var checkTempLevels = function checkTempLevels() {\n\t    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n\t      self.validateLayersElesOrdering(l, eles);\n\t\n\t      if (self.levelIsComplete(l, eles)) {\n\t        tmpLayers = layersByLvl[l];\n\t        return true;\n\t      }\n\t    };\n\t\n\t    var checkLvls = function checkLvls(dir) {\n\t      if (tmpLayers) {\n\t        return;\n\t      }\n\t\n\t      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n\t        if (canUseAsTmpLvl(l)) {\n\t          break;\n\t        }\n\t      }\n\t    };\n\t\n\t    checkLvls(+1);\n\t    checkLvls(-1);\n\t\n\t    // remove the invalid layers; they will be replaced as needed later in this function\n\t    for (var i = layers.length - 1; i >= 0; i--) {\n\t      var layer = layers[i];\n\t\n\t      if (layer.invalid) {\n\t        util.removeFromArray(layers, layer);\n\t      }\n\t    }\n\t  };\n\t\n\t  if (!lvlComplete) {\n\t    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n\t    // and later queue the current layerset so we can get the proper quality level soon\n\t\n\t    checkTempLevels();\n\t  } else {\n\t    // log('level complete, using existing layers\\n--');\n\t    return layers;\n\t  }\n\t\n\t  var getBb = function getBb() {\n\t    if (!bb) {\n\t      bb = math.makeBoundingBox();\n\t\n\t      for (var i = 0; i < eles.length; i++) {\n\t        math.updateBoundingBox(bb, eles[i].boundingBox());\n\t      }\n\t    }\n\t\n\t    return bb;\n\t  };\n\t\n\t  var makeLayer = function makeLayer(opts) {\n\t    opts = opts || {};\n\t\n\t    var after = opts.after;\n\t\n\t    getBb();\n\t\n\t    var area = bb.w * scale * (bb.h * scale);\n\t\n\t    if (area > maxLayerArea) {\n\t      return null;\n\t    }\n\t\n\t    var layer = self.makeLayer(bb, lvl);\n\t\n\t    if (after != null) {\n\t      var index = layers.indexOf(after) + 1;\n\t\n\t      layers.splice(index, 0, layer);\n\t    } else if (opts.insert === undefined || opts.insert) {\n\t      // no after specified => first layer made so put at start\n\t      layers.unshift(layer);\n\t    }\n\t\n\t    // if( tmpLayers ){\n\t    //self.queueLayer( layer );\n\t    // }\n\t\n\t    return layer;\n\t  };\n\t\n\t  if (self.skipping && !firstGet) {\n\t    // log('skip layers');\n\t    return null;\n\t  }\n\t\n\t  // log('do layers');\n\t\n\t  var layer = null;\n\t  var maxElesPerLayer = eles.length / defNumLayers;\n\t  var allowLazyQueueing = alwaysQueue && !firstGet;\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t    var rs = ele._private.rscratch;\n\t    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\t\n\t    // log('look at ele', ele.id());\n\t\n\t    var existingLayer = caches[lvl];\n\t\n\t    if (existingLayer) {\n\t      // reuse layer for later eles\n\t      // log('reuse layer for', ele.id());\n\t      layer = existingLayer;\n\t      continue;\n\t    }\n\t\n\t    if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n\t      // log('make new layer for ele %s', ele.id());\n\t\n\t      layer = makeLayer({ insert: true, after: layer });\n\t\n\t      // if now layer can be built then we can't use layers at this level\n\t      if (!layer) {\n\t        return null;\n\t      }\n\t\n\t      // log('new layer with id %s', layer.id);\n\t    }\n\t\n\t    if (tmpLayers || allowLazyQueueing) {\n\t      // log('queue ele %s in layer %s', ele.id(), layer.id);\n\t      self.queueLayer(layer, ele);\n\t    } else {\n\t      // log('draw ele %s in layer %s', ele.id(), layer.id);\n\t      self.drawEleInLayer(layer, ele, lvl, pxRatio);\n\t    }\n\t\n\t    layer.eles.push(ele);\n\t\n\t    caches[lvl] = layer;\n\t  }\n\t\n\t  // log('--');\n\t\n\t  if (tmpLayers) {\n\t    // then we only queued the current layerset and can't draw it yet\n\t    return tmpLayers;\n\t  }\n\t\n\t  if (allowLazyQueueing) {\n\t    // log('lazy queue level', lvl);\n\t    return null;\n\t  }\n\t\n\t  return layers;\n\t};\n\t\n\t// a layer may want to use an ele cache of a higher level to avoid blurriness\n\t// so the layer level might not equal the ele level\n\tLTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n\t  return lvl;\n\t};\n\t\n\tfunction imgSmoothing(context, bool) {\n\t  if (context.imageSmoothingEnabled != null) {\n\t    context.imageSmoothingEnabled = bool;\n\t  } else {\n\t    context.webkitImageSmoothingEnabled = bool;\n\t    context.mozImageSmoothingEnabled = bool;\n\t    context.msImageSmoothingEnabled = bool;\n\t  }\n\t}\n\t\n\tLTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n\t  var self = this;\n\t  var r = this.renderer;\n\t  var context = layer.context;\n\t  var bb = ele.boundingBox();\n\t\n\t  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n\t    return;\n\t  }\n\t\n\t  var eleCache = self.eleTxrCache;\n\t  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;\n\t\n\t  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n\t\n\t  var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;\n\t\n\t  if (cache) {\n\t    if (disableEleImgSmoothing) {\n\t      imgSmoothing(context, false);\n\t    }\n\t\n\t    context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);\n\t\n\t    if (disableEleImgSmoothing) {\n\t      imgSmoothing(context, true);\n\t    }\n\t  } else {\n\t    // if the element is not cacheable, then draw directly\n\t    r.drawElement(context, ele);\n\t  }\n\t};\n\t\n\tLTCp.levelIsComplete = function (lvl, eles) {\n\t  var self = this;\n\t  var layers = self.layersByLevel[lvl];\n\t\n\t  if (!layers || layers.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  var numElesInLayers = 0;\n\t\n\t  for (var i = 0; i < layers.length; i++) {\n\t    var layer = layers[i];\n\t\n\t    // if there are any eles needed to be drawn yet, the level is not complete\n\t    if (layer.reqs > 0) {\n\t      return false;\n\t    }\n\t\n\t    // if the layer is invalid, the level is not complete\n\t    if (layer.invalid) {\n\t      return false;\n\t    }\n\t\n\t    numElesInLayers += layer.eles.length;\n\t  }\n\t\n\t  // we should have exactly the number of eles passed in to be complete\n\t  if (numElesInLayers !== eles.length) {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tLTCp.validateLayersElesOrdering = function (lvl, eles) {\n\t  var layers = this.layersByLevel[lvl];\n\t\n\t  if (!layers) {\n\t    return;\n\t  }\n\t\n\t  // if in a layer the eles are not in the same order, then the layer is invalid\n\t  // (i.e. there is an ele in between the eles in the layer)\n\t\n\t  for (var i = 0; i < layers.length; i++) {\n\t    var layer = layers[i];\n\t    var offset = -1;\n\t\n\t    // find the offset\n\t    for (var j = 0; j < eles.length; j++) {\n\t      if (layer.eles[0] === eles[j]) {\n\t        offset = j;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (offset < 0) {\n\t      // then the layer has nonexistant elements and is invalid\n\t      this.invalidateLayer(layer);\n\t      continue;\n\t    }\n\t\n\t    // the eles in the layer must be in the same continuous order, else the layer is invalid\n\t\n\t    var o = offset;\n\t\n\t    for (var j = 0; j < layer.eles.length; j++) {\n\t      if (layer.eles[j] !== eles[o + j]) {\n\t        // log('invalidate based on ordering', layer.id);\n\t\n\t        this.invalidateLayer(layer);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.updateElementsInLayers = function (eles, update) {\n\t  var self = this;\n\t  var isEles = is.element(eles[0]);\n\t\n\t  // collect udpated elements (cascaded from the layers) and update each\n\t  // layer itself along the way\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var req = isEles ? null : eles[i];\n\t    var ele = isEles ? eles[i] : eles[i].ele;\n\t    var rs = ele._private.rscratch;\n\t    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\t\n\t    for (var l = minLvl; l <= maxLvl; l++) {\n\t      var layer = caches[l];\n\t\n\t      if (!layer) {\n\t        continue;\n\t      }\n\t\n\t      // if update is a request from the ele cache, then it affects only\n\t      // the matching level\n\t      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n\t        continue;\n\t      }\n\t\n\t      update(layer, ele, req);\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.haveLayers = function () {\n\t  var self = this;\n\t  var haveLayers = false;\n\t\n\t  for (var l = minLvl; l <= maxLvl; l++) {\n\t    var layers = self.layersByLevel[l];\n\t\n\t    if (layers && layers.length > 0) {\n\t      haveLayers = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  return haveLayers;\n\t};\n\t\n\tLTCp.invalidateElements = function (eles) {\n\t  var self = this;\n\t\n\t  self.lastInvalidationTime = util.performanceNow();\n\t\n\t  // log('update invalidate layer time from eles');\n\t\n\t  if (eles.length === 0 || !self.haveLayers()) {\n\t    return;\n\t  }\n\t\n\t  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n\t    self.invalidateLayer(layer);\n\t  });\n\t};\n\t\n\tLTCp.invalidateLayer = function (layer) {\n\t  // log('update invalidate layer time');\n\t\n\t  this.lastInvalidationTime = util.performanceNow();\n\t\n\t  if (layer.invalid) {\n\t    return;\n\t  } // save cycles\n\t\n\t  var lvl = layer.level;\n\t  var eles = layer.eles;\n\t  var layers = this.layersByLevel[lvl];\n\t\n\t  // log('invalidate layer', layer.id );\n\t\n\t  util.removeFromArray(layers, layer);\n\t  // layer.eles = [];\n\t\n\t  layer.elesQueue = [];\n\t\n\t  layer.invalid = true;\n\t\n\t  if (layer.replacement) {\n\t    layer.replacement.invalid = true;\n\t  }\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var caches = eles[i]._private.rscratch.imgLayerCaches;\n\t\n\t    if (caches) {\n\t      caches[lvl] = null;\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.refineElementTextures = function (eles) {\n\t  var self = this;\n\t\n\t  // log('refine', eles.length);\n\t\n\t  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n\t    var rLyr = layer.replacement;\n\t\n\t    if (!rLyr) {\n\t      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n\t      rLyr.replaces = layer;\n\t      rLyr.eles = layer.eles;\n\t\n\t      // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n\t    }\n\t\n\t    if (!rLyr.reqs) {\n\t      for (var i = 0; i < rLyr.eles.length; i++) {\n\t        self.queueLayer(rLyr, rLyr.eles[i]);\n\t      }\n\t\n\t      // log('queue replacement layer refinement', rLyr.id);\n\t    }\n\t  });\n\t};\n\t\n\tLTCp.setupEleCacheInvalidation = function () {\n\t  var self = this;\n\t  var eleDeqs = [];\n\t\n\t  if (!useEleTxrCaching) {\n\t    return;\n\t  }\n\t\n\t  var updatedElesInLayers = util.debounce(function () {\n\t    self.refineElementTextures(eleDeqs);\n\t\n\t    eleDeqs = [];\n\t  }, refineEleDebounceTime);\n\t\n\t  self.eleTxrCache.onDequeue(function (reqs) {\n\t    for (var i = 0; i < reqs.length; i++) {\n\t      eleDeqs.push(reqs[i]);\n\t    }\n\t\n\t    updatedElesInLayers();\n\t  });\n\t};\n\t\n\tLTCp.queueLayer = function (layer, ele) {\n\t  var self = this;\n\t  var q = self.layersQueue;\n\t  var elesQ = layer.elesQueue;\n\t  var hasId = elesQ.hasId = elesQ.hasId || {};\n\t\n\t  // if a layer is going to be replaced, queuing is a waste of time\n\t  if (layer.replacement) {\n\t    return;\n\t  }\n\t\n\t  if (ele) {\n\t    if (hasId[ele.id()]) {\n\t      return;\n\t    }\n\t\n\t    elesQ.push(ele);\n\t    hasId[ele.id()] = true;\n\t  }\n\t\n\t  if (layer.reqs) {\n\t    layer.reqs++;\n\t\n\t    q.updateItem(layer);\n\t  } else {\n\t    layer.reqs = 1;\n\t\n\t    q.push(layer);\n\t  }\n\t};\n\t\n\tLTCp.dequeue = function (pxRatio) {\n\t  var self = this;\n\t  var q = self.layersQueue;\n\t  var deqd = [];\n\t  var eleDeqs = 0;\n\t\n\t  while (eleDeqs < maxDeqSize) {\n\t    if (q.size() === 0) {\n\t      break;\n\t    }\n\t\n\t    var layer = q.peek();\n\t\n\t    // if a layer has been or will be replaced, then don't waste time with it\n\t    if (layer.replacement) {\n\t      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    // if this is a replacement layer that has been superceded, then forget it\n\t    if (layer.replaces && layer !== layer.replaces.replacement) {\n\t      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    if (layer.invalid) {\n\t      // log('replacement layer %s is invalid; dequeued', layer.id);\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    var ele = layer.elesQueue.shift();\n\t\n\t    if (ele) {\n\t      // log('dequeue layer %s', layer.id);\n\t\n\t      self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n\t\n\t      eleDeqs++;\n\t    }\n\t\n\t    if (deqd.length === 0) {\n\t      // we need only one entry in deqd to queue redrawing etc\n\t      deqd.push(true);\n\t    }\n\t\n\t    // if the layer has all its eles done, then remove from the queue\n\t    if (layer.elesQueue.length === 0) {\n\t      q.pop();\n\t\n\t      layer.reqs = 0;\n\t\n\t      // log('dequeue of layer %s complete', layer.id);\n\t\n\t      // when a replacement layer is dequeued, it replaces the old layer in the level\n\t      if (layer.replaces) {\n\t        self.applyLayerReplacement(layer);\n\t      }\n\t\n\t      self.requestRedraw();\n\t    }\n\t  }\n\t\n\t  return deqd;\n\t};\n\t\n\tLTCp.applyLayerReplacement = function (layer) {\n\t  var self = this;\n\t  var layersInLevel = self.layersByLevel[layer.level];\n\t  var replaced = layer.replaces;\n\t  var index = layersInLevel.indexOf(replaced);\n\t\n\t  // if the replaced layer is not in the active list for the level, then replacing\n\t  // refs would be a mistake (i.e. overwriting the true active layer)\n\t  if (index < 0 || replaced.invalid) {\n\t    // log('replacement layer would have no effect', layer.id);\n\t    return;\n\t  }\n\t\n\t  layersInLevel[index] = layer; // replace level ref\n\t\n\t  // replace refs in eles\n\t  for (var i = 0; i < layer.eles.length; i++) {\n\t    var _p = layer.eles[i]._private;\n\t    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\t\n\t    if (cache) {\n\t      cache[layer.level] = layer;\n\t    }\n\t  }\n\t\n\t  // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\t\n\t  self.requestRedraw();\n\t};\n\t\n\tLTCp.requestRedraw = util.debounce(function () {\n\t  var r = this.renderer;\n\t\n\t  r.redrawHint('eles', true);\n\t  r.redrawHint('drag', true);\n\t  r.redraw();\n\t}, 100);\n\t\n\tLTCp.setupDequeueing = defs.setupDequeueing({\n\t  deqRedrawThreshold: deqRedrawThreshold,\n\t  deqCost: deqCost,\n\t  deqAvgCost: deqAvgCost,\n\t  deqNoDrawCost: deqNoDrawCost,\n\t  deqFastCost: deqFastCost,\n\t  deq: function deq(self, pxRatio) {\n\t    return self.dequeue(pxRatio);\n\t  },\n\t  onDeqd: util.noop,\n\t  shouldRedraw: util.trueify,\n\t  priority: function priority(self) {\n\t    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n\t  }\n\t});\n\t\n\tmodule.exports = LayeredTextureCache;\n\t\n\t/***/ }),\n\t/* 113 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar CRp = {};\n\t\n\tCRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {\n\t  switch (name) {\n\t    case 'ellipse':\n\t      return this.drawEllipsePath(context, centerX, centerY, width, height);\n\t    case 'polygon':\n\t      return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n\t    case 'roundrectangle':\n\t      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n\t    case 'cutrectangle':\n\t      return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n\t    case 'bottomroundrectangle':\n\t      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n\t    case 'barrel':\n\t      return this.drawBarrelPath(context, centerX, centerY, width, height);\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\t\n\t/***/ }),\n\t/* 114 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tmodule.exports = [{ name: 'null', impl: __webpack_require__(115) }, { name: 'base', impl: __webpack_require__(97) }, { name: 'canvas', impl: __webpack_require__(111) }];\n\t\n\t/***/ }),\n\t/* 115 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tfunction NullRenderer(options) {\n\t  this.options = options;\n\t  this.notifications = 0; // for testing\n\t}\n\t\n\tvar noop = function noop() {};\n\t\n\tNullRenderer.prototype = {\n\t  recalculateRenderedStyle: noop,\n\t  notify: function notify() {\n\t    this.notifications++;\n\t  },\n\t  init: noop\n\t};\n\t\n\tmodule.exports = NullRenderer;\n\t\n\t/***/ }),\n\t/* 116 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar Core = __webpack_require__(12);\n\tvar extension = __webpack_require__(20);\n\tvar Stylesheet = __webpack_require__(21);\n\t\n\tvar cytoscape = function cytoscape(options) {\n\t  // jshint ignore:line\n\t  // if no options specified, use default\n\t  if (options === undefined) {\n\t    options = {};\n\t  }\n\t\n\t  // create instance\n\t  if (is.plainObject(options)) {\n\t    return new Core(options);\n\t  }\n\t\n\t  // allow for registration of extensions\n\t  else if (is.string(options)) {\n\t      return extension.apply(extension, arguments);\n\t    }\n\t};\n\t\n\t// e.g. cytoscape.use( require('cytoscape-foo'), bar )\n\tcytoscape.use = function (ext) {\n\t  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\t\n\t  args.unshift(cytoscape); // cytoscape is first arg to ext\n\t\n\t  ext.apply(null, args);\n\t\n\t  return this;\n\t};\n\t\n\t// replaced by build system\n\tcytoscape.version = __webpack_require__(22);\n\t\n\t// expose public apis (mostly for extensions)\n\tcytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\t\n\tmodule.exports = cytoscape;\n\t\n\t/***/ }),\n\t/* 117 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tfunction ObjectMap() {\n\t  this._obj = {};\n\t}\n\t\n\tvar p = ObjectMap.prototype;\n\t\n\tp.set = function (key, val) {\n\t  this._obj[key] = val;\n\t};\n\t\n\tp.delete = function (key) {\n\t  this._obj[key] = null;\n\t};\n\t\n\tp.has = function (key) {\n\t  return this._obj[key] != null;\n\t};\n\t\n\tp.get = function (key) {\n\t  return this._obj[key];\n\t};\n\t\n\t// TODO use the stdlib Map in future...\n\t// module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;\n\tmodule.exports = ObjectMap;\n\t\n\t/***/ }),\n\t/* 118 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _require = __webpack_require__(17),\n\t    stateSelectorRegex = _require.stateSelectorRegex;\n\t\n\tvar tokens = __webpack_require__(121);\n\tvar util = __webpack_require__(1);\n\tvar newQuery = __webpack_require__(11);\n\t\n\t// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n\t// so that values get compared properly in Selector.filter()\n\tvar cleanMetaChars = function cleanMetaChars(str) {\n\t  return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n\t    return $1;\n\t  });\n\t};\n\t\n\tvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n\t  if (examiningQuery === selector[selector.length - 1]) {\n\t    selector[selector.length - 1] = replacementQuery;\n\t  }\n\t};\n\t\n\t// NOTE: add new expression syntax here to have it recognised by the parser;\n\t// - a query contains all adjacent (i.e. no separator in between) expressions;\n\t// - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;\n\t// - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n\t// - when you add something here, also add to Selector.toString()\n\tvar exprs = [{\n\t  name: 'group',\n\t  query: true,\n\t  regex: '(' + tokens.group + ')',\n\t  populate: function populate(selector, query, _ref) {\n\t    var _ref2 = _slicedToArray(_ref, 1),\n\t        group = _ref2[0];\n\t\n\t    query.group = group === '*' ? group : group + 's';\n\t  }\n\t}, {\n\t  name: 'state',\n\t  query: true,\n\t  regex: stateSelectorRegex,\n\t  populate: function populate(selector, query, _ref3) {\n\t    var _ref4 = _slicedToArray(_ref3, 1),\n\t        state = _ref4[0];\n\t\n\t    query.colonSelectors.push(state);\n\t  }\n\t}, {\n\t  name: 'id',\n\t  query: true,\n\t  regex: '\\\\#(' + tokens.id + ')',\n\t  populate: function populate(selector, query, _ref5) {\n\t    var _ref6 = _slicedToArray(_ref5, 1),\n\t        id = _ref6[0];\n\t\n\t    query.ids.push(cleanMetaChars(id));\n\t  }\n\t}, {\n\t  name: 'className',\n\t  query: true,\n\t  regex: '\\\\.(' + tokens.className + ')',\n\t  populate: function populate(selector, query, _ref7) {\n\t    var _ref8 = _slicedToArray(_ref7, 1),\n\t        className = _ref8[0];\n\t\n\t    query.classes.push(cleanMetaChars(className));\n\t  }\n\t}, {\n\t  name: 'dataExists',\n\t  query: true,\n\t  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n\t  populate: function populate(selector, query, _ref9) {\n\t    var _ref10 = _slicedToArray(_ref9, 1),\n\t        variable = _ref10[0];\n\t\n\t    query.data.push({\n\t      field: cleanMetaChars(variable)\n\t    });\n\t  }\n\t}, {\n\t  name: 'dataCompare',\n\t  query: true,\n\t  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n\t  populate: function populate(selector, query, _ref11) {\n\t    var _ref12 = _slicedToArray(_ref11, 3),\n\t        variable = _ref12[0],\n\t        comparatorOp = _ref12[1],\n\t        value = _ref12[2];\n\t\n\t    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\t\n\t    if (valueIsString) {\n\t      value = value.substring(1, value.length - 1);\n\t    } else {\n\t      value = parseFloat(value);\n\t    }\n\t\n\t    query.data.push({\n\t      field: cleanMetaChars(variable),\n\t      operator: comparatorOp,\n\t      value: value\n\t    });\n\t  }\n\t}, {\n\t  name: 'dataBool',\n\t  query: true,\n\t  regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n\t  populate: function populate(selector, query, _ref13) {\n\t    var _ref14 = _slicedToArray(_ref13, 2),\n\t        boolOp = _ref14[0],\n\t        variable = _ref14[1];\n\t\n\t    query.data.push({\n\t      field: cleanMetaChars(variable),\n\t      operator: boolOp\n\t    });\n\t  }\n\t}, {\n\t  name: 'metaCompare',\n\t  query: true,\n\t  regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n\t  populate: function populate(selector, query, _ref15) {\n\t    var _ref16 = _slicedToArray(_ref15, 3),\n\t        meta = _ref16[0],\n\t        comparatorOp = _ref16[1],\n\t        number = _ref16[2];\n\t\n\t    query.meta.push({\n\t      field: cleanMetaChars(meta),\n\t      operator: comparatorOp,\n\t      value: parseFloat(number)\n\t    });\n\t  }\n\t}, {\n\t  name: 'nextQuery',\n\t  separator: true,\n\t  regex: tokens.separator,\n\t  populate: function populate(selector) {\n\t    // go on to next query\n\t    var nextQuery = selector[selector.length++] = newQuery();\n\t    selector.currentSubject = null;\n\t\n\t    return nextQuery;\n\t  }\n\t}, {\n\t  name: 'directedEdge',\n\t  separator: true,\n\t  regex: tokens.directedEdge,\n\t  populate: function populate(selector, query) {\n\t    var edgeQuery = newQuery();\n\t    var source = query;\n\t    var target = newQuery();\n\t\n\t    edgeQuery.group = 'edges';\n\t    edgeQuery.target = target;\n\t    edgeQuery.source = source;\n\t    edgeQuery.subject = selector.currentSubject;\n\t\n\t    // the query in the selector should be the edge rather than the source\n\t    replaceLastQuery(selector, query, edgeQuery);\n\t\n\t    // we're now populating the target query with expressions that follow\n\t    return target;\n\t  }\n\t}, {\n\t  name: 'undirectedEdge',\n\t  separator: true,\n\t  regex: tokens.undirectedEdge,\n\t  populate: function populate(selector, query) {\n\t    var edgeQuery = newQuery();\n\t    var source = query;\n\t    var target = newQuery();\n\t\n\t    edgeQuery.group = 'edges';\n\t    edgeQuery.connectedNodes = [source, target];\n\t    edgeQuery.subject = selector.currentSubject;\n\t\n\t    // the query in the selector should be the edge rather than the source\n\t    replaceLastQuery(selector, query, edgeQuery);\n\t\n\t    // we're now populating the target query with expressions that follow\n\t    return target;\n\t  }\n\t}, {\n\t  name: 'child',\n\t  separator: true,\n\t  regex: tokens.child,\n\t  populate: function populate(selector, query) {\n\t    // this query is the parent of the following query\n\t    var childQuery = newQuery();\n\t    childQuery.parent = query;\n\t    childQuery.subject = selector.currentSubject;\n\t\n\t    // it's cheaper to compare children first and go up so replace the parent\n\t    replaceLastQuery(selector, query, childQuery);\n\t\n\t    // we're now populating the child query with expressions that follow\n\t    return childQuery;\n\t  }\n\t}, {\n\t  name: 'descendant',\n\t  separator: true,\n\t  regex: tokens.descendant,\n\t  populate: function populate(selector, query) {\n\t    // this query is the ancestor of the following query\n\t    var descendantQuery = newQuery();\n\t    descendantQuery.ancestor = query;\n\t    descendantQuery.subject = selector.currentSubject;\n\t\n\t    // it's cheaper to compare descendants first and go up so replace the ancestor\n\t    replaceLastQuery(selector, query, descendantQuery);\n\t\n\t    // we're now populating the descendant query with expressions that follow\n\t    return descendantQuery;\n\t  }\n\t}, {\n\t  name: 'subject',\n\t  modifier: true,\n\t  regex: tokens.subject,\n\t  populate: function populate(selector, query) {\n\t    if (selector.currentSubject != null && query.subject != query) {\n\t      util.error('Redefinition of subject in selector `' + selector.toString() + '`');\n\t      return false;\n\t    }\n\t\n\t    selector.currentSubject = query;\n\t    query.subject = query;\n\t    selector[selector.length - 1].subject = query;\n\t  }\n\t}];\n\t\n\texprs.forEach(function (e) {\n\t  return e.regexObj = new RegExp('^' + e.regex);\n\t});\n\t\n\tmodule.exports = exprs;\n\t\n\t/***/ }),\n\t/* 119 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar _require = __webpack_require__(17),\n\t    stateSelectorMatches = _require.stateSelectorMatches;\n\t\n\tvar is = __webpack_require__(0);\n\t\n\t// generic checking for data/metadata\n\tvar operandsMatch = function operandsMatch(query, params) {\n\t  var allDataMatches = true;\n\t  for (var k = 0; k < query[params.name].length; k++) {\n\t    var data = query[params.name][k];\n\t    var operator = data.operator;\n\t    var value = data.value;\n\t    var field = data.field;\n\t    var _matches = void 0;\n\t    var fieldVal = params.fieldValue(field);\n\t\n\t    if (operator != null && value != null) {\n\t      var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;\n\t      var valStr = '' + value;\n\t\n\t      var caseInsensitive = false;\n\t      if (operator.indexOf('@') >= 0) {\n\t        fieldStr = fieldStr.toLowerCase();\n\t        valStr = valStr.toLowerCase();\n\t\n\t        operator = operator.replace('@', '');\n\t        caseInsensitive = true;\n\t      }\n\t\n\t      var notExpr = false;\n\t      if (operator.indexOf('!') >= 0) {\n\t        operator = operator.replace('!', '');\n\t        notExpr = true;\n\t      }\n\t\n\t      // if we're doing a case insensitive comparison, then we're using a STRING comparison\n\t      // even if we're comparing numbers\n\t      if (caseInsensitive) {\n\t        value = valStr.toLowerCase();\n\t        fieldVal = fieldStr.toLowerCase();\n\t      }\n\t\n\t      var isIneqCmp = false;\n\t\n\t      switch (operator) {\n\t        case '*=':\n\t          _matches = fieldStr.indexOf(valStr) >= 0;\n\t          break;\n\t        case '$=':\n\t          _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n\t          break;\n\t        case '^=':\n\t          _matches = fieldStr.indexOf(valStr) === 0;\n\t          break;\n\t        case '=':\n\t          _matches = fieldVal === value;\n\t          break;\n\t        case '>':\n\t          isIneqCmp = true;\n\t          _matches = fieldVal > value;\n\t          break;\n\t        case '>=':\n\t          isIneqCmp = true;\n\t          _matches = fieldVal >= value;\n\t          break;\n\t        case '<':\n\t          isIneqCmp = true;\n\t          _matches = fieldVal < value;\n\t          break;\n\t        case '<=':\n\t          isIneqCmp = true;\n\t          _matches = fieldVal <= value;\n\t          break;\n\t        default:\n\t          _matches = false;\n\t          break;\n\t      }\n\t\n\t      // apply the not op, but null vals for inequalities should always stay non-matching\n\t      if (notExpr && (fieldVal != null || !isIneqCmp)) {\n\t        _matches = !_matches;\n\t      }\n\t    } else if (operator != null) {\n\t      switch (operator) {\n\t        case '?':\n\t          _matches = fieldVal ? true : false;\n\t          break;\n\t        case '!':\n\t          _matches = fieldVal ? false : true;\n\t          break;\n\t        case '^':\n\t          _matches = fieldVal === undefined;\n\t          break;\n\t      }\n\t    } else {\n\t      _matches = fieldVal !== undefined;\n\t    }\n\t\n\t    if (!_matches) {\n\t      allDataMatches = false;\n\t      break;\n\t    }\n\t  } // for\n\t\n\t  return allDataMatches;\n\t}; // operandsMatch\n\t\n\t// check parent/child relations\n\tvar confirmRelations = function confirmRelations(query, isNecessary, eles) {\n\t  if (query != null) {\n\t    var _matches2 = false;\n\t\n\t    if (!isNecessary) {\n\t      return false;\n\t    }\n\t\n\t    eles = eles(); // save cycles if query == null\n\t\n\t    // query must match for at least one element (may be recursive)\n\t    for (var i = 0; i < eles.length; i++) {\n\t      if (queryMatches(query, eles[i])) {\n\t        _matches2 = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    return _matches2;\n\t  } else {\n\t    return true;\n\t  }\n\t};\n\t\n\tvar queryMatches = function queryMatches(query, ele) {\n\t  // make single group-only selectors really cheap to check since they're the most common ones\n\t  if (query.groupOnly) {\n\t    return query.group === '*' || query.group === ele.group();\n\t  }\n\t\n\t  // check group\n\t  if (query.group != null && query.group != '*' && query.group != ele.group()) {\n\t    return false;\n\t  }\n\t\n\t  var cy = ele.cy();\n\t  var k = void 0;\n\t\n\t  // check colon selectors\n\t  var allColonSelectorsMatch = true;\n\t  for (k = 0; k < query.colonSelectors.length; k++) {\n\t    var sel = query.colonSelectors[k];\n\t\n\t    allColonSelectorsMatch = stateSelectorMatches(sel, ele);\n\t\n\t    if (!allColonSelectorsMatch) break;\n\t  }\n\t  if (!allColonSelectorsMatch) return false;\n\t\n\t  // check id\n\t  var allIdsMatch = true;\n\t  for (k = 0; k < query.ids.length; k++) {\n\t    var id = query.ids[k];\n\t    var actualId = ele.id();\n\t\n\t    allIdsMatch = allIdsMatch && id == actualId;\n\t\n\t    if (!allIdsMatch) break;\n\t  }\n\t  if (!allIdsMatch) return false;\n\t\n\t  // check classes\n\t  var allClassesMatch = true;\n\t  for (k = 0; k < query.classes.length; k++) {\n\t    var cls = query.classes[k];\n\t\n\t    allClassesMatch = allClassesMatch && ele.hasClass(cls);\n\t\n\t    if (!allClassesMatch) break;\n\t  }\n\t  if (!allClassesMatch) return false;\n\t\n\t  // check data matches\n\t  var allDataMatches = operandsMatch(query, {\n\t    name: 'data',\n\t    fieldValue: function fieldValue(field) {\n\t      return ele.data(field);\n\t    }\n\t  });\n\t\n\t  if (!allDataMatches) {\n\t    return false;\n\t  }\n\t\n\t  // check metadata matches\n\t  var allMetaMatches = operandsMatch(query, {\n\t    name: 'meta',\n\t    fieldValue: function fieldValue(field) {\n\t      return ele[field]();\n\t    }\n\t  });\n\t\n\t  if (!allMetaMatches) {\n\t    return false;\n\t  }\n\t\n\t  // check collection\n\t  if (query.collection != null) {\n\t    var matchesAny = query.collection.hasElementWithId(ele.id());\n\t\n\t    if (!matchesAny) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  // check filter function\n\t  if (query.filter != null && ele.collection().some(query.filter)) {\n\t    return false;\n\t  }\n\t\n\t  var isCompound = cy.hasCompoundNodes();\n\t  var getSource = function getSource() {\n\t    return ele.source();\n\t  };\n\t  var getTarget = function getTarget() {\n\t    return ele.target();\n\t  };\n\t\n\t  if (!confirmRelations(query.parent, isCompound, function () {\n\t    return ele.parent();\n\t  })) {\n\t    return false;\n\t  }\n\t\n\t  if (!confirmRelations(query.ancestor, isCompound, function () {\n\t    return ele.parents();\n\t  })) {\n\t    return false;\n\t  }\n\t\n\t  if (!confirmRelations(query.child, isCompound, function () {\n\t    return ele.children();\n\t  })) {\n\t    return false;\n\t  }\n\t\n\t  if (!confirmRelations(query.descendant, isCompound, function () {\n\t    return ele.descendants();\n\t  })) {\n\t    return false;\n\t  }\n\t\n\t  if (!confirmRelations(query.source, true, getSource)) {\n\t    return false;\n\t  }\n\t\n\t  if (!confirmRelations(query.target, true, getTarget)) {\n\t    return false;\n\t  }\n\t\n\t  if (query.connectedNodes) {\n\t    var q0 = query.connectedNodes[0];\n\t    var q1 = query.connectedNodes[1];\n\t\n\t    if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {\n\t      // match\n\t    } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {\n\t      // match\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  // we've reached the end, so we've matched everything for this query\n\t  return true;\n\t}; // queryMatches\n\t\n\t// filter an existing collection\n\tvar filter = function filter(collection) {\n\t  var self = this;\n\t  var cy = collection.cy();\n\t\n\t  // don't bother trying if it's invalid\n\t  if (self.invalid()) {\n\t    return cy.collection();\n\t  }\n\t\n\t  // for 1 id #foo queries, just get the element\n\t  if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {\n\t    return collection.getElementById(self[0].ids[0]).collection();\n\t  }\n\t\n\t  var selectorFunction = function selectorFunction(element) {\n\t    for (var j = 0; j < self.length; j++) {\n\t      var query = self[j];\n\t\n\t      if (queryMatches(query, element)) {\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  };\n\t\n\t  if (self.text() == null) {\n\t    selectorFunction = function selectorFunction() {\n\t      return true;\n\t    };\n\t  }\n\t\n\t  var filteredCollection = collection.filter(selectorFunction);\n\t\n\t  return filteredCollection;\n\t}; // filter\n\t\n\t// does selector match a single element?\n\tvar matches = function matches(ele) {\n\t  var self = this;\n\t\n\t  // don't bother trying if it's invalid\n\t  if (self.invalid()) {\n\t    return false;\n\t  }\n\t\n\t  for (var j = 0; j < self.length; j++) {\n\t    var query = self[j];\n\t\n\t    if (queryMatches(query, ele)) {\n\t      return true;\n\t    }\n\t  }\n\t\n\t  return false;\n\t}; // filter\n\t\n\tmodule.exports = { matches: matches, filter: filter };\n\t\n\t/***/ }),\n\t/* 120 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar exprs = __webpack_require__(118);\n\tvar newQuery = __webpack_require__(11);\n\t\n\t// of all the expressions, find the first match in the remaining text\n\tvar consumeExpr = function consumeExpr(remaining) {\n\t  var expr = void 0;\n\t  var match = void 0;\n\t  var name = void 0;\n\t\n\t  for (var j = 0; j < exprs.length; j++) {\n\t    var e = exprs[j];\n\t    var n = e.name;\n\t\n\t    var m = remaining.match(e.regexObj);\n\t\n\t    if (m != null) {\n\t      match = m;\n\t      expr = e;\n\t      name = n;\n\t\n\t      var consumed = m[0];\n\t      remaining = remaining.substring(consumed.length);\n\t\n\t      break; // we've consumed one expr, so we can return now\n\t    }\n\t  }\n\t\n\t  return {\n\t    expr: expr,\n\t    match: match,\n\t    name: name,\n\t    remaining: remaining\n\t  };\n\t};\n\t\n\t// consume all leading whitespace\n\tvar consumeWhitespace = function consumeWhitespace(remaining) {\n\t  var match = remaining.match(/^\\s+/);\n\t\n\t  if (match) {\n\t    var consumed = match[0];\n\t    remaining = remaining.substring(consumed.length);\n\t  }\n\t\n\t  return remaining;\n\t};\n\t\n\tvar parse = function parse(selector) {\n\t  var self = this;\n\t\n\t  var remaining = self._private.selectorText = selector;\n\t\n\t  var currentQuery = self[0] = newQuery();\n\t  self.length = 1;\n\t\n\t  remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\t\n\t  for (;;) {\n\t    var check = consumeExpr(remaining);\n\t\n\t    if (check.expr == null) {\n\t      util.error('The selector `' + selector + '`is invalid');\n\t      return false;\n\t    } else {\n\t      var args = check.match.slice(1);\n\t\n\t      // let the token populate the selector object in currentQuery\n\t      var ret = check.expr.populate(self, currentQuery, args);\n\t\n\t      if (ret === false) {\n\t        return false; // exit if population failed\n\t      } else if (ret != null) {\n\t        currentQuery = ret; // change the current query to be filled if the expr specifies\n\t      }\n\t    }\n\t\n\t    remaining = check.remaining;\n\t\n\t    // we're done when there's nothing left to parse\n\t    if (remaining.match(/^\\s*$/)) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  // adjust references for subject\n\t  for (var j = 0; j < self.length; j++) {\n\t    var query = self[j];\n\t\n\t    if (query.subject != null) {\n\t      // go up the tree until we reach the subject\n\t      for (;;) {\n\t        if (query.subject === query) {\n\t          break;\n\t        } // done if subject is self\n\t\n\t        if (query.parent != null) {\n\t          // swap parent/child reference\n\t          var parent = query.parent;\n\t          var child = query;\n\t\n\t          child.parent = null;\n\t          parent.child = child;\n\t\n\t          query = parent; // go up the tree\n\t        } else if (query.ancestor != null) {\n\t          // swap ancestor/descendant\n\t          var ancestor = query.ancestor;\n\t          var descendant = query;\n\t\n\t          descendant.ancestor = null;\n\t          ancestor.descendant = descendant;\n\t\n\t          query = ancestor; // go up the tree\n\t        } else if (query.source || query.target || query.connectedNodes) {\n\t          util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');\n\t          return false;\n\t        } else {\n\t          util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');\n\t          return false;\n\t        }\n\t      } // for\n\t\n\t      self[j] = query.subject; // subject should be the root query\n\t    } // if\n\t  } // for\n\t\n\t  return true; // success\n\t};\n\t\n\tmodule.exports = { parse: parse };\n\t\n\t/***/ }),\n\t/* 121 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\t\n\t// tokens in the query language\n\tvar tokens = {\n\t  metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in let names, etc\n\t  comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n\t  boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n\t  string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n\t  number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n\t  meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)\n\t  separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n\t  descendant: '\\\\s+',\n\t  child: '\\\\s+>\\\\s+',\n\t  subject: '\\\\$',\n\t  group: 'node|edge|\\\\*',\n\t  directedEdge: '\\\\s+->\\\\s+',\n\t  undirectedEdge: '\\\\s+<->\\\\s+'\n\t};\n\ttokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name\n\ttokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n\ttokens.className = tokens.variable; // a class name (follows variable conventions)\n\ttokens.id = tokens.variable; // an element id (follows variable conventions)\n\t\n\t(function () {\n\t  var ops = void 0,\n\t      op = void 0,\n\t      i = void 0;\n\t\n\t  // add @ variants to comparatorOp\n\t  ops = tokens.comparatorOp.split('|');\n\t  for (i = 0; i < ops.length; i++) {\n\t    op = ops[i];\n\t    tokens.comparatorOp += '|@' + op;\n\t  }\n\t\n\t  // add ! variants to comparatorOp\n\t  ops = tokens.comparatorOp.split('|');\n\t  for (i = 0; i < ops.length; i++) {\n\t    op = ops[i];\n\t\n\t    if (op.indexOf('!') >= 0) {\n\t      continue;\n\t    } // skip ops that explicitly contain !\n\t    if (op === '=') {\n\t      continue;\n\t    } // skip = b/c != is explicitly defined\n\t\n\t    tokens.comparatorOp += '|\\\\!' + op;\n\t  }\n\t})();\n\t\n\tmodule.exports = tokens;\n\t\n\t/***/ }),\n\t/* 122 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar Promise = __webpack_require__(5);\n\t\n\tvar styfn = {};\n\t\n\t// (potentially expensive calculation)\n\t// apply the style to the element based on\n\t// - its bypass\n\t// - what selectors match it\n\tstyfn.apply = function (eles) {\n\t  var self = this;\n\t  var _p = self._private;\n\t  var cy = _p.cy;\n\t  var updatedEles = cy.collection();\n\t\n\t  if (_p.newStyle) {\n\t    // clear style caches\n\t    _p.contextStyles = {};\n\t    _p.propDiffs = {};\n\t\n\t    self.cleanElements(eles, true);\n\t  }\n\t\n\t  for (var ie = 0; ie < eles.length; ie++) {\n\t    var ele = eles[ie];\n\t\n\t    var cxtMeta = self.getContextMeta(ele);\n\t\n\t    if (cxtMeta.empty) {\n\t      continue;\n\t    } else {\n\t      updatedEles.merge(ele);\n\t    }\n\t\n\t    var cxtStyle = self.getContextStyle(cxtMeta);\n\t    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\t\n\t    if (!_p.newStyle) {\n\t      self.updateTransitions(ele, app.diffProps);\n\t    }\n\t\n\t    self.updateStyleHints(ele);\n\t  } // for elements\n\t\n\t  _p.newStyle = false;\n\t\n\t  return updatedEles;\n\t};\n\t\n\tstyfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n\t  var self = this;\n\t  var cache = self._private.propDiffs = self._private.propDiffs || {};\n\t  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n\t  var cachedVal = cache[dualCxtKey];\n\t\n\t  if (cachedVal) {\n\t    return cachedVal;\n\t  }\n\t\n\t  var diffProps = [];\n\t  var addedProp = {};\n\t\n\t  for (var i = 0; i < self.length; i++) {\n\t    var cxt = self[i];\n\t    var oldHasCxt = oldCxtKey[i] === 't';\n\t    var newHasCxt = newCxtKey[i] === 't';\n\t    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n\t    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\t\n\t    if (cxtHasDiffed || cxtHasMappedProps) {\n\t      var props = void 0;\n\t\n\t      if (cxtHasDiffed && cxtHasMappedProps) {\n\t        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n\t      } else if (cxtHasDiffed) {\n\t        props = cxt.properties; // need to check them all\n\t      } else if (cxtHasMappedProps) {\n\t        props = cxt.mappedProperties; // only need to check mapped\n\t      }\n\t\n\t      for (var j = 0; j < props.length; j++) {\n\t        var prop = props[j];\n\t        var name = prop.name;\n\t\n\t        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n\t        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n\t        // is cached)\n\t        var laterCxtOverrides = false;\n\t        for (var k = i + 1; k < self.length; k++) {\n\t          var laterCxt = self[k];\n\t          var hasLaterCxt = newCxtKey[k] === 't';\n\t\n\t          if (!hasLaterCxt) {\n\t            continue;\n\t          } // can't override unless the context is active\n\t\n\t          laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\t\n\t          if (laterCxtOverrides) {\n\t            break;\n\t          } // exit early as long as one later context overrides\n\t        }\n\t\n\t        if (!addedProp[name] && !laterCxtOverrides) {\n\t          addedProp[name] = true;\n\t          diffProps.push(name);\n\t        }\n\t      } // for props\n\t    } // if\n\t  } // for contexts\n\t\n\t  cache[dualCxtKey] = diffProps;\n\t  return diffProps;\n\t};\n\t\n\tstyfn.getContextMeta = function (ele) {\n\t  var self = this;\n\t  var cxtKey = '';\n\t  var diffProps = void 0;\n\t  var prevKey = ele._private.styleCxtKey || '';\n\t\n\t  if (self._private.newStyle) {\n\t    prevKey = ''; // since we need to apply all style if a fresh stylesheet\n\t  }\n\t\n\t  // get the cxt key\n\t  for (var i = 0; i < self.length; i++) {\n\t    var context = self[i];\n\t    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\t\n\t    if (contextSelectorMatches) {\n\t      cxtKey += 't';\n\t    } else {\n\t      cxtKey += 'f';\n\t    }\n\t  } // for context\n\t\n\t  diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n\t\n\t  ele._private.styleCxtKey = cxtKey;\n\t\n\t  return {\n\t    key: cxtKey,\n\t    diffPropNames: diffProps,\n\t    empty: diffProps.length === 0\n\t  };\n\t};\n\t\n\t// gets a computed ele style object based on matched contexts\n\tstyfn.getContextStyle = function (cxtMeta) {\n\t  var cxtKey = cxtMeta.key;\n\t  var self = this;\n\t  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\t\n\t  // if already computed style, returned cached copy\n\t  if (cxtStyles[cxtKey]) {\n\t    return cxtStyles[cxtKey];\n\t  }\n\t\n\t  var style = {\n\t    _private: {\n\t      key: cxtKey\n\t    }\n\t  };\n\t\n\t  for (var i = 0; i < self.length; i++) {\n\t    var cxt = self[i];\n\t    var hasCxt = cxtKey[i] === 't';\n\t\n\t    if (!hasCxt) {\n\t      continue;\n\t    }\n\t\n\t    for (var j = 0; j < cxt.properties.length; j++) {\n\t      var prop = cxt.properties[j];\n\t\n\t      style[prop.name] = prop;\n\t    }\n\t  }\n\t\n\t  cxtStyles[cxtKey] = style;\n\t  return style;\n\t};\n\t\n\tstyfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n\t  var self = this;\n\t  var diffProps = cxtMeta.diffPropNames;\n\t  var retDiffProps = {};\n\t\n\t  for (var i = 0; i < diffProps.length; i++) {\n\t    var diffPropName = diffProps[i];\n\t    var cxtProp = cxtStyle[diffPropName];\n\t    var eleProp = ele.pstyle(diffPropName);\n\t\n\t    if (!cxtProp) {\n\t      // no context prop means delete\n\t      if (!eleProp) {\n\t        continue; // no existing prop means nothing needs to be removed\n\t        // nb affects initial application on mapped values like control-point-distances\n\t      } else if (eleProp.bypass) {\n\t        cxtProp = { name: diffPropName, deleteBypassed: true };\n\t      } else {\n\t        cxtProp = { name: diffPropName, delete: true };\n\t      }\n\t    }\n\t\n\t    // save cycles when the context prop doesn't need to be applied\n\t    if (eleProp === cxtProp) {\n\t      continue;\n\t    }\n\t\n\t    var retDiffProp = retDiffProps[diffPropName] = {\n\t      prev: eleProp\n\t    };\n\t\n\t    self.applyParsedProperty(ele, cxtProp);\n\t\n\t    retDiffProp.next = ele.pstyle(diffPropName);\n\t\n\t    if (retDiffProp.next && retDiffProp.next.bypass) {\n\t      retDiffProp.next = retDiffProp.next.bypassed;\n\t    }\n\t  }\n\t\n\t  return {\n\t    diffProps: retDiffProps\n\t  };\n\t};\n\t\n\tstyfn.updateStyleHints = function (ele) {\n\t  var _p = ele._private;\n\t  var self = this;\n\t\n\t  if (ele.removed()) {\n\t    return;\n\t  }\n\t\n\t  // set whether has pie or not; for greater efficiency\n\t  var hasPie = false;\n\t  if (_p.group === 'nodes') {\n\t    for (var i = 1; i <= self.pieBackgroundN; i++) {\n\t      // 1..N\n\t      var _size = ele.pstyle('pie-' + i + '-background-size').value;\n\t\n\t      if (_size > 0) {\n\t        hasPie = true;\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  _p.hasPie = hasPie;\n\t\n\t  var transform = ele.pstyle('text-transform').strValue;\n\t  var content = ele.pstyle('label').strValue;\n\t  var srcContent = ele.pstyle('source-label').strValue;\n\t  var tgtContent = ele.pstyle('target-label').strValue;\n\t  var fStyle = ele.pstyle('font-style').strValue;\n\t  var size = ele.pstyle('font-size').pfValue + 'px';\n\t  var family = ele.pstyle('font-family').strValue;\n\t  // let letiant = style['font-letiant'].strValue;\n\t  var weight = ele.pstyle('font-weight').strValue;\n\t  var valign = ele.pstyle('text-valign').strValue;\n\t  var halign = ele.pstyle('text-valign').strValue;\n\t  var oWidth = ele.pstyle('text-outline-width').pfValue;\n\t  var wrap = ele.pstyle('text-wrap').strValue;\n\t  var wrapW = ele.pstyle('text-max-width').pfValue;\n\t  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;\n\t  _p.labelStyleKey = labelStyleKey;\n\t  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;\n\t  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;\n\t  _p.labelKey = labelStyleKey + '$' + content;\n\t  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;\n\t\n\t  _p.styleKey = Date.now();\n\t};\n\t\n\t// apply a property to the style (for internal use)\n\t// returns whether application was successful\n\t//\n\t// now, this function flattens the property, and here's how:\n\t//\n\t// for parsedProp:{ bypass: true, deleteBypass: true }\n\t// no property is generated, instead the bypass property in the\n\t// element's style is replaced by what's pointed to by the `bypassed`\n\t// field in the bypass property (i.e. restoring the property the\n\t// bypass was overriding)\n\t//\n\t// for parsedProp:{ mapped: truthy }\n\t// the generated flattenedProp:{ mapping: prop }\n\t//\n\t// for parsedProp:{ bypass: true }\n\t// the generated flattenedProp:{ bypassed: parsedProp }\n\tstyfn.applyParsedProperty = function (ele, parsedProp) {\n\t  var self = this;\n\t  var prop = parsedProp;\n\t  var style = ele._private.style;\n\t  var fieldVal = void 0,\n\t      flatProp = void 0;\n\t  var types = self.types;\n\t  var type = self.properties[prop.name].type;\n\t  var propIsBypass = prop.bypass;\n\t  var origProp = style[prop.name];\n\t  var origPropIsBypass = origProp && origProp.bypass;\n\t  var _p = ele._private;\n\t  var flatPropMapping = 'mapping';\n\t\n\t  var checkZOrder = function checkZOrder() {\n\t    self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);\n\t  };\n\t\n\t  // edges connected to compound nodes can not be haystacks\n\t  if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {\n\t    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n\t  }\n\t\n\t  if (prop.delete) {\n\t    // delete the property and use the default value on falsey value\n\t    style[prop.name] = undefined;\n\t\n\t    checkZOrder();\n\t\n\t    return true;\n\t  }\n\t\n\t  if (prop.deleteBypassed) {\n\t    // delete the property that the\n\t    if (!origProp) {\n\t      checkZOrder();\n\t\n\t      return true; // can't delete if no prop\n\t    } else if (origProp.bypass) {\n\t      // delete bypassed\n\t      origProp.bypassed = undefined;\n\t\n\t      checkZOrder();\n\t\n\t      return true;\n\t    } else {\n\t      return false; // we're unsuccessful deleting the bypassed\n\t    }\n\t  }\n\t\n\t  // check if we need to delete the current bypass\n\t  if (prop.deleteBypass) {\n\t    // then this property is just here to indicate we need to delete\n\t    if (!origProp) {\n\t      checkZOrder();\n\t\n\t      return true; // property is already not defined\n\t    } else if (origProp.bypass) {\n\t      // then replace the bypass property with the original\n\t      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n\t      style[prop.name] = origProp.bypassed;\n\t\n\t      checkZOrder();\n\t\n\t      return true;\n\t    } else {\n\t      return false; // we're unsuccessful deleting the bypass\n\t    }\n\t  }\n\t\n\t  var printMappingErr = function printMappingErr() {\n\t    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n\t  };\n\t\n\t  // put the property in the style objects\n\t  switch (prop.mapped) {// flatten the property if mapped\n\t    case types.mapData:\n\t      {\n\t        // flatten the field (e.g. data.foo.bar)\n\t        var fields = prop.field.split('.');\n\t        var _fieldVal = _p.data;\n\t\n\t        for (var i = 0; i < fields.length && _fieldVal; i++) {\n\t          var field = fields[i];\n\t          _fieldVal = _fieldVal[field];\n\t        }\n\t\n\t        var percent = void 0;\n\t        if (!is.number(_fieldVal)) {\n\t          // then keep the mapping but assume 0% for now\n\t          percent = 0;\n\t        } else {\n\t          percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n\t        }\n\t\n\t        // make sure to bound percent value\n\t        if (percent < 0) {\n\t          percent = 0;\n\t        } else if (percent > 1) {\n\t          percent = 1;\n\t        }\n\t\n\t        if (type.color) {\n\t          var r1 = prop.valueMin[0];\n\t          var r2 = prop.valueMax[0];\n\t          var g1 = prop.valueMin[1];\n\t          var g2 = prop.valueMax[1];\n\t          var b1 = prop.valueMin[2];\n\t          var b2 = prop.valueMax[2];\n\t          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n\t          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\t\n\t          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n\t\n\t          flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n\t            bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n\t            name: prop.name,\n\t            value: clr,\n\t            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n\t          };\n\t        } else if (type.number) {\n\t          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n\t          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n\t        } else {\n\t          return false; // can only map to colours and numbers\n\t        }\n\t\n\t        if (!flatProp) {\n\t          // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n\t          flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);\n\t        }\n\t\n\t        if (!flatProp) {\n\t          printMappingErr();\n\t        }\n\t        flatProp.mapping = prop; // keep a reference to the mapping\n\t        prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t        break;\n\t      }\n\t\n\t    // direct mapping\n\t    case types.data:\n\t      {\n\t        // flatten the field (e.g. data.foo.bar)\n\t        var _fields = prop.field.split('.');\n\t        var _fieldVal2 = _p.data;\n\t\n\t        if (_fieldVal2) {\n\t          for (var _i = 0; _i < _fields.length; _i++) {\n\t            var _field = _fields[_i];\n\t            _fieldVal2 = _fieldVal2[_field];\n\t          }\n\t        }\n\t\n\t        flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);\n\t\n\t        if (!flatProp) {\n\t          // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n\t          var flatPropVal = origProp ? origProp.strValue : '';\n\t\n\t          flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);\n\t        }\n\t\n\t        if (!flatProp) {\n\t          printMappingErr();\n\t        }\n\t        flatProp.mapping = prop; // keep a reference to the mapping\n\t        prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t        break;\n\t      }\n\t\n\t    case types.fn:\n\t      {\n\t        var fn = prop.value;\n\t        var fnRetVal = fn(ele);\n\t\n\t        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n\t        flatProp.mapping = prop; // keep a reference to the mapping\n\t        prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t        break;\n\t      }\n\t\n\t    case undefined:\n\t      break; // just set the property\n\t\n\t    default:\n\t      return false; // not a valid mapping\n\t  }\n\t\n\t  // if the property is a bypass property, then link the resultant property to the original one\n\t  if (propIsBypass) {\n\t    if (origPropIsBypass) {\n\t      // then this bypass overrides the existing one\n\t      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n\t    } else {\n\t      // then link the orig prop to the new bypass\n\t      prop.bypassed = origProp;\n\t    }\n\t\n\t    style[prop.name] = prop; // and set\n\t  } else {\n\t    // prop is not bypass\n\t    if (origPropIsBypass) {\n\t      // then keep the orig prop (since it's a bypass) and link to the new prop\n\t      origProp.bypassed = prop;\n\t    } else {\n\t      // then just replace the old prop with the new one\n\t      style[prop.name] = prop;\n\t    }\n\t  }\n\t\n\t  checkZOrder();\n\t\n\t  return true;\n\t};\n\t\n\tstyfn.cleanElements = function (eles, keepBypasses) {\n\t  var self = this;\n\t  var props = self.properties;\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t\n\t    if (!keepBypasses) {\n\t      ele._private.style = {};\n\t    } else {\n\t      var style = ele._private.style;\n\t\n\t      for (var j = 0; j < props.length; j++) {\n\t        var prop = props[j];\n\t        var eleProp = style[prop.name];\n\t\n\t        if (eleProp) {\n\t          if (eleProp.bypass) {\n\t            eleProp.bypassed = null;\n\t          } else {\n\t            style[prop.name] = null;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t// updates the visual style for all elements (useful for manual style modification after init)\n\tstyfn.update = function () {\n\t  var cy = this._private.cy;\n\t  var eles = cy.mutableElements();\n\t\n\t  eles.updateStyle();\n\t};\n\t\n\t// just update the functional properties (i.e. mappings) in the elements'\n\t// styles (less expensive than recalculation)\n\tstyfn.updateMappers = function (eles) {\n\t  var self = this;\n\t  var cy = this._private.cy;\n\t  var updatedEles = cy.collection();\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    // for each ele\n\t    var ele = eles[i];\n\t    var style = ele._private.style;\n\t    var updatedEle = false;\n\t\n\t    for (var j = 0; j < self.properties.length; j++) {\n\t      // for each prop\n\t      var prop = self.properties[j];\n\t      var propInStyle = style[prop.name];\n\t\n\t      if (propInStyle && propInStyle.mapping) {\n\t        var mapping = propInStyle.mapping;\n\t\n\t        this.applyParsedProperty(ele, mapping); // reapply the mapping property\n\t\n\t        updatedEle = true;\n\t      }\n\t    }\n\t\n\t    if (updatedEle) {\n\t      this.updateStyleHints(ele);\n\t\n\t      updatedEles.merge(ele);\n\t    }\n\t  }\n\t\n\t  return updatedEles;\n\t};\n\t\n\t// diffProps : { name => { prev, next } }\n\tstyfn.updateTransitions = function (ele, diffProps, isBypass) {\n\t  var self = this;\n\t  var _p = ele._private;\n\t  var props = ele.pstyle('transition-property').value;\n\t  var duration = ele.pstyle('transition-duration').pfValue;\n\t  var delay = ele.pstyle('transition-delay').pfValue;\n\t\n\t  if (props.length > 0 && duration > 0) {\n\t\n\t    var style = {};\n\t\n\t    // build up the style to animate towards\n\t    var anyPrev = false;\n\t    for (var i = 0; i < props.length; i++) {\n\t      var prop = props[i];\n\t      var styProp = ele.pstyle(prop);\n\t      var diffProp = diffProps[prop];\n\t\n\t      if (!diffProp) {\n\t        continue;\n\t      }\n\t\n\t      var prevProp = diffProp.prev;\n\t      var fromProp = prevProp;\n\t      var toProp = diffProp.next != null ? diffProp.next : styProp;\n\t      var diff = false;\n\t      var initVal = void 0;\n\t      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\t\n\t      if (!fromProp) {\n\t        continue;\n\t      }\n\t\n\t      // consider px values\n\t      if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {\n\t        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\t        initVal = fromProp.pfValue + initDt * diff;\n\t\n\t        // consider numerical values\n\t      } else if (is.number(fromProp.value) && is.number(toProp.value)) {\n\t        diff = toProp.value - fromProp.value; // nonzero is truthy\n\t        initVal = fromProp.value + initDt * diff;\n\t\n\t        // consider colour values\n\t      } else if (is.array(fromProp.value) && is.array(toProp.value)) {\n\t        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n\t\n\t        initVal = fromProp.strValue;\n\t      }\n\t\n\t      // the previous value is good for an animation only if it's different\n\t      if (diff) {\n\t        style[prop] = toProp.strValue; // to val\n\t        this.applyBypass(ele, prop, initVal); // from val\n\t        anyPrev = true;\n\t      }\n\t    } // end if props allow ani\n\t\n\t    // can't transition if there's nothing previous to transition from\n\t    if (!anyPrev) {\n\t      return;\n\t    }\n\t\n\t    _p.transitioning = true;\n\t\n\t    new Promise(function (resolve) {\n\t      if (delay > 0) {\n\t        ele.delayAnimation(delay).play().promise().then(resolve);\n\t      } else {\n\t        resolve();\n\t      }\n\t    }).then(function () {\n\t      return ele.animation({\n\t        style: style,\n\t        duration: duration,\n\t        easing: ele.pstyle('transition-timing-function').value,\n\t        queue: false\n\t      }).play().promise();\n\t    }).then(function () {\n\t      // if( !isBypass ){\n\t      self.removeBypasses(ele, props);\n\t      ele.emitAndNotify('style');\n\t      // }\n\t\n\t      _p.transitioning = false;\n\t    });\n\t  } else if (_p.transitioning) {\n\t    this.removeBypasses(ele, props);\n\t    ele.emitAndNotify('style');\n\t\n\t    _p.transitioning = false;\n\t  }\n\t};\n\t\n\tstyfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n\t  var prop = this.properties[name];\n\t\n\t  if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {\n\t    this._private.cy.notify({\n\t      type: 'zorder',\n\t      eles: ele\n\t    });\n\t  }\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 123 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\tvar util = __webpack_require__(1);\n\t\n\tvar styfn = {};\n\t\n\t// bypasses are applied to an existing style on an element, and just tacked on temporarily\n\t// returns true iff application was successful for at least 1 specified property\n\tstyfn.applyBypass = function (eles, name, value, updateTransitions) {\n\t  var self = this;\n\t  var props = [];\n\t  var isBypass = true;\n\t\n\t  // put all the properties (can specify one or many) in an array after parsing them\n\t  if (name === '*' || name === '**') {\n\t    // apply to all property names\n\t\n\t    if (value !== undefined) {\n\t      for (var i = 0; i < self.properties.length; i++) {\n\t        var prop = self.properties[i];\n\t        var _name = prop.name;\n\t\n\t        var parsedProp = this.parse(_name, value, true);\n\t\n\t        if (parsedProp) {\n\t          props.push(parsedProp);\n\t        }\n\t      }\n\t    }\n\t  } else if (is.string(name)) {\n\t    // then parse the single property\n\t    var _parsedProp = this.parse(name, value, true);\n\t\n\t    if (_parsedProp) {\n\t      props.push(_parsedProp);\n\t    }\n\t  } else if (is.plainObject(name)) {\n\t    // then parse each property\n\t    var specifiedProps = name;\n\t    updateTransitions = value;\n\t\n\t    var names = Object.keys(specifiedProps);\n\t\n\t    for (var _i = 0; _i < names.length; _i++) {\n\t      var _name2 = names[_i];\n\t      var _prop = self.properties[_name2];\n\t      var _value = specifiedProps[_name2];\n\t\n\t      if (_value === undefined) {\n\t        // try camel case name too\n\t        _value = specifiedProps[util.dash2camel(_name2)];\n\t      }\n\t\n\t      if (_value !== undefined) {\n\t        var _parsedProp2 = this.parse(_name2, _value, true);\n\t\n\t        if (_parsedProp2) {\n\t          props.push(_parsedProp2);\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    // can't do anything without well defined properties\n\t    return false;\n\t  }\n\t\n\t  // we've failed if there are no valid properties\n\t  if (props.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  // now, apply the bypass properties on the elements\n\t  var ret = false; // return true if at least one succesful bypass applied\n\t  for (var _i2 = 0; _i2 < eles.length; _i2++) {\n\t    // for each ele\n\t    var ele = eles[_i2];\n\t    var diffProps = {};\n\t    var diffProp = void 0;\n\t\n\t    for (var j = 0; j < props.length; j++) {\n\t      // for each prop\n\t      var _prop2 = props[j];\n\t\n\t      if (updateTransitions) {\n\t        var prevProp = ele.pstyle(_prop2.name);\n\t        diffProp = diffProps[_prop2.name] = { prev: prevProp };\n\t      }\n\t\n\t      ret = this.applyParsedProperty(ele, _prop2) || ret;\n\t\n\t      if (updateTransitions) {\n\t        diffProp.next = ele.pstyle(_prop2.name);\n\t      }\n\t    } // for props\n\t\n\t    if (ret) {\n\t      this.updateStyleHints(ele);\n\t    }\n\t\n\t    if (updateTransitions) {\n\t      this.updateTransitions(ele, diffProps, isBypass);\n\t    }\n\t  } // for eles\n\t\n\t  return ret;\n\t};\n\t\n\t// only useful in specific cases like animation\n\tstyfn.overrideBypass = function (eles, name, value) {\n\t  name = util.camel2dash(name);\n\t\n\t  for (var i = 0; i < eles.length; i++) {\n\t    var ele = eles[i];\n\t    var prop = ele._private.style[name];\n\t    var type = this.properties[name].type;\n\t    var isColor = type.color;\n\t    var isMulti = type.mutiple;\n\t\n\t    if (!prop || !prop.bypass) {\n\t      // need a bypass if one doesn't exist\n\t      this.applyBypass(ele, name, value);\n\t      continue;\n\t    }\n\t\n\t    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;\n\t\n\t    prop.value = value;\n\t\n\t    if (prop.pfValue != null) {\n\t      prop.pfValue = value;\n\t    }\n\t\n\t    if (isColor) {\n\t      prop.strValue = 'rgb(' + value.join(',') + ')';\n\t    } else if (isMulti) {\n\t      prop.strValue = value.join(' ');\n\t    } else {\n\t      prop.strValue = '' + value;\n\t    }\n\t\n\t    this.checkZOrderTrigger(ele, name, oldValue, value);\n\t  }\n\t};\n\t\n\tstyfn.removeAllBypasses = function (eles, updateTransitions) {\n\t  return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n\t};\n\t\n\tstyfn.removeBypasses = function (eles, props, updateTransitions) {\n\t  var isBypass = true;\n\t\n\t  for (var j = 0; j < eles.length; j++) {\n\t    var ele = eles[j];\n\t    var diffProps = {};\n\t\n\t    for (var i = 0; i < props.length; i++) {\n\t      var name = props[i];\n\t      var prop = this.properties[name];\n\t      var prevProp = ele.pstyle(prop.name);\n\t\n\t      if (!prevProp || !prevProp.bypass) {\n\t        // if a bypass doesn't exist for the prop, nothing needs to be removed\n\t        continue;\n\t      }\n\t\n\t      var value = ''; // empty => remove bypass\n\t      var parsedProp = this.parse(name, value, true);\n\t      var diffProp = diffProps[prop.name] = { prev: prevProp };\n\t\n\t      this.applyParsedProperty(ele, parsedProp);\n\t\n\t      diffProp.next = ele.pstyle(prop.name);\n\t    } // for props\n\t\n\t    this.updateStyleHints(ele);\n\t\n\t    if (updateTransitions) {\n\t      this.updateTransitions(ele, diffProps, isBypass);\n\t    }\n\t  } // for eles\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 124 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar window = __webpack_require__(4);\n\t\n\tvar styfn = {};\n\t\n\t// gets what an em size corresponds to in pixels relative to a dom element\n\tstyfn.getEmSizeInPixels = function () {\n\t  var px = this.containerCss('font-size');\n\t\n\t  if (px != null) {\n\t    return parseFloat(px);\n\t  } else {\n\t    return 1; // for headless\n\t  }\n\t};\n\t\n\t// gets css property from the core container\n\tstyfn.containerCss = function (propName) {\n\t  var cy = this._private.cy;\n\t  var domElement = cy.container();\n\t\n\t  if (window && domElement && window.getComputedStyle) {\n\t    return window.getComputedStyle(domElement).getPropertyValue(propName);\n\t  }\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 125 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar styfn = {};\n\t\n\t// gets the rendered style for an element\n\tstyfn.getRenderedStyle = function (ele, prop) {\n\t  if (prop) {\n\t    return this.getStylePropertyValue(ele, prop, true);\n\t  } else {\n\t    return this.getRawStyle(ele, true);\n\t  }\n\t};\n\t\n\t// gets the raw style for an element\n\tstyfn.getRawStyle = function (ele, isRenderedVal) {\n\t  var self = this;\n\t\n\t  ele = ele[0]; // insure it's an element\n\t\n\t  if (ele) {\n\t    var rstyle = {};\n\t\n\t    for (var i = 0; i < self.properties.length; i++) {\n\t      var prop = self.properties[i];\n\t      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\t\n\t      if (val != null) {\n\t        rstyle[prop.name] = val;\n\t        rstyle[util.dash2camel(prop.name)] = val;\n\t      }\n\t    }\n\t\n\t    return rstyle;\n\t  }\n\t};\n\t\n\tstyfn.getIndexedStyle = function (ele, property, subproperty, index) {\n\t  var pstyle = ele.pstyle(property)[subproperty][index];\n\t  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n\t};\n\t\n\tstyfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n\t  var self = this;\n\t\n\t  ele = ele[0]; // insure it's an element\n\t\n\t  if (ele) {\n\t    var prop = self.properties[propName];\n\t\n\t    if (prop.alias) {\n\t      prop = prop.pointsTo;\n\t    }\n\t\n\t    var type = prop.type;\n\t    var styleProp = ele.pstyle(prop.name);\n\t    var zoom = ele.cy().zoom();\n\t\n\t    if (styleProp) {\n\t      var units = styleProp.units ? type.implicitUnits || 'px' : null;\n\t      var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {\n\t        return pfValue * (isRenderedVal ? zoom : 1) + units;\n\t      }).join(' ') : styleProp.strValue;\n\t\n\t      return val;\n\t    }\n\t  }\n\t};\n\t\n\tstyfn.getAnimationStartStyle = function (ele, aniProps) {\n\t  var rstyle = {};\n\t\n\t  for (var i = 0; i < aniProps.length; i++) {\n\t    var aniProp = aniProps[i];\n\t    var name = aniProp.name;\n\t\n\t    var styleProp = ele.pstyle(name);\n\t\n\t    if (styleProp !== undefined) {\n\t      // then make a prop of it\n\t      if (is.plainObject(styleProp)) {\n\t        styleProp = this.parse(name, styleProp.strValue);\n\t      } else {\n\t        styleProp = this.parse(name, styleProp);\n\t      }\n\t    }\n\t\n\t    if (styleProp) {\n\t      rstyle[name] = styleProp;\n\t    }\n\t  }\n\t\n\t  return rstyle;\n\t};\n\t\n\tstyfn.getPropsList = function (propsObj) {\n\t  var self = this;\n\t  var rstyle = [];\n\t  var style = propsObj;\n\t  var props = self.properties;\n\t\n\t  if (style) {\n\t    var names = Object.keys(style);\n\t\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t      var val = style[name];\n\t      var prop = props[name] || props[util.camel2dash(name)];\n\t      var styleProp = this.parse(prop.name, val);\n\t\n\t      if (styleProp) {\n\t        rstyle.push(styleProp);\n\t      }\n\t    }\n\t  }\n\t\n\t  return rstyle;\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 126 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar styfn = {};\n\t\n\tstyfn.appendFromJson = function (json) {\n\t  var style = this;\n\t\n\t  for (var i = 0; i < json.length; i++) {\n\t    var context = json[i];\n\t    var selector = context.selector;\n\t    var props = context.style || context.css;\n\t    var names = Object.keys(props);\n\t\n\t    style.selector(selector); // apply selector\n\t\n\t    for (var j = 0; j < names.length; j++) {\n\t      var name = names[j];\n\t      var value = props[name];\n\t\n\t      style.css(name, value); // apply property\n\t    }\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\t// accessible cy.style() function\n\tstyfn.fromJson = function (json) {\n\t  var style = this;\n\t\n\t  style.resetToDefault();\n\t  style.appendFromJson(json);\n\t\n\t  return style;\n\t};\n\t\n\t// get json from cy.style() api\n\tstyfn.json = function () {\n\t  var json = [];\n\t\n\t  for (var i = this.defaultLength; i < this.length; i++) {\n\t    var cxt = this[i];\n\t    var selector = cxt.selector;\n\t    var props = cxt.properties;\n\t    var css = {};\n\t\n\t    for (var j = 0; j < props.length; j++) {\n\t      var prop = props[j];\n\t      css[prop.name] = prop.strValue;\n\t    }\n\t\n\t    json.push({\n\t      selector: !selector ? 'core' : selector.toString(),\n\t      style: css\n\t    });\n\t  }\n\t\n\t  return json;\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 127 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\tvar math = __webpack_require__(2);\n\t\n\tvar styfn = {};\n\t\n\t// a caching layer for property parsing\n\tstyfn.parse = function (name, value, propIsBypass, propIsFlat) {\n\t  var self = this;\n\t\n\t  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\t  if (is.fn(value)) {\n\t    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n\t  }\n\t\n\t  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n\t  var argHash = [name, value, propIsBypass, flatKey].join('$');\n\t  var propCache = self.propCache = self.propCache || {};\n\t  var ret = void 0;\n\t\n\t  if (!(ret = propCache[argHash])) {\n\t    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n\t  }\n\t\n\t  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n\t  // - mappings can't be shared b/c mappings are per-element\n\t  if (propIsBypass || propIsFlat === 'mapping') {\n\t    // need a copy since props are mutated later in their lifecycles\n\t    ret = util.copy(ret);\n\t\n\t    if (ret) {\n\t      ret.value = util.copy(ret.value); // because it could be an array, e.g. colour\n\t    }\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\tstyfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n\t  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\t\n\t  if (!prop && value != null) {\n\t    util.error('The style property `%s: %s` is invalid', name, value);\n\t  }\n\t\n\t  return prop;\n\t};\n\t\n\t// parse a property; return null on invalid; return parsed property otherwise\n\t// fields :\n\t// - name : the name of the property\n\t// - value : the parsed, native-typed value of the property\n\t// - strValue : a string value that represents the property value in valid css\n\t// - bypass : true iff the property is a bypass property\n\tstyfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n\t  var self = this;\n\t\n\t  name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\t\n\t  var property = self.properties[name];\n\t  var passedValue = value;\n\t  var types = self.types;\n\t\n\t  if (!property) {\n\t    return null;\n\t  } // return null on property of unknown name\n\t  if (value === undefined || value === null) {\n\t    return null;\n\t  } // can't assign null\n\t\n\t  // the property may be an alias\n\t  if (property.alias) {\n\t    property = property.pointsTo;\n\t    name = property.name;\n\t  }\n\t\n\t  var valueIsString = is.string(value);\n\t  if (valueIsString) {\n\t    // trim the value to make parsing easier\n\t    value = value.trim();\n\t  }\n\t\n\t  var type = property.type;\n\t  if (!type) {\n\t    return null;\n\t  } // no type, no luck\n\t\n\t  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\t  if (propIsBypass && (value === '' || value === null)) {\n\t    return {\n\t      name: name,\n\t      value: value,\n\t      bypass: true,\n\t      deleteBypass: true\n\t    };\n\t  }\n\t\n\t  // check if value is a function used as a mapper\n\t  if (is.fn(value)) {\n\t    return {\n\t      name: name,\n\t      value: value,\n\t      strValue: 'fn',\n\t      mapped: types.fn,\n\t      bypass: propIsBypass\n\t    };\n\t  }\n\t\n\t  // check if value is mapped\n\t  var data = void 0,\n\t      mapData = void 0;\n\t  if (!valueIsString || propIsFlat) {\n\t    // then don't bother to do the expensive regex checks\n\t\n\t  } else if (data = new RegExp(types.data.regex).exec(value)) {\n\t    if (propIsBypass) {\n\t      return false;\n\t    } // mappers not allowed in bypass\n\t\n\t    var mapped = types.data;\n\t\n\t    return {\n\t      name: name,\n\t      value: data,\n\t      strValue: '' + value,\n\t      mapped: mapped,\n\t      field: data[1],\n\t      bypass: propIsBypass\n\t    };\n\t  } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {\n\t    if (propIsBypass) {\n\t      return false;\n\t    } // mappers not allowed in bypass\n\t    if (type.multiple) {\n\t      return false;\n\t    } // impossible to map to num\n\t\n\t    var _mapped = types.mapData;\n\t\n\t    // we can map only if the type is a colour or a number\n\t    if (!(type.color || type.number)) {\n\t      return false;\n\t    }\n\t\n\t    var valueMin = this.parse(name, mapData[4]); // parse to validate\n\t    if (!valueMin || valueMin.mapped) {\n\t      return false;\n\t    } // can't be invalid or mapped\n\t\n\t    var valueMax = this.parse(name, mapData[5]); // parse to validate\n\t    if (!valueMax || valueMax.mapped) {\n\t      return false;\n\t    } // can't be invalid or mapped\n\t\n\t    // check if valueMin and valueMax are the same\n\t    if (valueMin.value === valueMax.value) {\n\t      return false; // can't make much of a mapper without a range\n\t    } else if (type.color) {\n\t      var c1 = valueMin.value;\n\t      var c2 = valueMax.value;\n\t\n\t      var same = c1[0] === c2[0] // red\n\t      && c1[1] === c2[1] // green\n\t      && c1[2] === c2[2] // blue\n\t      && ( // optional alpha\n\t      c1[3] === c2[3] // same alpha outright\n\t      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?\n\t      c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n\t      );\n\t\n\t      if (same) {\n\t        return false;\n\t      } // can't make a mapper without a range\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: mapData,\n\t      strValue: '' + value,\n\t      mapped: _mapped,\n\t      field: mapData[1],\n\t      fieldMin: parseFloat(mapData[2]), // min & max are numeric\n\t      fieldMax: parseFloat(mapData[3]),\n\t      valueMin: valueMin.value,\n\t      valueMax: valueMax.value,\n\t      bypass: propIsBypass\n\t    };\n\t  }\n\t\n\t  if (type.multiple && propIsFlat !== 'multiple') {\n\t    var vals = void 0;\n\t\n\t    if (valueIsString) {\n\t      vals = value.split(/\\s+/);\n\t    } else if (is.array(value)) {\n\t      vals = value;\n\t    } else {\n\t      vals = [value];\n\t    }\n\t\n\t    if (type.evenMultiple && vals.length % 2 !== 0) {\n\t      return null;\n\t    }\n\t\n\t    var valArr = [];\n\t    var unitsArr = [];\n\t    var pfValArr = [];\n\t    var hasEnum = false;\n\t\n\t    for (var i = 0; i < vals.length; i++) {\n\t      var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n\t\n\t      hasEnum = hasEnum || is.string(p.value);\n\t\n\t      valArr.push(p.value);\n\t      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n\t      unitsArr.push(p.units);\n\t    }\n\t\n\t    if (type.validate && !type.validate(valArr, unitsArr)) {\n\t      return null;\n\t    }\n\t\n\t    if (type.singleEnum && hasEnum) {\n\t      if (valArr.length === 1 && is.string(valArr[0])) {\n\t        return {\n\t          name: name,\n\t          value: valArr[0],\n\t          strValue: valArr[0],\n\t          bypass: propIsBypass\n\t        };\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: valArr,\n\t      pfValue: pfValArr,\n\t      strValue: valArr.join(' '),\n\t      bypass: propIsBypass,\n\t      units: unitsArr\n\t    };\n\t  }\n\t\n\t  // several types also allow enums\n\t  var checkEnums = function checkEnums() {\n\t    for (var _i = 0; _i < type.enums.length; _i++) {\n\t      var en = type.enums[_i];\n\t\n\t      if (en === value) {\n\t        return {\n\t          name: name,\n\t          value: value,\n\t          strValue: '' + value,\n\t          bypass: propIsBypass\n\t        };\n\t      }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  // check the type and return the appropriate object\n\t  if (type.number) {\n\t    var units = void 0;\n\t    var implicitUnits = 'px'; // not set => px\n\t\n\t    if (type.units) {\n\t      // use specified units if set\n\t      units = type.units;\n\t    }\n\t\n\t    if (type.implicitUnits) {\n\t      implicitUnits = type.implicitUnits;\n\t    }\n\t\n\t    if (!type.unitless) {\n\t      if (valueIsString) {\n\t        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\t        if (units) {\n\t          unitsRegex = units;\n\t        } // only allow explicit units if so set\n\t        var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');\n\t\n\t        if (match) {\n\t          value = match[1];\n\t          units = match[2] || implicitUnits;\n\t        }\n\t      } else if (!units || type.implicitUnits) {\n\t        units = implicitUnits; // implicitly px if unspecified\n\t      }\n\t    }\n\t\n\t    value = parseFloat(value);\n\t\n\t    // if not a number and enums not allowed, then the value is invalid\n\t    if (isNaN(value) && type.enums === undefined) {\n\t      return null;\n\t    }\n\t\n\t    // check if this number type also accepts special keywords in place of numbers\n\t    // (i.e. `left`, `auto`, etc)\n\t    if (isNaN(value) && type.enums !== undefined) {\n\t      value = passedValue;\n\t\n\t      return checkEnums();\n\t    }\n\t\n\t    // check if value must be an integer\n\t    if (type.integer && !is.integer(value)) {\n\t      return null;\n\t    }\n\t\n\t    // check value is within range\n\t    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n\t      return null;\n\t    }\n\t\n\t    var ret = {\n\t      name: name,\n\t      value: value,\n\t      strValue: '' + value + (units ? units : ''),\n\t      units: units,\n\t      bypass: propIsBypass\n\t    };\n\t\n\t    // normalise value in pixels\n\t    if (type.unitless || units !== 'px' && units !== 'em') {\n\t      ret.pfValue = value;\n\t    } else {\n\t      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n\t    }\n\t\n\t    // normalise value in ms\n\t    if (units === 'ms' || units === 's') {\n\t      ret.pfValue = units === 'ms' ? value : 1000 * value;\n\t    }\n\t\n\t    // normalise value in rad\n\t    if (units === 'deg' || units === 'rad') {\n\t      ret.pfValue = units === 'rad' ? value : math.deg2rad(value);\n\t    }\n\t\n\t    // normalize value in %\n\t    if (units === '%') {\n\t      ret.pfValue = value / 100;\n\t    }\n\t\n\t    return ret;\n\t  } else if (type.propList) {\n\t\n\t    var props = [];\n\t    var propsStr = '' + value;\n\t\n\t    if (propsStr === 'none') {\n\t      // leave empty\n\t\n\t    } else {\n\t      // go over each prop\n\t\n\t      var propsSplit = propsStr.split(',');\n\t      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n\t        var propName = propsSplit[_i2].trim();\n\t\n\t        if (self.properties[propName]) {\n\t          props.push(propName);\n\t        }\n\t      }\n\t\n\t      if (props.length === 0) {\n\t        return null;\n\t      }\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: props,\n\t      strValue: props.length === 0 ? 'none' : props.join(', '),\n\t      bypass: propIsBypass\n\t    };\n\t  } else if (type.color) {\n\t    var tuple = util.color2tuple(value);\n\t\n\t    if (!tuple) {\n\t      return null;\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: tuple,\n\t      pfValue: tuple,\n\t      strValue: '' + value,\n\t      bypass: propIsBypass\n\t    };\n\t  } else if (type.regex || type.regexes) {\n\t\n\t    // first check enums\n\t    if (type.enums) {\n\t      var enumProp = checkEnums();\n\t\n\t      if (enumProp) {\n\t        return enumProp;\n\t      }\n\t    }\n\t\n\t    var regexes = type.regexes ? type.regexes : [type.regex];\n\t\n\t    for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n\t      var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n\t      var m = regex.exec(value);\n\t\n\t      if (m) {\n\t        // regex matches\n\t        return {\n\t          name: name,\n\t          value: type.singleRegexMatchValue ? m[1] : m,\n\t          strValue: '' + value,\n\t          bypass: propIsBypass\n\t        };\n\t      }\n\t    }\n\t\n\t    return null; // didn't match any\n\t  } else if (type.string) {\n\t    // just return\n\t    return {\n\t      name: name,\n\t      value: '' + value,\n\t      strValue: '' + value,\n\t      bypass: propIsBypass\n\t    };\n\t  } else if (type.enums) {\n\t    // check enums last because it's a combo type in others\n\t    return checkEnums();\n\t  } else {\n\t    return null; // not a type we can handle\n\t  }\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 128 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar is = __webpack_require__(0);\n\t\n\tvar styfn = {};\n\t\n\t(function () {\n\t  var number = util.regex.number;\n\t  var rgba = util.regex.rgbaNoBackRefs;\n\t  var hsla = util.regex.hslaNoBackRefs;\n\t  var hex3 = util.regex.hex3;\n\t  var hex6 = util.regex.hex6;\n\t  var data = function data(prefix) {\n\t    return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n\t  };\n\t  var mapData = function mapData(prefix) {\n\t    var mapArg = number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;\n\t    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n\t  };\n\t  var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$'];\n\t\n\t  // each visual style property has a type and needs to be validated according to it\n\t  styfn.types = {\n\t    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n\t    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },\n\t    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n\t    zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },\n\t    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n\t    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n\t    position: { enums: ['parent', 'origin'] },\n\t    nodeSize: { number: true, min: 0, enums: ['label'] },\n\t    number: { number: true, unitless: true },\n\t    numbers: { number: true, unitless: true, multiple: true },\n\t    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },\n\t    size: { number: true, min: 0 },\n\t    bidirectionalSize: { number: true }, // allows negative\n\t    bidirectionalSizes: { number: true, multiple: true }, // allows negative\n\t    sizeMaybePercent: { number: true, min: 0, allowPercent: true },\n\t    paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },\n\t    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },\n\t    bgPos: { number: true, allowPercent: true, multiple: true },\n\t    bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },\n\t    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },\n\t    bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },\n\t    bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },\n\t    bgClip: { enums: ['none', 'node'] },\n\t    color: { color: true },\n\t    bool: { enums: ['yes', 'no'] },\n\t    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },\n\t    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },\n\t    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },\n\t    fontFamily: { regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$' },\n\t    fontletiant: { enums: ['small-caps', 'normal'] },\n\t    fontStyle: { enums: ['italic', 'normal', 'oblique'] },\n\t    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },\n\t    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },\n\t    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },\n\t    textWrap: { enums: ['none', 'wrap', 'ellipsis'] },\n\t    textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },\n\t    nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },\n\t    compoundIncludeLabels: { enums: ['include', 'exclude'] },\n\t    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },\n\t    arrowFill: { enums: ['filled', 'hollow'] },\n\t    display: { enums: ['element', 'none'] },\n\t    visibility: { enums: ['hidden', 'visible'] },\n\t    zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },\n\t    zIndexCompare: { enums: ['auto', 'manual'] },\n\t    valign: { enums: ['top', 'center', 'bottom'] },\n\t    halign: { enums: ['left', 'center', 'right'] },\n\t    text: { string: true },\n\t    data: { mapping: true, regex: data('data') },\n\t    layoutData: { mapping: true, regex: data('layoutData') },\n\t    scratch: { mapping: true, regex: data('scratch') },\n\t    mapData: { mapping: true, regex: mapData('mapData') },\n\t    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },\n\t    mapScratch: { mapping: true, regex: mapData('mapScratch') },\n\t    fn: { mapping: true, fn: true },\n\t    url: { regexes: urlRegexes, singleRegexMatchValue: true },\n\t    urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },\n\t    propList: { propList: true },\n\t    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },\n\t    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },\n\t    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },\n\t    edgeDistances: { enums: ['intersection', 'node-position'] },\n\t    edgeEndpoint: {\n\t      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',\n\t      enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,\n\t      validate: function validate(valArr, unitsArr) {\n\t        switch (valArr.length) {\n\t          case 2:\n\t            // can be % or px only\n\t            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n\t          case 1:\n\t            // can be enum, deg, or rad only\n\t            return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n\t          default:\n\t            return false;\n\t        }\n\t      }\n\t    },\n\t    easing: {\n\t      regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$'],\n\t      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n\t    }\n\t  };\n\t\n\t  var zOrderDiff = {\n\t    zeroNonZero: function zeroNonZero(val1, val2) {\n\t      if (val1 === 0 && val2 !== 0) {\n\t        return true;\n\t      } else if (val1 !== 0 && val2 === 0) {\n\t        return true;\n\t      } else {\n\t        return false;\n\t      }\n\t    },\n\t    anyDiff: function anyDiff(val1, val2) {\n\t      return val1 !== val2;\n\t    }\n\t  };\n\t\n\t  var zd = zOrderDiff;\n\t\n\t  // define visual style properties\n\t  var t = styfn.types;\n\t  var props = styfn.properties = [\n\t  // main label\n\t  { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },\n\t\n\t  // source label\n\t  { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },\n\t\n\t  // target label\n\t  { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },\n\t\n\t  // common label style\n\t  { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },\n\t  // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n\t  { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },\n\t  // { name: 'font-letiant', type: t.fontletiant }, // not useful\n\t  { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },\n\t\n\t  // behaviour\n\t  { name: 'events', type: t.bool },\n\t\n\t  // visibility\n\t  { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },\n\t\n\t  // overlays\n\t  { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },\n\t\n\t  // transition anis\n\t  { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },\n\t\n\t  // node body\n\t  { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },\n\t\n\t  // node border\n\t  { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },\n\t\n\t  // node background images\n\t  { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },\n\t\n\t  // compound props\n\t  { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },\n\t\n\t  // edge line\n\t  { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },\n\t\n\t  // ghost properties\n\t  { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },\n\t\n\t  // these are just for the core\n\t  { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];\n\t\n\t  // define aliases\n\t  var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];\n\t\n\t  // pie backgrounds for nodes\n\t  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\t  props.push({ name: 'pie-size', type: t.sizeMaybePercent });\n\t  for (var i = 1; i <= styfn.pieBackgroundN; i++) {\n\t    props.push({ name: 'pie-' + i + '-background-color', type: t.color });\n\t    props.push({ name: 'pie-' + i + '-background-size', type: t.percent });\n\t    props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });\n\t  }\n\t\n\t  // edge arrows\n\t  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n\t  [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {\n\t    arrowPrefixes.forEach(function (prefix) {\n\t      var name = prefix + '-' + prop.name;\n\t      var type = prop.type;\n\t\n\t      props.push({ name: name, type: type });\n\t    });\n\t  }, {});\n\t\n\t  // list of property names\n\t  styfn.propertyNames = props.map(function (p) {\n\t    return p.name;\n\t  });\n\t\n\t  // allow access of properties by name ( e.g. style.properties.height )\n\t  for (var _i = 0; _i < props.length; _i++) {\n\t    var prop = props[_i];\n\t\n\t    props[prop.name] = prop; // allow lookup by name\n\t  }\n\t\n\t  // map aliases\n\t  for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n\t    var alias = aliases[_i2];\n\t    var pointsToProp = props[alias.pointsTo];\n\t    var aliasProp = {\n\t      name: alias.name,\n\t      alias: true,\n\t      pointsTo: pointsToProp\n\t    };\n\t\n\t    // add alias prop for parsing\n\t    props.push(aliasProp);\n\t\n\t    props[alias.name] = aliasProp; // allow lookup by name\n\t  }\n\t})();\n\t\n\tstyfn.getDefaultProperty = function (name) {\n\t  return this.getDefaultProperties()[name];\n\t};\n\t\n\tstyfn.getDefaultProperties = util.memoize(function () {\n\t  var rawProps = util.extend({\n\t    // common node/edge props\n\t    'events': 'yes',\n\t    'text-events': 'no',\n\t    'text-valign': 'top',\n\t    'text-halign': 'center',\n\t    'color': '#000',\n\t    'text-outline-color': '#000',\n\t    'text-outline-width': 0,\n\t    'text-outline-opacity': 1,\n\t    'text-opacity': 1,\n\t    'text-decoration': 'none',\n\t    'text-transform': 'none',\n\t    'text-wrap': 'none',\n\t    'text-max-width': 9999,\n\t    'text-background-color': '#000',\n\t    'text-background-opacity': 0,\n\t    'text-background-shape': 'rectangle',\n\t    'text-background-padding': 0,\n\t    'text-border-opacity': 0,\n\t    'text-border-width': 0,\n\t    'text-border-style': 'solid',\n\t    'text-border-color': '#000',\n\t    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n\t    'font-style': 'normal',\n\t    // 'font-letiant': fontletiant,\n\t    'font-weight': 'normal',\n\t    'font-size': 16,\n\t    'min-zoomed-font-size': 0,\n\t    'text-rotation': 'none',\n\t    'source-text-rotation': 'none',\n\t    'target-text-rotation': 'none',\n\t    'visibility': 'visible',\n\t    'display': 'element',\n\t    'opacity': 1,\n\t    'z-compound-depth': 'auto',\n\t    'z-index-compare': 'auto',\n\t    'z-index': 0,\n\t    'label': '',\n\t    'text-margin-x': 0,\n\t    'text-margin-y': 0,\n\t    'source-label': '',\n\t    'source-text-offset': 0,\n\t    'source-text-margin-x': 0,\n\t    'source-text-margin-y': 0,\n\t    'target-label': '',\n\t    'target-text-offset': 0,\n\t    'target-text-margin-x': 0,\n\t    'target-text-margin-y': 0,\n\t    'overlay-opacity': 0,\n\t    'overlay-color': '#000',\n\t    'overlay-padding': 10,\n\t    'transition-property': 'none',\n\t    'transition-duration': 0,\n\t    'transition-delay': 0,\n\t    'transition-timing-function': 'linear',\n\t\n\t    // node props\n\t    'background-blacken': 0,\n\t    'background-color': '#999',\n\t    'background-opacity': 1,\n\t    'background-image': 'none',\n\t    'background-image-crossorigin': 'anonymous',\n\t    'background-image-opacity': 1,\n\t    'background-position-x': '50%',\n\t    'background-position-y': '50%',\n\t    'background-width-relative-to': 'include-padding',\n\t    'background-height-relative-to': 'include-padding',\n\t    'background-repeat': 'no-repeat',\n\t    'background-fit': 'none',\n\t    'background-clip': 'node',\n\t    'background-width': 'auto',\n\t    'background-height': 'auto',\n\t    'border-color': '#000',\n\t    'border-opacity': 1,\n\t    'border-width': 0,\n\t    'border-style': 'solid',\n\t    'height': 30,\n\t    'width': 30,\n\t    'shape': 'ellipse',\n\t    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n\t\n\t    // ghost props\n\t    'ghost': 'no',\n\t    'ghost-offset-y': 0,\n\t    'ghost-offset-x': 0,\n\t    'ghost-opacity': 0,\n\t\n\t    // compound props\n\t    'padding': 0,\n\t    'padding-relative-to': 'width',\n\t    'position': 'origin',\n\t    'compound-sizing-wrt-labels': 'include',\n\t    'min-width': 0,\n\t    'min-width-bias-left': 0,\n\t    'min-width-bias-right': 0,\n\t    'min-height': 0,\n\t    'min-height-bias-top': 0,\n\t    'min-height-bias-bottom': 0\n\t  }, {\n\t    // node pie bg\n\t    'pie-size': '100%'\n\t  }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {\n\t    for (var i = 1; i <= styfn.pieBackgroundN; i++) {\n\t      var name = prop.name.replace('{{i}}', i);\n\t      var val = prop.value;\n\t\n\t      css[name] = val;\n\t    }\n\t\n\t    return css;\n\t  }, {}), {\n\t    // edge props\n\t    'line-style': 'solid',\n\t    'line-color': '#999',\n\t    'control-point-step-size': 40,\n\t    'control-point-weights': 0.5,\n\t    'segment-weights': 0.5,\n\t    'segment-distances': 20,\n\t    'edge-distances': 'intersection',\n\t    'curve-style': 'bezier',\n\t    'haystack-radius': 0,\n\t    'arrow-scale': 1,\n\t    'loop-direction': '-45deg',\n\t    'loop-sweep': '-90deg',\n\t    'source-distance-from-node': 0,\n\t    'target-distance-from-node': 0,\n\t    'source-endpoint': 'outside-to-node',\n\t    'target-endpoint': 'outside-to-node'\n\t  }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {\n\t    styfn.arrowPrefixes.forEach(function (prefix) {\n\t      var name = prefix + '-' + prop.name;\n\t      var val = prop.value;\n\t\n\t      css[name] = val;\n\t    });\n\t\n\t    return css;\n\t  }, {}));\n\t\n\t  var parsedProps = {};\n\t\n\t  for (var i = 0; i < this.properties.length; i++) {\n\t    var prop = this.properties[i];\n\t\n\t    if (prop.pointsTo) {\n\t      continue;\n\t    }\n\t\n\t    var name = prop.name;\n\t    var val = rawProps[name];\n\t    var parsedProp = this.parse(name, val);\n\t\n\t    parsedProps[name] = parsedProp;\n\t  }\n\t\n\t  return parsedProps;\n\t});\n\t\n\tstyfn.addDefaultStylesheet = function () {\n\t  this.selector('$node > node') // compound (parent) node properties\n\t  .css({\n\t    'shape': 'rectangle',\n\t    'padding': 10,\n\t    'background-color': '#eee',\n\t    'border-color': '#ccc',\n\t    'border-width': 1\n\t  }).selector('edge') // just edge properties\n\t  .css({\n\t    'width': 3,\n\t    'curve-style': 'haystack'\n\t  }).selector(':parent <-> node').css({\n\t    'curve-style': 'bezier',\n\t    'source-endpoint': 'outside-to-line',\n\t    'target-endpoint': 'outside-to-line'\n\t  }).selector(':selected').css({\n\t    'background-color': '#0169D9',\n\t    'line-color': '#0169D9',\n\t    'source-arrow-color': '#0169D9',\n\t    'target-arrow-color': '#0169D9',\n\t    'mid-source-arrow-color': '#0169D9',\n\t    'mid-target-arrow-color': '#0169D9'\n\t  }).selector('node:parent:selected').css({\n\t    'background-color': '#CCE1F9',\n\t    'border-color': '#aec8e5'\n\t  }).selector(':active').css({\n\t    'overlay-color': 'black',\n\t    'overlay-padding': 10,\n\t    'overlay-opacity': 0.25\n\t  }).selector('core') // just core properties\n\t  .css({\n\t    'selection-box-color': '#ddd',\n\t    'selection-box-opacity': 0.65,\n\t    'selection-box-border-color': '#aaa',\n\t    'selection-box-border-width': 1,\n\t    'active-bg-color': 'black',\n\t    'active-bg-opacity': 0.15,\n\t    'active-bg-size': 30,\n\t    'outside-texture-bg-color': '#000',\n\t    'outside-texture-bg-opacity': 0.125\n\t  });\n\t\n\t  this.defaultLength = this.length;\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 129 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar util = __webpack_require__(1);\n\tvar Selector = __webpack_require__(6);\n\t\n\tvar styfn = {};\n\t\n\tstyfn.appendFromString = function (string) {\n\t  var self = this;\n\t  var style = this;\n\t  var remaining = '' + string;\n\t  var selAndBlockStr = void 0;\n\t  var blockRem = void 0;\n\t  var propAndValStr = void 0;\n\t\n\t  // remove comments from the style string\n\t  remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\t\n\t  function removeSelAndBlockFromRemaining() {\n\t    // remove the parsed selector and block from the remaining text to parse\n\t    if (remaining.length > selAndBlockStr.length) {\n\t      remaining = remaining.substr(selAndBlockStr.length);\n\t    } else {\n\t      remaining = '';\n\t    }\n\t  }\n\t\n\t  function removePropAndValFromRem() {\n\t    // remove the parsed property and value from the remaining block text to parse\n\t    if (blockRem.length > propAndValStr.length) {\n\t      blockRem = blockRem.substr(propAndValStr.length);\n\t    } else {\n\t      blockRem = '';\n\t    }\n\t  }\n\t\n\t  while (true) {\n\t    var nothingLeftToParse = remaining.match(/^\\s*$/);\n\t    if (nothingLeftToParse) {\n\t      break;\n\t    }\n\t\n\t    var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\t\n\t    if (!selAndBlock) {\n\t      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n\t      break;\n\t    }\n\t\n\t    selAndBlockStr = selAndBlock[0];\n\t\n\t    // parse the selector\n\t    var selectorStr = selAndBlock[1];\n\t    if (selectorStr !== 'core') {\n\t      var selector = new Selector(selectorStr);\n\t      if (selector._private.invalid) {\n\t        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n\t\n\t        // skip this selector and block\n\t        removeSelAndBlockFromRemaining();\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // parse the block of properties and values\n\t    var blockStr = selAndBlock[2];\n\t    var invalidBlock = false;\n\t    blockRem = blockStr;\n\t    var props = [];\n\t\n\t    while (true) {\n\t      var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n\t      if (_nothingLeftToParse) {\n\t        break;\n\t      }\n\t\n\t      var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);\n\t\n\t      if (!propAndVal) {\n\t        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n\t        invalidBlock = true;\n\t        break;\n\t      }\n\t\n\t      propAndValStr = propAndVal[0];\n\t      var propStr = propAndVal[1];\n\t      var valStr = propAndVal[2];\n\t\n\t      var prop = self.properties[propStr];\n\t      if (!prop) {\n\t        util.error('Skipping property: Invalid property name in: ' + propAndValStr);\n\t\n\t        // skip this property in the block\n\t        removePropAndValFromRem();\n\t        continue;\n\t      }\n\t\n\t      var parsedProp = style.parse(propStr, valStr);\n\t\n\t      if (!parsedProp) {\n\t        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);\n\t\n\t        // skip this property in the block\n\t        removePropAndValFromRem();\n\t        continue;\n\t      }\n\t\n\t      props.push({\n\t        name: propStr,\n\t        val: valStr\n\t      });\n\t      removePropAndValFromRem();\n\t    }\n\t\n\t    if (invalidBlock) {\n\t      removeSelAndBlockFromRemaining();\n\t      break;\n\t    }\n\t\n\t    // put the parsed block in the style\n\t    style.selector(selectorStr);\n\t    for (var i = 0; i < props.length; i++) {\n\t      var _prop = props[i];\n\t      style.css(_prop.name, _prop.val);\n\t    }\n\t\n\t    removeSelAndBlockFromRemaining();\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\tstyfn.fromString = function (string) {\n\t  var style = this;\n\t\n\t  style.resetToDefault();\n\t  style.appendFromString(string);\n\t\n\t  return style;\n\t};\n\t\n\tmodule.exports = styfn;\n\t\n\t/***/ }),\n\t/* 130 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tmodule.exports = {\n\t  // get [r, g, b] from #abc or #aabbcc\n\t  hex2tuple: function hex2tuple(hex) {\n\t    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n\t      return;\n\t    }\n\t\n\t    var shortHex = hex.length === 4;\n\t    var r = void 0,\n\t        g = void 0,\n\t        b = void 0;\n\t    var base = 16;\n\t\n\t    if (shortHex) {\n\t      r = parseInt(hex[1] + hex[1], base);\n\t      g = parseInt(hex[2] + hex[2], base);\n\t      b = parseInt(hex[3] + hex[3], base);\n\t    } else {\n\t      r = parseInt(hex[1] + hex[2], base);\n\t      g = parseInt(hex[3] + hex[4], base);\n\t      b = parseInt(hex[5] + hex[6], base);\n\t    }\n\t\n\t    return [r, g, b];\n\t  },\n\t\n\t  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n\t  hsl2tuple: function hsl2tuple(hsl) {\n\t    var ret = void 0;\n\t    var h = void 0,\n\t        s = void 0,\n\t        l = void 0,\n\t        a = void 0,\n\t        r = void 0,\n\t        g = void 0,\n\t        b = void 0;\n\t    function hue2rgb(p, q, t) {\n\t      if (t < 0) t += 1;\n\t      if (t > 1) t -= 1;\n\t      if (t < 1 / 6) return p + (q - p) * 6 * t;\n\t      if (t < 1 / 2) return q;\n\t      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n\t      return p;\n\t    }\n\t\n\t    var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);\n\t    if (m) {\n\t\n\t      // get hue\n\t      h = parseInt(m[1]);\n\t      if (h < 0) {\n\t        h = (360 - -1 * h % 360) % 360;\n\t      } else if (h > 360) {\n\t        h = h % 360;\n\t      }\n\t      h /= 360; // normalise on [0, 1]\n\t\n\t      s = parseFloat(m[2]);\n\t      if (s < 0 || s > 100) {\n\t        return;\n\t      } // saturation is [0, 100]\n\t      s = s / 100; // normalise on [0, 1]\n\t\n\t      l = parseFloat(m[3]);\n\t      if (l < 0 || l > 100) {\n\t        return;\n\t      } // lightness is [0, 100]\n\t      l = l / 100; // normalise on [0, 1]\n\t\n\t      a = m[4];\n\t      if (a !== undefined) {\n\t        a = parseFloat(a);\n\t\n\t        if (a < 0 || a > 1) {\n\t          return;\n\t        } // alpha is [0, 1]\n\t      }\n\t\n\t      // now, convert to rgb\n\t      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\t      if (s === 0) {\n\t        r = g = b = Math.round(l * 255); // achromatic\n\t      } else {\n\t        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t        var p = 2 * l - q;\n\t        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n\t        g = Math.round(255 * hue2rgb(p, q, h));\n\t        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n\t      }\n\t\n\t      ret = [r, g, b, a];\n\t    }\n\t\n\t    return ret;\n\t  },\n\t\n\t  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n\t  rgb2tuple: function rgb2tuple(rgb) {\n\t    var ret = void 0;\n\t\n\t    var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);\n\t    if (m) {\n\t      ret = [];\n\t\n\t      var isPct = [];\n\t      for (var i = 1; i <= 3; i++) {\n\t        var channel = m[i];\n\t\n\t        if (channel[channel.length - 1] === '%') {\n\t          isPct[i] = true;\n\t        }\n\t        channel = parseFloat(channel);\n\t\n\t        if (isPct[i]) {\n\t          channel = channel / 100 * 255; // normalise to [0, 255]\n\t        }\n\t\n\t        if (channel < 0 || channel > 255) {\n\t          return;\n\t        } // invalid channel value\n\t\n\t        ret.push(Math.floor(channel));\n\t      }\n\t\n\t      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n\t      var allArePct = isPct[1] && isPct[2] && isPct[3];\n\t      if (atLeastOneIsPct && !allArePct) {\n\t        return;\n\t      } // must all be percent values if one is\n\t\n\t      var alpha = m[4];\n\t      if (alpha !== undefined) {\n\t        alpha = parseFloat(alpha);\n\t\n\t        if (alpha < 0 || alpha > 1) {\n\t          return;\n\t        } // invalid alpha value\n\t\n\t        ret.push(alpha);\n\t      }\n\t    }\n\t\n\t    return ret;\n\t  },\n\t\n\t  colorname2tuple: function colorname2tuple(color) {\n\t    return this.colors[color.toLowerCase()];\n\t  },\n\t\n\t  color2tuple: function color2tuple(color) {\n\t    return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);\n\t  },\n\t\n\t  colors: {\n\t    // special colour names\n\t    transparent: [0, 0, 0, 0], // NB alpha === 0\n\t\n\t    // regular colours\n\t    aliceblue: [240, 248, 255],\n\t    antiquewhite: [250, 235, 215],\n\t    aqua: [0, 255, 255],\n\t    aquamarine: [127, 255, 212],\n\t    azure: [240, 255, 255],\n\t    beige: [245, 245, 220],\n\t    bisque: [255, 228, 196],\n\t    black: [0, 0, 0],\n\t    blanchedalmond: [255, 235, 205],\n\t    blue: [0, 0, 255],\n\t    blueviolet: [138, 43, 226],\n\t    brown: [165, 42, 42],\n\t    burlywood: [222, 184, 135],\n\t    cadetblue: [95, 158, 160],\n\t    chartreuse: [127, 255, 0],\n\t    chocolate: [210, 105, 30],\n\t    coral: [255, 127, 80],\n\t    cornflowerblue: [100, 149, 237],\n\t    cornsilk: [255, 248, 220],\n\t    crimson: [220, 20, 60],\n\t    cyan: [0, 255, 255],\n\t    darkblue: [0, 0, 139],\n\t    darkcyan: [0, 139, 139],\n\t    darkgoldenrod: [184, 134, 11],\n\t    darkgray: [169, 169, 169],\n\t    darkgreen: [0, 100, 0],\n\t    darkgrey: [169, 169, 169],\n\t    darkkhaki: [189, 183, 107],\n\t    darkmagenta: [139, 0, 139],\n\t    darkolivegreen: [85, 107, 47],\n\t    darkorange: [255, 140, 0],\n\t    darkorchid: [153, 50, 204],\n\t    darkred: [139, 0, 0],\n\t    darksalmon: [233, 150, 122],\n\t    darkseagreen: [143, 188, 143],\n\t    darkslateblue: [72, 61, 139],\n\t    darkslategray: [47, 79, 79],\n\t    darkslategrey: [47, 79, 79],\n\t    darkturquoise: [0, 206, 209],\n\t    darkviolet: [148, 0, 211],\n\t    deeppink: [255, 20, 147],\n\t    deepskyblue: [0, 191, 255],\n\t    dimgray: [105, 105, 105],\n\t    dimgrey: [105, 105, 105],\n\t    dodgerblue: [30, 144, 255],\n\t    firebrick: [178, 34, 34],\n\t    floralwhite: [255, 250, 240],\n\t    forestgreen: [34, 139, 34],\n\t    fuchsia: [255, 0, 255],\n\t    gainsboro: [220, 220, 220],\n\t    ghostwhite: [248, 248, 255],\n\t    gold: [255, 215, 0],\n\t    goldenrod: [218, 165, 32],\n\t    gray: [128, 128, 128],\n\t    grey: [128, 128, 128],\n\t    green: [0, 128, 0],\n\t    greenyellow: [173, 255, 47],\n\t    honeydew: [240, 255, 240],\n\t    hotpink: [255, 105, 180],\n\t    indianred: [205, 92, 92],\n\t    indigo: [75, 0, 130],\n\t    ivory: [255, 255, 240],\n\t    khaki: [240, 230, 140],\n\t    lavender: [230, 230, 250],\n\t    lavenderblush: [255, 240, 245],\n\t    lawngreen: [124, 252, 0],\n\t    lemonchiffon: [255, 250, 205],\n\t    lightblue: [173, 216, 230],\n\t    lightcoral: [240, 128, 128],\n\t    lightcyan: [224, 255, 255],\n\t    lightgoldenrodyellow: [250, 250, 210],\n\t    lightgray: [211, 211, 211],\n\t    lightgreen: [144, 238, 144],\n\t    lightgrey: [211, 211, 211],\n\t    lightpink: [255, 182, 193],\n\t    lightsalmon: [255, 160, 122],\n\t    lightseagreen: [32, 178, 170],\n\t    lightskyblue: [135, 206, 250],\n\t    lightslategray: [119, 136, 153],\n\t    lightslategrey: [119, 136, 153],\n\t    lightsteelblue: [176, 196, 222],\n\t    lightyellow: [255, 255, 224],\n\t    lime: [0, 255, 0],\n\t    limegreen: [50, 205, 50],\n\t    linen: [250, 240, 230],\n\t    magenta: [255, 0, 255],\n\t    maroon: [128, 0, 0],\n\t    mediumaquamarine: [102, 205, 170],\n\t    mediumblue: [0, 0, 205],\n\t    mediumorchid: [186, 85, 211],\n\t    mediumpurple: [147, 112, 219],\n\t    mediumseagreen: [60, 179, 113],\n\t    mediumslateblue: [123, 104, 238],\n\t    mediumspringgreen: [0, 250, 154],\n\t    mediumturquoise: [72, 209, 204],\n\t    mediumvioletred: [199, 21, 133],\n\t    midnightblue: [25, 25, 112],\n\t    mintcream: [245, 255, 250],\n\t    mistyrose: [255, 228, 225],\n\t    moccasin: [255, 228, 181],\n\t    navajowhite: [255, 222, 173],\n\t    navy: [0, 0, 128],\n\t    oldlace: [253, 245, 230],\n\t    olive: [128, 128, 0],\n\t    olivedrab: [107, 142, 35],\n\t    orange: [255, 165, 0],\n\t    orangered: [255, 69, 0],\n\t    orchid: [218, 112, 214],\n\t    palegoldenrod: [238, 232, 170],\n\t    palegreen: [152, 251, 152],\n\t    paleturquoise: [175, 238, 238],\n\t    palevioletred: [219, 112, 147],\n\t    papayawhip: [255, 239, 213],\n\t    peachpuff: [255, 218, 185],\n\t    peru: [205, 133, 63],\n\t    pink: [255, 192, 203],\n\t    plum: [221, 160, 221],\n\t    powderblue: [176, 224, 230],\n\t    purple: [128, 0, 128],\n\t    red: [255, 0, 0],\n\t    rosybrown: [188, 143, 143],\n\t    royalblue: [65, 105, 225],\n\t    saddlebrown: [139, 69, 19],\n\t    salmon: [250, 128, 114],\n\t    sandybrown: [244, 164, 96],\n\t    seagreen: [46, 139, 87],\n\t    seashell: [255, 245, 238],\n\t    sienna: [160, 82, 45],\n\t    silver: [192, 192, 192],\n\t    skyblue: [135, 206, 235],\n\t    slateblue: [106, 90, 205],\n\t    slategray: [112, 128, 144],\n\t    slategrey: [112, 128, 144],\n\t    snow: [255, 250, 250],\n\t    springgreen: [0, 255, 127],\n\t    steelblue: [70, 130, 180],\n\t    tan: [210, 180, 140],\n\t    teal: [0, 128, 128],\n\t    thistle: [216, 191, 216],\n\t    tomato: [255, 99, 71],\n\t    turquoise: [64, 224, 208],\n\t    violet: [238, 130, 238],\n\t    wheat: [245, 222, 179],\n\t    white: [255, 255, 255],\n\t    whitesmoke: [245, 245, 245],\n\t    yellow: [255, 255, 0],\n\t    yellowgreen: [154, 205, 50]\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 131 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar is = __webpack_require__(0);\n\t\n\tmodule.exports = {\n\t  // has anything been set in the map\n\t  mapEmpty: function mapEmpty(map) {\n\t    var empty = true;\n\t\n\t    if (map != null) {\n\t      return Object.keys(map).length === 0;\n\t    }\n\t\n\t    return empty;\n\t  },\n\t\n\t  // pushes to the array at the end of a map (map may not be built)\n\t  pushMap: function pushMap(options) {\n\t    var array = this.getMap(options);\n\t\n\t    if (array == null) {\n\t      // if empty, put initial array\n\t      this.setMap(this.extend({}, options, {\n\t        value: [options.value]\n\t      }));\n\t    } else {\n\t      array.push(options.value);\n\t    }\n\t  },\n\t\n\t  // sets the value in a map (map may not be built)\n\t  setMap: function setMap(options) {\n\t    var obj = options.map;\n\t    var key = void 0;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t      var _key = keys[i];\n\t\n\t      if (is.plainObject(_key)) {\n\t        this.error('Tried to set map with object key');\n\t      }\n\t\n\t      if (i < keys.length - 1) {\n\t\n\t        // extend the map if necessary\n\t        if (obj[_key] == null) {\n\t          obj[_key] = {};\n\t        }\n\t\n\t        obj = obj[_key];\n\t      } else {\n\t        // set the value\n\t        obj[_key] = options.value;\n\t      }\n\t    }\n\t  },\n\t\n\t  // gets the value in a map even if it's not built in places\n\t  getMap: function getMap(options) {\n\t    var obj = options.map;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t      var key = keys[i];\n\t\n\t      if (is.plainObject(key)) {\n\t        this.error('Tried to get map with object key');\n\t      }\n\t\n\t      obj = obj[key];\n\t\n\t      if (obj == null) {\n\t        return obj;\n\t      }\n\t    }\n\t\n\t    return obj;\n\t  },\n\t\n\t  // deletes the entry in the map\n\t  deleteMap: function deleteMap(options) {\n\t    var obj = options.map;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t    var keepChildren = options.keepChildren;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t      var key = keys[i];\n\t\n\t      if (is.plainObject(key)) {\n\t        this.error('Tried to delete map with object key');\n\t      }\n\t\n\t      var lastKey = i === options.keys.length - 1;\n\t      if (lastKey) {\n\t\n\t        if (keepChildren) {\n\t          // then only delete child fields not in keepChildren\n\t          var children = Object.keys(obj);\n\t\n\t          for (var j = 0; j < children.length; j++) {\n\t            var child = children[j];\n\t\n\t            if (!keepChildren[child]) {\n\t              obj[child] = undefined;\n\t            }\n\t          }\n\t        } else {\n\t          obj[key] = undefined;\n\t        }\n\t      } else {\n\t        obj = obj[key];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 132 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n\t\n\tvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n\tvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\t\n\tvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n\tvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\t\n\tvar hex3 = '\\\\#[0-9a-fA-F]{3}';\n\tvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\t\n\tmodule.exports = {\n\t  regex: {\n\t    number: number,\n\t    rgba: rgba,\n\t    rgbaNoBackRefs: rgbaNoBackRefs,\n\t    hsla: hsla,\n\t    hslaNoBackRefs: hslaNoBackRefs,\n\t    hex3: hex3,\n\t    hex6: hex6\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 133 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tfunction ascending(a, b) {\n\t  if (a < b) {\n\t    return -1;\n\t  } else if (a > b) {\n\t    return 1;\n\t  } else {\n\t    return 0;\n\t  }\n\t}\n\t\n\tfunction descending(a, b) {\n\t  return -1 * ascending(a, b);\n\t}\n\t\n\tmodule.exports = {\n\t  sort: {\n\t    ascending: ascending,\n\t    descending: descending\n\t  }\n\t};\n\t\n\t/***/ }),\n\t/* 134 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar memoize = __webpack_require__(19);\n\tvar is = __webpack_require__(0);\n\t\n\tmodule.exports = {\n\t\n\t  camel2dash: memoize(function (str) {\n\t    return str.replace(/([A-Z])/g, function (v) {\n\t      return '-' + v.toLowerCase();\n\t    });\n\t  }),\n\t\n\t  dash2camel: memoize(function (str) {\n\t    return str.replace(/(-\\w)/g, function (v) {\n\t      return v[1].toUpperCase();\n\t    });\n\t  }),\n\t\n\t  prependCamel: memoize(function (prefix, str) {\n\t    return prefix + str[0].toUpperCase() + str.substring(1);\n\t  }, function (prefix, str) {\n\t    return prefix + '$' + str;\n\t  }),\n\t\n\t  capitalize: function capitalize(str) {\n\t    if (is.emptyString(str)) {\n\t      return str;\n\t    }\n\t\n\t    return str.charAt(0).toUpperCase() + str.substring(1);\n\t  }\n\t\n\t};\n\t\n\t/***/ }),\n\t/* 135 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\"use strict\";\n\t\n\t\n\tvar window = __webpack_require__(4);\n\tvar performance = window ? window.performance : null;\n\t\n\tvar util = {};\n\t\n\tvar pnow = performance && performance.now ? function () {\n\t  return performance.now();\n\t} : function () {\n\t  return Date.now();\n\t};\n\t\n\tvar raf = function () {\n\t  if (window) {\n\t    if (window.requestAnimationFrame) {\n\t      return function (fn) {\n\t        window.requestAnimationFrame(fn);\n\t      };\n\t    } else if (window.mozRequestAnimationFrame) {\n\t      return function (fn) {\n\t        window.mozRequestAnimationFrame(fn);\n\t      };\n\t    } else if (window.webkitRequestAnimationFrame) {\n\t      return function (fn) {\n\t        window.webkitRequestAnimationFrame(fn);\n\t      };\n\t    } else if (window.msRequestAnimationFrame) {\n\t      return function (fn) {\n\t        window.msRequestAnimationFrame(fn);\n\t      };\n\t    }\n\t  }\n\t\n\t  return function (fn) {\n\t    if (fn) {\n\t      setTimeout(function () {\n\t        fn(pnow());\n\t      }, 1000 / 60);\n\t    }\n\t  };\n\t}();\n\t\n\tutil.requestAnimationFrame = function (fn) {\n\t  raf(fn);\n\t};\n\t\n\tutil.performanceNow = pnow;\n\t\n\tutil.debounce = __webpack_require__(141);\n\t\n\tutil.now = function () {\n\t  return Date.now();\n\t};\n\t\n\tmodule.exports = util;\n\t\n\t/***/ }),\n\t/* 136 */\n\t/***/ (function(module, exports) {\n\t\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\t\n\t\n\t/***/ }),\n\t/* 137 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 68\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(139), __webpack_require__(136)))\n\t\n\t/***/ }),\n\t/* 138 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(137);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\t\n\t\n\t/***/ }),\n\t/* 139 */\n\t/***/ (function(module, exports) {\n\t\n\tvar g;\r\n\t\r\n\t// This works in non-strict mode\r\n\tg = (function() {\r\n\t\treturn this;\r\n\t})();\r\n\t\r\n\ttry {\r\n\t\t// This works if eval is allowed (see CSP)\r\n\t\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n\t} catch(e) {\r\n\t\t// This works if the window reference is available\r\n\t\tif(typeof window === \"object\")\r\n\t\t\tg = window;\r\n\t}\r\n\t\r\n\t// g can still be undefined, but nothing to do about it...\r\n\t// We return undefined, instead of nothing here, so it's\r\n\t// easier to handle this case. if(!global) { ...}\r\n\t\r\n\tmodule.exports = g;\r\n\t\n\t\n\t/***/ }),\n\t/* 140 */\n\t/***/ (function(module, exports) {\n\t\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_140__;\n\t\n\t/***/ }),\n\t/* 141 */\n\t/***/ (function(module, exports) {\n\t\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_141__;\n\t\n\t/***/ })\n\t/******/ ]);\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(557).setImmediate, __webpack_require__(557).clearImmediate))\n\n/***/ }),\n\n/***/ 961:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(962);\n\n\n/***/ }),\n\n/***/ 962:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0\n\t(function() {\n\t  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\t\n\t  floor = Math.floor, min = Math.min;\n\t\n\t\n\t  /*\n\t  Default comparison function to be used\n\t   */\n\t\n\t  defaultCmp = function(x, y) {\n\t    if (x < y) {\n\t      return -1;\n\t    }\n\t    if (x > y) {\n\t      return 1;\n\t    }\n\t    return 0;\n\t  };\n\t\n\t\n\t  /*\n\t  Insert item x in list a, and keep it sorted assuming a is sorted.\n\t  \n\t  If x is already in a, insert it to the right of the rightmost x.\n\t  \n\t  Optional args lo (default 0) and hi (default a.length) bound the slice\n\t  of a to be searched.\n\t   */\n\t\n\t  insort = function(a, x, lo, hi, cmp) {\n\t    var mid;\n\t    if (lo == null) {\n\t      lo = 0;\n\t    }\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    if (lo < 0) {\n\t      throw new Error('lo must be non-negative');\n\t    }\n\t    if (hi == null) {\n\t      hi = a.length;\n\t    }\n\t    while (lo < hi) {\n\t      mid = floor((lo + hi) / 2);\n\t      if (cmp(x, a[mid]) < 0) {\n\t        hi = mid;\n\t      } else {\n\t        lo = mid + 1;\n\t      }\n\t    }\n\t    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n\t  };\n\t\n\t\n\t  /*\n\t  Push item onto heap, maintaining the heap invariant.\n\t   */\n\t\n\t  heappush = function(array, item, cmp) {\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    array.push(item);\n\t    return _siftdown(array, 0, array.length - 1, cmp);\n\t  };\n\t\n\t\n\t  /*\n\t  Pop the smallest item off the heap, maintaining the heap invariant.\n\t   */\n\t\n\t  heappop = function(array, cmp) {\n\t    var lastelt, returnitem;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    lastelt = array.pop();\n\t    if (array.length) {\n\t      returnitem = array[0];\n\t      array[0] = lastelt;\n\t      _siftup(array, 0, cmp);\n\t    } else {\n\t      returnitem = lastelt;\n\t    }\n\t    return returnitem;\n\t  };\n\t\n\t\n\t  /*\n\t  Pop and return the current smallest value, and add the new item.\n\t  \n\t  This is more efficient than heappop() followed by heappush(), and can be\n\t  more appropriate when using a fixed size heap. Note that the value\n\t  returned may be larger than item! That constrains reasonable use of\n\t  this routine unless written as part of a conditional replacement:\n\t      if item > array[0]\n\t        item = heapreplace(array, item)\n\t   */\n\t\n\t  heapreplace = function(array, item, cmp) {\n\t    var returnitem;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    returnitem = array[0];\n\t    array[0] = item;\n\t    _siftup(array, 0, cmp);\n\t    return returnitem;\n\t  };\n\t\n\t\n\t  /*\n\t  Fast version of a heappush followed by a heappop.\n\t   */\n\t\n\t  heappushpop = function(array, item, cmp) {\n\t    var _ref;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    if (array.length && cmp(array[0], item) < 0) {\n\t      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n\t      _siftup(array, 0, cmp);\n\t    }\n\t    return item;\n\t  };\n\t\n\t\n\t  /*\n\t  Transform list into a heap, in-place, in O(array.length) time.\n\t   */\n\t\n\t  heapify = function(array, cmp) {\n\t    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    _ref1 = (function() {\n\t      _results1 = [];\n\t      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n\t      return _results1;\n\t    }).apply(this).reverse();\n\t    _results = [];\n\t    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n\t      i = _ref1[_i];\n\t      _results.push(_siftup(array, i, cmp));\n\t    }\n\t    return _results;\n\t  };\n\t\n\t\n\t  /*\n\t  Update the position of the given item in the heap.\n\t  This function should be called every time the item is being modified.\n\t   */\n\t\n\t  updateItem = function(array, item, cmp) {\n\t    var pos;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    pos = array.indexOf(item);\n\t    if (pos === -1) {\n\t      return;\n\t    }\n\t    _siftdown(array, 0, pos, cmp);\n\t    return _siftup(array, pos, cmp);\n\t  };\n\t\n\t\n\t  /*\n\t  Find the n largest elements in a dataset.\n\t   */\n\t\n\t  nlargest = function(array, n, cmp) {\n\t    var elem, result, _i, _len, _ref;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    result = array.slice(0, n);\n\t    if (!result.length) {\n\t      return result;\n\t    }\n\t    heapify(result, cmp);\n\t    _ref = array.slice(n);\n\t    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n\t      elem = _ref[_i];\n\t      heappushpop(result, elem, cmp);\n\t    }\n\t    return result.sort(cmp).reverse();\n\t  };\n\t\n\t\n\t  /*\n\t  Find the n smallest elements in a dataset.\n\t   */\n\t\n\t  nsmallest = function(array, n, cmp) {\n\t    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    if (n * 10 <= array.length) {\n\t      result = array.slice(0, n).sort(cmp);\n\t      if (!result.length) {\n\t        return result;\n\t      }\n\t      los = result[result.length - 1];\n\t      _ref = array.slice(n);\n\t      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n\t        elem = _ref[_i];\n\t        if (cmp(elem, los) < 0) {\n\t          insort(result, elem, 0, null, cmp);\n\t          result.pop();\n\t          los = result[result.length - 1];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t    heapify(array, cmp);\n\t    _results = [];\n\t    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n\t      _results.push(heappop(array, cmp));\n\t    }\n\t    return _results;\n\t  };\n\t\n\t  _siftdown = function(array, startpos, pos, cmp) {\n\t    var newitem, parent, parentpos;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    newitem = array[pos];\n\t    while (pos > startpos) {\n\t      parentpos = (pos - 1) >> 1;\n\t      parent = array[parentpos];\n\t      if (cmp(newitem, parent) < 0) {\n\t        array[pos] = parent;\n\t        pos = parentpos;\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\t    return array[pos] = newitem;\n\t  };\n\t\n\t  _siftup = function(array, pos, cmp) {\n\t    var childpos, endpos, newitem, rightpos, startpos;\n\t    if (cmp == null) {\n\t      cmp = defaultCmp;\n\t    }\n\t    endpos = array.length;\n\t    startpos = pos;\n\t    newitem = array[pos];\n\t    childpos = 2 * pos + 1;\n\t    while (childpos < endpos) {\n\t      rightpos = childpos + 1;\n\t      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n\t        childpos = rightpos;\n\t      }\n\t      array[pos] = array[childpos];\n\t      pos = childpos;\n\t      childpos = 2 * pos + 1;\n\t    }\n\t    array[pos] = newitem;\n\t    return _siftdown(array, startpos, pos, cmp);\n\t  };\n\t\n\t  Heap = (function() {\n\t    Heap.push = heappush;\n\t\n\t    Heap.pop = heappop;\n\t\n\t    Heap.replace = heapreplace;\n\t\n\t    Heap.pushpop = heappushpop;\n\t\n\t    Heap.heapify = heapify;\n\t\n\t    Heap.updateItem = updateItem;\n\t\n\t    Heap.nlargest = nlargest;\n\t\n\t    Heap.nsmallest = nsmallest;\n\t\n\t    function Heap(cmp) {\n\t      this.cmp = cmp != null ? cmp : defaultCmp;\n\t      this.nodes = [];\n\t    }\n\t\n\t    Heap.prototype.push = function(x) {\n\t      return heappush(this.nodes, x, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.pop = function() {\n\t      return heappop(this.nodes, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.peek = function() {\n\t      return this.nodes[0];\n\t    };\n\t\n\t    Heap.prototype.contains = function(x) {\n\t      return this.nodes.indexOf(x) !== -1;\n\t    };\n\t\n\t    Heap.prototype.replace = function(x) {\n\t      return heapreplace(this.nodes, x, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.pushpop = function(x) {\n\t      return heappushpop(this.nodes, x, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.heapify = function() {\n\t      return heapify(this.nodes, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.updateItem = function(x) {\n\t      return updateItem(this.nodes, x, this.cmp);\n\t    };\n\t\n\t    Heap.prototype.clear = function() {\n\t      return this.nodes = [];\n\t    };\n\t\n\t    Heap.prototype.empty = function() {\n\t      return this.nodes.length === 0;\n\t    };\n\t\n\t    Heap.prototype.size = function() {\n\t      return this.nodes.length;\n\t    };\n\t\n\t    Heap.prototype.clone = function() {\n\t      var heap;\n\t      heap = new Heap();\n\t      heap.nodes = this.nodes.slice(0);\n\t      return heap;\n\t    };\n\t\n\t    Heap.prototype.toArray = function() {\n\t      return this.nodes.slice(0);\n\t    };\n\t\n\t    Heap.prototype.insert = Heap.prototype.push;\n\t\n\t    Heap.prototype.top = Heap.prototype.peek;\n\t\n\t    Heap.prototype.front = Heap.prototype.peek;\n\t\n\t    Heap.prototype.has = Heap.prototype.contains;\n\t\n\t    Heap.prototype.copy = Heap.prototype.clone;\n\t\n\t    return Heap;\n\t\n\t  })();\n\t\n\t  (function(root, factory) {\n\t    if (true) {\n\t      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t      return module.exports = factory();\n\t    } else {\n\t      return root.Heap = factory();\n\t    }\n\t  })(this, function() {\n\t    return Heap;\n\t  });\n\t\n\t}).call(this);\n\n\n/***/ }),\n\n/***/ 1060:\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\t\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t/** Used as references for various `Number` constants. */\n\tvar NAN = 0 / 0;\n\t\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\t\n\t/** Used to match leading and trailing whitespace. */\n\tvar reTrim = /^\\s+|\\s+$/g;\n\t\n\t/** Used to detect bad signed hexadecimal string values. */\n\tvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\t\n\t/** Used to detect binary string values. */\n\tvar reIsBinary = /^0b[01]+$/i;\n\t\n\t/** Used to detect octal string values. */\n\tvar reIsOctal = /^0o[0-7]+$/i;\n\t\n\t/** Built-in method references without a dependency on `root`. */\n\tvar freeParseInt = parseInt;\n\t\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\t\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\t\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax = Math.max,\n\t    nativeMin = Math.min;\n\t\n\t/**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */\n\tvar now = function() {\n\t  return root.Date.now();\n\t};\n\t\n\t/**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */\n\tfunction debounce(func, wait, options) {\n\t  var lastArgs,\n\t      lastThis,\n\t      maxWait,\n\t      result,\n\t      timerId,\n\t      lastCallTime,\n\t      lastInvokeTime = 0,\n\t      leading = false,\n\t      maxing = false,\n\t      trailing = true;\n\t\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  wait = toNumber(wait) || 0;\n\t  if (isObject(options)) {\n\t    leading = !!options.leading;\n\t    maxing = 'maxWait' in options;\n\t    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\t\n\t  function invokeFunc(time) {\n\t    var args = lastArgs,\n\t        thisArg = lastThis;\n\t\n\t    lastArgs = lastThis = undefined;\n\t    lastInvokeTime = time;\n\t    result = func.apply(thisArg, args);\n\t    return result;\n\t  }\n\t\n\t  function leadingEdge(time) {\n\t    // Reset any `maxWait` timer.\n\t    lastInvokeTime = time;\n\t    // Start the timer for the trailing edge.\n\t    timerId = setTimeout(timerExpired, wait);\n\t    // Invoke the leading edge.\n\t    return leading ? invokeFunc(time) : result;\n\t  }\n\t\n\t  function remainingWait(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime,\n\t        result = wait - timeSinceLastCall;\n\t\n\t    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n\t  }\n\t\n\t  function shouldInvoke(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime;\n\t\n\t    // Either this is the first call, activity has stopped and we're at the\n\t    // trailing edge, the system time has gone backwards and we're treating\n\t    // it as the trailing edge, or we've hit the `maxWait` limit.\n\t    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n\t      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n\t  }\n\t\n\t  function timerExpired() {\n\t    var time = now();\n\t    if (shouldInvoke(time)) {\n\t      return trailingEdge(time);\n\t    }\n\t    // Restart the timer.\n\t    timerId = setTimeout(timerExpired, remainingWait(time));\n\t  }\n\t\n\t  function trailingEdge(time) {\n\t    timerId = undefined;\n\t\n\t    // Only invoke if we have `lastArgs` which means `func` has been\n\t    // debounced at least once.\n\t    if (trailing && lastArgs) {\n\t      return invokeFunc(time);\n\t    }\n\t    lastArgs = lastThis = undefined;\n\t    return result;\n\t  }\n\t\n\t  function cancel() {\n\t    if (timerId !== undefined) {\n\t      clearTimeout(timerId);\n\t    }\n\t    lastInvokeTime = 0;\n\t    lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t  }\n\t\n\t  function flush() {\n\t    return timerId === undefined ? result : trailingEdge(now());\n\t  }\n\t\n\t  function debounced() {\n\t    var time = now(),\n\t        isInvoking = shouldInvoke(time);\n\t\n\t    lastArgs = arguments;\n\t    lastThis = this;\n\t    lastCallTime = time;\n\t\n\t    if (isInvoking) {\n\t      if (timerId === undefined) {\n\t        return leadingEdge(lastCallTime);\n\t      }\n\t      if (maxing) {\n\t        // Handle invocations in a tight loop.\n\t        timerId = setTimeout(timerExpired, wait);\n\t        return invokeFunc(lastCallTime);\n\t      }\n\t    }\n\t    if (timerId === undefined) {\n\t      timerId = setTimeout(timerExpired, wait);\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = cancel;\n\t  debounced.flush = flush;\n\t  return debounced;\n\t}\n\t\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  var type = typeof value;\n\t  return !!value && (type == 'object' || type == 'function');\n\t}\n\t\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n\t}\n\t\n\t/**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */\n\tfunction toNumber(value) {\n\t  if (typeof value == 'number') {\n\t    return value;\n\t  }\n\t  if (isSymbol(value)) {\n\t    return NAN;\n\t  }\n\t  if (isObject(value)) {\n\t    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n\t    value = isObject(other) ? (other + '') : other;\n\t  }\n\t  if (typeof value != 'string') {\n\t    return value === 0 ? value : +value;\n\t  }\n\t  value = value.replace(reTrim, '');\n\t  var isBinary = reIsBinary.test(value);\n\t  return (isBinary || reIsOctal.test(value))\n\t    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n\t    : (reIsBadHex.test(value) ? NAN : +value);\n\t}\n\t\n\tmodule.exports = debounce;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n\n/***/ 1477:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 68\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(60)))\n\n/***/ }),\n\n/***/ 557:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n\t            (typeof self !== \"undefined\" && self) ||\n\t            window;\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(scope, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(1477);\n\t// On some exotic environments, it's not clear which object `setimmediate` was\n\t// able to install onto.  Search each possibility in the same order as the\n\t// `setimmediate` library.\n\texports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n\t                       (typeof global !== \"undefined\" && global.setImmediate) ||\n\t                       (this && this.setImmediate);\n\texports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n\t                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n\t                         (this && this.clearImmediate);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n\n/***/ 645:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _classCallCheck2 = __webpack_require__(13);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(16);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(15);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _cytoscape = __webpack_require__(743);\n\t\n\tvar _cytoscape2 = _interopRequireDefault(_cytoscape);\n\t\n\t__webpack_require__(1218);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar nodes = [{ data: { id: 'Front-End' } }, { data: { id: 'HTML' } }, { data: { id: 'JavaScript' } }, { data: { id: 'CSS' } }];\n\tvar edges = [{\n\t  data: {\n\t    source: 'Front-End',\n\t    target: 'HTML'\n\t  }\n\t}, {\n\t  data: {\n\t    source: 'Front-End',\n\t    target: 'JavaScript'\n\t  }\n\t}, {\n\t  data: {\n\t    source: 'Front-End',\n\t    target: 'CSS'\n\t  }\n\t}];\n\t\n\tvar elements = [].concat(nodes, edges);\n\t\n\tvar Cytoscape = function (_Component) {\n\t  (0, _inherits3.default)(Cytoscape, _Component);\n\t\n\t  function Cytoscape() {\n\t    (0, _classCallCheck3.default)(this, Cytoscape);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Component.apply(this, arguments));\n\t  }\n\t\n\t  Cytoscape.prototype.componentDidMount = function componentDidMount() {\n\t    (0, _cytoscape2.default)({\n\t      container: document.getElementById('cy'),\n\t      elements: elements,\n\t\n\t      pan: { x: 0, y: 0 },\n\t\n\t      style: [// the stylesheet for the graph\n\t      {\n\t        selector: 'node',\n\t        style: {\n\t          'background-color': '#ededed',\n\t          label: 'data(id)'\n\t        }\n\t      }, {\n\t        selector: 'edge',\n\t        style: {\n\t          width: 3,\n\t          'line-color': '#6cf'\n\t        }\n\t      }],\n\t\n\t      // TODO: Change layout name by location or other config\n\t      layout: {\n\t        name: 'circle'\n\t      }\n\t\n\t    });\n\t  };\n\t\n\t  Cytoscape.prototype.render = function render() {\n\t    return _react2.default.createElement('div', { id: 'cy' });\n\t  };\n\t\n\t  return Cytoscape;\n\t}(_react.Component);\n\t\n\texports.default = Cytoscape;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 1218:\n/***/ (function(module, exports) {\n\n\t// empty (null-loader)\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-demo-route-index-js-3c2d287606d78cd9960e.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"heap\"), require(\"lodash.debounce\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"heap\", \"lodash.debounce\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscape\"] = factory(require(\"heap\"), require(\"lodash.debounce\"));\n\telse\n\t\troot[\"cytoscape\"] = factory(root[\"heap\"], root[\"lodash.debounce\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_140__, __WEBPACK_EXTERNAL_MODULE_141__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 116);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*global HTMLElement DocumentTouch */\n\nvar window = __webpack_require__(4);\nvar navigator = window ? window.navigator : null;\nvar document = window ? window.document : null;\n\nvar typeofstr = _typeof('');\nvar typeofobj = _typeof({});\nvar typeoffn = _typeof(function () {});\nvar typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);\n\nvar instanceStr = function instanceStr(obj) {\n  return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;\n};\n\nvar is = {\n  defined: function defined(obj) {\n    return obj != null; // not undefined or null\n  },\n\n  string: function string(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;\n  },\n\n  fn: function fn(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;\n  },\n\n  array: function array(obj) {\n    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n  },\n\n  plainObject: function plainObject(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;\n  },\n\n  object: function object(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;\n  },\n\n  number: function number(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);\n  },\n\n  integer: function integer(obj) {\n    return is.number(obj) && Math.floor(obj) === obj;\n  },\n\n  bool: function bool(obj) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);\n  },\n\n  htmlElement: function htmlElement(obj) {\n    if ('undefined' === typeofhtmlele) {\n      return undefined;\n    } else {\n      return null != obj && obj instanceof HTMLElement;\n    }\n  },\n\n  elementOrCollection: function elementOrCollection(obj) {\n    return is.element(obj) || is.collection(obj);\n  },\n\n  element: function element(obj) {\n    return instanceStr(obj) === 'collection' && obj._private.single;\n  },\n\n  collection: function collection(obj) {\n    return instanceStr(obj) === 'collection' && !obj._private.single;\n  },\n\n  core: function core(obj) {\n    return instanceStr(obj) === 'core';\n  },\n\n  style: function style(obj) {\n    return instanceStr(obj) === 'style';\n  },\n\n  stylesheet: function stylesheet(obj) {\n    return instanceStr(obj) === 'stylesheet';\n  },\n\n  event: function event(obj) {\n    return instanceStr(obj) === 'event';\n  },\n\n  thread: function thread(obj) {\n    return instanceStr(obj) === 'thread';\n  },\n\n  fabric: function fabric(obj) {\n    return instanceStr(obj) === 'fabric';\n  },\n\n  emptyString: function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n      // null is empty\n      return true;\n    } else if (obj === '' || obj.match(/^\\s+$/)) {\n      return true; // empty string is empty\n    }\n\n    return false; // otherwise, we don't know what we've got\n  },\n\n  nonemptyString: function nonemptyString(obj) {\n    if (obj && is.string(obj) && obj !== '' && !obj.match(/^\\s+$/)) {\n      return true;\n    }\n\n    return false;\n  },\n\n  domElement: function domElement(obj) {\n    if (typeof HTMLElement === 'undefined') {\n      return false; // we're not in a browser so it doesn't matter\n    } else {\n      return obj instanceof HTMLElement;\n    }\n  },\n\n  boundingBox: function boundingBox(obj) {\n    return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);\n  },\n\n  promise: function promise(obj) {\n    return is.object(obj) && is.fn(obj.then);\n  },\n\n  touch: function touch() {\n    return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);\n  },\n\n  gecko: function gecko() {\n    return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);\n  },\n\n  webkit: function webkit() {\n    return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);\n  },\n\n  chromium: function chromium() {\n    return window && typeof chrome !== 'undefined';\n  },\n\n  khtml: function khtml() {\n    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...\n  },\n\n  khtmlEtc: function khtmlEtc() {\n    return is.khtml() || is.webkit() || is.chromium();\n  },\n\n  ms: function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...\n  },\n\n  windows: function windows() {\n    return navigator && navigator.appVersion.match(/Win/i);\n  },\n\n  mac: function mac() {\n    return navigator && navigator.appVersion.match(/Mac/i);\n  },\n\n  linux: function linux() {\n    return navigator && navigator.appVersion.match(/Linux/i);\n  },\n\n  unix: function unix() {\n    return navigator && navigator.appVersion.match(/X11/i);\n  }\n};\n\nmodule.exports = is;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*global console */\n\nvar is = __webpack_require__(0);\nvar math = __webpack_require__(2);\n\nvar util = {\n\n  MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,\n\n  trueify: function trueify() {\n    return true;\n  },\n\n  falsify: function falsify() {\n    return false;\n  },\n\n  zeroify: function zeroify() {\n    return 0;\n  },\n\n  noop: function noop() {},\n\n  error: function error(msg) {\n    /* eslint-disable */\n    if (console.error) {\n      console.error.apply(console, arguments);\n\n      if (console.trace) {\n        console.trace();\n      }\n    } else {\n      console.log.apply(console, arguments);\n\n      if (console.trace) {\n        console.trace();\n      }\n    }\n    /* eslint-enable */\n  },\n\n  clone: function clone(obj) {\n    return this.extend({}, obj);\n  },\n\n  // gets a shallow copy of the argument\n  copy: function copy(obj) {\n    if (obj == null) {\n      return obj;\n    }if (is.array(obj)) {\n      return obj.slice();\n    } else if (is.plainObject(obj)) {\n      return this.clone(obj);\n    } else {\n      return obj;\n    }\n  },\n\n  copyArray: function copyArray(arr) {\n    return arr.slice();\n  },\n\n  clonePosition: function clonePosition(pos) {\n    return { x: pos.x, y: pos.y };\n  },\n\n  uuid: function uuid(a, b // placeholders\n  ) {\n    for ( // loop :)\n    b = a = ''; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n    ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n    ? // genetate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n    : 4 //  otherwise 4\n    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    ) {}\n    return b;\n  }\n\n};\n\nutil.makeBoundingBox = math.makeBoundingBox.bind(math);\n\nutil._staticEmptyObject = {};\n\nutil.staticEmptyObject = function () {\n  return util._staticEmptyObject;\n};\n\nutil.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  var args = arguments;\n\n  for (var i = 1; i < args.length; i++) {\n    var obj = args[i];\n\n    if (obj == null) {\n      continue;\n    }\n\n    var keys = Object.keys(obj);\n\n    for (var j = 0; j < keys.length; j++) {\n      var k = keys[j];\n\n      tgt[k] = obj[k];\n    }\n  }\n\n  return tgt;\n};\n\nutil.assign = util.extend;\n\nutil.default = function (val, def) {\n  if (val === undefined) {\n    return def;\n  } else {\n    return val;\n  }\n};\n\nutil.removeFromArray = function (arr, ele, manyCopies) {\n  for (var i = arr.length; i >= 0; i--) {\n    if (arr[i] === ele) {\n      arr.splice(i, 1);\n\n      if (!manyCopies) {\n        break;\n      }\n    }\n  }\n};\n\nutil.clearArray = function (arr) {\n  arr.splice(0, arr.length);\n};\n\nutil.push = function (arr, otherArr) {\n  for (var i = 0; i < otherArr.length; i++) {\n    var el = otherArr[i];\n\n    arr.push(el);\n  }\n};\n\nutil.getPrefixedProperty = function (obj, propName, prefix) {\n  if (prefix) {\n    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  return obj[propName];\n};\n\nutil.setPrefixedProperty = function (obj, propName, prefix, value) {\n  if (prefix) {\n    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  obj[propName] = value;\n};\n\n[__webpack_require__(130), __webpack_require__(131), { memoize: __webpack_require__(19) }, __webpack_require__(132), __webpack_require__(134), __webpack_require__(135), __webpack_require__(133)].forEach(function (req) {\n  util.extend(util, req);\n});\n\nmodule.exports = util;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = {};\n\nmath.arePositionsSame = function (p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n};\n\nmath.copyPosition = function (p) {\n  return { x: p.x, y: p.y };\n};\n\nmath.modelToRenderedPosition = function (p, zoom, pan) {\n  return {\n    x: p.x * zoom + pan.x,\n    y: p.y * zoom + pan.y\n  };\n};\n\nmath.renderedToModelPosition = function (p, zoom, pan) {\n  return {\n    x: (p.x - pan.x) / zoom,\n    y: (p.y - pan.y) / zoom\n  };\n};\n\nmath.array2point = function (arr) {\n  return {\n    x: arr[0],\n    y: arr[1]\n  };\n};\n\nmath.deg2rad = function (deg) {\n  return Math.PI * deg / 180;\n};\n\nmath.getAngleFromDisp = function (dispX, dispY) {\n  return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\n\nmath.log2 = Math.log2 || function (n) {\n  return Math.log(n) / Math.log(2);\n};\n\nmath.signum = function (x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nmath.dist = function (p1, p2) {\n  return Math.sqrt(math.sqdist(p1, p2));\n};\n\nmath.sqdist = function (p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n\n  return dx * dx + dy * dy;\n};\n\n// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves\nmath.qbezierAt = function (p0, p1, p2, t) {\n  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\n\nmath.qbezierPtAt = function (p0, p1, p2, t) {\n  return {\n    x: math.qbezierAt(p0.x, p1.x, p2.x, t),\n    y: math.qbezierAt(p0.y, p1.y, p2.y, t)\n  };\n};\n\nmath.lineAt = function (p0, p1, t, d) {\n  var vec = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n\n  var vecDist = math.dist(p0, p1);\n\n  var normVec = {\n    x: vec.x / vecDist,\n    y: vec.y / vecDist\n  };\n\n  t = t == null ? 0 : t;\n\n  d = d != null ? d : t * vecDist;\n\n  return {\n    x: p0.x + normVec.x * d,\n    y: p0.y + normVec.y * d\n  };\n};\n\nmath.lineAtDist = function (p0, p1, d) {\n  return math.lineAt(p0, p1, undefined, d);\n};\n\n// get angle at A via cosine law\nmath.triangleAngle = function (A, B, C) {\n  var a = math.dist(B, C);\n  var b = math.dist(A, C);\n  var c = math.dist(A, B);\n\n  return Math.acos((a * a + b * b - c * c) / (2 * a * b));\n};\n\nmath.bound = function (min, val, max) {\n  return Math.max(min, Math.min(max, val));\n};\n\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nmath.makeBoundingBox = function (bb) {\n  if (bb == null) {\n    return {\n      x1: Infinity,\n      y1: Infinity,\n      x2: -Infinity,\n      y2: -Infinity,\n      w: 0,\n      h: 0\n    };\n  } else if (bb.x1 != null && bb.y1 != null) {\n    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x2,\n        y2: bb.y2,\n        w: bb.x2 - bb.x1,\n        h: bb.y2 - bb.y1\n      };\n    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x1 + bb.w,\n        y2: bb.y1 + bb.h,\n        w: bb.w,\n        h: bb.h\n      };\n    }\n  }\n};\n\nmath.updateBoundingBox = function (bb1, bb2) {\n  // update bb1 with bb2 bounds\n\n  bb1.x1 = Math.min(bb1.x1, bb2.x1);\n  bb1.x2 = Math.max(bb1.x2, bb2.x2);\n  bb1.w = bb1.x2 - bb1.x1;\n\n  bb1.y1 = Math.min(bb1.y1, bb2.y1);\n  bb1.y2 = Math.max(bb1.y2, bb2.y2);\n  bb1.h = bb1.y2 - bb1.y1;\n};\n\nmath.expandBoundingBoxByPoint = function (bb, x, y) {\n  bb.x1 = Math.min(bb.x1, x);\n  bb.x2 = Math.max(bb.x2, x);\n  bb.w = bb.x2 - bb.x1;\n\n  bb.y1 = Math.min(bb.y1, y);\n  bb.y2 = Math.max(bb.y2, y);\n  bb.h = bb.y2 - bb.y1;\n};\n\nmath.expandBoundingBox = function (bb, padding) {\n  bb.x1 -= padding;\n  bb.x2 += padding;\n  bb.y1 -= padding;\n  bb.y2 += padding;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n\n  return bb;\n};\n\nmath.boundingBoxesIntersect = function (bb1, bb2) {\n  // case: one bb to right of other\n  if (bb1.x1 > bb2.x2) {\n    return false;\n  }\n  if (bb2.x1 > bb1.x2) {\n    return false;\n  }\n\n  // case: one bb to left of other\n  if (bb1.x2 < bb2.x1) {\n    return false;\n  }\n  if (bb2.x2 < bb1.x1) {\n    return false;\n  }\n\n  // case: one bb above other\n  if (bb1.y2 < bb2.y1) {\n    return false;\n  }\n  if (bb2.y2 < bb1.y1) {\n    return false;\n  }\n\n  // case: one bb below other\n  if (bb1.y1 > bb2.y2) {\n    return false;\n  }\n  if (bb2.y1 > bb1.y2) {\n    return false;\n  }\n\n  // otherwise, must have some overlap\n  return true;\n};\n\nmath.inBoundingBox = function (bb, x, y) {\n  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\n\nmath.pointInBoundingBox = function (bb, pt) {\n  return this.inBoundingBox(bb, pt.x, pt.y);\n};\n\nmath.boundingBoxInBoundingBox = function (bb1, bb2) {\n  return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\n\nmath.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {\n\n  var cornerRadius = this.getRoundRectangleRadius(width, height);\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n\n  // Check intersections with straight line segments\n  var straightLineIntersections = void 0;\n\n  // Top segment, left to right\n  {\n    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n    var topStartY = nodeY - halfHeight - padding;\n    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n    var topEndY = topStartY;\n\n    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Right segment, top to bottom\n  {\n    var rightStartX = nodeX + halfWidth + padding;\n    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n    var rightEndX = rightStartX;\n    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n\n    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Bottom segment, left to right\n  {\n    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n    var bottomStartY = nodeY + halfHeight + padding;\n    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n    var bottomEndY = bottomStartY;\n\n    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Left segment, top to bottom\n  {\n    var leftStartX = nodeX - halfWidth - padding;\n    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n    var leftEndX = leftStartX;\n    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n\n    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  }\n\n  // Check intersections with arc segments\n  var arcIntersections = void 0;\n\n  // Top Left\n  {\n    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Top Right\n  {\n    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Bottom Right\n  {\n    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  // Bottom Left\n  {\n    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n\n  return []; // if nothing\n};\n\nmath.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {\n  var t = tolerance;\n\n  var x1 = Math.min(lx1, lx2);\n  var x2 = Math.max(lx1, lx2);\n  var y1 = Math.min(ly1, ly2);\n  var y2 = Math.max(ly1, ly2);\n\n  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\n\nmath.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n\n  var bb = {\n    x1: Math.min(x1, x3, x2) - tolerance,\n    x2: Math.max(x1, x3, x2) + tolerance,\n    y1: Math.min(y1, y3, y2) - tolerance,\n    y2: Math.max(y1, y3, y2) + tolerance\n  };\n\n  // if outside the rough bounding box for the bezier, then it can't be a hit\n  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n    // console.log('bezier out of rough bb')\n    return false;\n  } else {\n    // console.log('do more expensive check');\n    return true;\n  }\n};\nmath.solveQuadratic = function (a, b, c, val) {\n  c -= val;\n\n  var r = b * b - 4 * a * c;\n\n  if (r < 0) {\n    return [];\n  }\n\n  var sqrtR = Math.sqrt(r);\n  var denom = 2 * a;\n  var root1 = (-b + sqrtR) / denom;\n  var root2 = (-b - sqrtR) / denom;\n\n  return [root1, root2];\n};\n\nmath.solveCubic = function (a, b, c, d, result) {\n\n  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n  // r is the real component, i is the imaginary component\n\n  // An implementation of the Cardano method from the year 1545\n  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\n  b /= a;\n  c /= a;\n  d /= a;\n\n  var discriminant = void 0,\n      q = void 0,\n      r = void 0,\n      dum1 = void 0,\n      s = void 0,\n      t = void 0,\n      term1 = void 0,\n      r13 = void 0;\n\n  q = (3.0 * c - b * b) / 9.0;\n  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n  r /= 54.0;\n\n  discriminant = q * q * q + r * r;\n  result[1] = 0;\n  term1 = b / 3.0;\n\n  if (discriminant > 0) {\n    s = r + Math.sqrt(discriminant);\n    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n    t = r - Math.sqrt(discriminant);\n    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n    result[0] = -term1 + s + t;\n    term1 += (s + t) / 2.0;\n    result[4] = result[2] = -term1;\n    term1 = Math.sqrt(3.0) * (-t + s) / 2;\n    result[3] = term1;\n    result[5] = -term1;\n    return;\n  }\n\n  result[5] = result[3] = 0;\n\n  if (discriminant === 0) {\n    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n    result[0] = -term1 + 2.0 * r13;\n    result[4] = result[2] = -(r13 + term1);\n    return;\n  }\n\n  q = -q;\n  dum1 = q * q * q;\n  dum1 = Math.acos(r / Math.sqrt(dum1));\n  r13 = 2.0 * Math.sqrt(q);\n  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n\n  return;\n};\n\nmath.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {\n\n  // Find minimum distance by using the minimum of the distance\n  // function between the given point and the curve\n\n  // This gives the coefficients of the resulting cubic equation\n  // whose roots tell us where a possible minimum is\n  // (Coefficients are divided by 4)\n\n  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n\n  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n\n  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n\n  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n\n  // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n  var roots = [];\n\n  // Use the cubic solving algorithm\n  this.solveCubic(a, b, c, d, roots);\n\n  var zeroThreshold = 0.0000001;\n\n  var params = [];\n\n  for (var index = 0; index < 6; index += 2) {\n    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n      params.push(roots[index]);\n    }\n  }\n\n  params.push(1.0);\n  params.push(0.0);\n\n  var minDistanceSquared = -1;\n\n  var curX = void 0,\n      curY = void 0,\n      distSquared = void 0;\n  for (var i = 0; i < params.length; i++) {\n    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n\n    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n\n    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n    // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n    if (minDistanceSquared >= 0) {\n      if (distSquared < minDistanceSquared) {\n        minDistanceSquared = distSquared;\n      }\n    } else {\n      minDistanceSquared = distSquared;\n    }\n  }\n\n  return minDistanceSquared;\n};\n\nmath.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {\n  var offset = [x - x1, y - y1];\n  var line = [x2 - x1, y2 - y1];\n\n  var lineSq = line[0] * line[0] + line[1] * line[1];\n  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n\n  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n  var adjSq = dotProduct * dotProduct / lineSq;\n\n  if (dotProduct < 0) {\n    return hypSq;\n  }\n\n  if (adjSq > lineSq) {\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n  }\n\n  return hypSq - adjSq;\n};\n\nmath.pointInsidePolygonPoints = function (x, y, points) {\n  var x1 = void 0,\n      y1 = void 0,\n      x2 = void 0,\n      y2 = void 0;\n  var y3 = void 0;\n\n  // Intersect with vertical line through (x, y)\n  var up = 0;\n  // let down = 0;\n  for (var i = 0; i < points.length / 2; i++) {\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n\n    if (i + 1 < points.length / 2) {\n      x2 = points[(i + 1) * 2];\n      y2 = points[(i + 1) * 2 + 1];\n    } else {\n      x2 = points[(i + 1 - points.length / 2) * 2];\n      y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n    }\n\n    if (x1 == x && x2 == x) {\n      // then ignore\n    } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n\n      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\n      if (y3 > y) {\n        up++;\n      }\n\n      // if( y3 < y ){\n      // down++;\n      // }\n    } else {\n      continue;\n    }\n  }\n\n  if (up % 2 === 0) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nmath.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n\n  //let direction = arguments[6];\n  var transformedPoints = new Array(basePoints.length);\n\n  // Gives negative angle\n  var angle = void 0;\n\n  if (direction[0] != null) {\n    angle = Math.atan(direction[1] / direction[0]);\n\n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n  } else {\n    angle = direction;\n  }\n\n  var cos = Math.cos(-angle);\n  var sin = Math.sin(-angle);\n\n  //    console.log(\"base: \" + basePoints);\n  for (var i = 0; i < transformedPoints.length / 2; i++) {\n    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n\n    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n\n    transformedPoints[i * 2] += centerX;\n    transformedPoints[i * 2 + 1] += centerY;\n  }\n\n  var points = void 0;\n\n  if (padding > 0) {\n    var expandedLineSet = this.expandPolygon(transformedPoints, -padding);\n\n    points = this.joinLines(expandedLineSet);\n  } else {\n    points = transformedPoints;\n  }\n\n  return math.pointInsidePolygonPoints(x, y, points);\n};\n\nmath.joinLines = function (lineSet) {\n\n  var vertices = new Array(lineSet.length / 2);\n\n  var currentLineStartX = void 0,\n      currentLineStartY = void 0,\n      currentLineEndX = void 0,\n      currentLineEndY = void 0;\n  var nextLineStartX = void 0,\n      nextLineStartY = void 0,\n      nextLineEndX = void 0,\n      nextLineEndY = void 0;\n\n  for (var i = 0; i < lineSet.length / 4; i++) {\n    currentLineStartX = lineSet[i * 4];\n    currentLineStartY = lineSet[i * 4 + 1];\n    currentLineEndX = lineSet[i * 4 + 2];\n    currentLineEndY = lineSet[i * 4 + 3];\n\n    if (i < lineSet.length / 4 - 1) {\n      nextLineStartX = lineSet[(i + 1) * 4];\n      nextLineStartY = lineSet[(i + 1) * 4 + 1];\n      nextLineEndX = lineSet[(i + 1) * 4 + 2];\n      nextLineEndY = lineSet[(i + 1) * 4 + 3];\n    } else {\n      nextLineStartX = lineSet[0];\n      nextLineStartY = lineSet[1];\n      nextLineEndX = lineSet[2];\n      nextLineEndY = lineSet[3];\n    }\n\n    var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n\n    vertices[i * 2] = intersection[0];\n    vertices[i * 2 + 1] = intersection[1];\n  }\n\n  return vertices;\n};\n\nmath.expandPolygon = function (points, pad) {\n\n  var expandedLineSet = new Array(points.length * 2);\n\n  var currentPointX = void 0,\n      currentPointY = void 0,\n      nextPointX = void 0,\n      nextPointY = void 0;\n\n  for (var i = 0; i < points.length / 2; i++) {\n    currentPointX = points[i * 2];\n    currentPointY = points[i * 2 + 1];\n\n    if (i < points.length / 2 - 1) {\n      nextPointX = points[(i + 1) * 2];\n      nextPointY = points[(i + 1) * 2 + 1];\n    } else {\n      nextPointX = points[0];\n      nextPointY = points[1];\n    }\n\n    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n\n    // Assume CCW polygon winding\n\n    var offsetX = nextPointY - currentPointY;\n    var offsetY = -(nextPointX - currentPointX);\n\n    // Normalize\n    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    var normalizedOffsetX = offsetX / offsetLength;\n    var normalizedOffsetY = offsetY / offsetLength;\n\n    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n  }\n\n  return expandedLineSet;\n};\n\nmath.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n\n  var dispX = centerX - x;\n  var dispY = centerY - y;\n\n  dispX /= ellipseWradius;\n  dispY /= ellipseHradius;\n\n  var len = Math.sqrt(dispX * dispX + dispY * dispY);\n\n  var newLength = len - 1;\n\n  if (newLength < 0) {\n    return [];\n  }\n\n  var lenProportion = newLength / len;\n\n  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n};\n\nmath.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {\n  x -= centerX;\n  y -= centerY;\n\n  x /= width / 2 + padding;\n  y /= height / 2 + padding;\n\n  return x * x + y * y <= 1;\n};\n\n// Returns intersections of increasing distance from line's start point\nmath.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {\n\n  // Calculate d, direction vector of line\n  var d = [x2 - x1, y2 - y1]; // Direction vector of line\n  var f = [x1 - centerX, y1 - centerY];\n\n  var a = d[0] * d[0] + d[1] * d[1];\n  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n\n  var discriminant = b * b - 4 * a * c;\n\n  if (discriminant < 0) {\n    return [];\n  }\n\n  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n\n  var tMin = Math.min(t1, t2);\n  var tMax = Math.max(t1, t2);\n  var inRangeParams = [];\n\n  if (tMin >= 0 && tMin <= 1) {\n    inRangeParams.push(tMin);\n  }\n\n  if (tMax >= 0 && tMax <= 1) {\n    inRangeParams.push(tMax);\n  }\n\n  if (inRangeParams.length === 0) {\n    return [];\n  }\n\n  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\n  if (inRangeParams.length > 1) {\n\n    if (inRangeParams[0] == inRangeParams[1]) {\n      return [nearIntersectionX, nearIntersectionY];\n    } else {\n\n      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n\n      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n    }\n  } else {\n    return [nearIntersectionX, nearIntersectionY];\n  }\n};\n\nmath.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {\n\n  var displacementX = farX - centerX;\n  var displacementY = farY - centerY;\n  var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);\n\n  var unitDisplacementX = displacementX / distance;\n  var unitDisplacementY = displacementY / distance;\n\n  return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];\n};\n\nmath.findMaxSqDistanceToOrigin = function (points) {\n  var maxSqDistance = 0.000001;\n  var sqDistance = void 0;\n\n  for (var i = 0; i < points.length / 2; i++) {\n\n    sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];\n\n    if (sqDistance > maxSqDistance) {\n      maxSqDistance = sqDistance;\n    }\n  }\n\n  return maxSqDistance;\n};\n\nmath.midOfThree = function (a, b, c) {\n  if (b <= a && a <= c || c <= a && a <= b) {\n    return a;\n  } else if (a <= b && b <= c || c <= b && b <= a) {\n    return b;\n  } else {\n    return c;\n  }\n};\n\n// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\nmath.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n\n  var dx13 = x1 - x3;\n  var dx21 = x2 - x1;\n  var dx43 = x4 - x3;\n\n  var dy13 = y1 - y3;\n  var dy21 = y2 - y1;\n  var dy43 = y4 - y3;\n\n  var ua_t = dx43 * dy13 - dy43 * dx13;\n  var ub_t = dx21 * dy13 - dy21 * dx13;\n  var u_b = dy43 * dx21 - dx43 * dy21;\n\n  if (u_b !== 0) {\n    var ua = ua_t / u_b;\n    var ub = ub_t / u_b;\n\n    var flptThreshold = 0.001;\n    var min = 0 - flptThreshold;\n    var max = 1 + flptThreshold;\n\n    if (min <= ua && ua <= max && min <= ub && ub <= max) {\n      return [x1 + ua * dx21, y1 + ua * dy21];\n    } else {\n      if (!infiniteLines) {\n        return [];\n      } else {\n        return [x1 + ua * dx21, y1 + ua * dy21];\n      }\n    }\n  } else {\n    if (ua_t === 0 || ub_t === 0) {\n\n      // Parallel, coincident lines. Check if overlap\n\n      // Check endpoint of second line\n      if (this.midOfThree(x1, x2, x4) === x4) {\n        return [x4, y4];\n      }\n\n      // Check start point of second line\n      if (this.midOfThree(x1, x2, x3) === x3) {\n        return [x3, y3];\n      }\n\n      // Endpoint of first line\n      if (this.midOfThree(x3, x4, x2) === x2) {\n        return [x2, y2];\n      }\n\n      return [];\n    } else {\n\n      // Parallel, non-coincident\n      return [];\n    }\n  }\n};\n\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\nmath.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {\n\n  var intersections = [];\n  var intersection = void 0;\n\n  var transformedPoints = new Array(basePoints.length);\n\n  var doTransform = true;\n  if (arguments.length === 5) {\n    doTransform = false;\n  }\n\n  var points = void 0;\n\n  if (doTransform) {\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n    }\n\n    if (padding > 0) {\n      var expandedLineSet = math.expandPolygon(transformedPoints, -padding);\n\n      points = math.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n  } else {\n    points = basePoints;\n  }\n\n  var currentX = void 0,\n      currentY = void 0,\n      nextX = void 0,\n      nextY = void 0;\n\n  for (var _i = 0; _i < points.length / 2; _i++) {\n\n    currentX = points[_i * 2];\n    currentY = points[_i * 2 + 1];\n\n    if (_i < points.length / 2 - 1) {\n      nextX = points[(_i + 1) * 2];\n      nextY = points[(_i + 1) * 2 + 1];\n    } else {\n      nextX = points[0];\n      nextY = points[1];\n    }\n\n    intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n\n  return intersections;\n};\n\nmath.shortenIntersection = function (intersection, offset, amount) {\n\n  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n\n  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n\n  var lenRatio = (length - amount) / length;\n\n  if (lenRatio < 0) {\n    lenRatio = 0.00001;\n  }\n\n  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n};\n\nmath.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {\n  var points = math.generateUnitNgonPoints(sides, rotationRadians);\n  points = math.fitPolygonToSquare(points);\n\n  return points;\n};\n\nmath.fitPolygonToSquare = function (points) {\n  var x = void 0,\n      y = void 0;\n  var sides = points.length / 2;\n  var minX = Infinity,\n      minY = Infinity,\n      maxX = -Infinity,\n      maxY = -Infinity;\n\n  for (var i = 0; i < sides; i++) {\n    x = points[2 * i];\n    y = points[2 * i + 1];\n\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n\n  // stretch factors\n  var sx = 2 / (maxX - minX);\n  var sy = 2 / (maxY - minY);\n\n  for (var _i2 = 0; _i2 < sides; _i2++) {\n    x = points[2 * _i2] = points[2 * _i2] * sx;\n    y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;\n\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n\n  if (minY < -1) {\n    for (var _i3 = 0; _i3 < sides; _i3++) {\n      y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);\n    }\n  }\n\n  return points;\n};\n\nmath.generateUnitNgonPoints = function (sides, rotationRadians) {\n\n  var increment = 1.0 / sides * 2 * Math.PI;\n  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n\n  startAngle += rotationRadians;\n\n  var points = new Array(sides * 2);\n\n  var currentAngle = void 0;\n  for (var i = 0; i < sides; i++) {\n    currentAngle = i * increment + startAngle;\n\n    points[2 * i] = Math.cos(currentAngle); // x\n    points[2 * i + 1] = Math.sin(-currentAngle); // y\n  }\n\n  return points;\n};\n\nmath.getRoundRectangleRadius = function (width, height) {\n\n  // Set the default radius, unless half of width or height is smaller than default\n  return Math.min(width / 4, height / 4, 8);\n};\n\nmath.getCutRectangleCornerLength = function () {\n  return 8;\n};\n\nmath.bezierPtsToQuadCoeff = function (p0, p1, p2) {\n  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n};\n\nmath.getBarrelCurveConstants = function (width, height) {\n  // get curve width, height, and control point position offsets as a percentage of node height / width\n  return {\n    heightOffset: Math.min(15, 0.05 * height),\n    widthOffset: Math.min(100, 0.25 * width),\n    ctrlPtOffsetPct: 0.05\n  };\n};\n\nmodule.exports = math;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// use this module to cherry pick functions into your prototype\n// (useful for functions shared between the core and collections, for example)\n\n// e.g.\n// let foo = define.foo({ /* params... */ })\n\nvar util = __webpack_require__(1);\n\nvar define = {};\n\n[__webpack_require__(72), __webpack_require__(73), __webpack_require__(74)].forEach(function (m) {\n  util.assign(define, m);\n});\n\nmodule.exports = define;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/\n\n/*  promise states [Promises/A+ 2.1]  */\nvar STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */\nvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */\nvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */\n\n/*  promise object constructor  */\nvar api = function api(executor) {\n  /*  optionally support non-constructor/plain-function call  */\n  if (!(this instanceof api)) return new api(executor);\n\n  /*  initialize object  */\n  this.id = 'Thenable/1.0.7';\n  this.state = STATE_PENDING; /*  initial state  */\n  this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */\n  this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */\n  this.onFulfilled = []; /*  initial handlers  */\n  this.onRejected = []; /*  initial handlers  */\n\n  /*  provide optional information-hiding proxy  */\n  this.proxy = {\n    then: this.then.bind(this)\n  };\n\n  /*  support optional executor function  */\n  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n\n/*  promise API methods  */\napi.prototype = {\n  /*  promise resolving methods  */\n  fulfill: function fulfill(value) {\n    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n  },\n  reject: function reject(value) {\n    return deliver(this, STATE_REJECTED, 'rejectReason', value);\n  },\n\n  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n  then: function then(onFulfilled, onRejected) {\n    var curr = this;\n    var next = new api(); /*  [Promises/A+ 2.2.7]  */\n    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */\n    curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */\n    execute(curr);\n    return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */\n  }\n};\n\n/*  deliver an action  */\nvar deliver = function deliver(curr, state, name, value) {\n  if (curr.state === STATE_PENDING) {\n    curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n    curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n    execute(curr);\n  }\n  return curr;\n};\n\n/*  execute all handlers  */\nvar execute = function execute(curr) {\n  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n};\n\n/*  execute particular set of handlers  */\nvar execute_handlers = function execute_handlers(curr, name, value) {\n  /* global setImmediate: true */\n  /* global setTimeout: true */\n\n  /*  short-circuit processing  */\n  if (curr[name].length === 0) return;\n\n  /*  iterate over all handlers, exactly once  */\n  var handlers = curr[name];\n  curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n  var func = function func() {\n    for (var i = 0; i < handlers.length; i++) {\n      handlers[i](value);\n    } /*  [Promises/A+ 2.2.5]  */\n  };\n\n  /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */\n  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n};\n\n/*  generate a resolver function  */\nvar resolver = function resolver(cb, next, method) {\n  return function (value) {\n    if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n      next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n    else {\n        var result;\n        try {\n          result = cb(value);\n        } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n        catch (e) {\n          next.reject(e); /*  [Promises/A+ 2.2.7.2]  */\n          return;\n        }\n        resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */\n      }\n  };\n};\n\n/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */\nvar resolve = function resolve(promise, x) {\n  /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */\n  if (promise === x || promise.proxy === x) {\n    promise.reject(new TypeError('cannot resolve promise with itself'));\n    return;\n  }\n\n  /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */\n  var then;\n  if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {\n    try {\n      then = x.then;\n    } /*  [Promises/A+ 2.3.3.1, 3.5]  */\n    catch (e) {\n      promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */\n      return;\n    }\n  }\n\n  /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n  if (typeof then === 'function') {\n    var resolved = false;\n    try {\n      /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */\n      then.call(x,\n      /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */\n      function (y) {\n        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n        if (y === x) /*  [Promises/A+ 3.6]  */\n          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n      },\n\n      /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */\n      function (r) {\n        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(r);\n      });\n    } catch (e) {\n      if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */\n    }\n    return;\n  }\n\n  /*  handle other values  */\n  promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n};\n\n// so we always have Promise.all()\napi.all = function (ps) {\n  return new api(function (resolveAll, rejectAll) {\n    var vals = new Array(ps.length);\n    var doneCount = 0;\n\n    var fulfill = function fulfill(i, val) {\n      vals[i] = val;\n      doneCount++;\n\n      if (doneCount === ps.length) {\n        resolveAll(vals);\n      }\n    };\n\n    for (var i = 0; i < ps.length; i++) {\n      (function (i) {\n        var p = ps[i];\n        var isPromise = p != null && p.then != null;\n\n        if (isPromise) {\n          p.then(function (val) {\n            fulfill(i, val);\n          }, function (err) {\n            rejectAll(err);\n          });\n        } else {\n          var val = p;\n          fulfill(i, val);\n        }\n      })(i);\n    }\n  });\n};\n\napi.resolve = function (val) {\n  return new api(function (resolve, reject) {\n    resolve(val);\n  });\n};\n\napi.reject = function (val) {\n  return new api(function (resolve, reject) {\n    reject(val);\n  });\n};\n\nmodule.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(138).setImmediate))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar newQuery = __webpack_require__(11);\n\nvar Selector = function Selector(selector) {\n  var self = this;\n\n  self._private = {\n    selectorText: selector,\n    invalid: true\n  };\n\n  if (selector == null || is.string(selector) && selector.match(/^\\s*$/)) {\n\n    self.length = 0;\n  } else if (selector === '*' || selector === 'edge' || selector === 'node') {\n\n    // make single, group-only selectors cheap to make and cheap to filter\n\n    self[0] = newQuery();\n    self[0].group = selector === '*' ? selector : selector + 's';\n    self[0].groupOnly = true;\n    self[0].length = 1;\n    self._private.invalid = false;\n    self.length = 1;\n  } else if (is.elementOrCollection(selector)) {\n\n    var collection = selector.collection();\n\n    self[0] = newQuery();\n    self[0].collection = collection;\n    self[0].length = 1;\n    self.length = 1;\n  } else if (is.fn(selector)) {\n\n    self[0] = newQuery();\n    self[0].filter = selector;\n    self[0].length = 1;\n    self.length = 1;\n  } else if (is.string(selector)) {\n    if (!self.parse(selector)) {\n      return;\n    }\n  } else {\n    util.error('A selector must be created from a string; found ', selector);\n    return;\n  }\n\n  self._private.invalid = false;\n};\n\nvar selfn = Selector.prototype;\n\nselfn.valid = function () {\n  return !this._private.invalid;\n};\n\nselfn.invalid = function () {\n  return this._private.invalid;\n};\n\nselfn.text = function () {\n  return this._private.selectorText;\n};\n\nselfn.size = function () {\n  return this.length;\n};\n\nselfn.eq = function (i) {\n  return this[i];\n};\n\nselfn.sameText = function (otherSel) {\n  return this.text() === otherSel.text();\n};\n\nselfn.toString = selfn.selector = function () {\n\n  if (this._private.toStringCache != null) {\n    return this._private.toStringCache;\n  }\n\n  var i = void 0;\n  var str = '';\n\n  var clean = function clean(obj) {\n    if (obj == null) {\n      return '';\n    } else {\n      return obj;\n    }\n  };\n\n  var cleanVal = function cleanVal(val) {\n    if (is.string(val)) {\n      return '\"' + val + '\"';\n    } else {\n      return clean(val);\n    }\n  };\n\n  var space = function space(val) {\n    return ' ' + val + ' ';\n  };\n\n  var queryToString = function queryToString(query) {\n    var str = '';\n    var j = void 0,\n        sel = void 0;\n\n    if (query.subject === query) {\n      str += '$';\n    }\n\n    var group = clean(query.group);\n    str += group.substring(0, group.length - 1);\n\n    for (j = 0; j < query.data.length; j++) {\n      var data = query.data[j];\n\n      if (data.value) {\n        str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';\n      } else {\n        str += '[' + clean(data.operator) + data.field + ']';\n      }\n    }\n\n    for (j = 0; j < query.meta.length; j++) {\n      var meta = query.meta[j];\n      str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';\n    }\n\n    for (j = 0; j < query.colonSelectors.length; j++) {\n      sel = query.colonSelectors[i];\n      str += sel;\n    }\n\n    for (j = 0; j < query.ids.length; j++) {\n      sel = '#' + query.ids[i];\n      str += sel;\n    }\n\n    for (j = 0; j < query.classes.length; j++) {\n      sel = '.' + query.classes[j];\n      str += sel;\n    }\n\n    if (query.source != null && query.target != null) {\n      str = queryToString(query.source) + ' -> ' + queryToString(query.target);\n    }\n\n    if (query.connectedNodes != null) {\n      var n = query.connectedNodes;\n\n      str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);\n    }\n\n    if (query.parent != null) {\n      str = queryToString(query.parent) + ' > ' + str;\n    }\n\n    if (query.ancestor != null) {\n      str = queryToString(query.ancestor) + ' ' + str;\n    }\n\n    if (query.child != null) {\n      str += ' > ' + queryToString(query.child);\n    }\n\n    if (query.descendant != null) {\n      str += ' ' + queryToString(query.descendant);\n    }\n\n    return str;\n  };\n\n  for (i = 0; i < this.length; i++) {\n    var query = this[i];\n\n    str += queryToString(query);\n\n    if (this.length > 1 && i < this.length - 1) {\n      str += ', ';\n    }\n  }\n\n  this._private.toStringCache = str;\n\n  return str;\n};\n\n[__webpack_require__(120), __webpack_require__(119)].forEach(function (p) {\n  return util.assign(selfn, p);\n});\n\nmodule.exports = Selector;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar Map = __webpack_require__(117);\nvar Set = __webpack_require__(9);\n\nvar Element = __webpack_require__(13);\n\n// factory for generating edge ids when no id is specified for a new element\nvar idFactory = {\n  generate: function generate(cy, element, tryThisId) {\n    var id = tryThisId != null ? tryThisId : util.uuid();\n\n    while (cy.hasElementWithId(id)) {\n      id = util.uuid();\n    }\n\n    return id;\n  }\n};\n\n// represents a set of nodes, edges, or both together\nvar Collection = function Collection(cy, elements, options) {\n  if (cy === undefined || !is.core(cy)) {\n    util.error('A collection must have a reference to the core');\n    return;\n  }\n\n  var map = new Map();\n  var createdElements = false;\n\n  if (!elements) {\n    elements = [];\n  } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {\n    createdElements = true;\n\n    // make elements from json and restore all at once later\n    var eles = [];\n    var elesIds = new Set();\n\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var json = elements[i];\n\n      if (json.data == null) {\n        json.data = {};\n      }\n\n      var data = json.data;\n\n      // make sure newly created elements have valid ids\n      if (data.id == null) {\n        data.id = idFactory.generate(cy, json);\n      } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {\n        continue; // can't create element if prior id already exists\n      }\n\n      var ele = new Element(cy, json, false);\n      eles.push(ele);\n      elesIds.add(data.id);\n    }\n\n    elements = eles;\n  }\n\n  this.length = 0;\n\n  for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n    var element = elements[_i];\n    if (element == null) {\n      continue;\n    }\n\n    var id = element._private.data.id;\n\n    if (options == null || options.unique && !map.has(id)) {\n      map.set(id, {\n        index: this.length,\n        ele: element\n      });\n\n      this[this.length] = element;\n      this.length++;\n    }\n  }\n\n  this._private = {\n    cy: cy,\n    map: map\n  };\n\n  // restore the elements if we created them from json\n  if (createdElements) {\n    this.restore();\n  }\n};\n\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn = Element.prototype = Collection.prototype;\n\nelesfn.instanceString = function () {\n  return 'collection';\n};\n\nelesfn.spawn = function (cy, eles, opts) {\n  if (!is.core(cy)) {\n    // cy is optional\n    opts = eles;\n    eles = cy;\n    cy = this.cy();\n  }\n\n  return new Collection(cy, eles, opts);\n};\n\nelesfn.spawnSelf = function () {\n  return this.spawn(this);\n};\n\nelesfn.cy = function () {\n  return this._private.cy;\n};\n\nelesfn.renderer = function () {\n  return this._private.cy.renderer();\n};\n\nelesfn.element = function () {\n  return this[0];\n};\n\nelesfn.collection = function () {\n  if (is.collection(this)) {\n    return this;\n  } else {\n    // an element\n    return new Collection(this._private.cy, [this]);\n  }\n};\n\nelesfn.unique = function () {\n  return new Collection(this._private.cy, this, { unique: true });\n};\n\nelesfn.hasElementWithId = function (id) {\n  return this._private.map.has(id);\n};\n\nelesfn.getElementById = function (id) {\n  var cy = this._private.cy;\n  var entry = this._private.map.get(id);\n\n  return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\n\nelesfn.$id = elesfn.getElementById;\n\nelesfn.poolIndex = function () {\n  var cy = this._private.cy;\n  var eles = cy._private.elements;\n  var id = this._private.data.id;\n\n  return eles._private.map.get(id).index;\n};\n\nelesfn.json = function (obj) {\n  var ele = this.element();\n  var cy = this.cy();\n\n  if (ele == null && obj) {\n    return this;\n  } // can't set to no eles\n\n  if (ele == null) {\n    return undefined;\n  } // can't get from no eles\n\n  var p = ele._private;\n\n  if (is.plainObject(obj)) {\n    // set\n\n    cy.startBatch();\n\n    if (obj.data) {\n      ele.data(obj.data);\n    }\n\n    if (obj.position) {\n      ele.position(obj.position);\n    }\n\n    // ignore group -- immutable\n\n    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n      var obj_k = obj[k];\n\n      if (obj_k != null && obj_k !== p[k]) {\n        if (obj_k) {\n          ele[trueFnName]();\n        } else {\n          ele[falseFnName]();\n        }\n      }\n    };\n\n    checkSwitch('removed', 'remove', 'restore');\n\n    checkSwitch('selected', 'select', 'unselect');\n\n    checkSwitch('selectable', 'selectify', 'unselectify');\n\n    checkSwitch('locked', 'lock', 'unlock');\n\n    checkSwitch('grabbable', 'grabify', 'ungrabify');\n\n    if (obj.classes != null) {\n      ele.classes(obj.classes);\n    }\n\n    cy.endBatch();\n\n    return this;\n  } else if (obj === undefined) {\n    // get\n\n    var json = {\n      data: util.copy(p.data),\n      position: util.copy(p.position),\n      group: p.group,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbable: p.grabbable,\n      classes: null\n    };\n\n    json.classes = '';\n\n    var i = 0;\n    p.classes.forEach(function (cls) {\n      return json.classes += i++ === 0 ? cls : ' ' + cls;\n    });\n\n    return json;\n  }\n};\n\nelesfn.jsons = function () {\n  var jsons = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n\n    jsons.push(json);\n  }\n\n  return jsons;\n};\n\nelesfn.clone = function () {\n  var cy = this.cy();\n  var elesArr = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    var clone = new Element(cy, json, false); // NB no restore\n\n    elesArr.push(clone);\n  }\n\n  return new Collection(cy, elesArr);\n};\nelesfn.copy = elesfn.clone;\n\nelesfn.restore = function (notifyRenderer) {\n  var self = this;\n  var cy = self.cy();\n  var cy_p = cy._private;\n\n  if (notifyRenderer === undefined) {\n    notifyRenderer = true;\n  }\n\n  // create arrays of nodes and edges, since we need to\n  // restore the nodes first\n  var nodes = [];\n  var edges = [];\n  var elements = void 0;\n  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {\n    var ele = self[_i2];\n\n    if (!ele.removed()) {\n      // don't need to handle this ele\n      continue;\n    }\n\n    // keep nodes first in the array and edges after\n    if (ele.isNode()) {\n      // put to front of array if node\n      nodes.push(ele);\n    } else {\n      // put to end of array if edge\n      edges.push(ele);\n    }\n  }\n\n  elements = nodes.concat(edges);\n\n  var i = void 0;\n  var removeFromElements = function removeFromElements() {\n    elements.splice(i, 1);\n    i--;\n  };\n\n  // now, restore each element\n  for (i = 0; i < elements.length; i++) {\n    var _ele = elements[i];\n\n    var _private = _ele._private;\n    var data = _private.data;\n\n    // the traversal cache should start fresh when ele is added\n    _ele.clearTraversalCache();\n\n    // set id and validate\n    if (data.id === undefined) {\n      data.id = idFactory.generate(cy, _ele);\n    } else if (is.number(data.id)) {\n      data.id = '' + data.id; // now it's a string\n    } else if (is.emptyString(data.id) || !is.string(data.id)) {\n      util.error('Can not create element with invalid string ID `' + data.id + '`');\n\n      // can't create element if it has empty string as id or non-string id\n      removeFromElements();\n      continue;\n    } else if (cy.hasElementWithId(data.id)) {\n      util.error('Can not create second element with ID `' + data.id + '`');\n\n      // can't create element if one already has that id\n      removeFromElements();\n      continue;\n    }\n\n    var id = data.id; // id is finalised, now let's keep a ref\n\n    if (_ele.isNode()) {\n      // extra checks for nodes\n      var pos = _private.position;\n\n      // make sure the nodes have a defined position\n\n      if (pos.x == null) {\n        pos.x = 0;\n      }\n\n      if (pos.y == null) {\n        pos.y = 0;\n      }\n    }\n\n    if (_ele.isEdge()) {\n      // extra checks for edges\n\n      var edge = _ele;\n      var fields = ['source', 'target'];\n      var fieldsLength = fields.length;\n      var badSourceOrTarget = false;\n      for (var j = 0; j < fieldsLength; j++) {\n\n        var field = fields[j];\n        var val = data[field];\n\n        if (is.number(val)) {\n          val = data[field] = '' + data[field]; // now string\n        }\n\n        if (val == null || val === '') {\n          // can't create if source or target is not defined properly\n          util.error('Can not create edge `' + id + '` with unspecified ' + field);\n          badSourceOrTarget = true;\n        } else if (!cy.hasElementWithId(val)) {\n          // can't create edge if one of its nodes doesn't exist\n          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n          badSourceOrTarget = true;\n        }\n      }\n\n      if (badSourceOrTarget) {\n        removeFromElements();continue;\n      } // can't create this\n\n      var src = cy.getElementById(data.source);\n      var tgt = cy.getElementById(data.target);\n\n      src._private.edges.push(edge);\n      tgt._private.edges.push(edge);\n\n      edge._private.source = src;\n      edge._private.target = tgt;\n    } // if is edge\n\n    // create mock ids / indexes maps for element so it can be used like collections\n    _private.map = new Map();\n    _private.map.set(id, { ele: _ele, index: 0 });\n\n    _private.removed = false;\n    cy.addToPool(_ele);\n  } // for each element\n\n  // do compound node sanity checks\n  for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n    // each node\n    var node = nodes[_i3];\n    var _data = node._private.data;\n\n    if (is.number(_data.parent)) {\n      // then automake string\n      _data.parent = '' + _data.parent;\n    }\n\n    var parentId = _data.parent;\n\n    var specifiedParent = parentId != null;\n\n    if (specifiedParent) {\n      var parent = cy.getElementById(parentId);\n\n      if (parent.empty()) {\n        // non-existant parent; just remove it\n        _data.parent = undefined;\n      } else {\n        var selfAsParent = false;\n        var ancestor = parent;\n        while (!ancestor.empty()) {\n          if (node.same(ancestor)) {\n            // mark self as parent and remove from data\n            selfAsParent = true;\n            _data.parent = undefined; // remove parent reference\n\n            // exit or we loop forever\n            break;\n          }\n\n          ancestor = ancestor.parent();\n        }\n\n        if (!selfAsParent) {\n          // connect with children\n          parent[0]._private.children.push(node);\n          node._private.parent = parent[0];\n\n          // let the core know we have a compound graph\n          cy_p.hasCompoundNodes = true;\n        }\n      } // else\n    } // if specified parent\n  } // for each node\n\n  if (elements.length > 0) {\n    var restored = new Collection(cy, elements);\n\n    for (var _i4 = 0; _i4 < restored.length; _i4++) {\n      var _ele2 = restored[_i4];\n\n      if (_ele2.isNode()) {\n        continue;\n      }\n\n      // adding an edge invalidates the traversal caches for the parallel edges\n      _ele2.parallelEdges().clearTraversalCache();\n\n      // adding an edge invalidates the traversal cache for the connected nodes\n      _ele2.source().clearTraversalCache();\n      _ele2.target().clearTraversalCache();\n    }\n\n    var toUpdateStyle = void 0;\n\n    if (cy_p.hasCompoundNodes) {\n      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n    } else {\n      toUpdateStyle = restored;\n    }\n\n    toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);\n\n    if (notifyRenderer) {\n      restored.emitAndNotify('add');\n    } else {\n      restored.emit('add');\n    }\n  }\n\n  return self; // chainability\n};\n\nelesfn.removed = function () {\n  var ele = this[0];\n  return ele && ele._private.removed;\n};\n\nelesfn.inside = function () {\n  var ele = this[0];\n  return ele && !ele._private.removed;\n};\n\nelesfn.remove = function (notifyRenderer) {\n  var self = this;\n  var removed = [];\n  var elesToRemove = [];\n  var elesToRemoveIds = {};\n  var cy = self._private.cy;\n\n  if (notifyRenderer === undefined) {\n    notifyRenderer = true;\n  }\n\n  // add connected edges\n  function addConnectedEdges(node) {\n    var edges = node._private.edges;\n    for (var i = 0; i < edges.length; i++) {\n      add(edges[i]);\n    }\n  }\n\n  // add descendant nodes\n  function addChildren(node) {\n    var children = node._private.children;\n\n    for (var i = 0; i < children.length; i++) {\n      add(children[i]);\n    }\n  }\n\n  function add(ele) {\n    var alreadyAdded = elesToRemoveIds[ele.id()];\n    if (alreadyAdded) {\n      return;\n    } else {\n      elesToRemoveIds[ele.id()] = true;\n    }\n\n    if (ele.isNode()) {\n      elesToRemove.push(ele); // nodes are removed last\n\n      addConnectedEdges(ele);\n      addChildren(ele);\n    } else {\n      elesToRemove.unshift(ele); // edges are removed first\n    }\n  }\n\n  // make the list of elements to remove\n  // (may be removing more than specified due to connected edges etc)\n\n  for (var i = 0, l = self.length; i < l; i++) {\n    var ele = self[i];\n\n    add(ele);\n  }\n\n  function removeEdgeRef(node, edge) {\n    var connectedEdges = node._private.edges;\n\n    util.removeFromArray(connectedEdges, edge);\n\n    // removing an edges invalidates the traversal cache for its nodes\n    node.clearTraversalCache();\n  }\n\n  function removeParallelRefs(edge) {\n    // removing an edge invalidates the traversal caches for the parallel edges\n    edge.parallelEdges().clearTraversalCache();\n  }\n\n  var alteredParents = [];\n  alteredParents.ids = {};\n\n  function removeChildRef(parent, ele) {\n    ele = ele[0];\n    parent = parent[0];\n\n    var children = parent._private.children;\n    var pid = parent.id();\n\n    util.removeFromArray(children, ele);\n\n    if (!alteredParents.ids[pid]) {\n      alteredParents.ids[pid] = true;\n      alteredParents.push(parent);\n    }\n  }\n\n  self.dirtyCompoundBoundsCache();\n\n  cy.removeFromPool(elesToRemove); // remove from core pool\n\n  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {\n    var _ele3 = elesToRemove[_i5];\n\n    // mark as removed\n    _ele3._private.removed = true;\n\n    // add to list of removed elements\n    removed.push(_ele3);\n\n    if (_ele3.isEdge()) {\n      // remove references to this edge in its connected nodes\n      var src = _ele3.source()[0];\n      var tgt = _ele3.target()[0];\n\n      removeEdgeRef(src, _ele3);\n      removeEdgeRef(tgt, _ele3);\n      removeParallelRefs(_ele3);\n    } else {\n      // remove reference to parent\n      var parent = _ele3.parent();\n\n      if (parent.length !== 0) {\n        removeChildRef(parent, _ele3);\n      }\n    }\n  }\n\n  // check to see if we have a compound graph or not\n  var elesStillInside = cy._private.elements;\n  cy._private.hasCompoundNodes = false;\n  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {\n    var _ele4 = elesStillInside[_i6];\n\n    if (_ele4.isParent()) {\n      cy._private.hasCompoundNodes = true;\n      break;\n    }\n  }\n\n  var removedElements = new Collection(this.cy(), removed);\n  if (removedElements.size() > 0) {\n    // must manually notify since trigger won't do this automatically once removed\n\n    if (notifyRenderer) {\n      this.cy().notify({\n        type: 'remove',\n        eles: removedElements\n      });\n    }\n\n    removedElements.emit('remove');\n  }\n\n  // the parents who were modified by the removal need their style updated\n  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {\n    var _ele5 = alteredParents[_i7];\n\n    if (!_ele5.removed()) {\n      _ele5.updateStyle();\n    }\n  }\n\n  return new Collection(cy, removed);\n};\n\nelesfn.move = function (struct) {\n  var cy = this._private.cy;\n\n  if (struct.source !== undefined || struct.target !== undefined) {\n    var srcId = struct.source;\n    var tgtId = struct.target;\n    var srcExists = cy.hasElementWithId(srcId);\n    var tgtExists = cy.hasElementWithId(tgtId);\n\n    if (srcExists || tgtExists) {\n      var jsons = this.jsons();\n\n      this.remove();\n\n      for (var i = 0; i < jsons.length; i++) {\n        var json = jsons[i];\n        var ele = this[i];\n\n        if (json.group === 'edges') {\n          if (srcExists) {\n            json.data.source = srcId;\n          }\n\n          if (tgtExists) {\n            json.data.target = tgtId;\n          }\n\n          json.scratch = ele._private.scratch;\n        }\n      }\n\n      return cy.add(jsons);\n    }\n  } else if (struct.parent !== undefined) {\n    // move node to new parent\n    var parentId = struct.parent;\n    var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\n    if (parentExists) {\n      var _jsons = this.jsons();\n      var descs = this.descendants();\n      var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();\n\n      this.remove(); // NB: also removes descendants and their connected edges\n\n      for (var _i8 = 0; _i8 < _jsons.length; _i8++) {\n        var _json = _jsons[_i8];\n        var _ele6 = this[_i8];\n\n        if (_json.group === 'nodes') {\n          _json.data.parent = parentId === null ? undefined : parentId;\n\n          _json.scratch = _ele6._private.scratch;\n        }\n      }\n\n      return cy.add(_jsons.concat(descsEtcJsons));\n    }\n  }\n\n  return this; // if nothing done\n};\n\n[__webpack_require__(32), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(44), __webpack_require__(47), __webpack_require__(48), __webpack_require__(49), __webpack_require__(7), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54)].forEach(function (props) {\n  util.extend(elesfn, props);\n});\n\nmodule.exports = Collection;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(140);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* global Set */\n\nvar undef =  true ? 'undefined' : _typeof(undefined);\n\nvar ObjectSet = function () {\n  function ObjectSet(arrayOrObjectSet) {\n    _classCallCheck(this, ObjectSet);\n\n    this._obj = Object.create(null);\n\n    if (arrayOrObjectSet != null) {\n      var arr = void 0;\n\n      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n        arr = arrayOrObjectSet.toArray();\n      } else {\n        arr = arrayOrObjectSet;\n      }\n\n      for (var i = 0; i < arr.length; i++) {\n        this.add(arr[i]);\n      }\n    }\n  }\n\n  _createClass(ObjectSet, [{\n    key: 'instanceString',\n    value: function instanceString() {\n      return 'set';\n    }\n  }, {\n    key: 'add',\n    value: function add(val) {\n      this._obj[val] = 1;\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(val) {\n      this._obj[val] = 0;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._obj = Object.create(null);\n    }\n  }, {\n    key: 'has',\n    value: function has(val) {\n      return this._obj[val] === 1;\n    }\n  }, {\n    key: 'toArray',\n    value: function toArray() {\n      var _this = this;\n\n      return Object.keys(this._obj).filter(function (key) {\n        return _this.has(key);\n      });\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(callback, thisArg) {\n      return this.toArray().forEach(callback, thisArg);\n    }\n  }, {\n    key: 'size',\n    get: function get() {\n      return this.toArray().length;\n    }\n  }]);\n\n  return ObjectSet;\n}();\n\n// TODO use the stdlib Set in future...\n// module.exports = typeof Set !== undef ? Set : ObjectSet;\n\n\nmodule.exports = ObjectSet;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar Event = __webpack_require__(15);\n\nvar eventRegex = /(\\w+)(\\.(?:\\w+|\\*))?/; // regex for matching event strings (e.g. \"click.namespace\")\nvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\nvar defaults = {\n  qualifierCompare: function qualifierCompare(q1, q2) {\n    return q1 === q2;\n  },\n  eventMatches: function eventMatches() /*context, listener, eventObj*/{\n    return true;\n  },\n  eventFields: function eventFields() /*context*/{\n    return {};\n  },\n  callbackContext: function callbackContext(context /*, listener, eventObj*/) {\n    return context;\n  },\n  beforeEmit: function beforeEmit() /* context, listener, eventObj */{},\n  afterEmit: function afterEmit() /* context, listener, eventObj */{},\n  bubble: function bubble() /*context*/{\n    return false;\n  },\n  parent: function parent() /*context*/{\n    return null;\n  },\n  context: undefined\n};\n\nfunction Emitter(opts) {\n  util.assign(this, defaults, opts);\n\n  this.listeners = [];\n  this.emitting = 0;\n}\n\nvar p = Emitter.prototype;\n\nvar forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n  if (is.fn(qualifier)) {\n    callback = qualifier;\n    qualifier = null;\n  }\n\n  if (confOverrides) {\n    if (conf == null) {\n      conf = confOverrides;\n    } else {\n      conf = util.assign({}, conf, confOverrides);\n    }\n  }\n\n  var eventList = events.split(/\\s+/);\n\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n\n    if (is.emptyString(evt)) {\n      continue;\n    }\n\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n\n      if (ret === false) {\n        break;\n      } // allow exiting early\n    }\n  }\n};\n\nvar makeEventObj = function makeEventObj(self, obj) {\n  return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));\n};\n\nvar forEachEventObj = function forEachEventObj(self, handler, events) {\n  if (is.event(events)) {\n    handler(self, events);\n\n    return;\n  } else if (is.plainObject(events)) {\n    handler(self, makeEventObj(self, events));\n\n    return;\n  }\n\n  var eventList = events.split(/\\s+/);\n\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n\n    if (is.emptyString(evt)) {\n      continue;\n    }\n\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var eventObj = makeEventObj(self, {\n        type: type,\n        namespace: namespace,\n        target: self.context\n      });\n\n      handler(self, eventObj);\n    }\n  }\n};\n\np.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n    if (is.fn(callback)) {\n      self.listeners.push({\n        event: event, // full event string\n        callback: callback, // callback to run\n        type: type, // the event type (e.g. 'click')\n        namespace: namespace, // the event namespace (e.g. \".foo\")\n        qualifier: qualifier, // a restriction on whether to match this emitter\n        conf: conf // additional configuration\n      });\n    }\n  }, events, qualifier, callback, conf, confOverrides);\n\n  return this;\n};\n\np.one = function (events, qualifier, callback, conf) {\n  return this.on(events, qualifier, callback, conf, { one: true });\n};\n\np.removeListener = p.off = function (events, qualifier, callback, conf) {\n  var _this = this;\n\n  if (this.emitting !== 0) {\n    this.listeners = util.copyArray(this.listeners);\n  }\n\n  var listeners = this.listeners;\n\n  var _loop = function _loop(i) {\n    var listener = listeners[i];\n\n    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {\n      if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n        listeners.splice(i, 1);\n\n        return false;\n      }\n    }, events, qualifier, callback, conf);\n  };\n\n  for (var i = listeners.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n\n  return this;\n};\n\np.emit = p.trigger = function (events, extraParams, manualCallback) {\n  var listeners = this.listeners;\n  var numListenersBeforeEmit = listeners.length;\n\n  this.emitting++;\n\n  if (!is.array(extraParams)) {\n    extraParams = [extraParams];\n  }\n\n  forEachEventObj(this, function (self, eventObj) {\n    if (manualCallback != null) {\n      listeners = [{\n        event: eventObj.event,\n        type: eventObj.type,\n        namespace: eventObj.namespace,\n        callback: manualCallback\n      }];\n\n      numListenersBeforeEmit = listeners.length;\n    }\n\n    var _loop2 = function _loop2(i) {\n      var listener = listeners[i];\n\n      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n        var args = [eventObj];\n\n        if (extraParams != null) {\n          util.push(args, extraParams);\n        }\n\n        self.beforeEmit(self.context, listener, eventObj);\n\n        if (listener.conf && listener.conf.one) {\n          self.listeners = self.listeners.filter(function (l) {\n            return l !== listener;\n          });\n        }\n\n        var context = self.callbackContext(self.context, listener, eventObj);\n        var ret = listener.callback.apply(context, args);\n\n        self.afterEmit(self.context, listener, eventObj);\n\n        if (ret === false) {\n          eventObj.stopPropagation();\n          eventObj.preventDefault();\n        }\n      } // if listener matches\n    };\n\n    for (var i = 0; i < numListenersBeforeEmit; i++) {\n      _loop2(i);\n    } // for listener\n\n    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n      self.parent(self.context).emit(eventObj, extraParams);\n    }\n  }, events);\n\n  this.emitting--;\n\n  return this;\n};\n\nmodule.exports = Emitter;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// storage for parsed queries\nvar newQuery = function newQuery() {\n  return {\n    classes: [],\n    colonSelectors: [],\n    data: [],\n    group: null,\n    ids: [],\n    meta: [],\n\n    // fake selectors\n    collection: null, // a collection to match against\n    filter: null, // filter function\n\n    // these are defined in the upward direction rather than down (e.g. child)\n    // because we need to go up in Selector.filter()\n    parent: null, // parent query obj\n    ancestor: null, // ancestor query obj\n    subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\n    // use these only when subject has been defined\n    child: null,\n    descendant: null\n  };\n};\n\nmodule.exports = newQuery;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar window = __webpack_require__(4);\nvar util = __webpack_require__(1);\nvar Collection = __webpack_require__(7);\nvar is = __webpack_require__(0);\nvar Promise = __webpack_require__(5);\nvar define = __webpack_require__(3);\n\nvar Core = function Core(opts) {\n  var cy = this;\n\n  opts = util.extend({}, opts);\n\n  var container = opts.container;\n\n  // allow for passing a wrapped jquery object\n  // e.g. cytoscape({ container: $('#cy') })\n  if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {\n    container = container[0];\n  }\n\n  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n  reg = reg || {};\n\n  if (reg && reg.cy) {\n    reg.cy.destroy();\n\n    reg = {}; // old instance => replace reg completely\n  }\n\n  var readies = reg.readies = reg.readies || [];\n\n  if (container) {\n    container._cyreg = reg;\n  } // make sure container assoc'd reg points to this cy\n  reg.cy = cy;\n\n  var head = window !== undefined && container !== undefined && !opts.headless;\n  var options = opts;\n  options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);\n  options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);\n\n  var defVal = function defVal(def, val, altVal) {\n    if (val !== undefined) {\n      return val;\n    } else if (altVal !== undefined) {\n      return altVal;\n    } else {\n      return def;\n    }\n  };\n\n  var _p = this._private = {\n    container: container, // html dom ele container\n    ready: false, // whether ready has been triggered\n    options: options, // cached options\n    elements: new Collection(this), // elements in the graph\n    listeners: [], // list of listeners\n    aniEles: new Collection(this), // elements being animated\n    scratch: {}, // scratch object for core\n    layout: null,\n    renderer: null,\n    destroyed: false, // whether destroy was called\n    notificationsEnabled: true, // whether notifications are sent to the renderer\n    minZoom: 1e-50,\n    maxZoom: 1e50,\n    zoomingEnabled: defVal(true, options.zoomingEnabled),\n    userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n    panningEnabled: defVal(true, options.panningEnabled),\n    userPanningEnabled: defVal(true, options.userPanningEnabled),\n    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n    autolock: defVal(false, options.autolock, options.autolockNodes),\n    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n    autounselectify: defVal(false, options.autounselectify),\n    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n    zoom: is.number(options.zoom) ? options.zoom : 1,\n    pan: {\n      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,\n      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0\n    },\n    animation: { // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    hasCompoundNodes: false\n  };\n\n  this.createEmitter();\n\n  // set selection type\n  var selType = options.selectionType;\n  if (selType === undefined || selType !== 'additive' && selType !== 'single') {\n    // then set default\n\n    _p.selectionType = 'single';\n  } else {\n    _p.selectionType = selType;\n  }\n\n  // init zoom bounds\n  if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {\n    _p.minZoom = options.minZoom;\n    _p.maxZoom = options.maxZoom;\n  } else if (is.number(options.minZoom) && options.maxZoom === undefined) {\n    _p.minZoom = options.minZoom;\n  } else if (is.number(options.maxZoom) && options.minZoom === undefined) {\n    _p.maxZoom = options.maxZoom;\n  }\n\n  var loadExtData = function loadExtData(extData, next) {\n    var anyIsPromise = extData.some(is.promise);\n\n    if (anyIsPromise) {\n      return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init\n    } else {\n      next(extData); // exec synchronously for convenience\n    }\n  };\n\n  // start with the default stylesheet so we have something before loading an external stylesheet\n  if (_p.styleEnabled) {\n    cy.setStyle([]);\n  }\n\n  // create the renderer\n  cy.initRenderer(util.extend({\n    hideEdgesOnViewport: options.hideEdgesOnViewport,\n    textureOnViewport: options.textureOnViewport,\n    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default\n    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,\n    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,\n    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,\n    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold\n  }, options.renderer));\n\n  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n    cy.notifications(false);\n\n    // remove old elements\n    var oldEles = cy.mutableElements();\n    if (oldEles.length > 0) {\n      oldEles.remove();\n    }\n\n    if (elements != null) {\n      if (is.plainObject(elements) || is.array(elements)) {\n        cy.add(elements);\n      }\n    }\n\n    cy.one('layoutready', function (e) {\n      cy.notifications(true);\n      cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n      cy.notify({\n        type: 'load',\n        eles: cy.mutableElements()\n      });\n\n      cy.one('load', onload);\n      cy.emit('load');\n    }).one('layoutstop', function () {\n      cy.one('done', ondone);\n      cy.emit('done');\n    });\n\n    var layoutOpts = util.extend({}, cy._private.options.layout);\n    layoutOpts.eles = cy.elements();\n\n    cy.layout(layoutOpts).run();\n  };\n\n  loadExtData([options.style, options.elements], function (thens) {\n    var initStyle = thens[0];\n    var initEles = thens[1];\n\n    // init style\n    if (_p.styleEnabled) {\n      cy.style().append(initStyle);\n    }\n\n    // initial load\n    setElesAndLayout(initEles, function () {\n      // onready\n      cy.startAnimationLoop();\n      _p.ready = true;\n\n      // if a ready callback is specified as an option, the bind it\n      if (is.fn(options.ready)) {\n        cy.on('ready', options.ready);\n      }\n\n      // bind all the ready handlers registered before creating this instance\n      for (var i = 0; i < readies.length; i++) {\n        var fn = readies[i];\n        cy.on('ready', fn);\n      }\n      if (reg) {\n        reg.readies = [];\n      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n      cy.emit('ready');\n    }, options.done);\n  });\n};\n\nvar corefn = Core.prototype; // short alias\n\nutil.extend(corefn, {\n  instanceString: function instanceString() {\n    return 'core';\n  },\n\n  isReady: function isReady() {\n    return this._private.ready;\n  },\n\n  isDestroyed: function isDestroyed() {\n    return this._private.destroyed;\n  },\n\n  ready: function ready(fn) {\n    if (this.isReady()) {\n      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n    } else {\n      this.on('ready', fn);\n    }\n\n    return this;\n  },\n\n  destroy: function destroy() {\n    var cy = this;\n    if (cy.isDestroyed()) return;\n\n    cy.stopAnimationLoop();\n\n    cy.destroyRenderer();\n\n    this.emit('destroy');\n\n    cy._private.destroyed = true;\n\n    return cy;\n  },\n\n  hasElementWithId: function hasElementWithId(id) {\n    return this._private.elements.hasElementWithId(id);\n  },\n\n  getElementById: function getElementById(id) {\n    return this._private.elements.getElementById(id);\n  },\n\n  selectionType: function selectionType() {\n    return this._private.selectionType;\n  },\n\n  hasCompoundNodes: function hasCompoundNodes() {\n    return this._private.hasCompoundNodes;\n  },\n\n  headless: function headless() {\n    return this._private.options.renderer.name === 'null';\n  },\n\n  styleEnabled: function styleEnabled() {\n    return this._private.styleEnabled;\n  },\n\n  addToPool: function addToPool(eles) {\n    this._private.elements.merge(eles);\n\n    return this; // chaining\n  },\n\n  removeFromPool: function removeFromPool(eles) {\n    this._private.elements.unmerge(eles);\n\n    return this;\n  },\n\n  container: function container() {\n    return this._private.container;\n  },\n\n  options: function options() {\n    return util.copy(this._private.options);\n  },\n\n  json: function json(obj) {\n    var cy = this;\n    var _p = cy._private;\n    var eles = cy.mutableElements();\n\n    if (is.plainObject(obj)) {\n      // set\n\n      cy.startBatch();\n\n      if (obj.elements) {\n        var idInJson = {};\n\n        var updateEles = function updateEles(jsons, gr) {\n          for (var i = 0; i < jsons.length; i++) {\n            var json = jsons[i];\n            var id = json.data.id;\n            var ele = cy.getElementById(id);\n\n            idInJson[id] = true;\n\n            if (ele.length !== 0) {\n              // existing element should be updated\n              ele.json(json);\n            } else {\n              // otherwise should be added\n              if (gr) {\n                cy.add(util.extend({ group: gr }, json));\n              } else {\n                cy.add(json);\n              }\n            }\n          }\n        };\n\n        if (is.array(obj.elements)) {\n          // elements: []\n          updateEles(obj.elements);\n        } else {\n          // elements: { nodes: [], edges: [] }\n          var grs = ['nodes', 'edges'];\n          for (var i = 0; i < grs.length; i++) {\n            var gr = grs[i];\n            var elements = obj.elements[gr];\n\n            if (is.array(elements)) {\n              updateEles(elements, gr);\n            }\n          }\n        }\n\n        // elements not specified in json should be removed\n        eles.stdFilter(function (ele) {\n          return !idInJson[ele.id()];\n        }).remove();\n      }\n\n      if (obj.style) {\n        cy.style(obj.style);\n      }\n\n      if (obj.zoom != null && obj.zoom !== _p.zoom) {\n        cy.zoom(obj.zoom);\n      }\n\n      if (obj.pan) {\n        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n          cy.pan(obj.pan);\n        }\n      }\n\n      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];\n\n      for (var _i = 0; _i < fields.length; _i++) {\n        var f = fields[_i];\n\n        if (obj[f] != null) {\n          cy[f](obj[f]);\n        }\n      }\n\n      cy.endBatch();\n\n      return this; // chaining\n    } else if (obj === undefined) {\n      // get\n      var json = {};\n\n      json.elements = {};\n      eles.forEach(function (ele) {\n        var group = ele.group();\n\n        if (!json.elements[group]) {\n          json.elements[group] = [];\n        }\n\n        json.elements[group].push(ele.json());\n      });\n\n      if (this._private.styleEnabled) {\n        json.style = cy.style().json();\n      }\n\n      json.zoomingEnabled = cy._private.zoomingEnabled;\n      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n      json.zoom = cy._private.zoom;\n      json.minZoom = cy._private.minZoom;\n      json.maxZoom = cy._private.maxZoom;\n      json.panningEnabled = cy._private.panningEnabled;\n      json.userPanningEnabled = cy._private.userPanningEnabled;\n      json.pan = util.copy(cy._private.pan);\n      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n      json.renderer = util.copy(cy._private.options.renderer);\n      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n      json.textureOnViewport = cy._private.options.textureOnViewport;\n      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n      json.motionBlur = cy._private.options.motionBlur;\n\n      return json;\n    }\n  },\n\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true\n  }),\n\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true\n  })\n\n});\n\ncorefn.$id = corefn.getElementById;\n\n[__webpack_require__(55), __webpack_require__(59), __webpack_require__(64), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71)].forEach(function (props) {\n  util.extend(corefn, props);\n});\n\nmodule.exports = Core;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar Set = __webpack_require__(9);\n\n// represents a node or an edge\nvar Element = function Element(cy, params, restore) {\n  restore = restore === undefined || restore ? true : false;\n\n  if (cy === undefined || params === undefined || !is.core(cy)) {\n    util.error('An element must have a core reference and parameters set');\n    return;\n  }\n\n  var group = params.group;\n\n  // try to automatically infer the group if unspecified\n  if (group == null) {\n    if (params.data && params.data.source != null && params.data.target != null) {\n      group = 'edges';\n    } else {\n      group = 'nodes';\n    }\n  }\n\n  // validate group\n  if (group !== 'nodes' && group !== 'edges') {\n    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n    return;\n  }\n\n  // make the element array-like, just like a collection\n  this.length = 1;\n  this[0] = this;\n\n  // NOTE: when something is added here, add also to ele.json()\n  var _p = this._private = {\n    cy: cy,\n    single: true, // indicates this is an element\n    data: params.data || {}, // data object\n    position: params.position || {}, // (x, y) position pair\n    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n    autoHeight: undefined,\n    autoPadding: undefined,\n    compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read\n    listeners: [], // array of bound listeners\n    group: group, // string; 'nodes' or 'edges'\n    style: {}, // properties as set by the style\n    rstyle: {}, // properties for style sent from the renderer to the core\n    styleCxts: [], // applied style contexts from the styler\n    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n    selected: params.selected ? true : false, // whether it's selected\n    selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable\n    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed\n    active: false, // whether the element is active from user interaction\n    classes: new Set(), // map ( className => true )\n    animation: { // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    rscratch: {}, // object in which the renderer can store information\n    scratch: params.scratch || {}, // scratch objects\n    edges: [], // array of connected edges\n    children: [], // array of children\n    parent: null, // parent ref\n    traversalCache: {} // cache of output of traversal functions\n  };\n\n  // renderedPosition overrides if specified\n  if (params.renderedPosition) {\n    var rpos = params.renderedPosition;\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n\n    _p.position = {\n      x: (rpos.x - pan.x) / zoom,\n      y: (rpos.y - pan.y) / zoom\n    };\n  }\n\n  if (is.string(params.classes)) {\n    var classes = params.classes.split(/\\s+/);\n    for (var i = 0, l = classes.length; i < l; i++) {\n      var cls = classes[i];\n      if (!cls || cls === '') {\n        continue;\n      }\n\n      _p.classes.add(cls);\n    }\n  }\n\n  if (params.style || params.css) {\n    cy.style().applyBypass(this, params.style || params.css);\n  }\n\n  this.createEmitter();\n\n  if (restore === undefined || restore) {\n    this.restore();\n  }\n};\n\nmodule.exports = Element;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */\nvar util = __webpack_require__(1);\n\nvar zIndexSort = function zIndexSort(a, b) {\n  var cy = a.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n\n  function getDepth(ele) {\n    var style = ele.pstyle('z-compound-depth');\n    if (style.value === 'auto') {\n      return hasCompoundNodes ? ele.zDepth() : 0;\n    } else if (style.value === 'bottom') {\n      return -1;\n    } else if (style.value === 'top') {\n      return util.MAX_INT;\n    }\n    // 'orphan'\n    return 0;\n  }\n  var depthDiff = getDepth(a) - getDepth(b);\n  if (depthDiff !== 0) {\n    return depthDiff;\n  }\n\n  function getEleDepth(ele) {\n    var style = ele.pstyle('z-index-compare');\n    if (style.value === 'auto') {\n      return ele.isNode() ? 1 : 0;\n    }\n    // 'manual'\n    return 0;\n  }\n  var eleDiff = getEleDepth(a) - getEleDepth(b);\n  if (eleDiff !== 0) {\n    return eleDiff;\n  }\n\n  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n  if (zDiff !== 0) {\n    return zDiff;\n  }\n  // compare indices in the core (order added to graph w/ last on top)\n  return a.poolIndex() - b.poolIndex();\n};\n\nmodule.exports = zIndexSort;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/\n\nvar Event = function Event(src, props) {\n  this.recycle(src, props);\n};\n\nfunction returnFalse() {\n  return false;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n  instanceString: function instanceString() {\n    return 'event';\n  },\n\n  recycle: function recycle(src, props) {\n    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n\n    if (src != null && src.preventDefault) {\n      // Browser Event object\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n    } else if (src != null && src.type) {\n      // Plain object containing all event details\n      props = src;\n    } else {\n      // Event string\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props != null) {\n      // more efficient to manually copy fields we use\n      this.originalEvent = props.originalEvent;\n      this.type = props.type != null ? props.type : this.type;\n      this.cy = props.cy;\n      this.target = props.target;\n      this.position = props.position;\n      this.renderedPosition = props.renderedPosition;\n      this.namespace = props.namespace;\n      this.layout = props.layout;\n    }\n\n    if (this.cy != null && this.position != null && this.renderedPosition == null) {\n      // create a rendered position based on the passed position\n      var pos = this.position;\n      var zoom = this.cy.zoom();\n      var pan = this.cy.pan();\n\n      this.renderedPosition = {\n        x: pos.x * zoom + pan.x,\n        y: pos.y * zoom + pan.y\n      };\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || Date.now();\n  },\n\n  preventDefault: function preventDefault() {\n    this.isDefaultPrevented = returnTrue;\n\n    var e = this.originalEvent;\n    if (!e) {\n      return;\n    }\n\n    // if preventDefault exists run it on the original event\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n  },\n\n  stopPropagation: function stopPropagation() {\n    this.isPropagationStopped = returnTrue;\n\n    var e = this.originalEvent;\n    if (!e) {\n      return;\n    }\n\n    // if stopPropagation exists run it on the original event\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n  },\n\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    this.isImmediatePropagationStopped = returnTrue;\n    this.stopPropagation();\n  },\n\n  isDefaultPrevented: returnFalse,\n  isPropagationStopped: returnFalse,\n  isImmediatePropagationStopped: returnFalse\n};\n\nmodule.exports = Event;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\n\nmodule.exports = {\n  setupDequeueing: function setupDequeueing(opts) {\n    return function setupDequeueingImpl() {\n      var self = this;\n      var r = this.renderer;\n\n      if (self.dequeueingSetup) {\n        return;\n      } else {\n        self.dequeueingSetup = true;\n      }\n\n      var queueRedraw = util.debounce(function () {\n        r.redrawHint('eles', true);\n        r.redrawHint('drag', true);\n\n        r.redraw();\n      }, opts.deqRedrawThreshold);\n\n      var dequeue = function dequeue(willDraw, frameStartTime) {\n        var startTime = util.performanceNow();\n        var avgRenderTime = r.averageRedrawTime;\n        var renderTime = r.lastRedrawTime;\n        var deqd = [];\n        var extent = r.cy.extent();\n        var pixelRatio = r.getPixelRatio();\n\n        while (true) {\n          var now = util.performanceNow();\n          var duration = now - startTime;\n          var frameDuration = now - frameStartTime;\n\n          if (renderTime < fullFpsTime) {\n            // if we're rendering faster than the ideal fps, then do dequeueing\n            // during all of the remaining frame time\n\n            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n\n            if (frameDuration >= opts.deqFastCost * timeAvailable) {\n              break;\n            }\n          } else {\n            if (willDraw) {\n              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                break;\n              }\n            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n              break;\n            }\n          }\n\n          var thisDeqd = opts.deq(self, pixelRatio, extent);\n\n          if (thisDeqd.length > 0) {\n            for (var i = 0; i < thisDeqd.length; i++) {\n              deqd.push(thisDeqd[i]);\n            }\n          } else {\n            break;\n          }\n        }\n\n        // callbacks on dequeue\n        if (deqd.length > 0) {\n          opts.onDeqd(self, deqd);\n\n          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n            queueRedraw();\n          }\n        }\n      };\n\n      var priority = opts.priority || util.noop;\n\n      r.beforeRender(dequeue, priority(self));\n    };\n  }\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar stateSelectors = [{\n  selector: ':selected',\n  matches: function matches(ele) {\n    return ele.selected();\n  }\n}, {\n  selector: ':unselected',\n  matches: function matches(ele) {\n    return !ele.selected();\n  }\n}, {\n  selector: ':selectable',\n  matches: function matches(ele) {\n    return ele.selectable();\n  }\n}, {\n  selector: ':unselectable',\n  matches: function matches(ele) {\n    return !ele.selectable();\n  }\n}, {\n  selector: ':locked',\n  matches: function matches(ele) {\n    return ele.locked();\n  }\n}, {\n  selector: ':unlocked',\n  matches: function matches(ele) {\n    return !ele.locked();\n  }\n}, {\n  selector: ':visible',\n  matches: function matches(ele) {\n    return ele.visible();\n  }\n}, {\n  selector: ':hidden',\n  matches: function matches(ele) {\n    return !ele.visible();\n  }\n}, {\n  selector: ':transparent',\n  matches: function matches(ele) {\n    return ele.transparent();\n  }\n}, {\n  selector: ':grabbed',\n  matches: function matches(ele) {\n    return ele.grabbed();\n  }\n}, {\n  selector: ':free',\n  matches: function matches(ele) {\n    return !ele.grabbed();\n  }\n}, {\n  selector: ':removed',\n  matches: function matches(ele) {\n    return ele.removed();\n  }\n}, {\n  selector: ':inside',\n  matches: function matches(ele) {\n    return !ele.removed();\n  }\n}, {\n  selector: ':grabbable',\n  matches: function matches(ele) {\n    return ele.grabbable();\n  }\n}, {\n  selector: ':ungrabbable',\n  matches: function matches(ele) {\n    return !ele.grabbable();\n  }\n}, {\n  selector: ':animated',\n  matches: function matches(ele) {\n    return ele.animated();\n  }\n}, {\n  selector: ':unanimated',\n  matches: function matches(ele) {\n    return !ele.animated();\n  }\n}, {\n  selector: ':parent',\n  matches: function matches(ele) {\n    return ele.isParent();\n  }\n}, {\n  selector: ':childless',\n  matches: function matches(ele) {\n    return ele.isChildless();\n  }\n}, {\n  selector: ':child',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':orphan',\n  matches: function matches(ele) {\n    return ele.isOrphan();\n  }\n}, {\n  selector: ':nonorphan',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':loop',\n  matches: function matches(ele) {\n    return ele.isLoop();\n  }\n}, {\n  selector: ':simple',\n  matches: function matches(ele) {\n    return ele.isSimple();\n  }\n}, {\n  selector: ':active',\n  matches: function matches(ele) {\n    return ele.active();\n  }\n}, {\n  selector: ':inactive',\n  matches: function matches(ele) {\n    return !ele.active();\n  }\n}, {\n  selector: ':backgrounding',\n  matches: function matches(ele) {\n    return ele.backgrounding();\n  }\n}, {\n  selector: ':nonbackgrounding',\n  matches: function matches(ele) {\n    return !ele.backgrounding();\n  }\n}].sort(function (a, b) {\n  // n.b. selectors that are starting substrings of others must have the longer ones first\n  return util.sort.descending(a.selector, b.selector);\n});\n\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n  var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {\n    var selToFn = {};\n    var s = void 0;\n\n    for (var i = 0; i < stateSelectors.length; i++) {\n      s = stateSelectors[i];\n\n      selToFn[s.selector] = s.matches;\n    }\n\n    return selToFn;\n  }();\n\n  return lookup[sel](ele);\n};\n\nvar stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n  return s.selector;\n}).join('|') + ')';\n\nmodule.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Selector = __webpack_require__(6);\n\nvar Style = function Style(cy) {\n\n  if (!(this instanceof Style)) {\n    return new Style(cy);\n  }\n\n  if (!is.core(cy)) {\n    util.error('A style must have a core reference');\n    return;\n  }\n\n  this._private = {\n    cy: cy,\n    coreStyle: {}\n  };\n\n  this.length = 0;\n\n  this.resetToDefault();\n};\n\nvar styfn = Style.prototype;\n\nstyfn.instanceString = function () {\n  return 'style';\n};\n\n// remove all contexts\nstyfn.clear = function () {\n  for (var i = 0; i < this.length; i++) {\n    this[i] = undefined;\n  }\n  this.length = 0;\n\n  var _p = this._private;\n\n  _p.newStyle = true;\n\n  return this; // chaining\n};\n\nstyfn.resetToDefault = function () {\n  this.clear();\n  this.addDefaultStylesheet();\n\n  return this;\n};\n\n// builds a style object for the 'core' selector\nstyfn.core = function () {\n  return this._private.coreStyle;\n};\n\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function (selectorStr) {\n  // 'core' is a special case and does not need a selector\n  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n\n  var i = this.length++; // new context means new index\n  this[i] = {\n    selector: selector,\n    properties: [],\n    mappedProperties: [],\n    index: i\n  };\n\n  return this; // chaining\n};\n\n// add one or many css rules to the current context\nstyfn.css = function () {\n  var self = this;\n  var args = arguments;\n\n  switch (args.length) {\n    case 1:\n      var map = args[0];\n\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var mapVal = map[prop.name];\n\n        if (mapVal === undefined) {\n          mapVal = map[util.dash2camel(prop.name)];\n        }\n\n        if (mapVal !== undefined) {\n          this.cssRule(prop.name, mapVal);\n        }\n      }\n\n      break;\n\n    case 2:\n      this.cssRule(args[0], args[1]);\n      break;\n\n    default:\n      break; // do nothing if args are invalid\n  }\n\n  return this; // chaining\n};\nstyfn.style = styfn.css;\n\n// add a single css rule to the current context\nstyfn.cssRule = function (name, value) {\n  // name-value pair\n  var property = this.parse(name, value);\n\n  // add property to current context if valid\n  if (property) {\n    var i = this.length - 1;\n    this[i].properties.push(property);\n    this[i].properties[property.name] = property; // allow access by name as well\n\n    if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n      this._private.hasPie = true;\n    }\n\n    if (property.mapped) {\n      this[i].mappedProperties.push(property);\n    }\n\n    // add to core style if necessary\n    var currentSelectorIsCore = !this[i].selector;\n    if (currentSelectorIsCore) {\n      this._private.coreStyle[property.name] = property;\n    }\n  }\n\n  return this; // chaining\n};\n\nstyfn.append = function (style) {\n  if (is.stylesheet(style)) {\n    style.appendToStyle(this);\n  } else if (is.array(style)) {\n    this.appendFromJson(style);\n  } else if (is.string(style)) {\n    this.appendFromString(style);\n  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n  return this;\n};\n\n// static function\nStyle.fromJson = function (cy, json) {\n  var style = new Style(cy);\n\n  style.fromJson(json);\n\n  return style;\n};\n\nStyle.fromString = function (cy, string) {\n  return new Style(cy).fromString(string);\n};\n\n[__webpack_require__(122), __webpack_require__(123), __webpack_require__(124), __webpack_require__(125), __webpack_require__(126), __webpack_require__(129), __webpack_require__(128), __webpack_require__(127)].forEach(function (props) {\n  util.extend(styfn, props);\n});\n\nStyle.types = styfn.types;\nStyle.properties = styfn.properties;\n\nmodule.exports = Style;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function memoize(fn, keyFn) {\n  if (!keyFn) {\n    keyFn = function keyFn() {\n      if (arguments.length === 1) {\n        return arguments[0];\n      } else if (arguments.length === 0) {\n        return 'undefined';\n      }\n\n      var args = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n\n      return args.join('$');\n    };\n  }\n\n  var memoizedFn = function memoizedFn() {\n    var self = this;\n    var args = arguments;\n    var ret = void 0;\n    var k = keyFn.apply(self, args);\n    var cache = memoizedFn.cache;\n\n    if (!(ret = cache[k])) {\n      ret = cache[k] = fn.apply(self, args);\n    }\n\n    return ret;\n  };\n\n  memoizedFn.cache = {};\n\n  return memoizedFn;\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar define = __webpack_require__(3);\nvar Collection = __webpack_require__(7);\nvar Core = __webpack_require__(12);\nvar incExts = __webpack_require__(75);\nvar is = __webpack_require__(0);\nvar Emitter = __webpack_require__(10);\n\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n\n// registered modules for extensions, indexed by name\nvar modules = {};\n\nfunction setExtension(type, name, registrant) {\n\n  var ext = registrant;\n\n  var overrideErr = function overrideErr(field) {\n    util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n  };\n\n  if (type === 'core') {\n    if (Core.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Core.prototype[name] = registrant;\n    }\n  } else if (type === 'collection') {\n    if (Collection.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Collection.prototype[name] = registrant;\n    }\n  } else if (type === 'layout') {\n    // fill in missing layout functions in the prototype\n\n    var Layout = function Layout(options) {\n      this.options = options;\n\n      registrant.call(this, options);\n\n      // make sure layout has _private for use w/ std apis like .on()\n      if (!is.plainObject(this._private)) {\n        this._private = {};\n      }\n\n      this._private.cy = options.cy;\n      this._private.listeners = [];\n\n      this.createEmitter();\n    };\n\n    var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n\n    var optLayoutFns = [];\n\n    for (var i = 0; i < optLayoutFns.length; i++) {\n      var fnName = optLayoutFns[i];\n\n      layoutProto[fnName] = layoutProto[fnName] || function () {\n        return this;\n      };\n    }\n\n    // either .start() or .run() is defined, so autogen the other\n    if (layoutProto.start && !layoutProto.run) {\n      layoutProto.run = function () {\n        this.start();return this;\n      };\n    } else if (!layoutProto.start && layoutProto.run) {\n      layoutProto.start = function () {\n        this.run();return this;\n      };\n    }\n\n    var regStop = registrant.prototype.stop;\n    layoutProto.stop = function () {\n      var opts = this.options;\n\n      if (opts && opts.animate) {\n        var anis = this.animations;\n\n        if (anis) {\n          for (var _i = 0; _i < anis.length; _i++) {\n            anis[_i].stop();\n          }\n        }\n      }\n\n      if (regStop) {\n        regStop.call(this);\n      } else {\n        this.emit('layoutstop');\n      }\n\n      return this;\n    };\n\n    if (!layoutProto.destroy) {\n      layoutProto.destroy = function () {\n        return this;\n      };\n    }\n\n    layoutProto.cy = function () {\n      return this._private.cy;\n    };\n\n    var getCy = function getCy(layout) {\n      return layout._private.cy;\n    };\n\n    util.assign(layoutProto, {\n      createEmitter: function createEmitter() {\n        this._private.emitter = new Emitter({\n          eventFields: function eventFields(layout) {\n            return {\n              layout: layout,\n              cy: getCy(layout),\n              target: layout\n            };\n          },\n          bubble: function bubble() {\n            return true;\n          },\n          parent: function parent(layout) {\n            return getCy(layout);\n          },\n          context: this\n        });\n\n        return this;\n      },\n      emitter: function emitter() {\n        return this._private.emitter;\n      },\n      on: function on(evt, cb) {\n        this.emitter().on(evt, cb);return this;\n      },\n      one: function one(evt, cb) {\n        this.emitter().one(evt, cb);return this;\n      },\n      once: function once(evt, cb) {\n        this.emitter().one(evt, cb);return this;\n      },\n      removeListener: function removeListener(evt, cb) {\n        this.emitter().removeListener(evt, cb);return this;\n      },\n      emit: function emit(evt, params) {\n        this.emitter().emit(evt, params);return this;\n      }\n    });\n\n    define.eventAliasesOn(layoutProto);\n\n    ext = Layout; // replace with our wrapped layout\n  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n    // user registered renderers inherit from base\n\n    var BaseRenderer = getExtension('renderer', 'base');\n    var bProto = BaseRenderer.prototype;\n    var RegistrantRenderer = registrant;\n    var rProto = registrant.prototype;\n\n    var Renderer = function Renderer() {\n      BaseRenderer.apply(this, arguments);\n      RegistrantRenderer.apply(this, arguments);\n    };\n\n    var proto = Renderer.prototype;\n\n    for (var pName in bProto) {\n      var pVal = bProto[pName];\n      var existsInR = rProto[pName] != null;\n\n      if (existsInR) {\n        return overrideErr(pName);\n      }\n\n      proto[pName] = pVal; // take impl from base\n    }\n\n    for (var _pName in rProto) {\n      proto[_pName] = rProto[_pName]; // take impl from registrant\n    }\n\n    bProto.clientFunctions.forEach(function (name) {\n      proto[name] = proto[name] || function () {\n        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n      };\n    });\n\n    ext = Renderer;\n  }\n\n  return util.setMap({\n    map: extensions,\n    keys: [type, name],\n    value: ext\n  });\n}\n\nfunction getExtension(type, name) {\n  return util.getMap({\n    map: extensions,\n    keys: [type, name]\n  });\n}\n\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n  return util.setMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName],\n    value: registrant\n  });\n}\n\nfunction getModule(type, name, moduleType, moduleName) {\n  return util.getMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName]\n  });\n}\n\nvar extension = function extension() {\n  // e.g. extension('renderer', 'svg')\n  if (arguments.length === 2) {\n    return getExtension.apply(null, arguments);\n  }\n\n  // e.g. extension('renderer', 'svg', { ... })\n  else if (arguments.length === 3) {\n      return setExtension.apply(null, arguments);\n    }\n\n    // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n    else if (arguments.length === 4) {\n        return getModule.apply(null, arguments);\n      }\n\n      // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n      else if (arguments.length === 5) {\n          return setModule.apply(null, arguments);\n        } else {\n          util.error('Invalid extension access syntax');\n        }\n};\n\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n\n// included extensions\nincExts.forEach(function (group) {\n  group.extensions.forEach(function (ext) {\n    setExtension(group.type, ext.name, ext.impl);\n  });\n});\n\nmodule.exports = extension;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Style = __webpack_require__(18);\n\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar Stylesheet = function Stylesheet() {\n  if (!(this instanceof Stylesheet)) {\n    return new Stylesheet();\n  }\n\n  this.length = 0;\n};\n\nvar sheetfn = Stylesheet.prototype;\n\nsheetfn.instanceString = function () {\n  return 'stylesheet';\n};\n\n// just store the selector to be parsed later\nsheetfn.selector = function (selector) {\n  var i = this.length++;\n\n  this[i] = {\n    selector: selector,\n    properties: []\n  };\n\n  return this; // chaining\n};\n\n// just store the property to be parsed later\nsheetfn.css = function (name, value) {\n  var i = this.length - 1;\n\n  if (is.string(name)) {\n    this[i].properties.push({\n      name: name,\n      value: value\n    });\n  } else if (is.plainObject(name)) {\n    var map = name;\n\n    for (var j = 0; j < Style.properties.length; j++) {\n      var prop = Style.properties[j];\n      var mapVal = map[prop.name];\n\n      if (mapVal === undefined) {\n        // also try camel case name\n        mapVal = map[util.dash2camel(prop.name)];\n      }\n\n      if (mapVal !== undefined) {\n        var _name = prop.name;\n        var _value = mapVal;\n\n        this[i].properties.push({\n          name: _name,\n          value: _value\n        });\n      }\n    }\n  }\n\n  return this; // chaining\n};\n\nsheetfn.style = sheetfn.css;\n\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function (cy) {\n  var style = new Style(cy);\n\n  return this.appendToStyle(style);\n};\n\n// append a dummy stylesheet object on a real style object\nsheetfn.appendToStyle = function (style) {\n  for (var i = 0; i < this.length; i++) {\n    var context = this[i];\n    var selector = context.selector;\n    var props = context.properties;\n\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n\n      style.css(prop.name, prop.value); // apply property\n    }\n  }\n\n  return style;\n};\n\nmodule.exports = Stylesheet;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = \"3.2.5\";\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar Promise = __webpack_require__(5);\n\nvar Animation = function Animation(target, opts, opts2) {\n  var _p = this._private = util.extend({\n    duration: 1000\n  }, opts, opts2);\n\n  _p.target = target;\n  _p.style = _p.style || _p.css;\n  _p.started = false;\n  _p.playing = false;\n  _p.hooked = false;\n  _p.applying = false;\n  _p.progress = 0;\n  _p.completes = [];\n  _p.frames = [];\n\n  if (_p.complete && is.fn(_p.complete)) {\n    _p.completes.push(_p.complete);\n  }\n\n  // for future timeline/animations impl\n  this.length = 1;\n  this[0] = this;\n};\n\nvar anifn = Animation.prototype;\n\nutil.extend(anifn, {\n\n  instanceString: function instanceString() {\n    return 'animation';\n  },\n\n  hook: function hook() {\n    var _p = this._private;\n\n    if (!_p.hooked) {\n      // add to target's animation queue\n      var q = void 0;\n      var tAni = _p.target._private.animation;\n      if (_p.queue) {\n        q = tAni.queue;\n      } else {\n        q = tAni.current;\n      }\n      q.push(this);\n\n      // add to the animation loop pool\n      if (is.elementOrCollection(_p.target)) {\n        _p.target.cy().addToAnimationPool(_p.target);\n      }\n\n      _p.hooked = true;\n    }\n\n    return this;\n  },\n\n  play: function play() {\n    var _p = this._private;\n\n    // autorewind\n    if (_p.progress === 1) {\n      _p.progress = 0;\n    }\n\n    _p.playing = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n\n    this.hook();\n\n    // the animation loop will start the animation...\n\n    return this;\n  },\n\n  playing: function playing() {\n    return this._private.playing;\n  },\n\n  apply: function apply() {\n    var _p = this._private;\n\n    _p.applying = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n\n    this.hook();\n\n    // the animation loop will apply the animation at this progress\n\n    return this;\n  },\n\n  applying: function applying() {\n    return this._private.applying;\n  },\n\n  pause: function pause() {\n    var _p = this._private;\n\n    _p.playing = false;\n    _p.started = false;\n\n    return this;\n  },\n\n  stop: function stop() {\n    var _p = this._private;\n\n    _p.playing = false;\n    _p.started = false;\n    _p.stopped = true; // to be removed from animation queues\n\n    return this;\n  },\n\n  rewind: function rewind() {\n    return this.progress(0);\n  },\n\n  fastforward: function fastforward() {\n    return this.progress(1);\n  },\n\n  time: function time(t) {\n    var _p = this._private;\n\n    if (t === undefined) {\n      return _p.progress * _p.duration;\n    } else {\n      return this.progress(t / _p.duration);\n    }\n  },\n\n  progress: function progress(p) {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if (p === undefined) {\n      return _p.progress;\n    } else {\n      if (wasPlaying) {\n        this.pause();\n      }\n\n      _p.progress = p;\n      _p.started = false;\n\n      if (wasPlaying) {\n        this.play();\n      }\n    }\n\n    return this;\n  },\n\n  completed: function completed() {\n    return this._private.progress === 1;\n  },\n\n  reverse: function reverse() {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if (wasPlaying) {\n      this.pause();\n    }\n\n    _p.progress = 1 - _p.progress;\n    _p.started = false;\n\n    var swap = function swap(a, b) {\n      var _pa = _p[a];\n\n      if (_pa == null) {\n        return;\n      }\n\n      _p[a] = _p[b];\n      _p[b] = _pa;\n    };\n\n    swap('zoom', 'startZoom');\n    swap('pan', 'startPan');\n    swap('position', 'startPosition');\n\n    // swap styles\n    if (_p.style) {\n      for (var i = 0; i < _p.style.length; i++) {\n        var prop = _p.style[i];\n        var name = prop.name;\n        var startStyleProp = _p.startStyle[name];\n\n        _p.startStyle[name] = prop;\n        _p.style[i] = startStyleProp;\n      }\n    }\n\n    if (wasPlaying) {\n      this.play();\n    }\n\n    return this;\n  },\n\n  promise: function promise(type) {\n    var _p = this._private;\n\n    var arr = void 0;\n\n    switch (type) {\n      case 'frame':\n        arr = _p.frames;\n        break;\n      default:\n      case 'complete':\n      case 'completed':\n        arr = _p.completes;\n    }\n\n    return new Promise(function (resolve, reject) {\n      arr.push(function () {\n        resolve();\n      });\n    });\n  }\n\n});\n\nanifn.complete = anifn.completed;\n\nmodule.exports = Animation;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar elesfn = {\n\n  // Implemented from pseudocode from wikipedia\n  aStar: function aStar(options) {\n    var eles = this;\n\n    options = options || {};\n\n    // Reconstructs the path from Start to End, acumulating the result in pathAcum\n    var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {\n      // Base case\n      if (start == end) {\n        pathAcum.unshift(cy.getElementById(end));\n        return pathAcum;\n      }\n\n      if (end in cameFromMap) {\n        // We know which node is before the last one\n        var previous = cameFromMap[end];\n        var previousEdge = cameFromEdge[end];\n\n        pathAcum.unshift(cy.getElementById(previousEdge));\n        pathAcum.unshift(cy.getElementById(end));\n\n        return reconstructPath(start, previous, cameFromMap, pathAcum);\n      }\n\n      // We should not reach here!\n      return undefined;\n    };\n\n    // Returns the index of the element in openSet which has minimum fScore\n    var findMin = function findMin(openSet, fScore) {\n      if (openSet.length === 0) {\n        // Should never be the case\n        return undefined;\n      }\n      var minPos = 0;\n      var tempScore = fScore[openSet[0]];\n      for (var i = 1; i < openSet.length; i++) {\n        var s = fScore[openSet[i]];\n        if (s < tempScore) {\n          tempScore = s;\n          minPos = i;\n        }\n      }\n      return minPos;\n    };\n\n    var cy = this._private.cy;\n\n    // root - mandatory!\n    if (options != null && options.root != null) {\n      var source = is.string(options.root) ?\n      // use it as a selector, e.g. \"#rootID\n      this.filter(options.root)[0] : options.root[0];\n    } else {\n      return undefined;\n    }\n\n    // goal - mandatory!\n    if (options.goal != null) {\n      var target = is.string(options.goal) ?\n      // use it as a selector, e.g. \"#goalID\n      this.filter(options.goal)[0] : options.goal[0];\n    } else {\n      return undefined;\n    }\n\n    // Heuristic function - optional\n    if (options.heuristic != null && is.fn(options.heuristic)) {\n      var heuristic = options.heuristic;\n    } else {\n      var heuristic = function heuristic() {\n        return 0;\n      }; // use constant if unspecified\n    }\n\n    // Weight function - optional\n    if (options.weight != null && is.fn(options.weight)) {\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function weightFn(e) {\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if (options.directed != null) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var sid = source.id();\n    var tid = target.id();\n\n    var closedSet = [];\n    var openSet = [sid];\n    var cameFrom = {};\n    var cameFromEdge = {};\n    var gScore = {};\n    var fScore = {};\n\n    gScore[sid] = 0;\n    fScore[sid] = heuristic(source);\n\n    // Counter\n    var steps = 0;\n\n    // Main loop\n    while (openSet.length > 0) {\n      var minPos = findMin(openSet, fScore);\n      var cMin = cy.getElementById(openSet[minPos]);\n      var cMinId = cMin.id();\n      steps++;\n\n      // If we've found our goal, then we are done\n      if (cMinId == tid) {\n        var rPath = reconstructPath(sid, tid, cameFrom, []);\n\n        return {\n          found: true,\n          distance: gScore[cMinId],\n          path: eles.spawn(rPath),\n          steps: steps\n        };\n      }\n\n      // Add cMin to processed nodes\n      closedSet.push(cMinId);\n      // Remove cMin from boundary nodes\n      openSet.splice(minPos, 1);\n\n      // Update scores for neighbors of cMin\n      // Take into account if graph is directed or not\n      var vwEdges = cMin._private.edges;\n\n      for (var i = 0; i < vwEdges.length; i++) {\n        var e = vwEdges[i];\n\n        // edge must be in set of calling eles\n        if (!this.hasElementWithId(e.id())) {\n          continue;\n        }\n\n        // cMin must be the source of edge if directed\n        if (directed && e.data('source') !== cMinId) {\n          continue;\n        }\n\n        var wSrc = e.source();\n        var wTgt = e.target();\n\n        var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n        var wid = w.id();\n\n        // node must be in set of calling eles\n        if (!this.hasElementWithId(wid)) {\n          continue;\n        }\n\n        // if node is in closedSet, ignore it\n        if (closedSet.indexOf(wid) != -1) {\n          continue;\n        }\n\n        // New tentative score for node w\n        var tempScore = gScore[cMinId] + weightFn(e);\n\n        // Update gScore for node w if:\n        //   w not present in openSet\n        // OR\n        //   tentative gScore is less than previous value\n\n        // w not in openSet\n        if (openSet.indexOf(wid) == -1) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          openSet.push(wid); // Add node to openSet\n          cameFrom[wid] = cMinId;\n          cameFromEdge[wid] = e.id();\n          continue;\n        }\n        // w already in openSet, but with greater gScore\n        if (tempScore < gScore[wid]) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          cameFrom[wid] = cMinId;\n        }\n      } // End of neighbors update\n    } // End of main loop\n\n    // If we've reached here, then we've not reached our goal\n    return {\n      found: false,\n      distance: undefined,\n      path: undefined,\n      steps: steps\n    };\n  }\n\n}; // elesfn\n\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\n\nvar elesfn = {\n\n  // Implemented from pseudocode from wikipedia\n  bellmanFord: function bellmanFord(options) {\n    var eles = this;\n\n    options = options || {};\n\n    // Weight function - optional\n    if (options.weight != null && is.fn(options.weight)) {\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function weightFn(e) {\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if (options.directed != null) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    // root - mandatory!\n    if (options.root != null) {\n      if (is.string(options.root)) {\n        // use it as a selector, e.g. \"#rootID\n        var source = this.filter(options.root)[0];\n      } else {\n        var source = options.root[0];\n      }\n    } else {\n      return undefined;\n    }\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter(function (e) {\n      return !e.isLoop();\n    });\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    // mapping: node id -> position in nodes array\n    var id2position = {};\n    for (var i = 0; i < numNodes; i++) {\n      id2position[nodes[i].id()] = i;\n    }\n\n    // Initializations\n    var cost = [];\n    var predecessor = [];\n    var predEdge = [];\n\n    for (var i = 0; i < numNodes; i++) {\n      if (nodes[i].id() === source.id()) {\n        cost[i] = 0;\n      } else {\n        cost[i] = Infinity;\n      }\n      predecessor[i] = undefined;\n    }\n\n    // Edges relaxation\n    var flag = false;\n    for (var i = 1; i < numNodes; i++) {\n      flag = false;\n      for (var e = 0; e < edges.length; e++) {\n        var sourceIndex = id2position[edges[e].source().id()];\n        var targetIndex = id2position[edges[e].target().id()];\n        var weight = weightFn(edges[e]);\n\n        var temp = cost[sourceIndex] + weight;\n        if (temp < cost[targetIndex]) {\n          cost[targetIndex] = temp;\n          predecessor[targetIndex] = sourceIndex;\n          predEdge[targetIndex] = edges[e];\n          flag = true;\n        }\n\n        // If undirected graph, we need to take into account the 'reverse' edge\n        if (!directed) {\n          var temp = cost[targetIndex] + weight;\n          if (temp < cost[sourceIndex]) {\n            cost[sourceIndex] = temp;\n            predecessor[sourceIndex] = targetIndex;\n            predEdge[sourceIndex] = edges[e];\n            flag = true;\n          }\n        }\n      }\n\n      if (!flag) {\n        break;\n      }\n    }\n\n    if (flag) {\n      // Check for negative weight cycles\n      for (var e = 0; e < edges.length; e++) {\n        var sourceIndex = id2position[edges[e].source().id()];\n        var targetIndex = id2position[edges[e].target().id()];\n        var weight = weightFn(edges[e]);\n\n        if (cost[sourceIndex] + weight < cost[targetIndex]) {\n          util.error('Graph contains a negative weight cycle for Bellman-Ford');\n          return { pathTo: undefined,\n            distanceTo: undefined,\n            hasNegativeWeightCycle: true };\n        }\n      }\n    }\n\n    // Build result object\n    var position2id = [];\n    for (var i = 0; i < numNodes; i++) {\n      position2id.push(nodes[i].id());\n    }\n\n    var res = {\n      distanceTo: function distanceTo(to) {\n        if (is.string(to)) {\n          // to is a selector string\n          var toId = cy.filter(to)[0].id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        return cost[id2position[toId]];\n      },\n\n      pathTo: function pathTo(to) {\n\n        var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {\n          for (;;) {\n            // Add toId to path\n            acumPath.push(cy.getElementById(position2id[toPos]));\n            acumPath.push(predEdge[toPos]);\n\n            if (fromPos === toPos) {\n              // reached starting node\n              return acumPath;\n            }\n\n            // If no path exists, discart acumulated path and return undefined\n            var predPos = predecessor[toPos];\n            if (typeof predPos === 'undefined') {\n              return undefined;\n            }\n\n            toPos = predPos;\n          }\n        };\n\n        if (is.string(to)) {\n          // to is a selector string\n          var toId = cy.filter(to)[0].id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n        var path = [];\n\n        // This returns a reversed path\n        var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);\n\n        // Get it in the correct order and return it\n        if (res != null) {\n          res.reverse();\n        }\n\n        return eles.spawn(res);\n      },\n\n      hasNegativeWeightCycle: false\n    };\n\n    return res;\n  } // bellmanFord\n\n}; // elesfn\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Heap = __webpack_require__(8);\n\nvar elesfn = {\n\n  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n  betweennessCentrality: function betweennessCentrality(options) {\n    options = options || {};\n\n    // Weight - optional\n    var weighted, weightFn;\n    if (is.fn(options.weight)) {\n      weightFn = options.weight;\n      weighted = true;\n    } else {\n      weighted = false;\n    }\n\n    // Directed - default false\n    var directed = options.directed != null ? options.directed : false;\n\n    var cy = this._private.cy;\n\n    // starting\n    var V = this.nodes();\n    var A = {};\n    var _C = {};\n    var max = 0;\n    var C = {\n      set: function set(key, val) {\n        _C[key] = val;\n\n        if (val > max) {\n          max = val;\n        }\n      },\n\n      get: function get(key) {\n        return _C[key];\n      }\n    };\n\n    // A contains the neighborhoods of every node\n    for (var i = 0; i < V.length; i++) {\n      var v = V[i];\n      var vid = v.id();\n\n      if (directed) {\n        A[vid] = v.outgoers().nodes(); // get outgoers of every node\n      } else {\n        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n      }\n\n      C.set(vid, 0);\n    }\n\n    for (var s = 0; s < V.length; s++) {\n      var sid = V[s].id();\n      var S = []; // stack\n      var P = {};\n      var g = {};\n      var d = {};\n      var Q = new Heap(function (a, b) {\n        return d[a] - d[b];\n      }); // queue\n\n      // init dictionaries\n      for (var i = 0; i < V.length; i++) {\n        var vid = V[i].id();\n\n        P[vid] = [];\n        g[vid] = 0;\n        d[vid] = Infinity;\n      }\n\n      g[sid] = 1; // sigma\n      d[sid] = 0; // distance to s\n\n      Q.push(sid);\n\n      while (!Q.empty()) {\n        var v = Q.pop();\n\n        S.push(v);\n\n        if (weighted) {\n          for (var j = 0; j < A[v].length; j++) {\n            var w = A[v][j];\n            var vEle = cy.getElementById(v);\n\n            var edge;\n            if (vEle.edgesTo(w).length > 0) {\n              edge = vEle.edgesTo(w)[0];\n            } else {\n              edge = w.edgesTo(vEle)[0];\n            }\n\n            var edgeWeight = weightFn(edge);\n\n            w = w.id();\n\n            if (d[w] > d[v] + edgeWeight) {\n              d[w] = d[v] + edgeWeight;\n\n              if (Q.nodes.indexOf(w) < 0) {\n                //if w is not in Q\n                Q.push(w);\n              } else {\n                // update position if w is in Q\n                Q.updateItem(w);\n              }\n\n              g[w] = 0;\n              P[w] = [];\n            }\n\n            if (d[w] == d[v] + edgeWeight) {\n              g[w] = g[w] + g[v];\n              P[w].push(v);\n            }\n          }\n        } else {\n          for (var j = 0; j < A[v].length; j++) {\n            var w = A[v][j].id();\n\n            if (d[w] == Infinity) {\n              Q.push(w);\n\n              d[w] = d[v] + 1;\n            }\n\n            if (d[w] == d[v] + 1) {\n              g[w] = g[w] + g[v];\n              P[w].push(v);\n            }\n          }\n        }\n      }\n\n      var e = {};\n      for (var i = 0; i < V.length; i++) {\n        e[V[i].id()] = 0;\n      }\n\n      while (S.length > 0) {\n        var w = S.pop();\n\n        for (var j = 0; j < P[w].length; j++) {\n          var v = P[w][j];\n\n          e[v] = e[v] + g[v] / g[w] * (1 + e[w]);\n\n          if (w != V[s].id()) {\n            C.set(w, C.get(w) + e[w]);\n          }\n        }\n      }\n    }\n\n    var ret = {\n      betweenness: function betweenness(node) {\n        if (is.string(node)) {\n          var node = cy.filter(node).id();\n        } else {\n          var node = node.id();\n        }\n\n        return C.get(node);\n      },\n\n      betweennessNormalized: function betweennessNormalized(node) {\n        if (max == 0) return 0;\n\n        if (is.string(node)) {\n          var node = cy.filter(node).id();\n        } else {\n          var node = node.id();\n        }\n\n        return C.get(node) / max;\n      }\n    };\n\n    // alias\n    ret.betweennessNormalised = ret.betweennessNormalized;\n\n    return ret;\n  } // betweennessCentrality\n\n}; // elesfn\n\n// nice, short mathemathical alias\nelesfn.bc = elesfn.betweennessCentrality;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar defineSearch = function defineSearch(params) {\n  params = {\n    bfs: params.bfs || !params.dfs,\n    dfs: params.dfs || !params.bfs\n  };\n\n  // from pseudocode on wikipedia\n  return function searchFn(roots, fn, directed) {\n    var options;\n    if (is.plainObject(roots) && !is.elementOrCollection(roots)) {\n      options = roots;\n      roots = options.roots || options.root;\n      fn = options.visit;\n      directed = options.directed;\n    }\n\n    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;\n    fn = is.fn(fn) ? fn : function () {};\n\n    var cy = this._private.cy;\n    var v = roots = is.string(roots) ? this.filter(roots) : roots;\n    var Q = [];\n    var connectedNodes = [];\n    var connectedBy = {};\n    var id2depth = {};\n    var V = {};\n    var j = 0;\n    var found;\n    var nodes = this.nodes();\n    var edges = this.edges();\n\n    // enqueue v\n    for (var i = 0; i < v.length; i++) {\n      if (v[i].isNode()) {\n        Q.unshift(v[i]);\n\n        if (params.bfs) {\n          V[v[i].id()] = true;\n\n          connectedNodes.push(v[i]);\n        }\n\n        id2depth[v[i].id()] = 0;\n      }\n    }\n\n    while (Q.length !== 0) {\n      var v = params.bfs ? Q.shift() : Q.pop();\n\n      if (params.dfs) {\n        if (V[v.id()]) {\n          continue;\n        }\n\n        V[v.id()] = true;\n\n        connectedNodes.push(v);\n      }\n\n      var depth = id2depth[v.id()];\n      var prevEdge = connectedBy[v.id()];\n      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];\n      var ret;\n\n      ret = fn(v, prevEdge, prevNode, j++, depth);\n\n      if (ret === true) {\n        found = v;\n        break;\n      }\n\n      if (ret === false) {\n        break;\n      }\n\n      var vwEdges = v.connectedEdges(directed ? function (ele) {\n        return ele.data('source') === v.id();\n      } : undefined).intersect(edges);\n      for (var i = 0; i < vwEdges.length; i++) {\n        var e = vwEdges[i];\n        var w = e.connectedNodes(function (n) {\n          return n.id() !== v.id();\n        }).intersect(nodes);\n\n        if (w.length !== 0 && !V[w.id()]) {\n          w = w[0];\n\n          Q.push(w);\n\n          if (params.bfs) {\n            V[w.id()] = true;\n\n            connectedNodes.push(w);\n          }\n\n          connectedBy[w.id()] = e;\n\n          id2depth[w.id()] = id2depth[v.id()] + 1;\n        }\n      }\n    }\n\n    var connectedEles = [];\n\n    for (var i = 0; i < connectedNodes.length; i++) {\n      var node = connectedNodes[i];\n      var edge = connectedBy[node.id()];\n\n      if (edge) {\n        connectedEles.push(edge);\n      }\n\n      connectedEles.push(node);\n    }\n\n    return {\n      path: cy.collection(connectedEles, { unique: true }),\n      found: cy.collection(found)\n    };\n  };\n};\n\n// search, spanning trees, etc\nvar elesfn = {\n  breadthFirstSearch: defineSearch({ bfs: true }),\n  depthFirstSearch: defineSearch({ dfs: true })\n};\n\n// nice, short mathemathical alias\nelesfn.bfs = elesfn.breadthFirstSearch;\nelesfn.dfs = elesfn.depthFirstSearch;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar elesfn = {\n\n  closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n    options = options || {};\n\n    var cy = this.cy();\n\n    var harmonic = options.harmonic;\n    if (harmonic === undefined) {\n      harmonic = true;\n    }\n\n    var closenesses = {};\n    var maxCloseness = 0;\n    var nodes = this.nodes();\n    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });\n\n    // Compute closeness for every node and find the maximum closeness\n    for (var i = 0; i < nodes.length; i++) {\n      var currCloseness = 0;\n      for (var j = 0; j < nodes.length; j++) {\n        if (i != j) {\n          var d = fw.distance(nodes[i], nodes[j]);\n\n          if (harmonic) {\n            currCloseness += 1 / d;\n          } else {\n            currCloseness += d;\n          }\n        }\n      }\n\n      if (!harmonic) {\n        currCloseness = 1 / currCloseness;\n      }\n\n      if (maxCloseness < currCloseness) {\n        maxCloseness = currCloseness;\n      }\n\n      closenesses[nodes[i].id()] = currCloseness;\n    }\n\n    return {\n      closeness: function closeness(node) {\n        if (maxCloseness == 0) {\n          return 0;\n        }\n\n        if (is.string(node)) {\n          // from is a selector string\n          var node = cy.filter(node)[0].id();\n        } else {\n          // from is a node\n          var node = node.id();\n        }\n\n        return closenesses[node] / maxCloseness;\n      }\n    };\n  },\n\n  // Implemented from pseudocode from wikipedia\n  closenessCentrality: function closenessCentrality(options) {\n    options = options || {};\n\n    // root - mandatory!\n    if (options.root != null) {\n      if (is.string(options.root)) {\n        // use it as a selector, e.g. \"#rootID\n        var root = this.filter(options.root)[0];\n      } else {\n        var root = options.root[0];\n      }\n    } else {\n      return undefined;\n    }\n\n    // weight - optional\n    if (options.weight != null && is.fn(options.weight)) {\n      var weight = options.weight;\n    } else {\n      var weight = function weight() {\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if (options.directed != null && is.bool(options.directed)) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var harmonic = options.harmonic;\n    if (harmonic === undefined) {\n      harmonic = true;\n    }\n\n    // we need distance from this node to every other node\n    var dijkstra = this.dijkstra({\n      root: root,\n      weight: weight,\n      directed: directed\n    });\n    var totalDistance = 0;\n\n    var nodes = this.nodes();\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].id() != root.id()) {\n        var d = dijkstra.distanceTo(nodes[i]);\n\n        if (harmonic) {\n          totalDistance += 1 / d;\n        } else {\n          totalDistance += d;\n        }\n      }\n    }\n\n    return harmonic ? totalDistance : 1 / totalDistance;\n  } // closenessCentrality\n\n}; // elesfn\n\n// nice, short mathemathical alias\nelesfn.cc = elesfn.closenessCentrality;\nelesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\n\nvar elesfn = {\n\n  degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n    options = options || {};\n\n    var cy = this.cy();\n\n    // directed - optional\n    if (options.directed != null) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    if (!directed) {\n      var degrees = {};\n      var maxDegree = 0;\n\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i];\n        // add current node to the current options object and call degreeCentrality\n        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));\n        if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;\n\n        degrees[node.id()] = currDegree.degree;\n      }\n\n      return {\n        degree: function degree(node) {\n          if (maxDegree == 0) return 0;\n\n          if (is.string(node)) {\n            // from is a selector string\n            var node = cy.filter(node)[0].id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return degrees[node] / maxDegree;\n        }\n      };\n    } else {\n      var indegrees = {};\n      var outdegrees = {};\n      var maxIndegree = 0;\n      var maxOutdegree = 0;\n\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i];\n        // add current node to the current options object and call degreeCentrality\n        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));\n\n        if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;\n\n        if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;\n\n        indegrees[node.id()] = currDegree.indegree;\n        outdegrees[node.id()] = currDegree.outdegree;\n      }\n\n      return {\n        indegree: function indegree(node) {\n          if (maxIndegree == 0) return 0;\n\n          if (is.string(node)) {\n            // from is a selector string\n            var node = cy.filter(node)[0].id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return indegrees[node] / maxIndegree;\n        },\n        outdegree: function outdegree(node) {\n          if (maxOutdegree == 0) return 0;\n\n          if (is.string(node)) {\n            // from is a selector string\n            var node = cy.filter(node)[0].id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return outdegrees[node] / maxOutdegree;\n        }\n\n      };\n    }\n  }, // degreeCentralityNormalized\n\n  // Implemented from the algorithm in Opsahl's paper\n  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n  // check the heading 2 \"Degree\"\n  degreeCentrality: function degreeCentrality(options) {\n    options = options || {};\n\n    var callingEles = this;\n\n    // root - mandatory!\n    if (options != null && options.root != null) {\n      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];\n    } else {\n      return undefined;\n    }\n\n    // weight - optional\n    if (options.weight != null && is.fn(options.weight)) {\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function weightFn(e) {\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if (options.directed != null) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    // alpha - optional\n    if (options.alpha != null && is.number(options.alpha)) {\n      var alpha = options.alpha;\n    } else {\n      alpha = 0;\n    }\n\n    if (!directed) {\n      var connEdges = root.connectedEdges().intersection(callingEles);\n      var k = connEdges.length;\n      var s = 0;\n\n      // Now, sum edge weights\n      for (var i = 0; i < connEdges.length; i++) {\n        var edge = connEdges[i];\n        s += weightFn(edge);\n      }\n\n      return {\n        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n      };\n    } else {\n      var incoming = root.connectedEdges('edge[target = \"' + root.id() + '\"]').intersection(callingEles);\n      var outgoing = root.connectedEdges('edge[source = \"' + root.id() + '\"]').intersection(callingEles);\n      var k_in = incoming.length;\n      var k_out = outgoing.length;\n      var s_in = 0;\n      var s_out = 0;\n\n      // Now, sum incoming edge weights\n      for (var i = 0; i < incoming.length; i++) {\n        var edge = incoming[i];\n        s_in += weightFn(edge);\n      }\n\n      // Now, sum outgoing edge weights\n      for (var i = 0; i < outgoing.length; i++) {\n        var edge = outgoing[i];\n        s_out += weightFn(edge);\n      }\n\n      return {\n        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n      };\n    }\n  } // degreeCentrality\n\n}; // elesfn\n\n// nice, short mathemathical alias\nelesfn.dc = elesfn.degreeCentrality;\nelesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Heap = __webpack_require__(8);\n\nvar elesfn = {\n\n  dijkstra: function dijkstra(root, weightFn, directed) {\n    var options;\n    if (is.plainObject(root) && !is.elementOrCollection(root)) {\n      options = root;\n      root = options.root;\n      weightFn = options.weight;\n      directed = options.directed;\n    }\n\n    var cy = this._private.cy;\n    weightFn = is.fn(weightFn) ? weightFn : function () {\n      return 1;\n    }; // if not specified, assume each edge has equal weight (1)\n\n    var source = is.string(root) ? this.filter(root)[0] : root[0];\n    var dist = {};\n    var prev = {};\n    var knownDist = {};\n\n    var edges = this.edges().filter(function (ele) {\n      return !ele.isLoop();\n    });\n    var nodes = this.nodes();\n\n    var getDist = function getDist(node) {\n      return dist[node.id()];\n    };\n\n    var setDist = function setDist(node, d) {\n      dist[node.id()] = d;\n\n      Q.updateItem(node);\n    };\n\n    var Q = new Heap(function (a, b) {\n      return getDist(a) - getDist(b);\n    });\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n\n      dist[node.id()] = node.same(source) ? 0 : Infinity;\n      Q.push(node);\n    }\n\n    var distBetween = function distBetween(u, v) {\n      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n      var smallestDistance = Infinity;\n      var smallestEdge;\n\n      for (var i = 0; i < uvs.length; i++) {\n        var edge = uvs[i];\n        var weight = weightFn(edge);\n\n        if (weight < smallestDistance || !smallestEdge) {\n          smallestDistance = weight;\n          smallestEdge = edge;\n        }\n      }\n\n      return {\n        edge: smallestEdge,\n        dist: smallestDistance\n      };\n    };\n\n    while (Q.size() > 0) {\n      var u = Q.pop();\n      var smalletsDist = getDist(u);\n      var uid = u.id();\n\n      knownDist[uid] = smalletsDist;\n\n      if (smalletsDist === Infinity) {\n        continue;\n      }\n\n      var neighbors = u.neighborhood().intersect(nodes);\n      for (var i = 0; i < neighbors.length; i++) {\n        var v = neighbors[i];\n        var vid = v.id();\n        var vDist = distBetween(u, v);\n\n        var alt = smalletsDist + vDist.dist;\n\n        if (alt < getDist(v)) {\n          setDist(v, alt);\n\n          prev[vid] = {\n            node: u,\n            edge: vDist.edge\n          };\n        }\n      } // for\n    } // while\n\n    return {\n      distanceTo: function distanceTo(node) {\n        var target = is.string(node) ? nodes.filter(node)[0] : node[0];\n\n        return knownDist[target.id()];\n      },\n\n      pathTo: function pathTo(node) {\n        var target = is.string(node) ? nodes.filter(node)[0] : node[0];\n        var S = [];\n        var u = target;\n\n        if (target.length > 0) {\n          S.unshift(target);\n\n          while (prev[u.id()]) {\n            var p = prev[u.id()];\n\n            S.unshift(p.edge);\n            S.unshift(p.node);\n\n            u = p.node;\n          }\n        }\n\n        return cy.collection(S);\n      }\n    };\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar elesfn = {\n\n  // Implemented from pseudocode from wikipedia\n  floydWarshall: function floydWarshall(options) {\n    options = options || {};\n\n    var cy = this.cy();\n\n    // Weight function - optional\n    if (options.weight != null && is.fn(options.weight)) {\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function weightFn(e) {\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if (options.directed != null) {\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var edges = this.edges().stdFilter(function (e) {\n      return !e.isLoop();\n    });\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    // mapping: node id -> position in nodes array\n    var id2position = {};\n    for (var i = 0; i < numNodes; i++) {\n      id2position[nodes[i].id()] = i;\n    }\n\n    // Initialize distance matrix\n    var dist = [];\n    for (var i = 0; i < numNodes; i++) {\n      var newRow = new Array(numNodes);\n      for (var j = 0; j < numNodes; j++) {\n        if (i == j) {\n          newRow[j] = 0;\n        } else {\n          newRow[j] = Infinity;\n        }\n      }\n      dist.push(newRow);\n    }\n\n    // Initialize matrix used for path reconstruction\n    // Initialize distance matrix\n    var next = [];\n    var edgeNext = [];\n\n    var initMatrix = function initMatrix(next) {\n      for (var i = 0; i < numNodes; i++) {\n        var newRow = new Array(numNodes);\n        for (var j = 0; j < numNodes; j++) {\n          newRow[j] = undefined;\n        }\n        next.push(newRow);\n      }\n    };\n\n    initMatrix(next);\n    initMatrix(edgeNext);\n\n    // Process edges\n    for (var i = 0; i < edges.length; i++) {\n      var sourceIndex = id2position[edges[i].source().id()];\n      var targetIndex = id2position[edges[i].target().id()];\n      var weight = weightFn(edges[i]);\n\n      // Check if already process another edge between same 2 nodes\n      if (dist[sourceIndex][targetIndex] > weight) {\n        dist[sourceIndex][targetIndex] = weight;\n        next[sourceIndex][targetIndex] = targetIndex;\n        edgeNext[sourceIndex][targetIndex] = edges[i];\n      }\n    }\n\n    // If undirected graph, process 'reversed' edges\n    if (!directed) {\n      for (var i = 0; i < edges.length; i++) {\n        var sourceIndex = id2position[edges[i].target().id()];\n        var targetIndex = id2position[edges[i].source().id()];\n        var weight = weightFn(edges[i]);\n\n        // Check if already process another edge between same 2 nodes\n        if (dist[sourceIndex][targetIndex] > weight) {\n          dist[sourceIndex][targetIndex] = weight;\n          next[sourceIndex][targetIndex] = targetIndex;\n          edgeNext[sourceIndex][targetIndex] = edges[i];\n        }\n      }\n    }\n\n    // Main loop\n    for (var k = 0; k < numNodes; k++) {\n      for (var i = 0; i < numNodes; i++) {\n        for (var j = 0; j < numNodes; j++) {\n          if (dist[i][k] + dist[k][j] < dist[i][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n            next[i][j] = next[i][k];\n          }\n        }\n      }\n    }\n\n    // Build result object\n    var position2id = [];\n    for (var i = 0; i < numNodes; i++) {\n      position2id.push(nodes[i].id());\n    }\n\n    var res = {\n      distance: function distance(from, to) {\n        if (is.string(from)) {\n          // from is a selector string\n          var fromId = cy.filter(from)[0].id();\n        } else {\n          // from is a node\n          var fromId = from.id();\n        }\n\n        if (is.string(to)) {\n          // to is a selector string\n          var toId = cy.filter(to)[0].id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        return dist[id2position[fromId]][id2position[toId]];\n      },\n\n      path: function path(from, to) {\n        var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {\n          if (from === to) {\n            return cy.getElementById(position2id[from]);\n          }\n          if (next[from][to] === undefined) {\n            return undefined;\n          }\n\n          var path = [cy.getElementById(position2id[from])];\n          var prev = from;\n          while (from !== to) {\n            prev = from;\n            from = next[from][to];\n\n            var edge = edgeNext[prev][from];\n            path.push(edge);\n\n            path.push(cy.getElementById(position2id[from]));\n          }\n          return path;\n        };\n\n        if (is.string(from)) {\n          // from is a selector string\n          var fromId = cy.filter(from)[0].id();\n        } else {\n          // from is a node\n          var fromId = from.id();\n        }\n\n        if (is.string(to)) {\n          // to is a selector string\n          var toId = cy.filter(to)[0].id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);\n\n        return cy.collection(pathArr);\n      }\n    };\n\n    return res;\n  } // floydWarshall\n\n}; // elesfn\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar elesfn = {};\n\n[__webpack_require__(27), __webpack_require__(30), __webpack_require__(34), __webpack_require__(24), __webpack_require__(31), __webpack_require__(25), __webpack_require__(33), __webpack_require__(35), __webpack_require__(29), __webpack_require__(28), __webpack_require__(26)].forEach(function (props) {\n  util.extend(elesfn, props);\n});\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar elesfn = {\n\n  // Computes the minimum cut of an undirected graph\n  // Returns the correct answer with high probability\n  kargerStein: function kargerStein(options) {\n    var eles = this;\n\n    options = options || {};\n\n    // Function which colapses 2 (meta) nodes into one\n    // Updates the remaining edge lists\n    // Receives as a paramater the edge which causes the collapse\n    var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {\n      var edgeInfo = remainingEdges[edgeIndex];\n      var sourceIn = edgeInfo[1];\n      var targetIn = edgeInfo[2];\n      var partition1 = nodeMap[sourceIn];\n      var partition2 = nodeMap[targetIn];\n\n      // Delete all edges between partition1 and partition2\n      var newEdges = remainingEdges.filter(function (edge) {\n        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {\n          return false;\n        }\n        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {\n          return false;\n        }\n        return true;\n      });\n\n      // All edges pointing to partition2 should now point to partition1\n      for (var i = 0; i < newEdges.length; i++) {\n        var edge = newEdges[i];\n        if (edge[1] === partition2) {\n          // Check source\n          newEdges[i] = edge.slice(0);\n          newEdges[i][1] = partition1;\n        } else if (edge[2] === partition2) {\n          // Check target\n          newEdges[i] = edge.slice(0);\n          newEdges[i][2] = partition1;\n        }\n      }\n\n      // Move all nodes from partition2 to partition1\n      for (var i = 0; i < nodeMap.length; i++) {\n        if (nodeMap[i] === partition2) {\n          nodeMap[i] = partition1;\n        }\n      }\n\n      return newEdges;\n    };\n\n    // Contracts a graph until we reach a certain number of meta nodes\n    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n      // Stop condition\n      if (size <= sizeLimit) {\n        return remainingEdges;\n      }\n\n      // Choose an edge randomly\n      var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n\n      // Colapse graph based on edge\n      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);\n\n      return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);\n    };\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter(function (e) {\n      return !e.isLoop();\n    });\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n    var stopSize = Math.floor(numNodes / Math.sqrt(2));\n\n    if (numNodes < 2) {\n      util.error('At least 2 nodes are required for Karger-Stein algorithm');\n      return undefined;\n    }\n\n    // Create numerical identifiers for each node\n    // mapping: node id -> position in nodes array\n    // for reverse mapping, simply use nodes array\n    var id2position = {};\n    for (var i = 0; i < numNodes; i++) {\n      id2position[nodes[i].id()] = i;\n    }\n\n    // Now store edge destination as indexes\n    // Format for each edge (edge index, source node index, target node index)\n    var edgeIndexes = [];\n    for (var i = 0; i < numEdges; i++) {\n      var e = edges[i];\n      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);\n    }\n\n    // We will store the best cut found here\n    var minCutSize = Infinity;\n    var minCut;\n\n    // Initial meta node partition\n    var originalMetaNode = [];\n    for (var i = 0; i < numNodes; i++) {\n      originalMetaNode.push(i);\n    }\n\n    // Main loop\n    for (var iter = 0; iter <= numIter; iter++) {\n      // Create new meta node partition\n      var metaNodeMap = originalMetaNode.slice(0);\n\n      // Contract until stop point (stopSize nodes)\n      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);\n\n      // Create a copy of the colapsed nodes state\n      var metaNodeMap2 = metaNodeMap.slice(0);\n\n      // Run 2 iterations starting in the stop state\n      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);\n\n      // Is any of the 2 results the best cut so far?\n      if (res1.length <= res2.length && res1.length < minCutSize) {\n        minCutSize = res1.length;\n        minCut = [res1, metaNodeMap];\n      } else if (res2.length <= res1.length && res2.length < minCutSize) {\n        minCutSize = res2.length;\n        minCut = [res2, metaNodeMap2];\n      }\n    } // end of main loop\n\n\n    // Construct result\n    var resEdges = minCut[0].map(function (e) {\n      return edges[e[0]];\n    });\n    var partition1 = [];\n    var partition2 = [];\n\n    // traverse metaNodeMap for best cut\n    var witnessNodePartition = minCut[1][0];\n    for (var i = 0; i < minCut[1].length; i++) {\n      var partitionId = minCut[1][i];\n      if (partitionId === witnessNodePartition) {\n        partition1.push(nodes[i]);\n      } else {\n        partition2.push(nodes[i]);\n      }\n    }\n\n    var ret = {\n      cut: eles.spawn(cy, resEdges),\n      partition1: eles.spawn(partition1),\n      partition2: eles.spawn(partition2)\n    };\n\n    return ret;\n  }\n}; // elesfn\n\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\n// search, spanning trees, etc\nvar elesfn = {\n\n  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n  // implemented from pseudocode from wikipedia\n  kruskal: function kruskal(weightFn) {\n    var cy = this.cy();\n\n    weightFn = is.fn(weightFn) ? weightFn : function () {\n      return 1;\n    }; // if not specified, assume each edge has equal weight (1)\n\n    function findSet(ele) {\n      for (var i = 0; i < forest.length; i++) {\n        var eles = forest[i];\n\n        if (eles.anySame(ele)) {\n          return {\n            eles: eles,\n            index: i\n          };\n        }\n      }\n    }\n\n    var A = cy.collection(cy, []);\n    var forest = [];\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      forest.push(nodes[i].collection());\n    }\n\n    var edges = this.edges();\n    var S = edges.toArray().sort(function (a, b) {\n      var weightA = weightFn(a);\n      var weightB = weightFn(b);\n\n      return weightA - weightB;\n    });\n\n    for (var i = 0; i < S.length; i++) {\n      var edge = S[i];\n      var u = edge.source()[0];\n      var v = edge.target()[0];\n      var setU = findSet(u);\n      var setV = findSet(v);\n\n      if (setU.index !== setV.index) {\n        A = A.add(edge);\n\n        // combine forests for u and v\n        forest[setU.index] = setU.eles.add(setV.eles);\n        forest.splice(setV.index, 1);\n      }\n    }\n\n    return nodes.add(A);\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar elesfn = {\n\n  pageRank: function pageRank(options) {\n    options = options || {};\n\n    var normalizeVector = function normalizeVector(vector) {\n      var length = vector.length;\n\n      // First, get sum of all elements\n      var total = 0;\n      for (var i = 0; i < length; i++) {\n        total += vector[i];\n      }\n\n      // Now, divide each by the sum of all elements\n      for (var i = 0; i < length; i++) {\n        vector[i] = vector[i] / total;\n      }\n    };\n\n    // dampingFactor - optional\n    if (options != null && options.dampingFactor != null) {\n      var dampingFactor = options.dampingFactor;\n    } else {\n      var dampingFactor = 0.8; // Default damping factor\n    }\n\n    // desired precision - optional\n    if (options != null && options.precision != null) {\n      var epsilon = options.precision;\n    } else {\n      var epsilon = 0.000001; // Default precision\n    }\n\n    // Max number of iterations - optional\n    if (options != null && options.iterations != null) {\n      var numIter = options.iterations;\n    } else {\n      var numIter = 200; // Default number of iterations\n    }\n\n    // Weight function - optional\n    if (options != null && options.weight != null && is.fn(options.weight)) {\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function weightFn(e) {\n        return 1;\n      };\n    }\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter(function (e) {\n      return !e.isLoop();\n    });\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n\n    // Create numerical identifiers for each node\n    // mapping: node id -> position in nodes array\n    // for reverse mapping, simply use nodes array\n    var id2position = {};\n    for (var i = 0; i < numNodes; i++) {\n      id2position[nodes[i].id()] = i;\n    }\n\n    // Construct transposed adjacency matrix\n    // First lets have a zeroed matrix of the right size\n    // We'll also keep track of the sum of each column\n    var matrix = [];\n    var columnSum = [];\n    var additionalProb = (1 - dampingFactor) / numNodes;\n\n    // Create null matric\n    for (var i = 0; i < numNodes; i++) {\n      var newRow = [];\n      for (var j = 0; j < numNodes; j++) {\n        newRow.push(0.0);\n      }\n      matrix.push(newRow);\n      columnSum.push(0.0);\n    }\n\n    // Now, process edges\n    for (var i = 0; i < numEdges; i++) {\n      var edge = edges[i];\n      var s = id2position[edge.source().id()];\n      var t = id2position[edge.target().id()];\n      var w = weightFn(edge);\n\n      // Update matrix\n      matrix[t][s] += w;\n\n      // Update column sum\n      columnSum[s] += w;\n    }\n\n    // Add additional probability based on damping factor\n    // Also, take into account columns that have sum = 0\n    var p = 1.0 / numNodes + additionalProb; // Shorthand\n    // Traverse matrix, column by column\n    for (var j = 0; j < numNodes; j++) {\n      if (columnSum[j] === 0) {\n        // No 'links' out from node jth, assume equal probability for each possible node\n        for (var i = 0; i < numNodes; i++) {\n          matrix[i][j] = p;\n        }\n      } else {\n        // Node jth has outgoing link, compute normalized probabilities\n        for (var i = 0; i < numNodes; i++) {\n          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;\n        }\n      }\n    }\n\n    // Compute dominant eigenvector using power method\n    var eigenvector = [];\n    var nullVector = [];\n    var previous;\n\n    // Start with a vector of all 1's\n    // Also, initialize a null vector which will be used as shorthand\n    for (var i = 0; i < numNodes; i++) {\n      eigenvector.push(1.0);\n      nullVector.push(0.0);\n    }\n\n    for (var iter = 0; iter < numIter; iter++) {\n      // New array with all 0's\n      var temp = nullVector.slice(0);\n\n      // Multiply matrix with previous result\n      for (var i = 0; i < numNodes; i++) {\n        for (var j = 0; j < numNodes; j++) {\n          temp[i] += matrix[i][j] * eigenvector[j];\n        }\n      }\n\n      normalizeVector(temp);\n      previous = eigenvector;\n      eigenvector = temp;\n\n      var diff = 0;\n      // Compute difference (squared module) of both vectors\n      for (var i = 0; i < numNodes; i++) {\n        diff += Math.pow(previous[i] - eigenvector[i], 2);\n      }\n\n      // If difference is less than the desired threshold, stop iterating\n      if (diff < epsilon) {\n        break;\n      }\n    }\n\n    // Construct result\n    var res = {\n      rank: function rank(node) {\n        if (is.string(node)) {\n          // is a selector string\n          var nodeId = cy.filter(node)[0].id();\n        } else {\n          // is a node object\n          var nodeId = node.id();\n        }\n        return eigenvector[id2position[nodeId]];\n      }\n    };\n\n    return res;\n  } // pageRank\n\n}; // elesfn\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar define = __webpack_require__(3);\n\nvar elesfn = {\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop()\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Set = __webpack_require__(9);\n\nvar elesfn = {\n  classes: function classes(_classes) {\n    _classes = (_classes || '').match(/\\S+/g) || [];\n    var self = this;\n    var changed = [];\n    var classesMap = new Set(_classes);\n\n    // check and update each ele\n\n    var _loop = function _loop(j) {\n      var ele = self[j];\n      var _p = ele._private;\n      var eleClasses = _p.classes;\n      var changedEle = false;\n\n      // check if ele has all of the passed classes\n      classesMap.forEach(function (cls) {\n        var eleHasClass = eleClasses.has(cls);\n\n        if (!eleHasClass) {\n          changedEle = true;\n        }\n      });\n\n      // check if ele has classes outside of those passed\n      if (!changedEle) {\n        eleClasses.forEach(function (eleCls) {\n          var specdClass = classesMap.has(eleCls);\n\n          if (!specdClass) {\n            changedEle = true;\n          }\n        });\n      }\n\n      if (changedEle) {\n        _p.classes = new Set(classesMap);\n\n        changed.push(ele);\n      }\n    };\n\n    for (var j = 0; j < self.length; j++) {\n      _loop(j);\n    }\n\n    // trigger update style on those eles that had class changes\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n\n    return self;\n  },\n\n  addClass: function addClass(classes) {\n    return this.toggleClass(classes, true);\n  },\n\n  hasClass: function hasClass(className) {\n    var ele = this[0];\n    return ele != null && ele._private.classes.has(className);\n  },\n\n  toggleClass: function toggleClass(classesStr, toggle) {\n    var classes = classesStr.match(/\\S+/g) || [];\n    var self = this;\n    var changed = []; // eles who had classes changed\n\n    for (var i = 0, il = self.length; i < il; i++) {\n      var _ele = self[i];\n      var _changedEle = false;\n\n      for (var j = 0; j < classes.length; j++) {\n        var cls = classes[j];\n        var _eleClasses = _ele._private.classes;\n        var hasClass = _eleClasses.has(cls);\n        var shouldAdd = toggle || toggle === undefined && !hasClass;\n\n        if (shouldAdd) {\n          _eleClasses.add(cls);\n\n          if (!hasClass && !_changedEle) {\n            changed.push(_ele);\n            _changedEle = true;\n          }\n        } else {\n          // then remove\n          _eleClasses.delete(cls);\n\n          if (hasClass && !_changedEle) {\n            changed.push(_ele);\n            _changedEle = true;\n          }\n        }\n      } // for j classes\n    } // for i eles\n\n    // trigger update style on those eles that had class changes\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n\n    return self;\n  },\n\n  removeClass: function removeClass(classes) {\n    return this.toggleClass(classes, false);\n  },\n\n  flashClass: function flashClass(classes, duration) {\n    var self = this;\n\n    if (duration == null) {\n      duration = 250;\n    } else if (duration === 0) {\n      return self; // nothing to do really\n    }\n\n    self.addClass(classes);\n    setTimeout(function () {\n      self.removeClass(classes);\n    }, duration);\n\n    return self;\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Selector = __webpack_require__(6);\n\nvar elesfn = {\n  allAre: function allAre(selector) {\n    var selObj = new Selector(selector);\n\n    return this.every(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n\n  is: function is(selector) {\n    var selObj = new Selector(selector);\n\n    return this.some(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n\n  some: function some(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n      if (ret) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  every: function every(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n      if (!ret) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  same: function same(collection) {\n    collection = this.cy().collection(collection);\n\n    // cheap extra check\n    if (this.length !== collection.length) {\n      return false;\n    }\n\n    return this.every(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n\n  anySame: function anySame(collection) {\n    collection = this.cy().collection(collection);\n\n    return this.some(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n\n  allAreNeighbors: function allAreNeighbors(collection) {\n    collection = this.cy().collection(collection);\n\n    var nhood = this.neighborhood();\n\n    return collection.every(function (ele) {\n      return nhood.hasElementWithId(ele.id());\n    });\n  },\n\n  contains: function contains(collection) {\n    collection = this.cy().collection(collection);\n\n    var self = this;\n\n    return collection.every(function (ele) {\n      return self.hasElementWithId(ele.id());\n    });\n  }\n};\n\nelesfn.allAreNeighbours = elesfn.allAreNeighbors;\nelesfn.has = elesfn.contains;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Set = __webpack_require__(9);\n\nvar elesfn = {\n  parent: function parent(selector) {\n    var parents = [];\n\n    // optimisation for single ele call\n    if (this.length === 1) {\n      var parent = this[0]._private.parent;\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _parent = ele._private.parent;\n\n      if (_parent) {\n        parents.push(_parent);\n      }\n    }\n\n    return this.spawn(parents, { unique: true }).filter(selector);\n  },\n\n  parents: function parents(selector) {\n    var parents = [];\n\n    var eles = this.parent();\n    while (eles.nonempty()) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        parents.push(ele);\n      }\n\n      eles = eles.parent();\n    }\n\n    return this.spawn(parents, { unique: true }).filter(selector);\n  },\n\n  commonAncestors: function commonAncestors(selector) {\n    var ancestors = void 0;\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var parents = ele.parents();\n\n      ancestors = ancestors || parents;\n\n      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n    }\n\n    return ancestors.filter(selector);\n  },\n\n  orphans: function orphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isOrphan();\n    }).filter(selector);\n  },\n\n  nonorphans: function nonorphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isChild();\n    }).filter(selector);\n  },\n\n  children: function children(selector) {\n    var children = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      children = children.concat(ele._private.children);\n    }\n\n    return this.spawn(children, { unique: true }).filter(selector);\n  },\n\n  siblings: function siblings(selector) {\n    return this.parent().children().not(this).filter(selector);\n  },\n\n  isParent: function isParent() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.children.length !== 0;\n    }\n  },\n\n  isChildless: function isChildless() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.children.length === 0;\n    }\n  },\n\n  isChild: function isChild() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.parent != null;\n    }\n  },\n\n  isOrphan: function isOrphan() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.parent == null;\n    }\n  },\n\n  descendants: function descendants(selector) {\n    var elements = [];\n\n    function add(eles) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        elements.push(ele);\n\n        if (ele.children().nonempty()) {\n          add(ele.children());\n        }\n      }\n    }\n\n    add(this.children());\n\n    return this.spawn(elements, { unique: true }).filter(selector);\n  }\n};\n\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n  var q = [];\n  var did = new Set();\n  var cy = eles.cy();\n  var hasCompounds = cy.hasCompoundNodes();\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (includeSelf) {\n      q.push(ele);\n    } else if (hasCompounds) {\n      recursiveStep(q, did, ele);\n    }\n  }\n\n  while (q.length > 0) {\n    var _ele = q.shift();\n\n    fn(_ele);\n\n    did.add(_ele.id());\n\n    if (hasCompounds) {\n      recursiveStep(q, did, _ele);\n    }\n  }\n\n  return eles;\n}\n\nfunction addChildren(q, did, ele) {\n  if (ele.isParent()) {\n    var children = ele._private.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (!did.has(child.id())) {\n        q.push(child);\n      }\n    }\n  }\n}\n\n// very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\nelesfn.forEachDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  return forEachCompound(this, fn, includeSelf, addChildren);\n};\n\nfunction addParent(q, did, ele) {\n  if (ele.isChild()) {\n    var parent = ele._private.parent;\n\n    if (!did.has(parent.id())) {\n      q.push(parent);\n    }\n  }\n}\n\nelesfn.forEachUp = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  return forEachCompound(this, fn, includeSelf, addParent);\n};\n\nfunction addParentAndChildren(q, did, ele) {\n  addParent(q, did, ele);\n  addChildren(q, did, ele);\n}\n\nelesfn.forEachUpAndDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n};\n\n// aliases\nelesfn.ancestors = elesfn.parents;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar define = __webpack_require__(3);\nvar fn = void 0,\n    elesfn = void 0;\n\nfn = elesfn = {\n\n  data: define.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n\n  removeData: define.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n\n  rscratch: define.data({\n    field: 'rscratch',\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: true\n  }),\n\n  removeRscratch: define.removeData({\n    field: 'rscratch',\n    triggerEvent: false\n  }),\n\n  id: function id() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.data.id;\n    }\n  }\n\n};\n\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar elesfn = {};\n\nfunction defineDegreeFunction(callback) {\n  return function (includeLoops) {\n    var self = this;\n\n    if (includeLoops === undefined) {\n      includeLoops = true;\n    }\n\n    if (self.length === 0) {\n      return;\n    }\n\n    if (self.isNode() && !self.removed()) {\n      var degree = 0;\n      var node = self[0];\n      var connectedEdges = node._private.edges;\n\n      for (var i = 0; i < connectedEdges.length; i++) {\n        var edge = connectedEdges[i];\n\n        if (!includeLoops && edge.isLoop()) {\n          continue;\n        }\n\n        degree += callback(node, edge);\n      }\n\n      return degree;\n    } else {\n      return;\n    }\n  };\n}\n\nutil.extend(elesfn, {\n  degree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(edge.target())) {\n      return 2;\n    } else {\n      return 1;\n    }\n  }),\n\n  indegree: defineDegreeFunction(function (node, edge) {\n    if (edge.target().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }),\n\n  outdegree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  })\n});\n\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n  return function (includeLoops) {\n    var ret = void 0;\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      var ele = nodes[i];\n      var degree = ele[degreeFn](includeLoops);\n      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n        ret = degree;\n      }\n    }\n\n    return ret;\n  };\n}\n\nutil.extend(elesfn, {\n  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n    return degree < min;\n  }),\n\n  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n    return degree > max;\n  }),\n\n  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n    return degree < min;\n  }),\n\n  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n    return degree > max;\n  }),\n\n  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n    return degree < min;\n  }),\n\n  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n    return degree > max;\n  })\n});\n\nutil.extend(elesfn, {\n  totalDegree: function totalDegree(includeLoops) {\n    var total = 0;\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      total += nodes[i].degree(includeLoops);\n    }\n\n    return total;\n  }\n});\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar fn = void 0,\n    elesfn = void 0;\n\nfn = elesfn = {};\n\nelesfn.renderedBoundingBox = function (options) {\n  var bb = this.boundingBox(options);\n  var cy = this.cy();\n  var zoom = cy.zoom();\n  var pan = cy.pan();\n\n  var x1 = bb.x1 * zoom + pan.x;\n  var x2 = bb.x2 * zoom + pan.x;\n  var y1 = bb.y1 * zoom + pan.y;\n  var y2 = bb.y2 * zoom + pan.y;\n\n  return {\n    x1: x1,\n    x2: x2,\n    y1: y1,\n    y2: y2,\n    w: x2 - x1,\n    h: y2 - y1\n  };\n};\n\nelesfn.dirtyCompoundBoundsCache = function () {\n  var cy = this.cy();\n\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  }\n\n  this.forEachUp(function (ele) {\n    ele._private.compoundBoundsClean = false;\n\n    if (ele.isParent()) {\n      ele.emit('bounds');\n    }\n  });\n\n  return this;\n};\n\nelesfn.updateCompoundBounds = function () {\n  var cy = this.cy();\n\n  // save cycles for non compound graphs or when style disabled\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  }\n\n  // save cycles when batching -- but bounds will be stale (or not exist yet)\n  if (cy.batching()) {\n    return this;\n  }\n\n  var updated = [];\n\n  function update(parent) {\n    if (!parent.isParent()) {\n      return;\n    }\n\n    var _p = parent._private;\n    var children = parent.children();\n    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n\n    var min = {\n      width: {\n        val: parent.pstyle('min-width').pfValue,\n        left: parent.pstyle('min-width-bias-left'),\n        right: parent.pstyle('min-width-bias-right')\n      },\n      height: {\n        val: parent.pstyle('min-height').pfValue,\n        top: parent.pstyle('min-height-bias-top'),\n        bottom: parent.pstyle('min-height-bias-bottom')\n      }\n    };\n\n    var bb = children.boundingBox({\n      includeLabels: includeLabels,\n      includeOverlays: false,\n\n      // updating the compound bounds happens outside of the regular\n      // cache cycle (i.e. before fired events)\n      useCache: false\n    });\n    var pos = _p.position;\n\n    // if children take up zero area then keep position and fall back on stylesheet w/h\n    if (bb.w === 0 || bb.h === 0) {\n      bb = {\n        w: parent.pstyle('width').pfValue,\n        h: parent.pstyle('height').pfValue\n      };\n\n      bb.x1 = pos.x - bb.w / 2;\n      bb.x2 = pos.x + bb.w / 2;\n      bb.y1 = pos.y - bb.h / 2;\n      bb.y2 = pos.y + bb.h / 2;\n    }\n\n    function computeBiasValues(propDiff, propBias, propBiasComplement) {\n      var biasDiff = 0;\n      var biasComplementDiff = 0;\n      var biasTotal = propBias + propBiasComplement;\n\n      if (propDiff > 0 && biasTotal > 0) {\n        biasDiff = propBias / biasTotal * propDiff;\n        biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n      }\n      return {\n        biasDiff: biasDiff,\n        biasComplementDiff: biasComplementDiff\n      };\n    }\n\n    function computePaddingValues(width, height, paddingObject, relativeTo) {\n      // Assuming percentage is number from 0 to 1\n      if (paddingObject.units === '%') {\n        switch (relativeTo) {\n          case 'width':\n            return width > 0 ? paddingObject.pfValue * width : 0;\n          case 'height':\n            return height > 0 ? paddingObject.pfValue * height : 0;\n          case 'average':\n            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n          case 'min':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n          case 'max':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n          default:\n            return 0;\n        }\n      } else if (paddingObject.units === 'px') {\n        return paddingObject.pfValue;\n      } else {\n        return 0;\n      }\n    }\n\n    var leftVal = min.width.left.value;\n    if (min.width.left.units === 'px' && min.width.val > 0) {\n      leftVal = leftVal * 100 / min.width.val;\n    }\n    var rightVal = min.width.right.value;\n    if (min.width.right.units === 'px' && min.width.val > 0) {\n      rightVal = rightVal * 100 / min.width.val;\n    }\n\n    var topVal = min.height.top.value;\n    if (min.height.top.units === 'px' && min.height.val > 0) {\n      topVal = topVal * 100 / min.height.val;\n    }\n\n    var bottomVal = min.height.bottom.value;\n    if (min.height.bottom.units === 'px' && min.height.val > 0) {\n      bottomVal = bottomVal * 100 / min.height.val;\n    }\n\n    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n    var diffLeft = widthBiasDiffs.biasDiff;\n    var diffRight = widthBiasDiffs.biasComplementDiff;\n\n    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n    var diffTop = heightBiasDiffs.biasDiff;\n    var diffBottom = heightBiasDiffs.biasComplementDiff;\n\n    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n\n    _p.autoWidth = Math.max(bb.w, min.width.val);\n    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n\n    _p.autoHeight = Math.max(bb.h, min.height.val);\n    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n\n    updated.push(parent);\n  }\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var _p = ele._private;\n\n    if (!_p.compoundBoundsClean) {\n      update(ele);\n\n      if (!cy._private.batchingStyle) {\n        _p.compoundBoundsClean = true;\n      }\n    }\n  }\n\n  return this;\n};\n\nvar noninf = function noninf(x) {\n  if (x === Infinity || x === -Infinity) {\n    return 0;\n  }\n\n  return x;\n};\n\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n  // don't update with zero area boxes\n  if (x2 - x1 === 0 || y2 - y1 === 0) {\n    return;\n  }\n\n  // don't update with null dim\n  if (x1 == null || y1 == null || x2 == null || y2 == null) {\n    return;\n  }\n\n  b.x1 = x1 < b.x1 ? x1 : b.x1;\n  b.x2 = x2 > b.x2 ? x2 : b.x2;\n  b.y1 = y1 < b.y1 ? y1 : b.y1;\n  b.y2 = y2 > b.y2 ? y2 : b.y2;\n};\n\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\n\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n  return util.getPrefixedProperty(obj, field, prefix);\n};\n\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var halfArW = rstyle.arrowWidth / 2;\n  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n  var x = void 0;\n  var y = void 0;\n\n  if (arrowType !== 'none') {\n    if (prefix === 'source') {\n      x = rstyle.srcX;\n      y = rstyle.srcY;\n    } else if (prefix === 'target') {\n      x = rstyle.tgtX;\n      y = rstyle.tgtY;\n    } else {\n      x = rstyle.midX;\n      y = rstyle.midY;\n    }\n\n    updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);\n  }\n};\n\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n\n  var prefixDash = void 0;\n\n  if (prefix) {\n    prefixDash = prefix + '-';\n  } else {\n    prefixDash = '';\n  }\n\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var label = ele.pstyle(prefixDash + 'label').strValue;\n\n  if (label) {\n    var halign = ele.pstyle('text-halign');\n    var valign = ele.pstyle('text-valign');\n    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n    var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n    var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n    var isEdge = ele.isEdge();\n    var rotation = ele.pstyle(prefixDash + 'text-rotation');\n    var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n    var borderWidth = ele.pstyle('text-border-width').pfValue;\n    var halfBorderWidth = borderWidth / 2;\n    var padding = ele.pstyle('text-background-padding').pfValue;\n\n    var lh = labelHeight + 2 * padding;\n    var lw = labelWidth + 2 * padding;\n    var lw_2 = lw / 2;\n    var lh_2 = lh / 2;\n    var lx1 = void 0,\n        lx2 = void 0,\n        ly1 = void 0,\n        ly2 = void 0;\n\n    if (isEdge) {\n      lx1 = labelX - lw_2;\n      lx2 = labelX + lw_2;\n      ly1 = labelY - lh_2;\n      ly2 = labelY + lh_2;\n    } else {\n      switch (halign.value) {\n        case 'left':\n          lx1 = labelX - lw;\n          lx2 = labelX;\n          break;\n\n        case 'center':\n          lx1 = labelX - lw_2;\n          lx2 = labelX + lw_2;\n          break;\n\n        case 'right':\n          lx1 = labelX;\n          lx2 = labelX + lw;\n          break;\n      }\n\n      switch (valign.value) {\n        case 'top':\n          ly1 = labelY - lh;\n          ly2 = labelY;\n          break;\n\n        case 'center':\n          ly1 = labelY - lh_2;\n          ly2 = labelY + lh_2;\n          break;\n\n        case 'bottom':\n          ly1 = labelY;\n          ly2 = labelY + lh;\n          break;\n      }\n    }\n\n    var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n\n    if (isAutorotate || isPfValue) {\n      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta);\n\n      var rotate = function rotate(x, y) {\n        x = x - labelX;\n        y = y - labelY;\n\n        return {\n          x: x * cos - y * sin + labelX,\n          y: x * sin + y * cos + labelY\n        };\n      };\n\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n\n      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n    }\n\n    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);\n    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);\n    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);\n    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);\n\n    updateBounds(bounds, lx1, ly1, lx2, ly2);\n  }\n\n  return bounds;\n};\n\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n  var cy = ele._private.cy;\n  var styleEnabled = cy.styleEnabled();\n  var headless = cy.headless();\n\n  var bounds = {\n    x1: Infinity,\n    y1: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  };\n\n  var _p = ele._private;\n  var display = styleEnabled ? ele.pstyle('display').value : 'element';\n  var isNode = ele.isNode();\n  var isEdge = ele.isEdge();\n  var ex1 = void 0,\n      ex2 = void 0,\n      ey1 = void 0,\n      ey2 = void 0; // extrema of body / lines\n  var x = void 0,\n      y = void 0; // node pos\n  var displayed = display !== 'none';\n\n  if (displayed) {\n    var overlayOpacity = 0;\n    var overlayPadding = 0;\n\n    if (styleEnabled && options.includeOverlays) {\n      overlayOpacity = ele.pstyle('overlay-opacity').value;\n\n      if (overlayOpacity !== 0) {\n        overlayPadding = ele.pstyle('overlay-padding').value;\n      }\n    }\n\n    var w = 0;\n    var wHalf = 0;\n\n    if (styleEnabled) {\n      w = ele.pstyle('width').pfValue;\n      wHalf = w / 2;\n    }\n\n    if (isNode && options.includeNodes) {\n      var pos = ele.position();\n      x = pos.x;\n      y = pos.y;\n      var _w = ele.outerWidth();\n      var halfW = _w / 2;\n      var h = ele.outerHeight();\n      var halfH = h / 2;\n\n      // handle node dimensions\n      /////////////////////////\n\n      ex1 = x - halfW - overlayPadding;\n      ex2 = x + halfW + overlayPadding;\n      ey1 = y - halfH - overlayPadding;\n      ey2 = y + halfH + overlayPadding;\n\n      updateBounds(bounds, ex1, ey1, ex2, ey2);\n    } else if (isEdge && options.includeEdges) {\n      var rstyle = _p.rstyle || {};\n\n      // handle edge dimensions (rough box estimate)\n      //////////////////////////////////////////////\n      if (styleEnabled && !headless) {\n        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n\n        // take into account edge width\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n      }\n\n      // precise haystacks\n      ////////////////////\n      if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {\n        var hpts = rstyle.haystackPts || [];\n\n        ex1 = hpts[0].x;\n        ey1 = hpts[0].y;\n        ex2 = hpts[1].x;\n        ey2 = hpts[1].y;\n\n        if (ex1 > ex2) {\n          var temp = ex1;\n          ex1 = ex2;\n          ex2 = temp;\n        }\n\n        if (ey1 > ey2) {\n          var _temp = ey1;\n          ey1 = ey2;\n          ey2 = _temp;\n        }\n\n        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n\n        // handle points along edge\n        ///////////////////////////\n      } else {\n        var pts = rstyle.bezierPts || rstyle.linePts || [];\n\n        for (var j = 0; j < pts.length; j++) {\n          var pt = pts[j];\n\n          ex1 = pt.x - wHalf;\n          ex2 = pt.x + wHalf;\n          ey1 = pt.y - wHalf;\n          ey2 = pt.y + wHalf;\n\n          updateBounds(bounds, ex1, ey1, ex2, ey2);\n        }\n\n        // fallback on source and target positions\n        //////////////////////////////////////////\n        if (pts.length === 0) {\n          var n1 = ele.source();\n          var n1pos = n1.position();\n\n          var n2 = ele.target();\n          var n2pos = n2.position();\n\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if (ex1 > ex2) {\n            var _temp2 = ex1;\n            ex1 = ex2;\n            ex2 = _temp2;\n          }\n\n          if (ey1 > ey2) {\n            var _temp3 = ey1;\n            ey1 = ey2;\n            ey2 = _temp3;\n          }\n\n          // take into account edge width\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n\n          updateBounds(bounds, ex1, ey1, ex2, ey2);\n        }\n      }\n    } // edges\n\n\n    // handle edge arrow size\n    /////////////////////////\n\n    if (styleEnabled && options.includeEdges && isEdge) {\n      updateBoundsFromArrow(bounds, ele, 'mid-source', options);\n      updateBoundsFromArrow(bounds, ele, 'mid-target', options);\n      updateBoundsFromArrow(bounds, ele, 'source', options);\n      updateBoundsFromArrow(bounds, ele, 'target', options);\n    }\n\n    // ghost\n    ////////\n\n    if (styleEnabled) {\n      var ghost = ele.pstyle('ghost').value === 'yes';\n\n      if (ghost) {\n        var gx = ele.pstyle('ghost-offset-x').pfValue;\n        var gy = ele.pstyle('ghost-offset-y').pfValue;\n\n        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n      }\n    }\n\n    // overlay\n    //////////\n\n    if (styleEnabled) {\n\n      ex1 = bounds.x1;\n      ex2 = bounds.x2;\n      ey1 = bounds.y1;\n      ey2 = bounds.y2;\n\n      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);\n    }\n\n    // handle label dimensions\n    //////////////////////////\n\n    if (styleEnabled && options.includeLabels) {\n      updateBoundsFromLabel(bounds, ele, null, options);\n\n      if (isEdge) {\n        updateBoundsFromLabel(bounds, ele, 'source', options);\n        updateBoundsFromLabel(bounds, ele, 'target', options);\n      }\n    } // style enabled for labels\n  } // if displayed\n\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n\n  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n  if (bounds.w > 0 && bounds.h > 0 && displayed) {\n    math.expandBoundingBox(bounds, 1);\n  }\n\n  return bounds;\n};\n\nvar tf = function tf(val) {\n  if (val) {\n    return 't';\n  } else {\n    return 'f';\n  }\n};\n\nvar getKey = function getKey(opts) {\n  var key = '';\n\n  key += tf(opts.incudeNodes);\n  key += tf(opts.includeEdges);\n  key += tf(opts.includeLabels);\n  key += tf(opts.includeOverlays);\n\n  return key;\n};\n\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n  var _p = ele._private;\n  var bb = void 0;\n  var headless = ele.cy().headless();\n  var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);\n\n  if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {\n    bb = boundingBoxImpl(ele, opts);\n\n    if (!headless) {\n      _p.bbCache = _p.bbCache || {};\n      _p.bbCache[key] = bb;\n    }\n  } else {\n    bb = _p.bbCache[key];\n  }\n\n  return bb;\n};\n\nvar defBbOpts = {\n  includeNodes: true,\n  includeEdges: true,\n  includeLabels: true,\n  includeOverlays: true,\n  useCache: true\n};\n\nvar defBbOptsKey = getKey(defBbOpts);\n\nfunction filledBbOpts(options) {\n  return {\n    includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),\n    includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),\n    includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),\n    includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),\n    useCache: util.default(options.useCache, defBbOpts.useCache)\n  };\n}\n\nelesfn.boundingBox = function (options) {\n  // the main usecase is ele.boundingBox() for a single element with no/def options\n  // specified s.t. the cache is used, so check for this case to make it faster by\n  // avoiding the overhead of the rest of the function\n  if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n    if (options === undefined) {\n      options = defBbOpts;\n    } else {\n      options = filledBbOpts(options);\n    }\n\n    return cachedBoundingBoxImpl(this[0], options);\n  }\n\n  var bounds = {\n    x1: Infinity,\n    y1: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  };\n\n  options = options || util.staticEmptyObject();\n\n  var opts = filledBbOpts(options);\n\n  var eles = this;\n  var cy = eles.cy();\n  var styleEnabled = cy.styleEnabled();\n\n  if (styleEnabled) {\n    this.recalculateRenderedStyle(opts.useCache);\n  }\n\n  this.updateCompoundBounds();\n\n  var updatedEdge = {}; // use to avoid duplicated edge updates\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {\n      var edges = ele.parallelEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        // make all as updated\n        updatedEdge[edges[j].id()] = true;\n      }\n\n      edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached\n    }\n\n    updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));\n  }\n\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n\n  return bounds;\n};\n\n// private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\nelesfn.boundingBoxAt = function (fn) {\n  var nodes = this.nodes();\n\n  if (is.plainObject(fn)) {\n    var obj = fn;\n\n    fn = function fn() {\n      return obj;\n    };\n  }\n\n  // save the current position and set the new one, per node\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    var _p = n._private;\n    var pos = _p.position;\n    var newPos = fn.call(n, n, i);\n\n    _p.bbAtOldPos = { x: pos.x, y: pos.y };\n\n    if (newPos) {\n      pos.x = newPos.x;\n      pos.y = newPos.y;\n    }\n  }\n\n  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs\n\n  nodes.dirtyCompoundBoundsCache().updateCompoundBounds();\n\n  var bb = this.boundingBox({ useCache: false });\n\n  // restore the original position, per node\n  for (var _i = 0; _i < nodes.length; _i++) {\n    var _n = nodes[_i];\n    var _p2 = _n._private;\n    var _pos = _n._private.position;\n    var old = _p2.bbAtOldPos;\n\n    _pos.x = old.x;\n    _pos.y = old.y;\n  }\n\n  nodes.dirtyCompoundBoundsCache();\n\n  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs\n\n  return bb;\n};\n\nfn.boundingbox = fn.boundingBox;\nfn.renderedBoundingbox = fn.renderedBoundingBox;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ifEdge = function ifEdge(self, then) {\n  if (self.isEdge()) {\n    return then(self.renderer());\n  }\n};\n\nmodule.exports = {\n  controlPoints: function controlPoints() {\n    var _this = this;\n\n    return ifEdge(this, function (renderer) {\n      return renderer.getControlPoints(_this);\n    });\n  },\n  segmentPoints: function segmentPoints() {\n    var _this2 = this;\n\n    return ifEdge(this, function (renderer) {\n      return renderer.getSegmentPoints(_this2);\n    });\n  },\n  sourceEndpoint: function sourceEndpoint() {\n    var _this3 = this;\n\n    return ifEdge(this, function (renderer) {\n      return renderer.getSourceEndpoint(_this3);\n    });\n  },\n  targetEndpoint: function targetEndpoint() {\n    var _this4 = this;\n\n    return ifEdge(this, function (renderer) {\n      return renderer.getTargetEndpoint(_this4);\n    });\n  },\n  midpoint: function midpoint() {\n    var _this5 = this;\n\n    return ifEdge(this, function (renderer) {\n      return renderer.getEdgeMidpoint(_this5);\n    });\n  }\n};\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar position = __webpack_require__(45);\nvar bounds = __webpack_require__(42);\nvar widthHeight = __webpack_require__(46);\nvar edgePoints = __webpack_require__(43);\n\nmodule.exports = util.assign({}, position, bounds, widthHeight, edgePoints);\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar define = __webpack_require__(3);\nvar is = __webpack_require__(0);\nvar math = __webpack_require__(2);\nvar fn = void 0,\n    elesfn = void 0;\n\nvar beforePositionSet = function beforePositionSet(eles, newPos) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (ele.isParent() && !ele.locked()) {\n      var oldPos = ele._private.position;\n      var delta = {\n        x: newPos.x - oldPos.x,\n        y: newPos.y - oldPos.y\n      };\n\n      eles.children().shift(delta);\n    }\n  }\n};\n\nfn = elesfn = {\n\n  position: define.data({\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'emitAndNotify',\n    allowGetting: true,\n    validKeys: ['x', 'y'],\n    beforeGet: function beforeGet(ele) {\n      ele.updateCompoundBounds();\n    },\n    beforeSet: beforePositionSet,\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n      return !ele.locked();\n    }\n  }),\n\n  // position but no notification to renderer\n  silentPosition: define.data({\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: false,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: false,\n    triggerFnName: 'trigger',\n    allowGetting: false,\n    validKeys: ['x', 'y'],\n    beforeSet: beforePositionSet,\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n      return !ele.locked();\n    }\n  }),\n\n  positions: function positions(pos, silent) {\n    if (is.plainObject(pos)) {\n      if (silent) {\n        this.silentPosition(pos);\n      } else {\n        this.position(pos);\n      }\n    } else if (is.fn(pos)) {\n      var _fn = pos;\n      var cy = this.cy();\n\n      cy.startBatch();\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _pos = void 0;\n\n        if (_pos = _fn(ele, i)) {\n          if (silent) {\n            ele.silentPosition(_pos);\n          } else {\n            ele.position(_pos);\n          }\n        }\n      }\n\n      cy.endBatch();\n    }\n\n    return this; // chaining\n  },\n\n  silentPositions: function silentPositions(pos) {\n    return this.positions(pos, true);\n  },\n\n  shift: function shift(dim, val) {\n    var delta = void 0;\n\n    if (is.plainObject(dim)) {\n      delta = dim;\n    } else if (is.string(dim) && is.number(val)) {\n      delta = { x: 0, y: 0 };\n\n      delta[dim] = val;\n    }\n\n    if (delta != null) {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var pos = ele.position();\n\n        ele.position({\n          x: pos.x + delta.x,\n          y: pos.y + delta.y\n        });\n      }\n    }\n\n    return this;\n  },\n\n  // get/set the rendered (i.e. on screen) positon of the element\n  renderedPosition: function renderedPosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var rpos = is.plainObject(dim) ? dim : undefined;\n    var setting = rpos !== undefined || val !== undefined && is.string(dim);\n\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele = this[i];\n\n          if (val !== undefined) {\n            // set one dimension\n            _ele.position(dim, (val - pan[dim]) / zoom);\n          } else if (rpos !== undefined) {\n            // set whole position\n            _ele.position(math.renderedToModelPosition(rpos, zoom, pan));\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n        rpos = math.modelToRenderedPosition(pos, zoom, pan);\n\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return rpos;\n        } else {\n          // then return the specified dimension\n          return rpos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  },\n\n  // get/set the position relative to the parent\n  relativePosition: function relativePosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var ppos = is.plainObject(dim) ? dim : undefined;\n    var setting = ppos !== undefined || val !== undefined && is.string(dim);\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele2 = this[i];\n          var parent = hasCompoundNodes ? _ele2.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n\n          if (hasParent) {\n            parent = parent[0];\n          }\n\n          var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };\n\n          if (val !== undefined) {\n            // set one dimension\n            _ele2.position(dim, val + origin[dim]);\n          } else if (ppos !== undefined) {\n            // set whole position\n            _ele2.position({\n              x: ppos.x + origin.x,\n              y: ppos.y + origin.y\n            });\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n        var _parent = hasCompoundNodes ? ele.parent() : null;\n        var _hasParent = _parent && _parent.length > 0;\n        var _relativeToParent = _hasParent;\n\n        if (_hasParent) {\n          _parent = _parent[0];\n        }\n\n        var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };\n\n        ppos = {\n          x: pos.x - _origin.x,\n          y: pos.y - _origin.y\n        };\n\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return ppos;\n        } else {\n          // then return the specified dimension\n          return ppos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  }\n};\n\n// aliases\nfn.modelPosition = fn.point = fn.position;\nfn.modelPositions = fn.points = fn.positions;\nfn.renderedPoint = fn.renderedPosition;\nfn.relativePoint = fn.relativePosition;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar fn = void 0,\n    elesfn = void 0;\n\nfn = elesfn = {};\n\nvar defineDimFns = function defineDimFns(opts) {\n  opts.uppercaseName = util.capitalize(opts.name);\n  opts.autoName = 'auto' + opts.uppercaseName;\n  opts.labelName = 'label' + opts.uppercaseName;\n  opts.outerName = 'outer' + opts.uppercaseName;\n  opts.uppercaseOuterName = util.capitalize(opts.outerName);\n\n  fn[opts.name] = function dimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if (ele) {\n      if (styleEnabled) {\n        if (ele.isParent()) {\n          ele.updateCompoundBounds();\n\n          return _p[opts.autoName] || 0;\n        }\n\n        var d = ele.pstyle(opts.name);\n\n        switch (d.strValue) {\n          case 'label':\n            ele.recalculateRenderedStyle();\n\n            return _p.rstyle[opts.labelName] || 0;\n\n          default:\n            return d.pfValue;\n        }\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn['outer' + opts.uppercaseName] = function outerDimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if (ele) {\n      if (styleEnabled) {\n        var dim = ele[opts.name]();\n        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n        var padding = 2 * ele.padding();\n\n        return dim + border + padding;\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n    var ele = this[0];\n\n    if (ele) {\n      var d = ele[opts.name]();\n      return d * this.cy().zoom();\n    }\n  };\n\n  fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n    var ele = this[0];\n\n    if (ele) {\n      var od = ele[opts.outerName]();\n      return od * this.cy().zoom();\n    }\n  };\n};\n\ndefineDimFns({\n  name: 'width'\n});\n\ndefineDimFns({\n  name: 'height'\n});\n\nelesfn.padding = function () {\n  var ele = this[0];\n  var _p = ele._private;\n  if (ele.isParent()) {\n    ele.updateCompoundBounds();\n\n    if (_p.autoPadding !== undefined) {\n      return _p.autoPadding;\n    } else {\n      return ele.pstyle('padding').pfValue;\n    }\n  } else {\n    return ele.pstyle('padding').pfValue;\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Emitter = __webpack_require__(10);\nvar define = __webpack_require__(3);\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Selector = __webpack_require__(6);\n\nvar emitterOptions = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(ele, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  eventFields: function eventFields(ele) {\n    return {\n      cy: ele.cy(),\n      target: ele\n    };\n  },\n  callbackContext: function callbackContext(ele, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : ele;\n  },\n  beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {\n    if (listener.conf && listener.conf.once) {\n      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n    }\n  },\n  bubble: function bubble() {\n    return true;\n  },\n  parent: function parent(ele) {\n    return ele.isChild() ? ele.parent() : ele.cy();\n  }\n};\n\nvar argSelector = function argSelector(arg) {\n  if (is.string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn = {\n  createEmitter: function createEmitter() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(util.assign({\n          context: ele\n        }, emitterOptions));\n      }\n    }\n\n    return this;\n  },\n\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n\n  on: function on(events, selector, callback) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      ele.emitter().on(events, argSelector(selector), callback);\n    }\n\n    return this;\n  },\n\n  removeListener: function removeListener(events, selector, callback) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      ele.emitter().removeListener(events, argSelector(selector), callback);\n    }\n\n    return this;\n  },\n\n  one: function one(events, selector, callback) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      ele.emitter().one(events, argSelector(selector), callback);\n    }\n\n    return this;\n  },\n\n  once: function once(events, selector, callback) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      ele.emitter().on(events, argSelector(selector), callback, {\n        once: true,\n        onceCollection: this\n      });\n    }\n  },\n\n  emit: function emit(events, extraParams) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      ele.emitter().emit(events, extraParams);\n    }\n\n    return this;\n  },\n\n  emitAndNotify: function emitAndNotify(event, extraParams) {\n    // for internal use only\n    if (this.length === 0) {\n      return;\n    } // empty collections don't need to notify anything\n\n    // notify renderer\n    this.cy().notify({\n      type: event,\n      eles: this\n    });\n\n    this.emit(event, extraParams);\n\n    return this;\n  }\n};\n\ndefine.eventAliasesOn(elesfn);\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Selector = __webpack_require__(6);\n\nvar elesfn = {\n  nodes: function nodes(selector) {\n    return this.filter(function (ele) {\n      return ele.isNode();\n    }).filter(selector);\n  },\n\n  edges: function edges(selector) {\n    return this.filter(function (ele) {\n      return ele.isEdge();\n    }).filter(selector);\n  },\n\n  filter: function filter(_filter, thisArg) {\n    if (_filter === undefined) {\n      // check this first b/c it's the most common/performant case\n      return this;\n    } else if (is.string(_filter) || is.elementOrCollection(_filter)) {\n      return new Selector(_filter).filter(this);\n    } else if (is.fn(_filter)) {\n      var filterEles = this.spawn();\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\n        if (include) {\n          filterEles.merge(ele);\n        }\n      }\n\n      return filterEles;\n    }\n\n    return this.spawn(); // if not handled by above, give 'em an empty collection\n  },\n\n  not: function not(toRemove) {\n    if (!toRemove) {\n      return this;\n    } else {\n\n      if (is.string(toRemove)) {\n        toRemove = this.filter(toRemove);\n      }\n\n      var elements = [];\n      var rMap = toRemove._private.map;\n\n      for (var i = 0; i < this.length; i++) {\n        var element = this[i];\n\n        var remove = rMap.has(element.id());\n        if (!remove) {\n          elements.push(element);\n        }\n      }\n\n      return this.spawn(elements);\n    }\n  },\n\n  absoluteComplement: function absoluteComplement() {\n    var cy = this.cy();\n\n    return cy.mutableElements().not(this);\n  },\n\n  intersect: function intersect(other) {\n    // if a selector is specified, then filter by it instead\n    if (is.string(other)) {\n      var selector = other;\n      return this.filter(selector);\n    }\n\n    var elements = [];\n    var col1 = this;\n    var col2 = other;\n    var col1Smaller = this.length < other.length;\n    var map2 = col1Smaller ? col2._private.map : col1._private.map;\n    var col = col1Smaller ? col1 : col2;\n\n    for (var i = 0; i < col.length; i++) {\n      var id = col[i]._private.data.id;\n      var entry = map2.get(id);\n\n      if (entry) {\n        elements.push(entry.ele);\n      }\n    }\n\n    return this.spawn(elements);\n  },\n\n  xor: function xor(other) {\n    var cy = this._private.cy;\n\n    if (is.string(other)) {\n      other = cy.$(other);\n    }\n\n    var elements = [];\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (!inOther) {\n          elements.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2);\n    add(col2, col1);\n\n    return this.spawn(elements);\n  },\n\n  diff: function diff(other) {\n    var cy = this._private.cy;\n\n    if (is.string(other)) {\n      other = cy.$(other);\n    }\n\n    var left = [];\n    var right = [];\n    var both = [];\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other, retEles) {\n\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (inOther) {\n          both.push(ele);\n        } else {\n          retEles.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2, left);\n    add(col2, col1, right);\n\n    return {\n      left: this.spawn(left, { unique: true }),\n      right: this.spawn(right, { unique: true }),\n      both: this.spawn(both, { unique: true })\n    };\n  },\n\n  add: function add(toAdd) {\n    var cy = this._private.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (is.string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < this.length; i++) {\n      elements.push(this[i]);\n    }\n\n    var map = this._private.map;\n\n    for (var _i = 0; _i < toAdd.length; _i++) {\n\n      var add = !map.has(toAdd[_i].id());\n      if (add) {\n        elements.push(toAdd[_i]);\n      }\n    }\n\n    return this.spawn(elements);\n  },\n\n  // in place merge on calling collection\n  merge: function merge(toAdd) {\n    var _p = this._private;\n    var cy = _p.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (toAdd && is.string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var map = _p.map;\n\n    for (var i = 0; i < toAdd.length; i++) {\n      var toAddEle = toAdd[i];\n      var id = toAddEle._private.data.id;\n      var add = !map.has(id);\n\n      if (add) {\n        var index = this.length++;\n\n        this[index] = toAddEle;\n\n        map.set(id, { ele: toAddEle, index: index });\n      } else {\n        // replace\n        var _index = map.get(id).index;\n\n        this[_index] = toAddEle;\n        map.set(id, { ele: toAddEle, index: _index });\n      }\n    }\n\n    return this; // chaining\n  },\n\n  // remove single ele in place in calling collection\n  unmergeOne: function unmergeOne(ele) {\n    ele = ele[0];\n\n    var _p = this._private;\n    var id = ele._private.data.id;\n    var map = _p.map;\n    var entry = map.get(id);\n\n    if (!entry) {\n      return this; // no need to remove\n    }\n\n    var i = entry.index;\n\n    // remove ele\n    this[i] = undefined;\n    map.delete(id);\n\n    var unmergedLastEle = i === this.length - 1;\n\n    // replace empty spot with last ele in collection\n    if (this.length > 1 && !unmergedLastEle) {\n      var lastEleI = this.length - 1;\n      var lastEle = this[lastEleI];\n      var lastEleId = lastEle._private.data.id;\n\n      this[lastEleI] = undefined;\n      this[i] = lastEle;\n      map.set(lastEleId, { ele: lastEle, index: i });\n    }\n\n    // the collection is now 1 ele smaller\n    this.length--;\n\n    return this;\n  },\n\n  // remove eles in place on calling collection\n  unmerge: function unmerge(toRemove) {\n    var cy = this._private.cy;\n\n    if (!toRemove) {\n      return this;\n    }\n\n    if (toRemove && is.string(toRemove)) {\n      var selector = toRemove;\n      toRemove = cy.mutableElements().filter(selector);\n    }\n\n    for (var i = 0; i < toRemove.length; i++) {\n      this.unmergeOne(toRemove[i]);\n    }\n\n    return this; // chaining\n  },\n\n  map: function map(mapFn, thisArg) {\n    var arr = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n\n      arr.push(ret);\n    }\n\n    return arr;\n  },\n\n  reduce: function reduce(fn, initialValue) {\n    var val = initialValue;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      val = fn(val, eles[i], i, eles);\n    }\n\n    return val;\n  },\n\n  max: function max(valFn, thisArg) {\n    var max = -Infinity;\n    var maxEle = void 0;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val > max) {\n        max = val;\n        maxEle = ele;\n      }\n    }\n\n    return {\n      value: max,\n      ele: maxEle\n    };\n  },\n\n  min: function min(valFn, thisArg) {\n    var min = Infinity;\n    var minEle = void 0;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val < min) {\n        min = val;\n        minEle = ele;\n      }\n    }\n\n    return {\n      value: min,\n      ele: minEle\n    };\n  }\n};\n\n// aliases\nvar fn = elesfn;\nfn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;\nfn['\\\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;\nfn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;\nfn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;\nfn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;\nfn.complement = fn.abscomp = fn.absoluteComplement;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar elesfn = {\n  isNode: function isNode() {\n    return this.group() === 'nodes';\n  },\n\n  isEdge: function isEdge() {\n    return this.group() === 'edges';\n  },\n\n  isLoop: function isLoop() {\n    return this.isEdge() && this.source().id() === this.target().id();\n  },\n\n  isSimple: function isSimple() {\n    return this.isEdge() && this.source().id() !== this.target().id();\n  },\n\n  group: function group() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.group;\n    }\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar zIndexSort = __webpack_require__(14);\nvar util = __webpack_require__(1);\n\nvar elesfn = {\n  forEach: function forEach(fn, thisArg) {\n    if (is.fn(fn)) {\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n\n        if (ret === false) {\n          break;\n        } // exit each early on return false\n      }\n    }\n\n    return this;\n  },\n\n  toArray: function toArray() {\n    var array = [];\n\n    for (var i = 0; i < this.length; i++) {\n      array.push(this[i]);\n    }\n\n    return array;\n  },\n\n  slice: function slice(start, end) {\n    var array = [];\n    var thisSize = this.length;\n\n    if (end == null) {\n      end = thisSize;\n    }\n\n    if (start == null) {\n      start = 0;\n    }\n\n    if (start < 0) {\n      start = thisSize + start;\n    }\n\n    if (end < 0) {\n      end = thisSize + end;\n    }\n\n    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n      array.push(this[i]);\n    }\n\n    return this.spawn(array);\n  },\n\n  size: function size() {\n    return this.length;\n  },\n\n  eq: function eq(i) {\n    return this[i] || this.spawn();\n  },\n\n  first: function first() {\n    return this[0] || this.spawn();\n  },\n\n  last: function last() {\n    return this[this.length - 1] || this.spawn();\n  },\n\n  empty: function empty() {\n    return this.length === 0;\n  },\n\n  nonempty: function nonempty() {\n    return !this.empty();\n  },\n\n  sort: function sort(sortFn) {\n    if (!is.fn(sortFn)) {\n      return this;\n    }\n\n    var sorted = this.toArray().sort(sortFn);\n\n    return this.spawn(sorted);\n  },\n\n  sortByZIndex: function sortByZIndex() {\n    return this.sort(zIndexSort);\n  },\n\n  zDepth: function zDepth() {\n    var ele = this[0];\n    if (!ele) {\n      return undefined;\n    }\n\n    // let cy = ele.cy();\n    var _p = ele._private;\n    var group = _p.group;\n\n    if (group === 'nodes') {\n      var depth = _p.data.parent ? ele.parents().size() : 0;\n\n      if (!ele.isParent()) {\n        return util.MAX_INT - 1; // childless nodes always on top\n      }\n\n      return depth;\n    } else {\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcDepth = src.zDepth();\n      var tgtDepth = tgt.zDepth();\n\n      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n    }\n  }\n};\n\nelesfn.each = elesfn.forEach;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Promise = __webpack_require__(5);\nvar math = __webpack_require__(2);\n\nvar elesfn = {\n  // Calculates and returns node dimensions { x, y } based on options given\n  layoutDimensions: function layoutDimensions(options) {\n    options = util.assign({\n      nodeDimensionsIncludeLabels: true\n    }, options);\n\n    if (options.nodeDimensionsIncludeLabels) {\n      var bbDim = this.boundingBox();\n      return {\n        w: bbDim.w,\n        h: bbDim.h\n      };\n    } else {\n      return {\n        w: this.outerWidth(),\n        h: this.outerHeight()\n      };\n    }\n  },\n\n  // using standard layout options, apply position function (w/ or w/o animation)\n  layoutPositions: function layoutPositions(layout, options, fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var layoutEles = options.eles; // nodes & edges\n    var getMemoizeKey = function getMemoizeKey(node, i) {\n      return node.id() + '$' + i;\n    };\n    var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function\n\n    layout.emit({ type: 'layoutstart', layout: layout });\n\n    layout.animations = [];\n\n    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n      var center = {\n        x: nodesBb.x1 + nodesBb.w / 2,\n        y: nodesBb.y1 + nodesBb.h / 2\n      };\n\n      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)\n        x: (pos.x - center.x) * spacing,\n        y: (pos.y - center.y) * spacing\n      };\n\n      return {\n        x: center.x + spacingVector.x,\n        y: center.y + spacingVector.y\n      };\n    };\n\n    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\n    var spacingBb = function spacingBb() {\n      if (!useSpacingFactor) {\n        return null;\n      }\n\n      var bb = math.makeBoundingBox();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = fnMem(node, i);\n\n        math.expandBoundingBoxByPoint(bb, pos.x, pos.y);\n      }\n\n      return bb;\n    };\n\n    var bb = spacingBb();\n\n    var getFinalPos = util.memoize(function (node, i) {\n      var newPos = fnMem(node, i);\n      var pos = node.position();\n\n      if (!is.number(pos.x) || !is.number(pos.y)) {\n        node.silentPosition({ x: 0, y: 0 });\n      }\n\n      if (useSpacingFactor) {\n        var spacing = Math.abs(options.spacingFactor);\n\n        newPos = calculateSpacing(spacing, bb, newPos);\n      }\n\n      if (options.transform != null) {\n        newPos = options.transform(node, newPos);\n      }\n\n      return newPos;\n    }, getMemoizeKey);\n\n    if (options.animate) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var newPos = getFinalPos(node, i);\n        var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\n        if (animateNode) {\n          var ani = node.animation({\n            position: newPos,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n\n          layout.animations.push(ani);\n\n          ani.play();\n        } else {\n          node.position(newPos);\n        }\n      }\n\n      if (options.fit) {\n        var fitAni = cy.animation({\n          fit: {\n            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n            padding: options.padding\n          },\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n\n        layout.animations.push(fitAni);\n\n        fitAni.play();\n      } else if (options.zoom !== undefined && options.pan !== undefined) {\n        var zoomPanAni = cy.animation({\n          zoom: options.zoom,\n          pan: options.pan,\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n\n        layout.animations.push(zoomPanAni);\n\n        zoomPanAni.play();\n      }\n\n      layout.one('layoutready', options.ready);\n      layout.emit({ type: 'layoutready', layout: layout });\n\n      Promise.all(layout.animations.map(function (ani) {\n        return ani.promise();\n      })).then(function () {\n        layout.one('layoutstop', options.stop);\n        layout.emit({ type: 'layoutstop', layout: layout });\n      });\n    } else {\n\n      nodes.positions(getFinalPos);\n\n      if (options.fit) {\n        cy.fit(options.eles, options.padding);\n      }\n\n      if (options.zoom != null) {\n        cy.zoom(options.zoom);\n      }\n\n      if (options.pan) {\n        cy.pan(options.pan);\n      }\n\n      layout.one('layoutready', options.ready);\n      layout.emit({ type: 'layoutready', layout: layout });\n\n      layout.one('layoutstop', options.stop);\n      layout.emit({ type: 'layoutstop', layout: layout });\n    }\n\n    return this; // chaining\n  },\n\n  layout: function layout(options) {\n    var cy = this.cy();\n\n    return cy.makeLayout(util.extend({}, options, {\n      eles: this\n    }));\n  }\n\n};\n\n// aliases:\nelesfn.createLayout = elesfn.makeLayout = elesfn.layout;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nfunction styleCache(key, fn, ele) {\n  var _p = ele._private;\n  var cache = _p.styleCache = _p.styleCache || {};\n  var val;\n\n  if ((val = cache[key]) != null) {\n    return val;\n  } else {\n    val = cache[key] = fn(ele);\n\n    return val;\n  }\n}\n\nfunction cacheStyleFunction(key, fn) {\n  return function cachedStyleFunction(ele) {\n    return styleCache(key, fn, ele);\n  };\n}\n\nfunction cachePrototypeStyleFunction(key, fn) {\n  var selfFn = function selfFn(ele) {\n    return fn.call(ele);\n  };\n\n  return function cachedPrototypeStyleFunction() {\n    var ele = this[0];\n\n    if (ele) {\n      return styleCache(key, selfFn, ele);\n    }\n  };\n}\n\nvar elesfn = {\n\n  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n    var cy = this.cy();\n    var renderer = cy.renderer();\n    var styleEnabled = cy.styleEnabled();\n\n    if (renderer && styleEnabled) {\n      renderer.recalculateRenderedStyle(this, useCache);\n    }\n\n    return this;\n  },\n\n  dirtyStyleCache: function dirtyStyleCache() {\n    var cy = this.cy();\n    var dirty = function dirty(ele) {\n      return ele._private.styleCache = {};\n    };\n\n    if (cy.hasCompoundNodes()) {\n      var eles = void 0;\n\n      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n\n      eles.merge(eles.connectedEdges());\n\n      eles.forEach(dirty);\n    } else {\n      this.forEach(function (ele) {\n        dirty(ele);\n\n        ele.connectedEdges().forEach(dirty);\n      });\n    }\n\n    return this;\n  },\n\n  // fully updates (recalculates) the style for the elements\n  updateStyle: function updateStyle(notifyRenderer) {\n    var cy = this._private.cy;\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    if (cy._private.batchingStyle) {\n      var bEles = cy._private.batchStyleEles;\n\n      bEles.merge(this);\n\n      return this; // chaining and exit early when batching\n    }\n\n    var hasCompounds = cy.hasCompoundNodes();\n    var style = cy.style();\n    var updatedEles = this;\n\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    if (hasCompounds) {\n      // then add everything up and down for compound selector checks\n      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n    }\n\n    var changedEles = style.apply(updatedEles);\n\n    changedEles.dirtyStyleCache();\n    changedEles.dirtyCompoundBoundsCache();\n\n    if (notifyRenderer) {\n      changedEles.emitAndNotify('style'); // let renderer know we changed style\n    } else {\n      changedEles.emit('style'); // just fire the event\n    }\n\n    return this; // chaining\n  },\n\n  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n  updateMappers: function updateMappers(notifyRenderer) {\n    var cy = this._private.cy;\n    var style = cy.style();\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var changedEles = style.updateMappers(this);\n\n    changedEles.dirtyStyleCache();\n    changedEles.dirtyCompoundBoundsCache();\n\n    if (notifyRenderer) {\n      changedEles.emitAndNotify('style'); // let renderer know we changed style\n    } else {\n      changedEles.emit('style'); // just fire the event\n    }\n    return this; // chaining\n  },\n\n  // get the internal parsed style object for the specified property\n  parsedStyle: function parsedStyle(property) {\n    var ele = this[0];\n    var cy = ele.cy();\n\n    if (!cy.styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      return ele._private.style[property] || cy.style().getDefaultProperty(property);\n    }\n  },\n\n  numericStyle: function numericStyle(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      var pstyle = ele.pstyle(property);\n\n      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n    }\n  },\n\n  numericStyleUnits: function numericStyleUnits(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      return ele.pstyle(property).units;\n    }\n  },\n\n  // get the specified css property as a rendered value (i.e. on-screen value)\n  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n  renderedStyle: function renderedStyle(property) {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var ele = this[0];\n\n    if (ele) {\n      return cy.style().getRenderedStyle(ele, property);\n    }\n  },\n\n  // read the calculated css style of the element or override the style (via a bypass)\n  style: function style(name, value) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n\n    if (is.plainObject(name)) {\n      // then extend the bypass\n      var props = name;\n      style.applyBypass(this, props, updateTransitions);\n\n      this.dirtyStyleCache();\n      this.dirtyCompoundBoundsCache();\n\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n    } else if (is.string(name)) {\n\n      if (value === undefined) {\n        // then get the property from the style\n        var ele = this[0];\n\n        if (ele) {\n          return style.getStylePropertyValue(ele, name);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      } else {\n        // then set the bypass with the property value\n        style.applyBypass(this, name, value, updateTransitions);\n\n        this.dirtyStyleCache();\n        this.dirtyCompoundBoundsCache();\n\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      }\n    } else if (name === undefined) {\n      var _ele = this[0];\n\n      if (_ele) {\n        return style.getRawStyle(_ele);\n      } else {\n        // empty collection => can't get any value\n        return;\n      }\n    }\n\n    return this; // chaining\n  },\n\n  removeStyle: function removeStyle(names) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n    var eles = this;\n\n    if (names === undefined) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        style.removeAllBypasses(ele, updateTransitions);\n      }\n    } else {\n      names = names.split(/\\s+/);\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele2 = eles[_i];\n\n        style.removeBypasses(_ele2, names, updateTransitions);\n      }\n    }\n\n    this.dirtyStyleCache();\n    this.dirtyCompoundBoundsCache();\n\n    this.emitAndNotify('style'); // let the renderer know we've updated style\n\n    return this; // chaining\n  },\n\n  show: function show() {\n    this.css('display', 'element');\n    return this; // chaining\n  },\n\n  hide: function hide() {\n    this.css('display', 'none');\n    return this; // chaining\n  },\n\n  effectiveOpacity: function effectiveOpacity() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return 1;\n    }\n\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var ele = this[0];\n\n    if (ele) {\n      var _p = ele._private;\n      var parentOpacity = ele.pstyle('opacity').value;\n\n      if (!hasCompoundNodes) {\n        return parentOpacity;\n      }\n\n      var parents = !_p.data.parent ? null : ele.parents();\n\n      if (parents) {\n        for (var i = 0; i < parents.length; i++) {\n          var parent = parents[i];\n          var opacity = parent.pstyle('opacity').value;\n\n          parentOpacity = opacity * parentOpacity;\n        }\n      }\n\n      return parentOpacity;\n    }\n  },\n\n  transparent: function transparent() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n    if (ele) {\n      if (!hasCompoundNodes) {\n        return ele.pstyle('opacity').value === 0;\n      } else {\n        return ele.effectiveOpacity() === 0;\n      }\n    }\n  },\n\n  backgrounding: function backgrounding() {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n\n    return ele._private.backgrounding ? true : false;\n  }\n\n};\n\nfunction checkCompound(ele, parentOk) {\n  var _p = ele._private;\n  var parents = _p.data.parent ? ele.parents() : null;\n\n  if (parents) {\n    for (var i = 0; i < parents.length; i++) {\n      var parent = parents[i];\n\n      if (!parentOk(parent)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction defineDerivedStateFunction(specs) {\n  var ok = specs.ok;\n  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n  var parentOk = specs.parentOk || specs.ok;\n\n  return function () {\n    var cy = this.cy();\n    if (!cy.styleEnabled()) {\n      return true;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if (ele) {\n      var _p = ele._private;\n\n      if (!ok(ele)) {\n        return false;\n      }\n\n      if (ele.isNode()) {\n        return !hasCompoundNodes || checkCompound(ele, parentOk);\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n\n        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n      }\n    }\n  };\n}\n\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\n\nelesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n  ok: eleTakesUpSpace\n}));\n\nvar eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\n\nvar parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\n\nelesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n  ok: eleInteractive,\n  parentOk: parentInteractive,\n  edgeOkViaNode: eleTakesUpSpace\n}));\n\nelesfn.noninteractive = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.interactive();\n  }\n};\n\nvar eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\n\nvar edgeVisibleViaNode = eleTakesUpSpace;\n\nelesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n  ok: eleVisible,\n  edgeOkViaNode: edgeVisibleViaNode\n}));\n\nelesfn.hidden = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.visible();\n  }\n};\n\nelesfn.bypass = elesfn.css = elesfn.style;\nelesfn.renderedCss = elesfn.renderedStyle;\nelesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;\nelesfn.pstyle = elesfn.parsedStyle;\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar elesfn = {};\n\nfunction defineSwitchFunction(params) {\n  return function () {\n    var args = arguments;\n    var changedEles = [];\n\n    // e.g. cy.nodes().select( data, handler )\n    if (args.length === 2) {\n      var data = args[0];\n      var handler = args[1];\n      this.on(params.event, data, handler);\n    }\n\n    // e.g. cy.nodes().select( handler )\n    else if (args.length === 1) {\n        var _handler = args[0];\n        this.on(params.event, _handler);\n      }\n\n      // e.g. cy.nodes().select()\n      else if (args.length === 0) {\n          for (var i = 0; i < this.length; i++) {\n            var ele = this[i];\n            var able = !params.ableField || ele._private[params.ableField];\n            var changed = ele._private[params.field] != params.value;\n\n            if (params.overrideAble) {\n              var overrideAble = params.overrideAble(ele);\n\n              if (overrideAble !== undefined) {\n                able = overrideAble;\n\n                if (!overrideAble) {\n                  return this;\n                } // to save cycles assume not able for all on override\n              }\n            }\n\n            if (able) {\n              ele._private[params.field] = params.value;\n\n              if (changed) {\n                changedEles.push(ele);\n              }\n            }\n          }\n\n          var changedColl = this.spawn(changedEles);\n          changedColl.updateStyle(); // change of state => possible change of style\n          changedColl.emit(params.event);\n        }\n\n    return this;\n  };\n}\n\nfunction defineSwitchSet(params) {\n  elesfn[params.field] = function () {\n    var ele = this[0];\n\n    if (ele) {\n      if (params.overrideField) {\n        var val = params.overrideField(ele);\n\n        if (val !== undefined) {\n          return val;\n        }\n      }\n\n      return ele._private[params.field];\n    }\n  };\n\n  elesfn[params.on] = defineSwitchFunction({\n    event: params.on,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: true\n  });\n\n  elesfn[params.off] = defineSwitchFunction({\n    event: params.off,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: false\n  });\n}\n\ndefineSwitchSet({\n  field: 'locked',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autolock() ? true : undefined;\n  },\n  on: 'lock',\n  off: 'unlock'\n});\n\ndefineSwitchSet({\n  field: 'grabbable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autoungrabify() ? false : undefined;\n  },\n  on: 'grabify',\n  off: 'ungrabify'\n});\n\ndefineSwitchSet({\n  field: 'selected',\n  ableField: 'selectable',\n  overrideAble: function overrideAble(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'select',\n  off: 'unselect'\n});\n\ndefineSwitchSet({\n  field: 'selectable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'selectify',\n  off: 'unselectify'\n});\n\nelesfn.deselect = elesfn.unselect;\n\nelesfn.grabbed = function () {\n  var ele = this[0];\n  if (ele) {\n    return ele._private.grabbed;\n  }\n};\n\ndefineSwitchSet({\n  field: 'active',\n  on: 'activate',\n  off: 'unactivate'\n});\n\nelesfn.inactive = function () {\n  var ele = this[0];\n  if (ele) {\n    return !ele._private.active;\n  }\n};\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar elesfn = {};\n\nvar cache = function cache(fn, name) {\n  return function traversalCache(arg1, arg2, arg3, arg4) {\n    var selectorOrEles = arg1;\n    var eles = this;\n    var key = void 0;\n\n    if (selectorOrEles == null) {\n      key = 'null';\n    } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n      key = '#' + selectorOrEles.id();\n    }\n\n    if (eles.length === 1 && key) {\n      var _p = eles[0]._private;\n      var tch = _p.traversalCache = _p.traversalCache || {};\n      var ch = tch[name] = tch[name] || {};\n      var cacheHit = ch[key];\n\n      if (cacheHit) {\n        return cacheHit;\n      } else {\n        return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);\n      }\n    } else {\n      return fn.call(eles, arg1, arg2, arg3, arg4);\n    }\n  };\n};\n\n// DAG functions\n////////////////\n\nvar defineDagExtremity = function defineDagExtremity(params) {\n  return function dagExtremityImpl(selector) {\n    var eles = this;\n    var ret = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var disqualified = false;\n      var edges = ele.connectedEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n          disqualified = true;\n          break;\n        }\n      }\n\n      if (!disqualified) {\n        ret.push(ele);\n      }\n    }\n\n    return this.spawn(ret, { unique: true }).filter(selector);\n  };\n};\n\nvar defineDagOneHop = function defineDagOneHop(params) {\n  return function (selector) {\n    var eles = this;\n    var oEles = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var edges = ele.connectedEdges();\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.outgoing && src === ele) {\n          oEles.push(edge);\n          oEles.push(tgt);\n        } else if (params.incoming && tgt === ele) {\n          oEles.push(edge);\n          oEles.push(src);\n        }\n      }\n    }\n\n    return this.spawn(oEles, { unique: true }).filter(selector);\n  };\n};\n\nvar defineDagAllHops = function defineDagAllHops(params) {\n  return function (selector) {\n    var eles = this;\n    var sEles = [];\n    var sElesIds = {};\n\n    for (;;) {\n      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n      if (next.length === 0) {\n        break;\n      } // done if none left\n\n      var newNext = false;\n      for (var i = 0; i < next.length; i++) {\n        var n = next[i];\n        var nid = n.id();\n\n        if (!sElesIds[nid]) {\n          sElesIds[nid] = true;\n          sEles.push(n);\n          newNext = true;\n        }\n      }\n\n      if (!newNext) {\n        break;\n      } // done if touched all outgoers already\n\n      eles = next;\n    }\n\n    return this.spawn(sEles, { unique: true }).filter(selector);\n  };\n};\n\nelesfn.clearTraversalCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    this[i]._private.traversalCache = null;\n  }\n};\n\nutil.extend(elesfn, {\n  // get the root nodes in the DAG\n  roots: defineDagExtremity({ noIncomingEdges: true }),\n\n  // get the leaf nodes in the DAG\n  leaves: defineDagExtremity({ noOutgoingEdges: true }),\n\n  // normally called children in graph theory\n  // these nodes =edges=> outgoing nodes\n  outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),\n\n  // aka DAG descendants\n  successors: defineDagAllHops({ outgoing: true }),\n\n  // normally called parents in graph theory\n  // these nodes <=edges= incoming nodes\n  incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),\n\n  // aka DAG ancestors\n  predecessors: defineDagAllHops({ incoming: true })\n});\n\n// Neighbourhood functions\n//////////////////////////\n\nutil.extend(elesfn, {\n  neighborhood: cache(function (selector) {\n    var elements = [];\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      // for all nodes\n      var node = nodes[i];\n      var connectedEdges = node.connectedEdges();\n\n      // for each connected edge, add the edge and the other node\n      for (var j = 0; j < connectedEdges.length; j++) {\n        var edge = connectedEdges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        var otherNode = node === src ? tgt : src;\n\n        // need check in case of loop\n        if (otherNode.length > 0) {\n          elements.push(otherNode[0]); // add node 1 hop away\n        }\n\n        // add connected edge\n        elements.push(edge[0]);\n      }\n    }\n\n    return this.spawn(elements, { unique: true }).filter(selector);\n  }, 'neighborhood'),\n\n  closedNeighborhood: function closedNeighborhood(selector) {\n    return this.neighborhood().add(this).filter(selector);\n  },\n\n  openNeighborhood: function openNeighborhood(selector) {\n    return this.neighborhood(selector);\n  }\n});\n\n// aliases\nelesfn.neighbourhood = elesfn.neighborhood;\nelesfn.closedNeighbourhood = elesfn.closedNeighborhood;\nelesfn.openNeighbourhood = elesfn.openNeighborhood;\n\n// Edge functions\n/////////////////\n\nutil.extend(elesfn, {\n  source: cache(function sourceImpl(selector) {\n    var ele = this[0];\n    var src = void 0;\n\n    if (ele) {\n      src = ele._private.source || ele.cy().collection();\n    }\n\n    return src && selector ? src.filter(selector) : src;\n  }, 'source'),\n\n  target: cache(function targetImpl(selector) {\n    var ele = this[0];\n    var tgt = void 0;\n\n    if (ele) {\n      tgt = ele._private.target || ele.cy().collection();\n    }\n\n    return tgt && selector ? tgt.filter(selector) : tgt;\n  }, 'target'),\n\n  sources: defineSourceFunction({\n    attr: 'source'\n  }),\n\n  targets: defineSourceFunction({\n    attr: 'target'\n  })\n});\n\nfunction defineSourceFunction(params) {\n  return function sourceImpl(selector) {\n    var sources = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var src = ele._private[params.attr];\n\n      if (src) {\n        sources.push(src);\n      }\n    }\n\n    return this.spawn(sources, { unique: true }).filter(selector);\n  };\n}\n\nutil.extend(elesfn, {\n  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n\n  edgesTo: cache(defineEdgesWithFunction({\n    thisIsSrc: true\n  }), 'edgesTo')\n});\n\nfunction defineEdgesWithFunction(params) {\n\n  return function edgesWithImpl(otherNodes) {\n    var elements = [];\n    var cy = this._private.cy;\n    var p = params || {};\n\n    // get elements if a selector is specified\n    if (is.string(otherNodes)) {\n      otherNodes = cy.$(otherNodes);\n    }\n\n    for (var h = 0; h < otherNodes.length; h++) {\n      var edges = otherNodes[h]._private.edges;\n\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        var edgeData = edge._private.data;\n        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n        if (!edgeConnectsThisAndOther) {\n          continue;\n        }\n\n        if (p.thisIsSrc || p.thisIsTgt) {\n          if (p.thisIsSrc && !thisToOther) {\n            continue;\n          }\n\n          if (p.thisIsTgt && !otherToThis) {\n            continue;\n          }\n        }\n\n        elements.push(edge);\n      }\n    }\n\n    return this.spawn(elements, { unique: true });\n  };\n}\n\nutil.extend(elesfn, {\n  connectedEdges: cache(function (selector) {\n    var retEles = [];\n\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var node = eles[i];\n      if (!node.isNode()) {\n        continue;\n      }\n\n      var edges = node._private.edges;\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        retEles.push(edge);\n      }\n    }\n\n    return this.spawn(retEles, { unique: true }).filter(selector);\n  }, 'connectedEdges'),\n\n  connectedNodes: cache(function (selector) {\n    var retEles = [];\n\n    var eles = this;\n    for (var i = 0; i < eles.length; i++) {\n      var edge = eles[i];\n      if (!edge.isEdge()) {\n        continue;\n      }\n\n      retEles.push(edge.source()[0]);\n      retEles.push(edge.target()[0]);\n    }\n\n    return this.spawn(retEles, { unique: true }).filter(selector);\n  }, 'connectedNodes'),\n\n  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n\n  codirectedEdges: cache(defineParallelEdgesFunction({\n    codirected: true\n  }), 'codirectedEdges')\n});\n\nfunction defineParallelEdgesFunction(params) {\n  var defaults = {\n    codirected: false\n  };\n  params = util.extend({}, defaults, params);\n\n  return function parallelEdgesImpl(selector) {\n    // micro-optimised for renderer\n    var elements = [];\n    var edges = this.edges();\n    var p = params;\n\n    // look at all the edges in the collection\n    for (var i = 0; i < edges.length; i++) {\n      var edge1 = edges[i];\n      var edge1_p = edge1._private;\n      var src1 = edge1_p.source;\n      var srcid1 = src1._private.data.id;\n      var tgtid1 = edge1_p.data.target;\n      var srcEdges1 = src1._private.edges;\n\n      // look at edges connected to the src node of this edge\n      for (var j = 0; j < srcEdges1.length; j++) {\n        var edge2 = srcEdges1[j];\n        var edge2data = edge2._private.data;\n        var tgtid2 = edge2data.target;\n        var srcid2 = edge2data.source;\n\n        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n          elements.push(edge2);\n        }\n      }\n    }\n\n    return this.spawn(elements, { unique: true }).filter(selector);\n  };\n}\n\n// Misc functions\n/////////////////\n\nutil.extend(elesfn, {\n  components: function components() {\n    var self = this;\n    var cy = self.cy();\n    var visited = self.spawn();\n    var unvisited = self.nodes().spawnSelf();\n    var components = [];\n\n    var visitInComponent = function visitInComponent(node, component) {\n      visited.merge(node);\n      unvisited.unmerge(node);\n      component.merge(node);\n    };\n\n    if (unvisited.empty()) {\n      return self.spawn();\n    }\n\n    var _loop = function _loop() {\n      var component = cy.collection();\n      components.push(component);\n\n      var root = unvisited[0];\n      visitInComponent(root, component);\n\n      self.bfs({\n        directed: false,\n        roots: root,\n        visit: function visit(v, e, u, i, depth) {\n          visitInComponent(v, component);\n        }\n      });\n    };\n\n    do {\n      _loop();\n    } while (unvisited.length > 0);\n\n    return components.map(function (component) {\n      var connectedEdges = component.connectedEdges().stdFilter(function (edge) {\n        return component.anySame(edge.source()) && component.anySame(edge.target());\n      });\n\n      return component.union(connectedEdges);\n    });\n  }\n});\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Collection = __webpack_require__(7);\nvar Element = __webpack_require__(13);\n\nvar corefn = {\n  add: function add(opts) {\n\n    var elements = void 0;\n    var cy = this;\n\n    // add the elements\n    if (is.elementOrCollection(opts)) {\n      var eles = opts;\n\n      if (eles._private.cy === cy) {\n        // same instance => just restore\n        elements = eles.restore();\n      } else {\n        // otherwise, copy from json\n        var jsons = [];\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          jsons.push(ele.json());\n        }\n\n        elements = new Collection(cy, jsons);\n      }\n    }\n\n    // specify an array of options\n    else if (is.array(opts)) {\n        var _jsons = opts;\n\n        elements = new Collection(cy, _jsons);\n      }\n\n      // specify via opts.nodes and opts.edges\n      else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {\n          var elesByGroup = opts;\n          var _jsons2 = [];\n\n          var grs = ['nodes', 'edges'];\n          for (var _i = 0, il = grs.length; _i < il; _i++) {\n            var group = grs[_i];\n            var elesArray = elesByGroup[group];\n\n            if (is.array(elesArray)) {\n\n              for (var j = 0, jl = elesArray.length; j < jl; j++) {\n                var json = util.extend({ group: group }, elesArray[j]);\n\n                _jsons2.push(json);\n              }\n            }\n          }\n\n          elements = new Collection(cy, _jsons2);\n        }\n\n        // specify options for one element\n        else {\n            var _json = opts;\n            elements = new Element(cy, _json).collection();\n          }\n\n    return elements;\n  },\n\n  remove: function remove(collection) {\n    if (is.elementOrCollection(collection)) {\n      // already have right ref\n    } else if (is.string(collection)) {\n      var selector = collection;\n      collection = this.$(selector);\n    }\n\n    return collection.remove();\n  }\n};\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/* global Float32Array */\n\n/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\nfunction generateCubicBezier(mX1, mY1, mX2, mY2) {\n  var NEWTON_ITERATIONS = 4,\n      NEWTON_MIN_SLOPE = 0.001,\n      SUBDIVISION_PRECISION = 0.0000001,\n      SUBDIVISION_MAX_ITERATIONS = 10,\n      kSplineTableSize = 11,\n      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n      float32ArraySupported = typeof Float32Array !== 'undefined';\n\n  /* Must contain four arguments. */\n  if (arguments.length !== 4) {\n    return false;\n  }\n\n  /* Arguments must be numbers. */\n  for (var i = 0; i < 4; ++i) {\n    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n      return false;\n    }\n  }\n\n  /* X values must be in the [0, 1] range. */\n  mX1 = Math.min(mX1, 1);\n  mX2 = Math.min(mX2, 1);\n  mX1 = Math.max(mX1, 0);\n  mX2 = Math.max(mX2, 0);\n\n  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n\n  function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n\n  function C(aA1) {\n    return 3.0 * aA1;\n  }\n\n  function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  }\n\n  function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT) {\n    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n\n    return aGuessT;\n  }\n\n  function calcSampleValues() {\n    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function binarySubdivide(aX, aA, aB) {\n    var currentX = void 0,\n        currentT = void 0,\n        i = 0;\n\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n    return currentT;\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0,\n        currentSample = 1,\n        lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n        guessForT = intervalStart + dist * kSampleStepSize,\n        initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n    }\n  }\n\n  var _precomputed = false;\n\n  function precompute() {\n    _precomputed = true;\n    if (mX1 !== mY1 || mX2 !== mY2) {\n      calcSampleValues();\n    }\n  }\n\n  var f = function f(aX) {\n    if (!_precomputed) {\n      precompute();\n    }\n    if (mX1 === mY1 && mX2 === mY2) {\n      return aX;\n    }\n    if (aX === 0) {\n      return 0;\n    }\n    if (aX === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(aX), mY1, mY2);\n  };\n\n  f.getControlPoints = function () {\n    return [{\n      x: mX1,\n      y: mY1\n    }, {\n      x: mX2,\n      y: mY2\n    }];\n  };\n\n  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n  f.toString = function () {\n    return str;\n  };\n\n  return f;\n}\n\nmodule.exports = generateCubicBezier;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nfunction getEasedValue(type, start, end, percent, easingFn) {\n  if (percent === 1) {\n    return end;\n  }\n\n  var val = easingFn(start, end, percent);\n\n  if (type == null) {\n    return val;\n  }\n\n  if (type.roundValue || type.color) {\n    val = Math.round(val);\n  }\n\n  if (type.min !== undefined) {\n    val = Math.max(val, type.min);\n  }\n\n  if (type.max !== undefined) {\n    val = Math.min(val, type.max);\n  }\n\n  return val;\n}\n\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n  var type = propSpec != null ? propSpec.type : null;\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  var start = void 0,\n      end = void 0;\n\n  if (startProp.pfValue != null || startProp.value != null) {\n    start = startProp.pfValue != null ? startProp.pfValue : startProp.value;\n  } else {\n    start = startProp;\n  }\n\n  if (endProp.pfValue != null || endProp.value != null) {\n    end = endProp.pfValue != null ? endProp.pfValue : endProp.value;\n  } else {\n    end = endProp;\n  }\n\n  if (is.number(start) && is.number(end)) {\n    return getEasedValue(type, start, end, percent, easingFn);\n  } else if (is.array(start) && is.array(end)) {\n    var easedArr = [];\n\n    for (var i = 0; i < end.length; i++) {\n      var si = start[i];\n      var ei = end[i];\n\n      if (si != null && ei != null) {\n        var val = getEasedValue(type, si, ei, percent, easingFn);\n\n        easedArr.push(val);\n      } else {\n        easedArr.push(ei);\n      }\n    }\n\n    return easedArr;\n  }\n\n  return undefined;\n}\n\nmodule.exports = ease;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar generateCubicBezier = __webpack_require__(56);\nvar generateSpringRK4 = __webpack_require__(60);\n\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n  var bezier = generateCubicBezier(t1, p1, t2, p2);\n\n  return function (start, end, percent) {\n    return start + (end - start) * bezier(percent);\n  };\n};\n\nvar easings = {\n  'linear': function linear(start, end, percent) {\n    return start + (end - start) * percent;\n  },\n\n  // default easings\n  'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n  'ease-in': cubicBezier(0.42, 0, 1, 1),\n  'ease-out': cubicBezier(0, 0, 0.58, 1),\n  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n\n  // sine\n  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n\n  // quad\n  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n\n  // cubic\n  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n\n  // quart\n  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n\n  // quint\n  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n\n  // expo\n  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n\n  // circ\n  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n\n  // user param easings...\n\n  'spring': function spring(tension, friction, duration) {\n    if (duration === 0) {\n      // can't get a spring w/ duration 0\n      return easings.linear; // duration 0 => jump to end so impl doesn't matter\n    }\n\n    var spring = generateSpringRK4(tension, friction, duration);\n\n    return function (start, end, percent) {\n      return start + (end - start) * spring(percent);\n    };\n  },\n\n  'cubic-bezier': cubicBezier\n};\n\nmodule.exports = easings;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar define = __webpack_require__(3);\nvar util = __webpack_require__(1);\nvar stepAll = __webpack_require__(62);\n\nvar corefn = {\n\n  // pull in animation functions\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop(),\n\n  addToAnimationPool: function addToAnimationPool(eles) {\n    var cy = this;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n    cy._private.aniEles.merge(eles);\n  },\n\n  stopAnimationLoop: function stopAnimationLoop() {\n    this._private.animationsRunning = false;\n  },\n\n  startAnimationLoop: function startAnimationLoop() {\n    var cy = this;\n\n    cy._private.animationsRunning = true;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n    // NB the animation loop will exec in headless environments if style enabled\n    // and explicit cy.destroy() is necessary to stop the loop\n\n    function headlessStep() {\n      if (!cy._private.animationsRunning) {\n        return;\n      }\n\n      util.requestAnimationFrame(function animationStep(now) {\n        stepAll(now, cy);\n        headlessStep();\n      });\n    }\n\n    var renderer = cy.renderer();\n\n    if (renderer && renderer.beforeRender) {\n      // let the renderer schedule animations\n      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n        stepAll(now, cy);\n      }, renderer.beforeRenderPriorities.animations);\n    } else {\n      // manage the animation loop ourselves\n      headlessStep(); // first call\n    }\n  }\n\n};\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\nvar generateSpringRK4 = function () {\n  function springAccelerationForState(state) {\n    return -state.tension * state.x - state.friction * state.v;\n  }\n\n  function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n    var state = {\n      x: initialState.x + derivative.dx * dt,\n      v: initialState.v + derivative.dv * dt,\n      tension: initialState.tension,\n      friction: initialState.friction\n    };\n\n    return { dx: state.v, dv: springAccelerationForState(state) };\n  }\n\n  function springIntegrateState(state, dt) {\n    var a = {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    },\n        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n        d = springEvaluateStateWithDerivative(state, dt, c),\n        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n\n    state.x = state.x + dxdt * dt;\n    state.v = state.v + dvdt * dt;\n\n    return state;\n  }\n\n  return function springRK4Factory(tension, friction, duration) {\n\n    var initState = {\n      x: -1,\n      v: 0,\n      tension: null,\n      friction: null\n    },\n        path = [0],\n        time_lapsed = 0,\n        tolerance = 1 / 10000,\n        DT = 16 / 1000,\n        have_duration = void 0,\n        dt = void 0,\n        last_state = void 0;\n\n    tension = parseFloat(tension) || 500;\n    friction = parseFloat(friction) || 20;\n    duration = duration || null;\n\n    initState.tension = tension;\n    initState.friction = friction;\n\n    have_duration = duration !== null;\n\n    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n    if (have_duration) {\n      /* Run the simulation without a duration. */\n      time_lapsed = springRK4Factory(tension, friction);\n      /* Compute the adjusted time delta. */\n      dt = time_lapsed / duration * DT;\n    } else {\n      dt = DT;\n    }\n\n    for (;;) {\n      /* Next/step function .*/\n      last_state = springIntegrateState(last_state || initState, dt);\n      /* Store the position. */\n      path.push(1 + last_state.x);\n      time_lapsed += 16;\n      /* If the change threshold is reached, break. */\n      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n        break;\n      }\n    }\n\n    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */\n    return !have_duration ? time_lapsed : function (percentComplete) {\n      return path[percentComplete * (path.length - 1) | 0];\n    };\n  };\n}();\n\nmodule.exports = generateSpringRK4;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction startAnimation(self, ani, now, isCore) {\n  var isEles = !isCore;\n  var ele = self;\n  var ani_p = ani._private;\n  var cy = isCore ? self : self.cy();\n  var style = cy.style();\n\n  if (isEles) {\n    var pos = ele.position();\n\n    ani_p.startPosition = ani_p.startPosition || {\n      x: pos.x,\n      y: pos.y\n    };\n\n    ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);\n  }\n\n  if (isCore) {\n    var pan = cy._private.pan;\n\n    ani_p.startPan = ani_p.startPan || {\n      x: pan.x,\n      y: pan.y\n    };\n\n    ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;\n  }\n\n  ani_p.started = true;\n  ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\n\nmodule.exports = startAnimation;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar step = __webpack_require__(63);\nvar startAnimation = __webpack_require__(61);\n\nfunction stepAll(now, cy) {\n  var eles = cy._private.aniEles;\n  var doneEles = [];\n\n  function stepOne(ele, isCore) {\n    var _p = ele._private;\n    var current = _p.animation.current;\n    var queue = _p.animation.queue;\n    var ranAnis = false;\n\n    // cancel all animations on display:none ele\n    if (!isCore && ele.pstyle('display').value === 'none') {\n      // put all current and queue animations in this tick's current list\n      // and empty the lists for the element\n      current = current.splice(0, current.length).concat(queue.splice(0, queue.length));\n\n      // stop all animations\n      for (var i = 0; i < current.length; i++) {\n        current[i].stop();\n      }\n    }\n\n    // if nothing currently animating, get something from the queue\n    if (current.length === 0) {\n      var next = queue.shift();\n\n      if (next) {\n        current.push(next);\n      }\n    }\n\n    var callbacks = function callbacks(_callbacks) {\n      for (var j = _callbacks.length - 1; j >= 0; j--) {\n        var cb = _callbacks[j];\n\n        cb();\n      }\n\n      _callbacks.splice(0, _callbacks.length);\n    };\n\n    // step and remove if done\n    for (var _i = current.length - 1; _i >= 0; _i--) {\n      var ani = current[_i];\n      var ani_p = ani._private;\n\n      if (ani_p.stopped) {\n        current.splice(_i, 1);\n\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n\n        callbacks(ani_p.frames);\n\n        continue;\n      }\n\n      if (!ani_p.playing && !ani_p.applying) {\n        continue;\n      }\n\n      // an apply() while playing shouldn't do anything\n      if (ani_p.playing && ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      if (!ani_p.started) {\n        startAnimation(ele, ani, now, isCore);\n      }\n\n      step(ele, ani, now, isCore);\n\n      if (ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      callbacks(ani_p.frames);\n\n      if (ani.completed()) {\n        current.splice(_i, 1);\n\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n\n        callbacks(ani_p.completes);\n      }\n\n      ranAnis = true;\n    }\n\n    if (!isCore && current.length === 0 && queue.length === 0) {\n      doneEles.push(ele);\n    }\n\n    return ranAnis;\n  } // stepElement\n\n  // handle all eles\n  var ranEleAni = false;\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n    var handledThisEle = stepOne(ele);\n\n    ranEleAni = ranEleAni || handledThisEle;\n  } // each element\n\n  var ranCoreAni = stepOne(cy, true);\n\n  // notify renderer\n  if (ranEleAni || ranCoreAni) {\n    if (eles.length > 0) {\n      eles.dirtyCompoundBoundsCache();\n\n      cy.notify({\n        type: 'draw',\n        eles: eles\n      });\n    } else {\n      cy.notify({\n        type: 'draw'\n      });\n    }\n  }\n\n  // remove elements from list of currently animating if its queues are empty\n  eles.unmerge(doneEles);\n\n  cy.emit('step');\n} // stepAll\n\nmodule.exports = stepAll;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar easings = __webpack_require__(58);\nvar ease = __webpack_require__(57);\nvar is = __webpack_require__(0);\n\nfunction step(self, ani, now, isCore) {\n  var isEles = !isCore;\n  var _p = self._private;\n  var ani_p = ani._private;\n  var pEasing = ani_p.easing;\n  var startTime = ani_p.startTime;\n  var cy = isCore ? self : self.cy();\n  var style = cy.style();\n\n  if (!ani_p.easingImpl) {\n\n    if (pEasing == null) {\n      // use default\n      ani_p.easingImpl = easings['linear'];\n    } else {\n      // then define w/ name\n      var easingVals = void 0;\n\n      if (is.string(pEasing)) {\n        var easingProp = style.parse('transition-timing-function', pEasing);\n\n        easingVals = easingProp.value;\n      } else {\n        // then assume preparsed array\n        easingVals = pEasing;\n      }\n\n      var name = void 0,\n          args = void 0;\n\n      if (is.string(easingVals)) {\n        name = easingVals;\n        args = [];\n      } else {\n        name = easingVals[1];\n        args = easingVals.slice(2).map(function (n) {\n          return +n;\n        });\n      }\n\n      if (args.length > 0) {\n        // create with args\n        if (name === 'spring') {\n          args.push(ani_p.duration); // need duration to generate spring\n        }\n\n        ani_p.easingImpl = easings[name].apply(null, args);\n      } else {\n        // static impl by name\n        ani_p.easingImpl = easings[name];\n      }\n    }\n  }\n\n  var easing = ani_p.easingImpl;\n  var percent = void 0;\n\n  if (ani_p.duration === 0) {\n    percent = 1;\n  } else {\n    percent = (now - startTime) / ani_p.duration;\n  }\n\n  if (ani_p.applying) {\n    percent = ani_p.progress;\n  }\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  if (ani_p.delay == null) {\n    // then update\n\n    var startPos = ani_p.startPosition;\n    var endPos = ani_p.position;\n\n    if (endPos && isEles && !self.locked()) {\n      var pos = self.position();\n\n      if (valid(startPos.x, endPos.x)) {\n        pos.x = ease(startPos.x, endPos.x, percent, easing);\n      }\n\n      if (valid(startPos.y, endPos.y)) {\n        pos.y = ease(startPos.y, endPos.y, percent, easing);\n      }\n\n      self.emit('position');\n    }\n\n    var startPan = ani_p.startPan;\n    var endPan = ani_p.pan;\n    var pan = _p.pan;\n    var animatingPan = endPan != null && isCore;\n    if (animatingPan) {\n      if (valid(startPan.x, endPan.x)) {\n        pan.x = ease(startPan.x, endPan.x, percent, easing);\n      }\n\n      if (valid(startPan.y, endPan.y)) {\n        pan.y = ease(startPan.y, endPan.y, percent, easing);\n      }\n\n      self.emit('pan');\n    }\n\n    var startZoom = ani_p.startZoom;\n    var endZoom = ani_p.zoom;\n    var animatingZoom = endZoom != null && isCore;\n    if (animatingZoom) {\n      if (valid(startZoom, endZoom)) {\n        _p.zoom = ease(startZoom, endZoom, percent, easing);\n      }\n\n      self.emit('zoom');\n    }\n\n    if (animatingPan || animatingZoom) {\n      self.emit('viewport');\n    }\n\n    var props = ani_p.style;\n    if (props && props.length > 0 && isEles) {\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var _name = prop.name;\n        var end = prop;\n        var start = ani_p.startStyle[_name];\n        var propSpec = style.properties[start.name];\n        var easedVal = ease(start, end, percent, easing, propSpec);\n\n        style.overrideBypass(self, _name, easedVal);\n      } // for props\n\n      self.emit('style');\n    } // if\n  }\n\n  ani_p.progress = percent;\n\n  return percent;\n}\n\nfunction valid(start, end) {\n  if (start == null || end == null) {\n    return false;\n  }\n\n  if (is.number(start) && is.number(end)) {\n    return true;\n  } else if (start && end) {\n    return true;\n  }\n\n  return false;\n}\n\nmodule.exports = step;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Emitter = __webpack_require__(10);\nvar define = __webpack_require__(3);\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar Selector = __webpack_require__(6);\n\nvar emitterOptions = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(cy, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  eventFields: function eventFields(cy) {\n    return {\n      cy: cy,\n      target: cy\n    };\n  },\n  callbackContext: function callbackContext(cy, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : cy;\n  }\n};\n\nvar argSelector = function argSelector(arg) {\n  if (is.string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn = {\n  createEmitter: function createEmitter() {\n    var _p = this._private;\n\n    if (!_p.emitter) {\n      _p.emitter = new Emitter(util.assign({\n        context: this\n      }, emitterOptions));\n    }\n\n    return this;\n  },\n\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n\n  on: function on(events, selector, callback) {\n    this.emitter().on(events, argSelector(selector), callback);\n\n    return this;\n  },\n\n  removeListener: function removeListener(events, selector, callback) {\n    this.emitter().removeListener(events, argSelector(selector), callback);\n\n    return this;\n  },\n\n  one: function one(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n\n    return this;\n  },\n\n  once: function once(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n\n    return this;\n  },\n\n  emit: function emit(events, extraParams) {\n    this.emitter().emit(events, extraParams);\n\n    return this;\n  }\n};\n\ndefine.eventAliasesOn(elesfn);\n\nmodule.exports = elesfn;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar corefn = {\n\n  png: function png(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n\n    return renderer.png(options);\n  },\n\n  jpg: function jpg(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n\n    options.bg = options.bg || '#fff';\n\n    return renderer.jpg(options);\n  }\n\n};\n\ncorefn.jpeg = corefn.jpg;\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar corefn = {\n\n  layout: function layout(options) {\n    var cy = this;\n\n    if (options == null) {\n      util.error('Layout options must be specified to make a layout');\n      return;\n    }\n\n    if (options.name == null) {\n      util.error('A `name` must be specified to make a layout');\n      return;\n    }\n\n    var name = options.name;\n    var Layout = cy.extension('layout', name);\n\n    if (Layout == null) {\n      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');\n      return;\n    }\n\n    var eles = void 0;\n    if (is.string(options.eles)) {\n      eles = cy.$(options.eles);\n    } else {\n      eles = options.eles != null ? options.eles : cy.$();\n    }\n\n    var layout = new Layout(util.extend({}, options, {\n      cy: cy,\n      eles: eles\n    }));\n\n    return layout;\n  }\n\n};\n\ncorefn.createLayout = corefn.makeLayout = corefn.layout;\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar corefn = {\n  notify: function notify(params) {\n    var _p = this._private;\n\n    if (_p.batchingNotify) {\n      var bEles = _p.batchNotifyEles;\n      var bTypes = _p.batchNotifyTypes;\n\n      if (params.eles) {\n        bEles.merge(params.eles);\n      }\n\n      if (!bTypes.ids[params.type]) {\n        bTypes.push(params.type);\n        bTypes.ids[params.type] = true;\n      }\n\n      return; // notifications are disabled during batching\n    }\n\n    if (!_p.notificationsEnabled) {\n      return;\n    } // exit on disabled\n\n    var renderer = this.renderer();\n\n    // exit if destroy() called on core or renderer in between frames #1499 #1528\n    if (this.isDestroyed() || !renderer) {\n      return;\n    }\n\n    renderer.notify(params);\n  },\n\n  notifications: function notifications(bool) {\n    var p = this._private;\n\n    if (bool === undefined) {\n      return p.notificationsEnabled;\n    } else {\n      p.notificationsEnabled = bool ? true : false;\n    }\n  },\n\n  noNotifications: function noNotifications(callback) {\n    this.notifications(false);\n    callback();\n    this.notifications(true);\n  },\n\n  batching: function batching() {\n    return this._private.batchCount > 0;\n  },\n\n  startBatch: function startBatch() {\n    var _p = this._private;\n\n    if (_p.batchCount == null) {\n      _p.batchCount = 0;\n    }\n\n    if (_p.batchCount === 0) {\n      _p.batchingStyle = _p.batchingNotify = true;\n      _p.batchStyleEles = this.collection();\n      _p.batchNotifyEles = this.collection();\n      _p.batchNotifyTypes = [];\n      _p.batchNotifyTypes.ids = {};\n    }\n\n    _p.batchCount++;\n\n    return this;\n  },\n\n  endBatch: function endBatch() {\n    var _p = this._private;\n\n    _p.batchCount--;\n\n    if (_p.batchCount === 0) {\n      // update style for dirty eles\n      _p.batchingStyle = false;\n      _p.batchStyleEles.updateStyle();\n\n      // notify the renderer of queued eles and event types\n      _p.batchingNotify = false;\n      this.notify({\n        type: _p.batchNotifyTypes,\n        eles: _p.batchNotifyEles\n      });\n    }\n\n    return this;\n  },\n\n  batch: function batch(callback) {\n    this.startBatch();\n    callback();\n    this.endBatch();\n\n    return this;\n  },\n\n  // for backwards compatibility\n  batchData: function batchData(map) {\n    var cy = this;\n\n    return this.batch(function () {\n      var ids = Object.keys(map);\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = map[id];\n        var ele = cy.getElementById(id);\n\n        ele.data(data);\n      }\n    });\n  }\n};\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar corefn = {\n\n  renderTo: function renderTo(context, zoom, pan, pxRatio) {\n    var r = this._private.renderer;\n\n    r.renderTo(context, zoom, pan, pxRatio);\n    return this;\n  },\n\n  renderer: function renderer() {\n    return this._private.renderer;\n  },\n\n  forceRender: function forceRender() {\n    this.notify({\n      type: 'draw'\n    });\n\n    return this;\n  },\n\n  resize: function resize() {\n    this.invalidateSize();\n\n    this.notify({\n      type: 'resize'\n    });\n\n    this.emit('resize');\n\n    return this;\n  },\n\n  initRenderer: function initRenderer(options) {\n    var cy = this;\n\n    var RendererProto = cy.extension('renderer', options.name);\n    if (RendererProto == null) {\n      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);\n      return;\n    }\n\n    cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));\n\n    this.notify({ type: 'init' });\n  },\n\n  destroyRenderer: function destroyRenderer() {\n    var cy = this;\n\n    cy.notify({ type: 'destroy' }); // destroy the renderer\n\n    var domEle = cy.container();\n    if (domEle) {\n      domEle._cyreg = null;\n\n      while (domEle.childNodes.length > 0) {\n        domEle.removeChild(domEle.childNodes[0]);\n      }\n    }\n\n    cy._private.renderer = null; // to be extra safe, remove the ref\n  },\n\n  onRender: function onRender(fn) {\n    return this.on('render', fn);\n  },\n\n  offRender: function offRender(fn) {\n    return this.off('render', fn);\n  }\n\n};\n\ncorefn.invalidateDimensions = corefn.resize;\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Collection = __webpack_require__(7);\n\nvar corefn = {\n\n  // get a collection\n  // - empty collection on no args\n  // - collection of elements in the graph on selector arg\n  // - guarantee a returned collection when elements or collection specified\n  collection: function collection(eles, opts) {\n\n    if (is.string(eles)) {\n      return this.$(eles);\n    } else if (is.elementOrCollection(eles)) {\n      return eles.collection();\n    } else if (is.array(eles)) {\n      return new Collection(this, eles, opts);\n    }\n\n    return new Collection(this);\n  },\n\n  nodes: function nodes(selector) {\n    var nodes = this.$(function (ele) {\n      return ele.isNode();\n    });\n\n    if (selector) {\n      return nodes.filter(selector);\n    }\n\n    return nodes;\n  },\n\n  edges: function edges(selector) {\n    var edges = this.$(function (ele) {\n      return ele.isEdge();\n    });\n\n    if (selector) {\n      return edges.filter(selector);\n    }\n\n    return edges;\n  },\n\n  // search the graph like jQuery\n  $: function $(selector) {\n    var eles = this._private.elements;\n\n    if (selector) {\n      return eles.filter(selector);\n    } else {\n      return eles.spawnSelf();\n    }\n  },\n\n  mutableElements: function mutableElements() {\n    return this._private.elements;\n  }\n\n};\n\n// aliases\ncorefn.elements = corefn.filter = corefn.$;\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Style = __webpack_require__(18);\n\nvar corefn = {\n\n  style: function style(newStyle) {\n    if (newStyle) {\n      var s = this.setStyle(newStyle);\n\n      s.update();\n    }\n\n    return this._private.style;\n  },\n\n  setStyle: function setStyle(style) {\n    var _p = this._private;\n\n    if (is.stylesheet(style)) {\n      _p.style = style.generateStyle(this);\n    } else if (is.array(style)) {\n      _p.style = Style.fromJson(this, style);\n    } else if (is.string(style)) {\n      _p.style = Style.fromString(this, style);\n    } else {\n      _p.style = Style(this);\n    }\n\n    return _p.style;\n  }\n};\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar window = __webpack_require__(4);\nvar math = __webpack_require__(2);\n\nvar corefn = {\n\n  autolock: function autolock(bool) {\n    if (bool !== undefined) {\n      this._private.autolock = bool ? true : false;\n    } else {\n      return this._private.autolock;\n    }\n\n    return this; // chaining\n  },\n\n  autoungrabify: function autoungrabify(bool) {\n    if (bool !== undefined) {\n      this._private.autoungrabify = bool ? true : false;\n    } else {\n      return this._private.autoungrabify;\n    }\n\n    return this; // chaining\n  },\n\n  autounselectify: function autounselectify(bool) {\n    if (bool !== undefined) {\n      this._private.autounselectify = bool ? true : false;\n    } else {\n      return this._private.autounselectify;\n    }\n\n    return this; // chaining\n  },\n\n  panningEnabled: function panningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.panningEnabled = bool ? true : false;\n    } else {\n      return this._private.panningEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  userPanningEnabled: function userPanningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userPanningEnabled = bool ? true : false;\n    } else {\n      return this._private.userPanningEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  zoomingEnabled: function zoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.zoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.zoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  userZoomingEnabled: function userZoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userZoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.userZoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  boxSelectionEnabled: function boxSelectionEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.boxSelectionEnabled = bool ? true : false;\n    } else {\n      return this._private.boxSelectionEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  pan: function pan() {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim = void 0,\n        val = void 0,\n        dims = void 0,\n        x = void 0,\n        y = void 0;\n\n    switch (args.length) {\n      case 0:\n        // .pan()\n        return pan;\n\n      case 1:\n\n        if (is.string(args[0])) {\n          // .pan('x')\n          dim = args[0];\n          return pan[dim];\n        } else if (is.plainObject(args[0])) {\n          // .pan({ x: 0, y: 100 })\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (is.number(x)) {\n            pan.x = x;\n          }\n\n          if (is.number(y)) {\n            pan.y = y;\n          }\n\n          this.emit('pan viewport');\n        }\n        break;\n\n      case 2:\n        // .pan('x', 100)\n        if (!this._private.panningEnabled) {\n          return this;\n        }\n\n        dim = args[0];\n        val = args[1];\n\n        if ((dim === 'x' || dim === 'y') && is.number(val)) {\n          pan[dim] = val;\n        }\n\n        this.emit('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n    }\n\n    this.notify({ // notify the renderer that the viewport changed\n      type: 'viewport'\n    });\n\n    return this; // chaining\n  },\n\n  panBy: function panBy(arg0, arg1) {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim = void 0,\n        val = void 0,\n        dims = void 0,\n        x = void 0,\n        y = void 0;\n\n    if (!this._private.panningEnabled) {\n      return this;\n    }\n\n    switch (args.length) {\n      case 1:\n\n        if (is.plainObject(arg0)) {\n          // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (is.number(x)) {\n            pan.x += x;\n          }\n\n          if (is.number(y)) {\n            pan.y += y;\n          }\n\n          this.emit('pan viewport');\n        }\n        break;\n\n      case 2:\n        // .panBy('x', 100)\n        dim = arg0;\n        val = arg1;\n\n        if ((dim === 'x' || dim === 'y') && is.number(val)) {\n          pan[dim] += val;\n        }\n\n        this.emit('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n    }\n\n    this.notify({ // notify the renderer that the viewport changed\n      type: 'viewport'\n    });\n\n    return this; // chaining\n  },\n\n  fit: function fit(elements, padding) {\n    var viewportState = this.getFitViewport(elements, padding);\n\n    if (viewportState) {\n      var _p = this._private;\n      _p.zoom = viewportState.zoom;\n      _p.pan = viewportState.pan;\n\n      this.emit('pan zoom viewport');\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n    }\n\n    return this; // chaining\n  },\n\n  getFitViewport: function getFitViewport(elements, padding) {\n    if (is.number(elements) && padding === undefined) {\n      // elements is optional\n      padding = elements;\n      elements = undefined;\n    }\n\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return;\n    }\n\n    var bb = void 0;\n\n    if (is.string(elements)) {\n      var sel = elements;\n      elements = this.$(sel);\n    } else if (is.boundingBox(elements)) {\n      // assume bb\n      var bbe = elements;\n      bb = {\n        x1: bbe.x1,\n        y1: bbe.y1,\n        x2: bbe.x2,\n        y2: bbe.y2\n      };\n\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    } else if (!is.elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (is.elementOrCollection(elements) && elements.empty()) {\n      return;\n    } // can't fit to nothing\n\n    bb = bb || elements.boundingBox();\n\n    var w = this.width();\n    var h = this.height();\n    var zoom = void 0;\n    padding = is.number(padding) ? padding : 0;\n\n    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n\n      // crop zoom\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n      var pan = { // now pan to middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n\n      return {\n        zoom: zoom,\n        pan: pan\n      };\n    }\n\n    return;\n  },\n\n  minZoom: function minZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.minZoom;\n    } else if (is.number(zoom)) {\n      this._private.minZoom = zoom;\n    }\n\n    return this;\n  },\n\n  maxZoom: function maxZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.maxZoom;\n    } else if (is.number(zoom)) {\n      this._private.maxZoom = zoom;\n    }\n\n    return this;\n  },\n\n  getZoomedViewport: function getZoomedViewport(params) {\n    var _p = this._private;\n    var currentPan = _p.pan;\n    var currentZoom = _p.zoom;\n    var pos = void 0; // in rendered px\n    var zoom = void 0;\n    var bail = false;\n\n    if (!_p.zoomingEnabled) {\n      // zooming disabled\n      bail = true;\n    }\n\n    if (is.number(params)) {\n      // then set the zoom\n      zoom = params;\n    } else if (is.plainObject(params)) {\n      // then zoom about a point\n      zoom = params.level;\n\n      if (params.position != null) {\n        pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);\n      } else if (params.renderedPosition != null) {\n        pos = params.renderedPosition;\n      }\n\n      if (pos != null && !_p.panningEnabled) {\n        // panning disabled\n        bail = true;\n      }\n    }\n\n    // crop zoom\n    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n    zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n\n    // can't zoom with invalid params\n    if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {\n      return null;\n    }\n\n    if (pos != null) {\n      // set zoom about position\n      var pan1 = currentPan;\n      var zoom1 = currentZoom;\n      var zoom2 = zoom;\n\n      var pan2 = {\n        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n      };\n\n      return {\n        zoomed: true,\n        panned: true,\n        zoom: zoom2,\n        pan: pan2\n      };\n    } else {\n      // just set the zoom\n      return {\n        zoomed: true,\n        panned: false,\n        zoom: zoom,\n        pan: currentPan\n      };\n    }\n  },\n\n  zoom: function zoom(params) {\n    if (params === undefined) {\n      // get\n      return this._private.zoom;\n    } else {\n      // set\n      var vp = this.getZoomedViewport(params);\n      var _p = this._private;\n\n      if (vp == null || !vp.zoomed) {\n        return this;\n      }\n\n      _p.zoom = vp.zoom;\n\n      if (vp.panned) {\n        _p.pan.x = vp.pan.x;\n        _p.pan.y = vp.pan.y;\n      }\n\n      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    }\n  },\n\n  viewport: function viewport(opts) {\n    var _p = this._private;\n    var zoomDefd = true;\n    var panDefd = true;\n    var events = []; // to trigger\n    var zoomFailed = false;\n    var panFailed = false;\n\n    if (!opts) {\n      return this;\n    }\n    if (!is.number(opts.zoom)) {\n      zoomDefd = false;\n    }\n    if (!is.plainObject(opts.pan)) {\n      panDefd = false;\n    }\n    if (!zoomDefd && !panDefd) {\n      return this;\n    }\n\n    if (zoomDefd) {\n      var z = opts.zoom;\n\n      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n        zoomFailed = true;\n      } else {\n        _p.zoom = z;\n\n        events.push('zoom');\n      }\n    }\n\n    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n      var p = opts.pan;\n\n      if (is.number(p.x)) {\n        _p.pan.x = p.x;\n        panFailed = false;\n      }\n\n      if (is.number(p.y)) {\n        _p.pan.y = p.y;\n        panFailed = false;\n      }\n\n      if (!panFailed) {\n        events.push('pan');\n      }\n    }\n\n    if (events.length > 0) {\n      events.push('viewport');\n      this.emit(events.join(' '));\n\n      this.notify({\n        type: 'viewport'\n      });\n    }\n\n    return this; // chaining\n  },\n\n  center: function center(elements) {\n    var pan = this.getCenterPan(elements);\n\n    if (pan) {\n      this._private.pan = pan;\n\n      this.emit('pan viewport');\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n    }\n\n    return this; // chaining\n  },\n\n  getCenterPan: function getCenterPan(elements, zoom) {\n    if (!this._private.panningEnabled) {\n      return;\n    }\n\n    if (is.string(elements)) {\n      var selector = elements;\n      elements = this.mutableElements().filter(selector);\n    } else if (!is.elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (elements.length === 0) {\n      return;\n    } // can't centre pan to nothing\n\n    var bb = elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    zoom = zoom === undefined ? this._private.zoom : zoom;\n\n    var pan = { // middle\n      x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n      y: (h - zoom * (bb.y1 + bb.y2)) / 2\n    };\n\n    return pan;\n  },\n\n  reset: function reset() {\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return this;\n    }\n\n    this.viewport({\n      pan: { x: 0, y: 0 },\n      zoom: 1\n    });\n\n    return this; // chaining\n  },\n\n  invalidateSize: function invalidateSize() {\n    this._private.sizeCache = null;\n  },\n\n  size: function size() {\n    var _p = this._private;\n    var container = _p.container;\n\n    return _p.sizeCache = _p.sizeCache || (container ? function () {\n      var style = window.getComputedStyle(container);\n      var val = function val(name) {\n        return parseFloat(style.getPropertyValue(name));\n      };\n\n      return {\n        width: container.clientWidth - val('padding-left') - val('padding-right'),\n        height: container.clientHeight - val('padding-top') - val('padding-bottom')\n      };\n    }() : { // fallback if no container (not 0 b/c can be used for dividing etc)\n      width: 1,\n      height: 1\n    });\n  },\n\n  width: function width() {\n    return this.size().width;\n  },\n\n  height: function height() {\n    return this.size().height;\n  },\n\n  extent: function extent() {\n    var pan = this._private.pan;\n    var zoom = this._private.zoom;\n    var rb = this.renderedExtent();\n\n    var b = {\n      x1: (rb.x1 - pan.x) / zoom,\n      x2: (rb.x2 - pan.x) / zoom,\n      y1: (rb.y1 - pan.y) / zoom,\n      y2: (rb.y2 - pan.y) / zoom\n    };\n\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n\n    return b;\n  },\n\n  renderedExtent: function renderedExtent() {\n    var width = this.width();\n    var height = this.height();\n\n    return {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n      w: width,\n      h: height\n    };\n  }\n};\n\n// aliases\ncorefn.centre = corefn.center;\n\n// backwards compatibility\ncorefn.autolockNodes = corefn.autolock;\ncorefn.autoungrabifyNodes = corefn.autoungrabify;\n\nmodule.exports = corefn;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar Animation = __webpack_require__(23);\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\n\nvar define = {\n\n  animated: function animated() {\n    return function animatedImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = all[0];\n\n      if (ele) {\n        return ele._private.animation.current.length > 0;\n      }\n    };\n  }, // animated\n\n  clearQueue: function clearQueue() {\n    return function clearQueueImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        ele._private.animation.queue = [];\n      }\n\n      return this;\n    };\n  }, // clearQueue\n\n  delay: function delay() {\n    return function delayImpl(time, complete) {\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      return this.animate({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  }, // delay\n\n  delayAnimation: function delayAnimation() {\n    return function delayAnimationImpl(time, complete) {\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      return this.animation({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  }, // delay\n\n  animation: function animation() {\n    return function animationImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      var isCore = !selfIsArrayLike;\n      var isEles = !isCore;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var style = cy.style();\n\n      properties = util.assign({}, properties, params);\n\n      var propertiesEmpty = Object.keys(properties).length === 0;\n\n      if (propertiesEmpty) {\n        return new Animation(all[0], properties); // nothing to animate\n      }\n\n      if (properties.duration === undefined) {\n        properties.duration = 400;\n      }\n\n      switch (properties.duration) {\n        case 'slow':\n          properties.duration = 600;\n          break;\n        case 'fast':\n          properties.duration = 200;\n          break;\n      }\n\n      if (isEles) {\n        properties.style = style.getPropsList(properties.style || properties.css);\n\n        properties.css = undefined;\n      }\n\n      if (isEles && properties.renderedPosition != null) {\n        var rpos = properties.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n\n        properties.position = math.renderedToModelPosition(rpos, zoom, pan);\n      }\n\n      // override pan w/ panBy if set\n      if (isCore && properties.panBy != null) {\n        var panBy = properties.panBy;\n        var cyPan = cy.pan();\n\n        properties.pan = {\n          x: cyPan.x + panBy.x,\n          y: cyPan.y + panBy.y\n        };\n      }\n\n      // override pan w/ center if set\n      var center = properties.center || properties.centre;\n      if (isCore && center != null) {\n        var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n\n        if (centerPan != null) {\n          properties.pan = centerPan;\n        }\n      }\n\n      // override pan & zoom w/ fit if set\n      if (isCore && properties.fit != null) {\n        var fit = properties.fit;\n        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n\n        if (fitVp != null) {\n          properties.pan = fitVp.pan;\n          properties.zoom = fitVp.zoom;\n        }\n      }\n\n      // override zoom (& potentially pan) w/ zoom obj if set\n      if (isCore && is.plainObject(properties.zoom)) {\n        var vp = cy.getZoomedViewport(properties.zoom);\n\n        if (vp != null) {\n          if (vp.zoomed) {\n            properties.zoom = vp.zoom;\n          }\n\n          if (vp.panned) {\n            properties.pan = vp.pan;\n          }\n        }\n      }\n\n      return new Animation(all[0], properties);\n    };\n  }, // animate\n\n  animate: function animate() {\n    return function animateImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      if (params) {\n        properties = util.extend({}, properties, params);\n      }\n\n      // manually hook and run the animation\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n\n        var ani = ele.animation(properties, queue ? { queue: true } : undefined);\n\n        ani.play();\n      }\n\n      return this; // chaining\n    };\n  }, // animate\n\n  stop: function stop() {\n    return function stopImpl(clearQueue, jumpToEnd) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var _p = ele._private;\n        var anis = _p.animation.current;\n\n        for (var j = 0; j < anis.length; j++) {\n          var ani = anis[j];\n          var ani_p = ani._private;\n\n          if (jumpToEnd) {\n            // next iteration of the animation loop, the animation\n            // will go straight to the end and be removed\n            ani_p.duration = 0;\n          }\n        }\n\n        // clear the queue of future animations\n        if (clearQueue) {\n          _p.animation.queue = [];\n        }\n\n        if (!jumpToEnd) {\n          _p.animation.current = [];\n        }\n      }\n\n      // we have to notify (the animation loop doesn't do it for us on `stop`)\n      cy.notify({\n        eles: this,\n        type: 'draw'\n      });\n\n      return this;\n    };\n  } // stop\n\n}; // define\n\nmodule.exports = define;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar define = {\n\n  // access data field\n  data: function data(params) {\n    var defaults = {\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: false,\n      allowSetting: false,\n      allowGetting: false,\n      settingEvent: 'data',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      immutableKeys: {}, // key => true if immutable\n      updateStyle: false,\n      beforeGet: function beforeGet(self) {},\n      beforeSet: function beforeSet(self, obj) {},\n      onSet: function onSet(self) {},\n      canSet: function canSet(self) {\n        return true;\n      }\n    };\n    params = util.extend({}, defaults, params);\n\n    return function dataImpl(name, value) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      var single = selfIsArrayLike ? self[0] : self;\n\n      // .data('foo', ...)\n      if (is.string(name)) {\n        // set or get property\n\n        // .data('foo')\n        if (p.allowGetting && value === undefined) {\n          // get\n\n          var ret = void 0;\n          if (single) {\n            p.beforeGet(single);\n\n            ret = single._private[p.field][name];\n          }\n          return ret;\n\n          // .data('foo', 'bar')\n        } else if (p.allowSetting && value !== undefined) {\n          // set\n          var valid = !p.immutableKeys[name];\n          if (valid) {\n            var change = _defineProperty({}, name, value);\n\n            p.beforeSet(self, change);\n\n            for (var i = 0, l = all.length; i < l; i++) {\n              var ele = all[i];\n\n              if (p.canSet(ele)) {\n                ele._private[p.field][name] = value;\n              }\n            }\n\n            // update mappers if asked\n            if (p.updateStyle) {\n              self.updateStyle();\n            }\n\n            // call onSet callback\n            p.onSet(self);\n\n            if (p.settingTriggersEvent) {\n              self[p.triggerFnName](p.settingEvent);\n            }\n          }\n        }\n\n        // .data({ 'foo': 'bar' })\n      } else if (p.allowSetting && is.plainObject(name)) {\n        // extend\n        var obj = name;\n        var k = void 0,\n            v = void 0;\n        var keys = Object.keys(obj);\n\n        p.beforeSet(self, obj);\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          k = keys[_i];\n          v = obj[k];\n\n          var _valid = !p.immutableKeys[k];\n          if (_valid) {\n            for (var j = 0; j < all.length; j++) {\n              var _ele = all[j];\n\n              if (p.canSet(_ele)) {\n                _ele._private[p.field][k] = v;\n              }\n            }\n          }\n        }\n\n        // update mappers if asked\n        if (p.updateStyle) {\n          self.updateStyle();\n        }\n\n        // call onSet callback\n        p.onSet(self);\n\n        if (p.settingTriggersEvent) {\n          self[p.triggerFnName](p.settingEvent);\n        }\n\n        // .data(function(){ ... })\n      } else if (p.allowBinding && is.fn(name)) {\n        // bind to event\n        var fn = name;\n        self.on(p.bindingEvent, fn);\n\n        // .data()\n      } else if (p.allowGetting && name === undefined) {\n        // get whole object\n        var _ret = void 0;\n        if (single) {\n          p.beforeGet(single);\n\n          _ret = single._private[p.field];\n        }\n        return _ret;\n      }\n\n      return self; // maintain chainability\n    }; // function\n  }, // data\n\n  // remove data field\n  removeData: function removeData(params) {\n    var defaults = {\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: false,\n      immutableKeys: {} // key => true if immutable\n    };\n    params = util.extend({}, defaults, params);\n\n    return function removeDataImpl(names) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      // .removeData('foo bar')\n      if (is.string(names)) {\n        // then get the list of keys, and delete them\n        var keys = names.split(/\\s+/);\n        var l = keys.length;\n\n        for (var i = 0; i < l; i++) {\n          // delete each non-empty key\n          var key = keys[i];\n          if (is.emptyString(key)) {\n            continue;\n          }\n\n          var valid = !p.immutableKeys[key]; // not valid if immutable\n          if (valid) {\n            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n              all[i_a]._private[p.field][key] = undefined;\n            }\n          }\n        }\n\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        }\n\n        // .removeData()\n      } else if (names === undefined) {\n        // then delete all keys\n\n        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n          var _privateFields = all[_i_a]._private[p.field];\n          var _keys = Object.keys(_privateFields);\n\n          for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n            var _key = _keys[_i2];\n            var validKeyToDelete = !p.immutableKeys[_key];\n\n            if (validKeyToDelete) {\n              _privateFields[_key] = undefined;\n            }\n          }\n        }\n\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        }\n      }\n\n      return self; // maintain chaining\n    }; // function\n  } // removeData\n}; // define\n\nmodule.exports = define;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(5);\n\nvar define = {\n\n  eventAliasesOn: function eventAliasesOn(proto) {\n    var p = proto;\n\n    p.addListener = p.listen = p.bind = p.on;\n    p.unlisten = p.unbind = p.off = p.removeListener;\n    p.trigger = p.emit;\n\n    // this is just a wrapper alias of .on()\n    p.pon = p.promiseOn = function (events, selector) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 0);\n\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(e) {\n          self.off.apply(self, offArgs);\n\n          resolve(e);\n        };\n\n        var onArgs = args.concat([callback]);\n        var offArgs = onArgs.concat([]);\n\n        self.on.apply(self, onArgs);\n      });\n    };\n  }\n\n}; // define\n\nmodule.exports = define;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = [{\n  type: 'layout',\n  extensions: __webpack_require__(81)\n}, {\n  type: 'renderer',\n  extensions: __webpack_require__(114)\n}];\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n  padding: 30, // padding on fit\n  circle: false, // put depths in concentric circles if true, put depths top down if false\n  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n  roots: undefined, // the roots of the trees\n  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled,\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\n\nfunction BreadthFirstLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nBreadthFirstLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n  var graph = eles;\n\n  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  });\n\n  var roots = void 0;\n  if (is.elementOrCollection(options.roots)) {\n    roots = options.roots;\n  } else if (is.array(options.roots)) {\n    var rootsArray = [];\n\n    for (var i = 0; i < options.roots.length; i++) {\n      var id = options.roots[i];\n      var ele = cy.getElementById(id);\n      rootsArray.push(ele);\n    }\n\n    roots = cy.collection(rootsArray);\n  } else if (is.string(options.roots)) {\n    roots = cy.$(options.roots);\n  } else {\n    if (options.directed) {\n      roots = nodes.roots();\n    } else {\n      var components = [];\n      var unhandledNodes = nodes;\n\n      var _loop = function _loop() {\n        var currComp = cy.collection();\n\n        eles.bfs({\n          roots: unhandledNodes[0],\n          visit: function visit(node, edge, pNode, i, depth) {\n            currComp = currComp.add(node);\n          },\n          directed: false\n        });\n\n        unhandledNodes = unhandledNodes.not(currComp);\n        components.push(currComp);\n      };\n\n      while (unhandledNodes.length > 0) {\n        _loop();\n      }\n\n      roots = cy.collection();\n\n      var _loop2 = function _loop2(_i) {\n        var comp = components[_i];\n        var maxDegree = comp.maxDegree(false);\n        var compRoots = comp.filter(function (ele) {\n          return ele.degree(false) === maxDegree;\n        });\n\n        roots = roots.add(compRoots);\n      };\n\n      for (var _i = 0; _i < components.length; _i++) {\n        _loop2(_i);\n      }\n    }\n  }\n\n  var depths = [];\n  var foundByBfs = {};\n  var id2depth = {};\n  var prevNode = {};\n  var prevEdge = {};\n  var successors = {};\n\n  // find the depths of the nodes\n  graph.bfs({\n    roots: roots,\n    directed: options.directed,\n    visit: function visit(node, edge, pNode, i, depth) {\n      var ele = node[0];\n      var id = ele.id();\n\n      if (!depths[depth]) {\n        depths[depth] = [];\n      }\n\n      depths[depth].push(ele);\n      foundByBfs[id] = true;\n      id2depth[id] = depth;\n      prevNode[id] = pNode;\n      prevEdge[id] = edge;\n\n      if (pNode) {\n        var prevId = pNode.id();\n        var succ = successors[prevId] = successors[prevId] || [];\n\n        succ.push(node);\n      }\n    }\n  });\n\n  // check for nodes not found by bfs\n  var orphanNodes = [];\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n\n    if (foundByBfs[_ele.id()]) {\n      continue;\n    } else {\n      orphanNodes.push(_ele);\n    }\n  }\n\n  // assign orphan nodes a depth from their neighborhood\n  var maxChecks = orphanNodes.length * 3;\n  var checks = 0;\n  while (orphanNodes.length !== 0 && checks < maxChecks) {\n    var node = orphanNodes.shift();\n    var neighbors = node.neighborhood().nodes();\n    var assignedDepth = false;\n\n    for (var _i3 = 0; _i3 < neighbors.length; _i3++) {\n      var depth = id2depth[neighbors[_i3].id()];\n\n      if (depth !== undefined) {\n        depths[depth].push(node);\n        assignedDepth = true;\n        break;\n      }\n    }\n\n    if (!assignedDepth) {\n      orphanNodes.push(node);\n    }\n\n    checks++;\n  }\n\n  // assign orphan nodes that are still left to the depth of their subgraph\n  while (orphanNodes.length !== 0) {\n    var _node = orphanNodes.shift();\n    //let subgraph = graph.bfs( node ).path;\n    var _assignedDepth = false;\n\n    // for( let i = 0; i < subgraph.length; i++ ){\n    //   let depth = id2depth[ subgraph[i].id() ];\n\n    //   if( depth !== undefined ){\n    //     depths[depth].push( node );\n    //     assignedDepth = true;\n    //     break;\n    //   }\n    // }\n\n    if (!_assignedDepth) {\n      // worst case if the graph really isn't tree friendly, then just dump it in 0\n      if (depths.length === 0) {\n        depths.push([]);\n      }\n\n      depths[0].push(_node);\n    }\n  }\n\n  // assign the nodes a depth and index\n  var assignDepthsToEles = function assignDepthsToEles() {\n    for (var _i4 = 0; _i4 < depths.length; _i4++) {\n      var _eles = depths[_i4];\n\n      for (var j = 0; j < _eles.length; j++) {\n        var _ele2 = _eles[j];\n\n        if (_ele2 == null) {\n          _eles.splice(j, 1);\n          j--;\n          continue;\n        }\n\n        _ele2._private.scratch.breadthfirst = {\n          depth: _i4,\n          index: j\n        };\n      }\n    }\n  };\n  assignDepthsToEles();\n\n  var intersectsDepth = function intersectsDepth(node) {\n    // returns true if has edges pointing in from a higher depth\n    var edges = node.connectedEdges(function (ele) {\n      return ele.data('target') === node.id();\n    });\n    var thisInfo = node._private.scratch.breadthfirst;\n    var highestDepthOfOther = 0;\n    var highestOther = void 0;\n    for (var _i5 = 0; _i5 < edges.length; _i5++) {\n      var edge = edges[_i5];\n      var otherNode = edge.source()[0];\n      var otherInfo = otherNode._private.scratch.breadthfirst;\n\n      if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {\n        highestDepthOfOther = otherInfo.depth;\n        highestOther = otherNode;\n      }\n    }\n\n    return highestOther;\n  };\n\n  // make maximal if so set by adjusting depths\n  for (var adj = 0; adj < options.maximalAdjustments; adj++) {\n\n    var nDepths = depths.length;\n    var elesToMove = [];\n    for (var _i6 = 0; _i6 < nDepths; _i6++) {\n      var _depth = depths[_i6];\n\n      var nDepth = _depth.length;\n      for (var j = 0; j < nDepth; j++) {\n        var _ele3 = _depth[j];\n        var info = _ele3._private.scratch.breadthfirst;\n        var intEle = intersectsDepth(_ele3);\n\n        if (intEle) {\n          info.intEle = intEle;\n          elesToMove.push(_ele3);\n        }\n      }\n    }\n\n    for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {\n      var _ele4 = elesToMove[_i7];\n      var _info = _ele4._private.scratch.breadthfirst;\n      var _intEle = _info.intEle;\n      var intInfo = _intEle._private.scratch.breadthfirst;\n\n      depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)\n\n      // add to end of new depth\n      var newDepth = intInfo.depth + 1;\n      while (newDepth > depths.length - 1) {\n        depths.push([]);\n      }\n      depths[newDepth].push(_ele4);\n\n      _info.depth = newDepth;\n      _info.index = depths[newDepth].length - 1;\n    }\n\n    assignDepthsToEles();\n  }\n\n  // find min distance we need to leave between nodes\n  var minDistance = 0;\n  if (options.avoidOverlap) {\n    for (var _i8 = 0; _i8 < nodes.length; _i8++) {\n      var n = nodes[_i8];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n\n      minDistance = Math.max(minDistance, w, h);\n    }\n  }\n\n  // get the weighted percent for an element based on its connectivity to other levels\n  var cachedWeightedPercent = {};\n  var getWeightedPercent = function getWeightedPercent(ele) {\n    if (cachedWeightedPercent[ele.id()]) {\n      return cachedWeightedPercent[ele.id()];\n    }\n\n    var eleDepth = ele._private.scratch.breadthfirst.depth;\n    var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);\n    var percent = 0;\n    var samples = 0;\n\n    for (var _i9 = 0; _i9 < neighbors.length; _i9++) {\n      var neighbor = neighbors[_i9];\n      var bf = neighbor._private.scratch.breadthfirst;\n      var index = bf.index;\n      var _depth2 = bf.depth;\n      var _nDepth = depths[_depth2].length;\n\n      if (eleDepth > _depth2 || eleDepth === 0) {\n        // only get influenced by elements above\n        percent += index / _nDepth;\n        samples++;\n      }\n    }\n\n    samples = Math.max(1, samples);\n    percent = percent / samples;\n\n    if (samples === 0) {\n      // so lone nodes have a \"don't care\" state in sorting\n      percent = undefined;\n    }\n\n    cachedWeightedPercent[ele.id()] = percent;\n    return percent;\n  };\n\n  // rearrange the indices in each depth level based on connectivity\n\n  var sortFn = function sortFn(a, b) {\n    var apct = getWeightedPercent(a);\n    var bpct = getWeightedPercent(b);\n\n    return apct - bpct;\n  };\n\n  for (var times = 0; times < 3; times++) {\n    // do it a few times b/c the depths are dynamic and we want a more stable result\n\n    for (var _i10 = 0; _i10 < depths.length; _i10++) {\n      depths[_i10] = depths[_i10].sort(sortFn);\n    }\n    assignDepthsToEles(); // and update\n  }\n\n  var biggestDepthSize = 0;\n  for (var _i11 = 0; _i11 < depths.length; _i11++) {\n    biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);\n  }\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.x1 + bb.h / 2\n  };\n\n  var getPosition = function getPosition(ele, isBottomDepth) {\n    var info = ele._private.scratch.breadthfirst;\n    var depth = info.depth;\n    var index = info.index;\n    var depthSize = depths[depth].length;\n\n    var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);\n    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n    radiusStepSize = Math.max(radiusStepSize, minDistance);\n\n    if (!options.circle) {\n\n      var epos = {\n        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n        y: (depth + 1) * distanceY\n      };\n\n      if (isBottomDepth) {\n        return epos;\n      }\n\n      // let succs = successors[ ele.id() ];\n      // if( succs ){\n      //   epos.x = 0;\n      //\n      //   for( let i = 0 ; i < succs.length; i++ ){\n      //     let spos = pos[ succs[i].id() ];\n      //\n      //     epos.x += spos.x;\n      //   }\n      //\n      //   epos.x /= succs.length;\n      // } else {\n      //   //debugger;\n      // }\n\n      return epos;\n    } else {\n      if (options.circle) {\n        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n        var theta = 2 * Math.PI / depths[depth].length * index;\n\n        if (depth === 0 && depths[0].length === 1) {\n          radius = 1;\n        }\n\n        return {\n          x: center.x + radius * Math.cos(theta),\n          y: center.y + radius * Math.sin(theta)\n        };\n      } else {\n        return {\n          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n      }\n    }\n  };\n\n  // get positions in reverse depth order\n  var pos = {};\n  for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {\n    var _depth3 = depths[_i12];\n\n    for (var _j = 0; _j < _depth3.length; _j++) {\n      var _node2 = _depth3[_j];\n\n      pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);\n    }\n  }\n\n  nodes.layoutPositions(this, options, function (node) {\n    return pos[node.id()];\n  });\n\n  return this; // chaining\n};\n\nmodule.exports = BreadthFirstLayout;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // the padding on fit\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  radius: undefined, // the radius of the circle\n  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n};\n\nfunction CircleLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nCircleLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\n  var nodes = eles.nodes().not(':parent');\n\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n\n  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  });\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n\n  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n  var dTheta = sweep / Math.max(1, nodes.length - 1);\n  var r = void 0;\n\n  var minDistance = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var w = nbb.w;\n    var h = nbb.h;\n\n    minDistance = Math.max(minDistance, w, h);\n  }\n\n  if (is.number(options.radius)) {\n    r = options.radius;\n  } else if (nodes.length <= 1) {\n    r = 0;\n  } else {\n    r = Math.min(bb.h, bb.w) / 2 - minDistance;\n  }\n\n  // calculate the radius\n  if (nodes.length > 1 && options.avoidOverlap) {\n    // but only if more than one node (can't overlap)\n    minDistance *= 1.75; // just to have some nice spacing\n\n    var dcos = Math.cos(dTheta) - Math.cos(0);\n    var dsin = Math.sin(dTheta) - Math.sin(0);\n    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n    r = Math.max(rMin, r);\n  }\n\n  var getPos = function getPos(ele, i) {\n    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n\n    var rx = r * Math.cos(theta);\n    var ry = r * Math.sin(theta);\n    var pos = {\n      x: center.x + rx,\n      y: center.y + ry\n    };\n\n    return pos;\n  };\n\n  nodes.layoutPositions(this, options, getPos);\n\n  return this; // chaining\n};\n\nmodule.exports = CircleLayout;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // the padding on fit\n  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n  height: undefined, // height of layout area (overrides container height)\n  width: undefined, // width of layout area (overrides container width)\n  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  concentric: function concentric(node) {\n    // returns numeric value for each node, placing higher nodes in levels towards the centre\n    return node.degree();\n  },\n  levelWidth: function levelWidth(nodes) {\n    // the letiation of concentric values in each level\n    return nodes.maxDegree() / 4;\n  },\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction ConcentricLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nConcentricLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\n  var cy = params.cy;\n\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n\n  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  });\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n\n  var nodeValues = []; // { node, value }\n  var theta = options.startAngle;\n  var maxNodeSize = 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var value = void 0;\n\n    // calculate the node value\n    value = options.concentric(node);\n    nodeValues.push({\n      value: value,\n      node: node\n    });\n\n    // for style mapping\n    node._private.scratch.concentric = value;\n  }\n\n  // in case we used the `concentric` in style\n  nodes.updateStyle();\n\n  // calculate max size now based on potentially updated mappers\n  for (var _i = 0; _i < nodes.length; _i++) {\n    var _node = nodes[_i];\n    var nbb = _node.layoutDimensions(options);\n\n    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n  }\n\n  // sort node values in descreasing order\n  nodeValues.sort(function (a, b) {\n    return b.value - a.value;\n  });\n\n  var levelWidth = options.levelWidth(nodes);\n\n  // put the values into levels\n  var levels = [[]];\n  var currentLevel = levels[0];\n  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n    var val = nodeValues[_i2];\n\n    if (currentLevel.length > 0) {\n      var diff = Math.abs(currentLevel[0].value - val.value);\n\n      if (diff >= levelWidth) {\n        currentLevel = [];\n        levels.push(currentLevel);\n      }\n    }\n\n    currentLevel.push(val);\n  }\n\n  // create positions from levels\n\n  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n  if (!options.avoidOverlap) {\n    // then strictly constrain to bb\n    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n\n    minDist = Math.min(minDist, rStep);\n  }\n\n  // find the metrics for each level\n  var r = 0;\n  for (var _i3 = 0; _i3 < levels.length; _i3++) {\n    var level = levels[_i3];\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n\n    // calculate the radius\n    if (level.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n\n    level.r = r;\n\n    r += minDist;\n  }\n\n  if (options.equidistant) {\n    var rDeltaMax = 0;\n    var _r = 0;\n\n    for (var _i4 = 0; _i4 < levels.length; _i4++) {\n      var _level = levels[_i4];\n      var rDelta = _level.r - _r;\n\n      rDeltaMax = Math.max(rDeltaMax, rDelta);\n    }\n\n    _r = 0;\n    for (var _i5 = 0; _i5 < levels.length; _i5++) {\n      var _level2 = levels[_i5];\n\n      if (_i5 === 0) {\n        _r = _level2.r;\n      }\n\n      _level2.r = _r;\n\n      _r += rDeltaMax;\n    }\n  }\n\n  // calculate the node positions\n  var pos = {}; // id => position\n  for (var _i6 = 0; _i6 < levels.length; _i6++) {\n    var _level3 = levels[_i6];\n    var _dTheta = _level3.dTheta;\n    var _r2 = _level3.r;\n\n    for (var j = 0; j < _level3.length; j++) {\n      var _val = _level3[j];\n      var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n\n      var p = {\n        x: center.x + _r2 * Math.cos(_theta),\n        y: center.y + _r2 * Math.sin(_theta)\n      };\n\n      pos[_val.node.id()] = p;\n    }\n  }\n\n  // position the nodes\n  nodes.layoutPositions(this, options, function (ele) {\n    var id = ele.id();\n\n    return pos[id];\n  });\n\n  return this; // chaining\n};\n\nmodule.exports = ConcentricLayout;\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\nvar Promise = __webpack_require__(5);\n\nvar DEBUG;\n\n/**\n * @brief :  default layout options\n */\nvar defaults = {\n  // Called on `layoutready`\n  ready: function ready() {},\n\n  // Called on `layoutstop`\n  stop: function stop() {},\n\n  // Whether to animate while running the layout\n  // true : Animate continuously as the layout is running\n  // false : Just show the end result\n  // 'end' : Animate with the end result, from the initial positions to the end positions\n  animate: true,\n\n  // Easing of the animation for animate:'end'\n  animationEasing: undefined,\n\n  // The duration of the animation for animate:'end'\n  animationDuration: undefined,\n\n  // A function that determines whether the node should be animated\n  // All nodes animated by default on animate enabled\n  // Non-animated nodes are positioned immediately when the layout starts\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n\n  // The layout animates only after this many milliseconds for animate:true\n  // (prevents flashing on fast runs)\n  animationThreshold: 250,\n\n  // Number of iterations between consecutive screen positions update\n  // (0 -> only updated on the end)\n  refresh: 20,\n\n  // Whether to fit the network view after when done\n  fit: true,\n\n  // Padding on fit\n  padding: 30,\n\n  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  boundingBox: undefined,\n\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  nodeDimensionsIncludeLabels: false,\n\n  // Randomize the initial positions of the nodes (true) or use existing positions (false)\n  randomize: false,\n\n  // Extra spacing between components in non-compound graphs\n  componentSpacing: 40,\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 2048;\n  },\n\n  // Node repulsion (overlapping) multiplier\n  nodeOverlap: 4,\n\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 32;\n  },\n\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 32;\n  },\n\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 1.2,\n\n  // Gravity force (constant)\n  gravity: 1,\n\n  // Maximum number of iterations to perform\n  numIter: 1000,\n\n  // Initial temperature (maximum node displacement)\n  initialTemp: 1000,\n\n  // Cooling factor (how the temperature is reduced between consecutive iterations\n  coolingFactor: 0.99,\n\n  // Lower temperature threshold (below this point the layout will end)\n  minTemp: 1.0,\n\n  // Pass a reference to weaver to use threads for calculations\n  weaver: false\n};\n\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */\nfunction CoseLayout(options) {\n  this.options = util.extend({}, defaults, options);\n\n  this.options.layout = this;\n}\n\n/**\n * @brief : runs the layout\n */\nCoseLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var layout = this;\n  var thread = this.thread;\n  var Thread = options.weaver ? options.weaver.Thread : null;\n\n  var falseThread = { // use false thread as polyfill\n    listeners: [],\n    on: function on(e, cb) {\n      this.listeners.push({ event: e, callback: cb });\n\n      return this;\n    },\n    trigger: function trigger(e) {\n      if (is.string(e)) {\n        e = { type: e };\n      }\n\n      var matchesEvent = function matchesEvent(l) {\n        return l.event === e.type;\n      };\n      var trigger = function trigger(l) {\n        l.callback(e);\n      };\n\n      this.listeners.filter(matchesEvent).forEach(trigger);\n\n      return this;\n    },\n    pass: function pass(data) {\n      this.pass = data;\n\n      return this;\n    },\n    run: function run(cb) {\n      var pass = this.pass;\n\n      return new Promise(function (resolve) {\n        resolve(cb(pass));\n      });\n    },\n    stop: function stop() {\n      return this;\n    }\n  };\n\n  function broadcast(message) {\n    // for false thread\n    var e = { type: 'message', message: message };\n\n    falseThread.trigger(e);\n  }\n\n  if (!thread || thread.stopped()) {\n    thread = this.thread = Thread ? new Thread() : falseThread;\n  }\n\n  layout.stopped = false;\n\n  if (options.animate === true || options.animate === false) {\n    layout.emit({ type: 'layoutstart', layout: layout });\n  }\n\n  // Set DEBUG - Global variable\n  if (true === options.debug) {\n    DEBUG = true;\n  } else {\n    DEBUG = false;\n  }\n\n  // Initialize layout info\n  var layoutInfo = createLayoutInfo(cy, layout, options);\n\n  // Show LayoutInfo contents if debugging\n  if (DEBUG) {\n    printLayoutInfo(layoutInfo);\n  }\n\n  // If required, randomize node positions\n  if (options.randomize) {\n    randomizePositions(layoutInfo, cy);\n  }\n\n  var startTime = Date.now();\n  var refreshRequested = false;\n  var refresh = function refresh(rOpts) {\n    rOpts = rOpts || {};\n\n    if (refreshRequested && !rOpts.next) {\n      return;\n    }\n\n    if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {\n      return;\n    }\n\n    refreshRequested = true;\n\n    util.requestAnimationFrame(function () {\n      refreshPositions(layoutInfo, cy, options);\n\n      // Fit the graph if necessary\n      if (true === options.fit) {\n        cy.fit(options.padding);\n      }\n\n      refreshRequested = false;\n\n      if (rOpts.next) {\n        rOpts.next();\n      }\n    });\n  };\n\n  thread.on('message', function (e) {\n    var layoutNodes = e.message;\n\n    layoutInfo.layoutNodes = layoutNodes;\n    refresh();\n  });\n\n  thread.pass({\n    layoutInfo: layoutInfo,\n    options: {\n      animate: options.animate,\n      refresh: options.refresh,\n      componentSpacing: options.componentSpacing,\n      nodeOverlap: options.nodeOverlap,\n      nestingFactor: options.nestingFactor,\n      gravity: options.gravity,\n      numIter: options.numIter,\n      initialTemp: options.initialTemp,\n      coolingFactor: options.coolingFactor,\n      minTemp: options.minTemp\n    }\n  }).run(function (pass) {\n    var layoutInfo = pass.layoutInfo;\n    var options = pass.options;\n    var stopped = false;\n\n    /**\n     * @brief          : Performs one iteration of the physical simulation\n     * @arg layoutInfo : LayoutInfo object already initialized\n     * @arg cy         : Cytoscape object\n     * @arg options    : Layout options\n     */\n    var step = function step(layoutInfo, options, _step) {\n      // var s = \"\\n\\n###############################\";\n      // s += \"\\nSTEP: \" + step;\n      // s += \"\\n###############################\\n\";\n      // logDebug(s);\n\n      // Calculate node repulsions\n      calculateNodeForces(layoutInfo, options);\n      // Calculate edge forces\n      calculateEdgeForces(layoutInfo, options);\n      // Calculate gravity forces\n      calculateGravityForces(layoutInfo, options);\n      // Propagate forces from parent to child\n      propagateForces(layoutInfo, options);\n      // Update positions based on calculated forces\n      updatePositions(layoutInfo, options);\n    };\n\n    /**\n     * @brief : Computes the node repulsion forces\n     */\n    var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n      // Go through each of the graphs in graphSet\n      // Nodes only repel each other if they belong to the same graph\n      // var s = 'calculateNodeForces';\n      // logDebug(s);\n      for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n\n        // Now get all the pairs of nodes\n        // Only get each pair once, (A, B) = (B, A)\n        for (var j = 0; j < numNodes; j++) {\n          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\n          for (var k = j + 1; k < numNodes; k++) {\n            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n\n            nodeRepulsion(node1, node2, layoutInfo, options);\n          }\n        }\n      }\n    };\n\n    var randomDistance = function randomDistance(max) {\n      return -max + 2 * max * Math.random();\n    };\n\n    /**\n     * @brief : Compute the node repulsion forces between a pair of nodes\n     */\n    var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n      // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\n      var cmptId1 = node1.cmptId;\n      var cmptId2 = node2.cmptId;\n\n      if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n        return;\n      }\n\n      // Get direction of line connecting both node centers\n      var directionX = node2.positionX - node1.positionX;\n      var directionY = node2.positionY - node1.positionY;\n      var maxRandDist = 1;\n      // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\n      // If both centers are the same, apply a random force\n      if (0 === directionX && 0 === directionY) {\n        directionX = randomDistance(maxRandDist);\n        directionY = randomDistance(maxRandDist);\n      }\n\n      var overlap = nodesOverlap(node1, node2, directionX, directionY);\n\n      if (overlap > 0) {\n        // s += \"\\nNodes DO overlap.\";\n        // s += \"\\nOverlap: \" + overlap;\n        // If nodes overlap, repulsion force is proportional\n        // to the overlap\n        var force = options.nodeOverlap * overlap;\n\n        // Compute the module and components of the force vector\n        var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n        // s += \"\\nDistance: \" + distance;\n        var forceX = force * directionX / distance;\n        var forceY = force * directionY / distance;\n      } else {\n        // s += \"\\nNodes do NOT overlap.\";\n        // If there's no overlap, force is inversely proportional\n        // to squared distance\n\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(node1, directionX, directionY);\n        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n\n        // Use clipping points to compute distance\n        var distanceX = point2.x - point1.x;\n        var distanceY = point2.y - point1.y;\n        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n        var distance = Math.sqrt(distanceSqr);\n        // s += \"\\nDistance: \" + distance;\n\n        // Compute the module and components of the force vector\n        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n        var forceX = force * distanceX / distance;\n        var forceY = force * distanceY / distance;\n      }\n\n      // Apply force\n      if (!node1.isLocked) {\n        node1.offsetX -= forceX;\n        node1.offsetY -= forceY;\n      }\n\n      if (!node2.isLocked) {\n        node2.offsetX += forceX;\n        node2.offsetY += forceY;\n      }\n\n      // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n      // logDebug(s);\n\n      return;\n    };\n\n    /**\n     * @brief  : Determines whether two nodes overlap or not\n     * @return : Amount of overlapping (0 => no overlap)\n     */\n    var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n\n      if (dX > 0) {\n        var overlapX = node1.maxX - node2.minX;\n      } else {\n        var overlapX = node2.maxX - node1.minX;\n      }\n\n      if (dY > 0) {\n        var overlapY = node1.maxY - node2.minY;\n      } else {\n        var overlapY = node2.maxY - node1.minY;\n      }\n\n      if (overlapX >= 0 && overlapY >= 0) {\n        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n      } else {\n        return 0;\n      }\n    };\n\n    /**\n     * @brief : Finds the point in which an edge (direction dX, dY) intersects\n     *          the rectangular bounding box of it's source/target node\n     */\n    var findClippingPoint = function findClippingPoint(node, dX, dY) {\n\n      // Shorcuts\n      var X = node.positionX;\n      var Y = node.positionY;\n      var H = node.height || 1;\n      var W = node.width || 1;\n      var dirSlope = dY / dX;\n      var nodeSlope = H / W;\n\n      // var s = 'Computing clipping point of node ' + node.id +\n      //   \" . Height:  \" + H + \", Width: \" + W +\n      //   \"\\nDirection \" + dX + \", \" + dY;\n      //\n      // Compute intersection\n      var res = {};\n\n      // Case: Vertical direction (up)\n      if (0 === dX && 0 < dY) {\n        res.x = X;\n        // s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n\n        return res;\n      }\n\n      // Case: Vertical direction (down)\n      if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        // s += \"\\nDown direction\";\n\n        return res;\n      }\n\n      // Case: Intersects the right border\n      if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + W * dY / 2 / dX;\n        // s += \"\\nRightborder\";\n\n        return res;\n      }\n\n      // Case: Intersects the left border\n      if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - W * dY / 2 / dX;\n        // s += \"\\nLeftborder\";\n\n        return res;\n      }\n\n      // Case: Intersects the top border\n      if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X + H * dX / 2 / dY;\n        res.y = Y + H / 2;\n        // s += \"\\nTop border\";\n\n        return res;\n      }\n\n      // Case: Intersects the bottom border\n      if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X - H * dX / 2 / dY;\n        res.y = Y - H / 2;\n        // s += \"\\nBottom border\";\n\n        return res;\n      }\n\n      // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n      // logDebug(s);\n      return res;\n    };\n\n    /**\n     * @brief : Calculates all edge forces\n     */\n    var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n      // Iterate over all edges\n      for (var i = 0; i < layoutInfo.edgeSize; i++) {\n        // Get edge, source & target nodes\n        var edge = layoutInfo.layoutEdges[i];\n        var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n        var source = layoutInfo.layoutNodes[sourceIx];\n        var targetIx = layoutInfo.idToIndex[edge.targetId];\n        var target = layoutInfo.layoutNodes[targetIx];\n\n        // Get direction of line connecting both node centers\n        var directionX = target.positionX - source.positionX;\n        var directionY = target.positionY - source.positionY;\n\n        // If both centers are the same, do nothing.\n        // A random force has already been applied as node repulsion\n        if (0 === directionX && 0 === directionY) {\n          continue;\n        }\n\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(source, directionX, directionY);\n        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n\n        var lx = point2.x - point1.x;\n        var ly = point2.y - point1.y;\n        var l = Math.sqrt(lx * lx + ly * ly);\n\n        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n\n        if (0 !== l) {\n          var forceX = force * lx / l;\n          var forceY = force * ly / l;\n        } else {\n          var forceX = 0;\n          var forceY = 0;\n        }\n\n        // Add this force to target and source nodes\n        if (!source.isLocked) {\n          source.offsetX += forceX;\n          source.offsetY += forceY;\n        }\n\n        if (!target.isLocked) {\n          target.offsetX -= forceX;\n          target.offsetY -= forceY;\n        }\n\n        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n        // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n        // logDebug(s);\n      }\n    };\n\n    /**\n     * @brief : Computes gravity forces for all nodes\n     */\n    var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n      var distThreshold = 1;\n\n      // var s = 'calculateGravityForces';\n      // logDebug(s);\n      for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n\n        // Compute graph center\n        if (0 === i) {\n          var centerX = layoutInfo.clientHeight / 2;\n          var centerY = layoutInfo.clientWidth / 2;\n        } else {\n          // Get Parent node for this graph, and use its position as center\n          var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n          var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n          var centerX = parent.positionX;\n          var centerY = parent.positionY;\n        }\n        // s = \"Center found at: \" + centerX + \", \" + centerY;\n        // logDebug(s);\n\n        // Apply force to all nodes in graph\n        for (var j = 0; j < numNodes; j++) {\n          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n          // s = \"Node: \" + node.id;\n\n          if (node.isLocked) {\n            continue;\n          }\n\n          var dx = centerX - node.positionX;\n          var dy = centerY - node.positionY;\n          var d = Math.sqrt(dx * dx + dy * dy);\n          if (d > distThreshold) {\n            var fx = options.gravity * dx / d;\n            var fy = options.gravity * dy / d;\n            node.offsetX += fx;\n            node.offsetY += fy;\n            // s += \": Applied force: \" + fx + \", \" + fy;\n          } else {}\n            // s += \": skypped since it's too close to center\";\n\n            // logDebug(s);\n        }\n      }\n    };\n\n    /**\n     * @brief          : This function propagates the existing offsets from\n     *                   parent nodes to its descendents.\n     * @arg layoutInfo : layoutInfo Object\n     * @arg cy         : cytoscape Object\n     * @arg options    : Layout options\n     */\n    var propagateForces = function propagateForces(layoutInfo, options) {\n      // Inline implementation of a queue, used for traversing the graph in BFS order\n      var queue = [];\n      var start = 0; // Points to the start the queue\n      var end = -1; // Points to the end of the queue\n\n      // logDebug('propagateForces');\n\n      // Start by visiting the nodes in the root graph\n      queue.push.apply(queue, layoutInfo.graphSet[0]);\n      end += layoutInfo.graphSet[0].length;\n\n      // Traverse the graph, level by level,\n      while (start <= end) {\n        // Get the node to visit and remove it from queue\n        var nodeId = queue[start++];\n        var nodeIndex = layoutInfo.idToIndex[nodeId];\n        var node = layoutInfo.layoutNodes[nodeIndex];\n        var children = node.children;\n\n        // We only need to process the node if it's compound\n        if (0 < children.length && !node.isLocked) {\n          var offX = node.offsetX;\n          var offY = node.offsetY;\n\n          // var s = \"Propagating offset from parent node : \" + node.id +\n          //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n          // s += \"\\n Children: \" + children.toString();\n          // logDebug(s);\n\n          for (var i = 0; i < children.length; i++) {\n            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n            // Propagate offset\n            childNode.offsetX += offX;\n            childNode.offsetY += offY;\n            // Add children to queue to be visited\n            queue[++end] = children[i];\n          }\n\n          // Reset parent offsets\n          node.offsetX = 0;\n          node.offsetY = 0;\n        }\n      }\n    };\n\n    /**\n     * @brief : Updates the layout model positions, based on\n     *          the accumulated forces\n     */\n    var updatePositions = function updatePositions(layoutInfo, options) {\n      // var s = 'Updating positions';\n      // logDebug(s);\n\n      // Reset boundaries for compound nodes\n      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length) {\n          // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n          n.maxX = undefined;\n          n.minX = undefined;\n          n.maxY = undefined;\n          n.minY = undefined;\n        }\n      }\n\n      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length || n.isLocked) {\n          // No need to set compound or locked node position\n          // logDebug(\"Skipping position update of node: \" + n.id);\n          continue;\n        }\n        // s = \"Node: \" + n.id + \" Previous position: (\" +\n        // n.positionX + \", \" + n.positionY + \").\";\n\n        // Limit displacement in order to improve stability\n        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n        n.positionX += tempForce.x;\n        n.positionY += tempForce.y;\n        n.offsetX = 0;\n        n.offsetY = 0;\n        n.minX = n.positionX - n.width;\n        n.maxX = n.positionX + n.width;\n        n.minY = n.positionY - n.height;\n        n.maxY = n.positionY + n.height;\n        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n        // logDebug(s);\n\n        // Update ancestry boudaries\n        updateAncestryBoundaries(n, layoutInfo);\n      }\n\n      // Update size, position of compund nodes\n      for (var i = 0; i < layoutInfo.nodeSize; i++) {\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length && !n.isLocked) {\n          n.positionX = (n.maxX + n.minX) / 2;\n          n.positionY = (n.maxY + n.minY) / 2;\n          n.width = n.maxX - n.minX;\n          n.height = n.maxY - n.minY;\n          // s = \"Updating position, size of compound node \" + n.id;\n          // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n          // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n          // logDebug(s);\n        }\n      }\n    };\n\n    /**\n     * @brief : Limits a force (forceX, forceY) to be not\n     *          greater (in modulo) than max.\n     8          Preserves force direction.\n     */\n    var limitForce = function limitForce(forceX, forceY, max) {\n      // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n      var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n      if (force > max) {\n        var res = {\n          x: max * forceX / force,\n          y: max * forceY / force\n        };\n      } else {\n        var res = {\n          x: forceX,\n          y: forceY\n        };\n      }\n\n      // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n      // logDebug(s);\n\n      return res;\n    };\n\n    /**\n     * @brief : Function used for keeping track of compound node\n     *          sizes, since they should bound all their subnodes.\n     */\n    var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n      // var s = \"Propagating new position/size of node \" + node.id;\n      var parentId = node.parentId;\n      if (null == parentId) {\n        // If there's no parent, we are done\n        // s += \". No parent node.\";\n        // logDebug(s);\n        return;\n      }\n\n      // Get Parent Node\n      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n      var flag = false;\n\n      // MaxX\n      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n        p.maxX = node.maxX + p.padRight;\n        flag = true;\n        // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n      }\n\n      // MinX\n      if (null == p.minX || node.minX - p.padLeft < p.minX) {\n        p.minX = node.minX - p.padLeft;\n        flag = true;\n        // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n      }\n\n      // MaxY\n      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n        p.maxY = node.maxY + p.padBottom;\n        flag = true;\n        // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n      }\n\n      // MinY\n      if (null == p.minY || node.minY - p.padTop < p.minY) {\n        p.minY = node.minY - p.padTop;\n        flag = true;\n        // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n      }\n\n      // If updated boundaries, propagate changes upward\n      if (flag) {\n        // logDebug(s);\n        return updateAncestryBoundaries(p, layoutInfo);\n      }\n\n      // s += \". No changes in boundaries/position of parent node \" + p.id;\n      // logDebug(s);\n      return;\n    };\n\n    var separateComponents = function separateComponents(layutInfo, options) {\n      var nodes = layoutInfo.layoutNodes;\n      var components = [];\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var cid = node.cmptId;\n        var component = components[cid] = components[cid] || [];\n\n        component.push(node);\n      }\n\n      var totalA = 0;\n\n      for (var i = 0; i < components.length; i++) {\n        var c = components[i];\n\n        if (!c) {\n          continue;\n        }\n\n        c.x1 = Infinity;\n        c.x2 = -Infinity;\n        c.y1 = Infinity;\n        c.y2 = -Infinity;\n\n        for (var j = 0; j < c.length; j++) {\n          var n = c[j];\n\n          c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n          c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n          c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n          c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n        }\n\n        c.w = c.x2 - c.x1;\n        c.h = c.y2 - c.y1;\n\n        totalA += c.w * c.h;\n      }\n\n      components.sort(function (c1, c2) {\n        return c2.w * c2.h - c1.w * c1.h;\n      });\n\n      var x = 0;\n      var y = 0;\n      var usedW = 0;\n      var rowH = 0;\n      var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\n      for (var i = 0; i < components.length; i++) {\n        var c = components[i];\n\n        if (!c) {\n          continue;\n        }\n\n        for (var j = 0; j < c.length; j++) {\n          var n = c[j];\n\n          if (!n.isLocked) {\n            n.positionX += x;\n            n.positionY += y;\n          }\n        }\n\n        x += c.w + options.componentSpacing;\n        usedW += c.w + options.componentSpacing;\n        rowH = Math.max(rowH, c.h);\n\n        if (usedW > maxRowW) {\n          y += rowH + options.componentSpacing;\n          x = 0;\n          usedW = 0;\n          rowH = 0;\n        }\n      }\n    };\n\n    var mainLoop = function mainLoop(i) {\n      if (stopped) {\n        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      }\n\n      // Do one step in the phisical simulation\n      step(layoutInfo, options, i);\n\n      // Update temperature\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n      // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if (layoutInfo.temperature < options.minTemp) {\n        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var i = 0;\n    var loopRet;\n\n    do {\n      var f = 0;\n\n      while (f < options.refresh && i < options.numIter) {\n        var loopRet = mainLoop(i);\n        if (!loopRet) {\n          break;\n        }\n\n        f++;\n        i++;\n      }\n\n      if (options.animate === true) {\n        broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef\n      }\n    } while (loopRet && i + 1 < options.numIter);\n\n    separateComponents(layoutInfo, options);\n\n    return layoutInfo;\n  }).then(function (layoutInfoUpdated) {\n    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions\n\n    thread.stop();\n    done();\n  });\n\n  var done = function done() {\n    if (options.animate === true || options.animate === false) {\n      refresh({\n        force: true,\n        next: function next() {\n          // Layout has finished\n          layout.one('layoutstop', options.stop);\n          layout.emit({ type: 'layoutstop', layout: layout });\n        }\n      });\n    } else {\n      options.eles.nodes().layoutPositions(layout, options, function (node) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\n        return { x: lnode.positionX, y: lnode.positionY };\n      });\n    }\n  };\n\n  return this; // chaining\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\nCoseLayout.prototype.stop = function () {\n  this.stopped = true;\n\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  this.emit('layoutstop');\n\n  return this; // chaining\n};\n\nCoseLayout.prototype.destroy = function () {\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  return this; // chaining\n};\n\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */\nvar createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n  // Shortcut\n  var edges = options.eles.edges();\n  var nodes = options.eles.nodes();\n\n  var layoutInfo = {\n    isCompound: cy.hasCompoundNodes(),\n    layoutNodes: [],\n    idToIndex: {},\n    nodeSize: nodes.size(),\n    graphSet: [],\n    indexToGraph: [],\n    layoutEdges: [],\n    edgeSize: edges.size(),\n    temperature: options.initialTemp,\n    clientWidth: cy.width(),\n    clientHeight: cy.width(),\n    boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    })\n  };\n\n  var components = options.eles.components();\n  var id2cmptId = {};\n\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n\n    for (var j = 0; j < component.length; j++) {\n      var node = component[j];\n\n      id2cmptId[node.id()] = i;\n    }\n  }\n\n  // Iterate over all nodes, creating layout nodes\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n\n    var tempNode = {};\n    tempNode.isLocked = n.locked();\n    tempNode.id = n.data('id');\n    tempNode.parentId = n.data('parent');\n    tempNode.cmptId = id2cmptId[n.id()];\n    tempNode.children = [];\n    tempNode.positionX = n.position('x');\n    tempNode.positionY = n.position('y');\n    tempNode.offsetX = 0;\n    tempNode.offsetY = 0;\n    tempNode.height = nbb.w;\n    tempNode.width = nbb.h;\n    tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n    tempNode.minX = tempNode.positionX - tempNode.width / 2;\n    tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n    tempNode.minY = tempNode.positionY - tempNode.height / 2;\n    tempNode.padLeft = parseFloat(n.style('padding'));\n    tempNode.padRight = parseFloat(n.style('padding'));\n    tempNode.padTop = parseFloat(n.style('padding'));\n    tempNode.padBottom = parseFloat(n.style('padding'));\n\n    // forces\n    tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n\n    // Add new node\n    layoutInfo.layoutNodes.push(tempNode);\n    // Add entry to id-index map\n    layoutInfo.idToIndex[tempNode.id] = i;\n  }\n\n  // Inline implementation of a queue, used for traversing the graph in BFS order\n  var queue = [];\n  var start = 0; // Points to the start the queue\n  var end = -1; // Points to the end of the queue\n\n  var tempGraph = [];\n\n  // Second pass to add child information and\n  // initialize queue for hierarchical traversal\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    var p_id = n.parentId;\n    // Check if node n has a parent node\n    if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n    } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);\n    }\n  }\n\n  // Add root graph to graphSet\n  layoutInfo.graphSet.push(tempGraph);\n\n  // Traverse the graph, level by level,\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var node_id = queue[start++];\n    var node_ix = layoutInfo.idToIndex[node_id];\n    var node = layoutInfo.layoutNodes[node_ix];\n    var children = node.children;\n    if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children);\n      // Add children to que queue to be visited\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n    }\n  }\n\n  // Create indexToGraph map\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n    }\n  }\n\n  // Iterate over all edges, creating Layout Edges\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    var e = edges[i];\n    var tempEdge = {};\n    tempEdge.id = e.data('id');\n    tempEdge.sourceId = e.data('source');\n    tempEdge.targetId = e.data('target');\n\n    // Compute ideal length\n    var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n    var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n\n    // Check if it's an inter graph edge\n    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n    var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n    var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n    if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n\n      // Compute sum of node depths, relative to lca graph\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth = 0;\n\n      // Source depth\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // Target depth\n      tempNode = layoutInfo.layoutNodes[targetIx];\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n      //  \". Depth: \" + depth);\n\n      // Update idealLength\n      idealLength *= depth * options.nestingFactor;\n    }\n\n    tempEdge.idealLength = idealLength;\n    tempEdge.elasticity = elasticity;\n\n    layoutInfo.layoutEdges.push(tempEdge);\n  }\n\n  // Finally, return layoutInfo object\n  return layoutInfo;\n};\n\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */\nvar findLCA = function findLCA(node1, node2, layoutInfo) {\n  // Find their common ancester, starting from the root graph\n  var res = findLCA_aux(node1, node2, 0, layoutInfo);\n  if (2 > res.count) {\n    // If aux function couldn't find the common ancester,\n    // then it is the root graph\n    return 0;\n  } else {\n    return res.graph;\n  }\n};\n\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancesters (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */\nvar findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n  var graph = layoutInfo.graphSet[graphIx];\n  // If both nodes belongs to graphIx\n  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n    return { count: 2, graph: graphIx };\n  }\n\n  // Make recursive calls for all subgraphs\n  var c = 0;\n  for (var i = 0; i < graph.length; i++) {\n    var nodeId = graph[i];\n    var nodeIx = layoutInfo.idToIndex[nodeId];\n    var children = layoutInfo.layoutNodes[nodeIx].children;\n\n    // If the node has no child, skip it\n    if (0 === children.length) {\n      continue;\n    }\n\n    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n    if (0 === result.count) {\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n    } else if (1 === result.count) {\n      // One of (node1, node2) is present in this subgraph\n      c++;\n      if (2 === c) {\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n    } else {\n      // Both nodes are present in this subgraph\n      return result;\n    }\n  }\n\n  return { count: c, graph: graphIx };\n};\n\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */\nvar printLayoutInfo = function printLayoutInfo(layoutInfo) {\n  /* eslint-disable */\n\n  if (!DEBUG) {\n    return;\n  }\n  console.debug('layoutNodes:');\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    var s = '\\nindex: ' + i + '\\nId: ' + n.id + '\\nChildren: ' + n.children.toString() + '\\nparentId: ' + n.parentId + '\\npositionX: ' + n.positionX + '\\npositionY: ' + n.positionY + '\\nOffsetX: ' + n.offsetX + '\\nOffsetY: ' + n.offsetY + '\\npadLeft: ' + n.padLeft + '\\npadRight: ' + n.padRight + '\\npadTop: ' + n.padTop + '\\npadBottom: ' + n.padBottom;\n\n    console.debug(s);\n  }\n\n  console.debug('idToIndex');\n  for (var i in layoutInfo.idToIndex) {\n    console.debug('Id: ' + i + '\\nIndex: ' + layoutInfo.idToIndex[i]);\n  }\n\n  console.debug('Graph Set');\n  var set = layoutInfo.graphSet;\n  for (var i = 0; i < set.length; i++) {\n    console.debug('Set : ' + i + ': ' + set[i].toString());\n  }\n\n  var s = 'IndexToGraph';\n  for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {\n    s += '\\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];\n  }\n  console.debug(s);\n\n  s = 'Layout Edges';\n  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {\n    var e = layoutInfo.layoutEdges[i];\n    s += '\\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;\n  }\n  console.debug(s);\n\n  s = 'nodeSize: ' + layoutInfo.nodeSize;\n  s += '\\nedgeSize: ' + layoutInfo.edgeSize;\n  s += '\\ntemperature: ' + layoutInfo.temperature;\n  console.debug(s);\n\n  return;\n  /* eslint-enable */\n};\n\n/**\n * @brief : Randomizes the position of all nodes\n */\nvar randomizePositions = function randomizePositions(layoutInfo, cy) {\n  var width = layoutInfo.clientWidth;\n  var height = layoutInfo.clientHeight;\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n\n    // No need to randomize compound nodes or locked nodes\n    if (0 === n.children.length && !n.isLocked) {\n      n.positionX = Math.random() * width;\n      n.positionY = Math.random() * height;\n    }\n  }\n};\n\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\nvar refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n  // var s = 'Refreshing positions';\n  // logDebug(s);\n\n  var layout = options.layout;\n  var nodes = options.eles.nodes();\n  var bb = layoutInfo.boundingBox;\n  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n\n  if (options.boundingBox) {\n    nodes.forEach(function (node) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\n      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n\n      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n    });\n\n    coseBB.w = coseBB.x2 - coseBB.x1;\n    coseBB.h = coseBB.y2 - coseBB.y1;\n  }\n\n  nodes.positions(function (ele, i) {\n    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n    // s = \"Node: \" + lnode.id + \". Refreshed position: (\" +\n    // lnode.positionX + \", \" + lnode.positionY + \").\";\n    // logDebug(s);\n\n    if (options.boundingBox) {\n      // then add extra bounding box constraint\n      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\n      return {\n        x: bb.x1 + pctX * bb.w,\n        y: bb.y1 + pctY * bb.h\n      };\n    } else {\n      return {\n        x: lnode.positionX,\n        y: lnode.positionY\n      };\n    }\n  });\n\n  // Trigger layoutReady only on first call\n  if (true !== layoutInfo.ready) {\n    // s = 'Triggering layoutready';\n    // logDebug(s);\n    layoutInfo.ready = true;\n    layout.one('layoutready', options.ready);\n    layout.emit({ type: 'layoutready', layout: this });\n  }\n};\n\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */\n// var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n\nmodule.exports = CoseLayout;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // padding used on fit\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true\n  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  condense: false, // uses all available space on false, uses minimal space on true\n  rows: undefined, // force num of rows in the grid\n  cols: undefined, // force num of columns in the grid\n  position: function position(node) {}, // returns { row, col } for element\n  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction GridLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nGridLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n\n  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  });\n\n  if (bb.h === 0 || bb.w === 0) {\n    nodes.layoutPositions(this, options, function (ele) {\n      return { x: bb.x1, y: bb.y1 };\n    });\n  } else {\n\n    // width/height * splits^2 = cells where splits is number of times to split width\n    var cells = nodes.size();\n    var splits = Math.sqrt(cells * bb.h / bb.w);\n    var rows = Math.round(splits);\n    var cols = Math.round(bb.w / bb.h * splits);\n\n    var small = function small(val) {\n      if (val == null) {\n        return Math.min(rows, cols);\n      } else {\n        var min = Math.min(rows, cols);\n        if (min == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var large = function large(val) {\n      if (val == null) {\n        return Math.max(rows, cols);\n      } else {\n        var max = Math.max(rows, cols);\n        if (max == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var oRows = options.rows;\n    var oCols = options.cols != null ? options.cols : options.columns;\n\n    // if rows or columns were set in options, use those values\n    if (oRows != null && oCols != null) {\n      rows = oRows;\n      cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      rows = oRows;\n      cols = Math.ceil(cells / rows);\n    } else if (oRows == null && oCols != null) {\n      cols = oCols;\n      rows = Math.ceil(cells / cols);\n    }\n\n    // otherwise use the automatic values and adjust accordingly\n\n    // if rounding was up, see if we can reduce rows or columns\n    else if (cols * rows > cells) {\n        var sm = small();\n        var lg = large();\n\n        // reducing the small side takes away the most cells, so try it first\n        if ((sm - 1) * lg >= cells) {\n          small(sm - 1);\n        } else if ((lg - 1) * sm >= cells) {\n          large(lg - 1);\n        }\n      } else {\n\n        // if rounding was too low, add rows or columns\n        while (cols * rows < cells) {\n          var _sm = small();\n          var _lg = large();\n\n          // try to add to larger side first (adds less in multiplication)\n          if ((_lg + 1) * _sm >= cells) {\n            large(_lg + 1);\n          } else {\n            small(_sm + 1);\n          }\n        }\n      }\n\n    var cellWidth = bb.w / cols;\n    var cellHeight = bb.h / rows;\n\n    if (options.condense) {\n      cellWidth = 0;\n      cellHeight = 0;\n    }\n\n    if (options.avoidOverlap) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = node._private.position;\n\n        if (pos.x == null || pos.y == null) {\n          // for bb\n          pos.x = 0;\n          pos.y = 0;\n        }\n\n        var nbb = node.layoutDimensions(options);\n        var p = options.avoidOverlapPadding;\n\n        var w = nbb.w + p;\n        var h = nbb.h + p;\n\n        cellWidth = Math.max(cellWidth, w);\n        cellHeight = Math.max(cellHeight, h);\n      }\n    }\n\n    var cellUsed = {}; // e.g. 'c-0-2' => true\n\n    var used = function used(row, col) {\n      return cellUsed['c-' + row + '-' + col] ? true : false;\n    };\n\n    var use = function use(row, col) {\n      cellUsed['c-' + row + '-' + col] = true;\n    };\n\n    // to keep track of current cell position\n    var row = 0;\n    var col = 0;\n    var moveToNextCell = function moveToNextCell() {\n      col++;\n      if (col >= cols) {\n        col = 0;\n        row++;\n      }\n    };\n\n    // get a cache of all the manual positions\n    var id2manPos = {};\n    for (var _i = 0; _i < nodes.length; _i++) {\n      var _node = nodes[_i];\n      var rcPos = options.position(_node);\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        var _pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (_pos.col === undefined) {\n          // find unused col\n          _pos.col = 0;\n\n          while (used(_pos.row, _pos.col)) {\n            _pos.col++;\n          }\n        } else if (_pos.row === undefined) {\n          // find unused row\n          _pos.row = 0;\n\n          while (used(_pos.row, _pos.col)) {\n            _pos.row++;\n          }\n        }\n\n        id2manPos[_node.id()] = _pos;\n        use(_pos.row, _pos.col);\n      }\n    }\n\n    var getPos = function getPos(element, i) {\n      var x = void 0,\n          y = void 0;\n\n      if (element.locked() || element.isParent()) {\n        return false;\n      }\n\n      // see if we have a manual position set\n      var rcPos = id2manPos[element.id()];\n      if (rcPos) {\n        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n      } else {\n        // otherwise set automatically\n\n        while (used(row, col)) {\n          moveToNextCell();\n        }\n\n        x = col * cellWidth + cellWidth / 2 + bb.x1;\n        y = row * cellHeight + cellHeight / 2 + bb.y1;\n        use(row, col);\n\n        moveToNextCell();\n      }\n\n      return { x: x, y: y };\n    };\n\n    nodes.layoutPositions(this, options, getPos);\n  }\n\n  return this; // chaining\n};\n\nmodule.exports = GridLayout;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = [{ name: 'breadthfirst', impl: __webpack_require__(76) }, { name: 'circle', impl: __webpack_require__(77) }, { name: 'concentric', impl: __webpack_require__(78) }, { name: 'cose', impl: __webpack_require__(79) }, { name: 'grid', impl: __webpack_require__(80) }, { name: 'null', impl: __webpack_require__(82) }, { name: 'preset', impl: __webpack_require__(83) }, { name: 'random', impl: __webpack_require__(84) }];\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\n// default layout options\nvar defaults = {\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n};\n\n// constructor\n// options : object containing layout options\nfunction NullLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\n// runs the layout\nNullLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles; // elements to consider in the layout\n  var layout = this;\n\n  // cy is automatically populated for us in the constructor\n  var cy = options.cy; // jshint ignore:line\n\n  layout.emit('layoutstart');\n\n  // puts all nodes at (0, 0)\n  eles.nodes().positions(function () {\n    return {\n      x: 0,\n      y: 0\n    };\n  });\n\n  // trigger layoutready when each node has had its position set at least once\n  layout.one('layoutready', options.ready);\n  layout.emit('layoutready');\n\n  // trigger layoutstop when the layout stops (e.g. finishes)\n  layout.one('layoutstop', options.stop);\n  layout.emit('layoutstop');\n\n  return this; // chaining\n};\n\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function () {\n  return this; // chaining\n};\n\nmodule.exports = NullLayout;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar defaults = {\n  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n  zoom: undefined, // the zoom level to set (prob want fit = false if set)\n  pan: undefined, // the pan level to set (prob want fit = false if set)\n  fit: true, // whether to fit to viewport\n  padding: 30, // padding on fit\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction PresetLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nPresetLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles;\n\n  var nodes = eles.nodes();\n  var posIsFn = is.fn(options.positions);\n\n  function getPosition(node) {\n    if (options.positions == null) {\n      return null;\n    }\n\n    if (posIsFn) {\n      return options.positions(node);\n    }\n\n    var pos = options.positions[node._private.data.id];\n\n    if (pos == null) {\n      return null;\n    }\n\n    return pos;\n  }\n\n  nodes.layoutPositions(this, options, function (node, i) {\n    var position = getPosition(node);\n\n    if (node.locked() || position == null) {\n      return false;\n    }\n\n    return position;\n  });\n\n  return this; // chaining\n};\n\nmodule.exports = PresetLayout;\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\n\nvar defaults = {\n  fit: true, // whether to fit to viewport\n  padding: 30, // fit padding\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined, // callback on layoutready\n  stop: undefined, // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\n\nfunction RandomLayout(options) {\n  this.options = util.extend({}, defaults, options);\n}\n\nRandomLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n\n  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  });\n\n  var getPos = function getPos(node, i) {\n    return {\n      x: bb.x1 + Math.round(Math.random() * bb.w),\n      y: bb.y1 + Math.round(Math.random() * bb.h)\n    };\n  };\n\n  nodes.layoutPositions(this, options, getPos);\n\n  return this; // chaining\n};\n\nmodule.exports = RandomLayout;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\n\nvar BRp = {};\n\nBRp.arrowShapeWidth = 0.3;\n\nBRp.registerArrowShapes = function () {\n  var arrowShapes = this.arrowShapes = {};\n  var renderer = this;\n\n  // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n    var x1 = translation.x - size / 2 - padding;\n    var x2 = translation.x + size / 2 + padding;\n    var y1 = translation.y - size / 2 - padding;\n    var y2 = translation.y + size / 2 + padding;\n\n    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\n    return inside;\n  };\n\n  var transform = function transform(x, y, size, angle, translation) {\n    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n\n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n\n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n\n  var transformPoints = function transformPoints(pts, size, angle, translation) {\n    var retPts = [];\n\n    for (var i = 0; i < pts.length; i += 2) {\n      var x = pts[i];\n      var y = pts[i + 1];\n\n      retPts.push(transform(x, y, size, angle, translation));\n    }\n\n    return retPts;\n  };\n\n  var pointsToArr = function pointsToArr(pts) {\n    var ret = [];\n\n    for (var i = 0; i < pts.length; i++) {\n      var p = pts[i];\n\n      ret.push(p.x, p.y);\n    }\n\n    return ret;\n  };\n\n  var standardGap = function standardGap(edge) {\n    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n  };\n\n  var defineArrowShape = function defineArrowShape(name, defn) {\n    if (is.string(defn)) {\n      defn = arrowShapes[defn];\n    }\n\n    arrowShapes[name] = util.extend({\n      name: name,\n\n      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n\n      collide: function collide(x, y, size, angle, translation, padding) {\n        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var inside = math.pointInsidePolygonPoints(x, y, points);\n\n        return inside;\n      },\n\n      roughCollide: bbCollide,\n\n      draw: function draw(context, size, angle, translation) {\n        var points = transformPoints(this.points, size, angle, translation);\n\n        renderer.arrowShapeImpl('polygon')(context, points);\n      },\n\n      spacing: function spacing(edge) {\n        return 0;\n      },\n\n      gap: standardGap\n    }, defn);\n  };\n\n  defineArrowShape('none', {\n    collide: util.falsify,\n\n    roughCollide: util.falsify,\n\n    draw: util.noop,\n\n    spacing: util.zeroify,\n\n    gap: util.zeroify\n  });\n\n  defineArrowShape('triangle', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n  });\n\n  defineArrowShape('arrow', 'triangle');\n\n  defineArrowShape('triangle-backcurve', {\n    points: arrowShapes['triangle'].points,\n\n    controlPoint: [0, -0.15],\n\n    roughCollide: bbCollide,\n\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var ptsTrans = transformPoints(this.points, size, angle, translation);\n      var ctrlPt = this.controlPoint;\n      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n\n      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n    },\n\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.985;\n    }\n  });\n\n  defineArrowShape('triangle-tee', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],\n\n    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n\n      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);\n\n      return inside;\n    },\n\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var teePts = transformPoints(this.pointsTee, size, angle, translation);\n\n      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n    }\n  });\n\n  defineArrowShape('triangle-cross', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],\n\n    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle\n    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle\n    0.15, -0.4],\n\n    crossLinePts: function crossLinePts(size, edgeWidth) {\n      // shift points so that the distance between the cross points matches edge width\n      var p = this.baseCrossLinePts.slice();\n      var shiftFactor = edgeWidth / size;\n      var y0 = 3;\n      var y1 = 5;\n\n      p[y0] = p[y0] - shiftFactor;\n      p[y1] = p[y1] - shiftFactor;\n\n      return p;\n    },\n\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);\n\n      return inside;\n    },\n\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n\n      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n    }\n  });\n\n  defineArrowShape('vee', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.985;\n    }\n  });\n\n  defineArrowShape('circle', {\n    radius: 0.15,\n\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var t = translation;\n      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n\n      return inside;\n    },\n\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n    },\n\n    spacing: function spacing(edge) {\n      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n    }\n  });\n\n  defineArrowShape('tee', {\n    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n\n    spacing: function spacing(edge) {\n      return 1;\n    },\n\n    gap: function gap(edge) {\n      return 1;\n    }\n  });\n\n  defineArrowShape('square', {\n    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n  });\n\n  defineArrowShape('diamond', {\n    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n\n    gap: function gap(edge) {\n      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n    }\n  });\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar window = __webpack_require__(4);\nvar math = __webpack_require__(2);\nvar util = __webpack_require__(1);\nvar window = __webpack_require__(4);\n\nvar BRp = {};\n\n// Project mouse\nBRp.projectIntoViewport = function (clientX, clientY) {\n  var cy = this.cy;\n  var offsets = this.findContainerClientCoords();\n  var offsetLeft = offsets[0];\n  var offsetTop = offsets[1];\n  var scale = offsets[4];\n  var pan = cy.pan();\n  var zoom = cy.zoom();\n\n  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n\n  return [x, y];\n};\n\nBRp.findContainerClientCoords = function () {\n  if (this.containerBB) {\n    return this.containerBB;\n  }\n\n  var container = this.container;\n  var rect = container.getBoundingClientRect();\n  var style = window.getComputedStyle(container);\n  var styleValue = function styleValue(name) {\n    return parseFloat(style.getPropertyValue(name));\n  };\n\n  var padding = {\n    left: styleValue('padding-left'),\n    right: styleValue('padding-right'),\n    top: styleValue('padding-top'),\n    bottom: styleValue('padding-bottom')\n  };\n\n  var border = {\n    left: styleValue('border-left-width'),\n    right: styleValue('border-right-width'),\n    top: styleValue('border-top-width'),\n    bottom: styleValue('border-bottom-width')\n  };\n\n  var clientWidth = container.clientWidth;\n  var clientHeight = container.clientHeight;\n\n  var paddingHor = padding.left + padding.right;\n  var paddingVer = padding.top + padding.bottom;\n\n  var borderHor = border.left + border.right;\n  var borderVer = border.top + border.bottom;\n\n  var scale = rect.width / (clientWidth + borderHor);\n\n  var unscaledW = clientWidth - paddingHor;\n  var unscaledH = clientHeight - paddingVer;\n\n  var scaledW = rect.width - (paddingHor + borderHor) * scale;\n  var scaledH = rect.height - (paddingVer + borderVer) * scale;\n\n  var left = rect.left + padding.left + border.left;\n  var top = rect.top + padding.top + border.top;\n\n  return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n};\n\nBRp.invalidateContainerClientCoordsCache = function () {\n  this.containerBB = null;\n};\n\nBRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\n\nBRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n  var self = this;\n  var r = this;\n  var eles = r.getCachedZSortedEles();\n  var near = []; // 1 node max, 1 edge max\n  var zoom = r.cy.zoom();\n  var hasCompounds = r.cy.hasCompoundNodes();\n  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n  var minSqDist = Infinity;\n  var nearEdge;\n  var nearNode;\n\n  if (interactiveElementsOnly) {\n    eles = eles.interactive;\n  }\n\n  function addEle(ele, sqDist) {\n    if (ele.isNode()) {\n      if (nearNode) {\n        return; // can't replace node\n      } else {\n        nearNode = ele;\n        near.push(ele);\n      }\n    }\n\n    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n      if (nearEdge) {\n        // then replace existing edge\n        // can replace only if same z-index\n        if (nearEdge.pstyle('z-index').value === ele.pstyle('z-index').value) {\n          for (var i = 0; i < near.length; i++) {\n            if (near[i].isEdge()) {\n              near[i] = ele;\n              nearEdge = ele;\n              minSqDist = sqDist != null ? sqDist : minSqDist;\n              break;\n            }\n          }\n        }\n      } else {\n        near.push(ele);\n        nearEdge = ele;\n        minSqDist = sqDist != null ? sqDist : minSqDist;\n      }\n    }\n  }\n\n  function checkNode(node) {\n    var width = node.outerWidth() + 2 * nodeThreshold;\n    var height = node.outerHeight() + 2 * nodeThreshold;\n    var hw = width / 2;\n    var hh = height / 2;\n    var pos = node.position();\n\n    if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n    && pos.y - hh <= y && y <= pos.y + hh // bb check y\n    ) {\n        var shape = r.nodeShapes[self.getNodeShape(node)];\n\n        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n          addEle(node, 0);\n          return true;\n        }\n      }\n  }\n\n  function checkEdge(edge) {\n    var _p = edge._private;\n\n    var rs = _p.rscratch;\n    var styleWidth = edge.pstyle('width').pfValue;\n    var scale = edge.pstyle('arrow-scale').value;\n    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n    var widthSq = width * width;\n    var width2 = width * 2;\n    var src = _p.source;\n    var tgt = _p.target;\n    var inEdgeBB = false;\n    var sqDist;\n\n    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n      var pts = rs.allpts;\n\n      for (var i = 0; i + 3 < pts.length; i += 2) {\n        if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n      var pts = rs.allpts;\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    }\n\n    // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\n    var src = src || _p.source;\n    var tgt = tgt || _p.target;\n\n    var arSize = self.getArrowWidth(styleWidth, scale);\n\n    var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];\n\n    for (var i = 0; i < arrows.length; i++) {\n      var ar = arrows[i];\n      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n      var edgeWidth = edge.pstyle('width').pfValue;\n      if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {\n        addEle(edge);\n        return true;\n      }\n    }\n\n    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n    if (hasCompounds && near.length > 0) {\n      checkNode(src);\n      checkNode(tgt);\n    }\n  }\n\n  function preprop(obj, name, pre) {\n    return util.getPrefixedProperty(obj, name, pre);\n  }\n\n  function checkLabel(ele, prefix) {\n    var _p = ele._private;\n    var th = labelThreshold;\n\n    var prefixDash;\n    if (prefix) {\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n\n    var text = ele.pstyle(prefixDash + 'label').value;\n    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n\n    if (!eventsEnabled || !text) {\n      return;\n    }\n\n    var rstyle = _p.rstyle;\n    var bw = ele.pstyle('text-border-width').pfValue;\n    var pw = ele.pstyle('text-background-padding').pfValue;\n    var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;\n    var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;\n    var lx = preprop(rstyle, 'labelX', prefix);\n    var ly = preprop(rstyle, 'labelY', prefix);\n\n    var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n\n    var lx1 = lx - lw / 2;\n    var lx2 = lx + lw / 2;\n    var ly1 = ly - lh / 2;\n    var ly2 = ly + lh / 2;\n\n    if (theta) {\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta);\n\n      var rotate = function rotate(x, y) {\n        x = x - lx;\n        y = y - ly;\n\n        return {\n          x: x * cos - y * sin + lx,\n          y: x * sin + y * cos + ly\n        };\n      };\n\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n\n      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];\n\n      if (math.pointInsidePolygonPoints(x, y, points)) {\n        addEle(ele);\n        return true;\n      }\n    } else {\n      // do a cheaper bb check\n      var bb = {\n        w: lw,\n        h: lh,\n        x1: lx1,\n        x2: lx2,\n        y1: ly1,\n        y2: ly2\n      };\n\n      if (math.inBoundingBox(bb, x, y)) {\n        addEle(ele);\n        return true;\n      }\n    }\n  }\n\n  for (var i = eles.length - 1; i >= 0; i--) {\n    // reverse order for precedence\n    var ele = eles[i];\n\n    if (ele.isNode()) {\n      checkNode(ele) || checkLabel(ele);\n    } else {\n      // then edge\n      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n    }\n  }\n\n  return near;\n};\n\n// 'Give me everything from this box'\nBRp.getAllInBox = function (x1, y1, x2, y2) {\n  var eles = this.getCachedZSortedEles().interactive;\n  var box = [];\n\n  var x1c = Math.min(x1, x2);\n  var x2c = Math.max(x1, x2);\n  var y1c = Math.min(y1, y2);\n  var y2c = Math.max(y1, y2);\n\n  x1 = x1c;\n  x2 = x2c;\n  y1 = y1c;\n  y2 = y2c;\n\n  var boxBb = math.makeBoundingBox({\n    x1: x1, y1: y1,\n    x2: x2, y2: y2\n  });\n\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n\n    if (ele.isNode()) {\n      var node = ele;\n      var nodeBb = node.boundingBox({\n        includeNodes: true,\n        includeEdges: false,\n        includeLabels: false\n      });\n\n      if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {\n        box.push(node);\n      }\n    } else {\n      var edge = ele;\n      var _p = edge._private;\n      var rs = _p.rscratch;\n\n      if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {\n        continue;\n      }\n      if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {\n        continue;\n      }\n\n      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n\n        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n        var allInside = true;\n\n        for (var i = 0; i < pts.length; i++) {\n          if (!math.pointInBoundingBox(boxBb, pts[i])) {\n            allInside = false;\n            break;\n          }\n        }\n\n        if (allInside) {\n          box.push(edge);\n        }\n      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n        box.push(edge);\n      }\n    }\n  }\n\n  return box;\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\n\nvar BRp = {};\n\nBRp.calculateArrowAngles = function (edge) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n  var isBezier = rs.edgeType === 'bezier';\n  var isMultibezier = rs.edgeType === 'multibezier';\n  var isSegments = rs.edgeType === 'segments';\n  var isCompound = rs.edgeType === 'compound';\n  var isSelf = rs.edgeType === 'self';\n\n  // Displacement gives direction for arrowhead orientation\n  var dispX, dispY;\n  var startX, startY, endX, endY, midX, midY;\n\n  if (isHaystack) {\n    startX = rs.haystackPts[0];\n    startY = rs.haystackPts[1];\n    endX = rs.haystackPts[2];\n    endY = rs.haystackPts[3];\n  } else {\n    startX = rs.arrowStartX;\n    startY = rs.arrowStartY;\n    endX = rs.arrowEndX;\n    endY = rs.arrowEndY;\n  }\n\n  midX = rs.midX;\n  midY = rs.midY;\n\n  // source\n  //\n\n  if (isSegments) {\n    dispX = startX - rs.segpts[0];\n    dispY = startY - rs.segpts[1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);\n    var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);\n\n    dispX = startX - bX;\n    dispY = startY - bY;\n  } else {\n    dispX = startX - midX;\n    dispY = startY - midY;\n  }\n\n  rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\n  // mid target\n  //\n\n  var midX = rs.midX;\n  var midY = rs.midY;\n\n  if (isHaystack) {\n    midX = (startX + endX) / 2;\n    midY = (startY + endY) / 2;\n  }\n\n  dispX = endX - startX;\n  dispY = endY - startY;\n\n  if (isSegments) {\n    var pts = rs.allpts;\n\n    if (pts.length / 2 % 2 === 0) {\n      var i2 = pts.length / 2;\n      var i1 = i2 - 2;\n\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i1 = i2 - 2;\n      var i3 = i2 + 2;\n\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    }\n  } else if (isMultibezier || isCompound || isSelf) {\n    var pts = rs.allpts;\n    var cpts = rs.ctrlpts;\n    var bp0x, bp0y;\n    var bp1x, bp1y;\n\n    if (cpts.length / 2 % 2 === 0) {\n      var p0 = pts.length / 2 - 1; // startpt\n      var ic = p0 + 2;\n      var p1 = ic + 2;\n\n      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n\n      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n    } else {\n      var ic = pts.length / 2 - 1; // ctrpt\n      var p0 = ic - 2; // startpt\n      var p1 = ic + 2; // endpt\n\n      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n\n      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n    }\n\n    dispX = bp1x - bp0x;\n    dispY = bp1y - bp0y;\n  }\n\n  rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\n  rs.midDispX = dispX;\n  rs.midDispY = dispY;\n\n  // mid source\n  //\n\n  dispX *= -1;\n  dispY *= -1;\n\n  if (isSegments) {\n    var pts = rs.allpts;\n\n    if (pts.length / 2 % 2 === 0) {\n      // already ok\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i3 = i2 + 2;\n\n      dispX = -(pts[i3] - pts[i2]);\n      dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n    }\n  }\n\n  rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);\n\n  // target\n  //\n\n  if (isSegments) {\n    dispX = endX - rs.segpts[rs.segpts.length - 2];\n    dispY = endY - rs.segpts[rs.segpts.length - 1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var l = pts.length;\n    var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n    var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n\n    dispX = endX - bX;\n    dispY = endY - bY;\n  } else {\n    dispX = endX - midX;\n    dispY = endY - midY;\n  }\n\n  rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);\n};\n\nBRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {\n  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\n  var cachedVal = cache[edgeWidth + ', ' + scale];\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n  cache[edgeWidth + ', ' + scale] = cachedVal;\n\n  return cachedVal;\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\n\nvar BRp = {};\n\nBRp.findEdgeControlPoints = function (edges) {\n  if (!edges || edges.length === 0) {\n    return;\n  }\n\n  var r = this;\n  var cy = r.cy;\n  var hasCompounds = cy.hasCompoundNodes();\n  var hashTable = {};\n  var pairIds = [];\n  var haystackEdges = [];\n\n  // create a table of edge (src, tgt) => list of edges between them\n  var pairId;\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var _p = edge._private;\n    var data = _p.data;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n\n    // ignore edges who are not to be displayed\n    // they shouldn't take up space\n    if (edge.pstyle('display').value === 'none') {\n      continue;\n    }\n\n    if (curveStyle === 'haystack') {\n      haystackEdges.push(edge);\n      continue;\n    }\n\n    var srcId = data.source;\n    var tgtId = data.target;\n\n    pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;\n\n    if (edgeIsUnbundled) {\n      pairId = 'unbundled' + '$-$' + data.id;\n    }\n\n    var tableEntry = hashTable[pairId];\n\n    if (tableEntry == null) {\n      tableEntry = hashTable[pairId] = [];\n      pairIds.push(pairId);\n    }\n\n    tableEntry.push(edge);\n\n    if (edgeIsUnbundled) {\n      tableEntry.hasUnbundled = true;\n    }\n\n    if (edgeIsBezier) {\n      tableEntry.hasBezier = true;\n    }\n  }\n\n  var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;\n  var vectorNormInverse;\n  var badBezier;\n\n  // for each pair (src, tgt), create the ctrl pts\n  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n  for (var p = 0; p < pairIds.length; p++) {\n    pairId = pairIds[p];\n    var pairEdges = hashTable[pairId];\n\n    // for each pair id, the edges should be sorted by index\n    pairEdges.sort(function (edge1, edge2) {\n      return edge1.poolIndex() - edge2.poolIndex();\n    });\n\n    src = pairEdges[0]._private.source;\n    tgt = pairEdges[0]._private.target;\n\n    // make sure src/tgt distinction is consistent for bundled edges\n    if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {\n      var temp = src;\n      src = tgt;\n      tgt = temp;\n    }\n\n    srcPos = src.position();\n    tgtPos = tgt.position();\n\n    srcW = src.outerWidth();\n    srcH = src.outerHeight();\n\n    tgtW = tgt.outerWidth();\n    tgtH = tgt.outerHeight();\n\n    srcShape = r.nodeShapes[this.getNodeShape(src)];\n    tgtShape = r.nodeShapes[this.getNodeShape(tgt)];\n\n    badBezier = false;\n\n    var edge;\n    var edge_p;\n    var rs;\n\n    var dirCounts = {\n      'north': 0,\n      'west': 0,\n      'south': 0,\n      'east': 0,\n      'northwest': 0,\n      'southwest': 0,\n      'northeast': 0,\n      'southeast': 0\n    };\n\n    var srcX2 = srcPos.x;\n    var srcY2 = srcPos.y;\n    var srcW2 = srcW;\n    var srcH2 = srcH;\n\n    var tgtX2 = tgtPos.x;\n    var tgtY2 = tgtPos.y;\n    var tgtW2 = tgtW;\n    var tgtH2 = tgtH;\n\n    var numEdges2 = pairEdges.length;\n\n    for (var i = 0; i < pairEdges.length; i++) {\n      edge = pairEdges[i];\n      edge_p = edge._private;\n      rs = edge_p.rscratch;\n\n      var edgeIndex1 = rs.lastEdgeIndex;\n      var edgeIndex2 = i;\n\n      var numEdges1 = rs.lastNumEdges;\n\n      var curveStyle = edge.pstyle('curve-style').value;\n\n      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\n      // whether the normalised pair order is the reverse of the edge's src-tgt order\n      var edgeIsSwapped = src.id() !== edge.source().id();\n\n      var ctrlptDists = edge.pstyle('control-point-distances');\n      var loopDir = edge.pstyle('loop-direction').pfValue;\n      var loopSwp = edge.pstyle('loop-sweep').pfValue;\n      var ctrlptWs = edge.pstyle('control-point-weights');\n      var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n      var stepSize = edge.pstyle('control-point-step-size').pfValue;\n      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n      var ctrlptWeight = ctrlptWs.value[0];\n      var edgeDistances = edge.pstyle('edge-distances').value;\n      var segmentWs = edge.pstyle('segment-weights');\n      var segmentDs = edge.pstyle('segment-distances');\n      var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n      var srcEndpt = edge.pstyle('source-endpoint').value;\n      var tgtEndpt = edge.pstyle('target-endpoint').value;\n      var srcArrShape = edge.pstyle('source-arrow-shape').value;\n      var tgtArrShape = edge.pstyle('target-arrow-shape').value;\n      var arrowScale = edge.pstyle('arrow-scale').value;\n      var lineWidth = edge.pstyle('width').pfValue;\n\n      var srcX1 = rs.lastSrcCtlPtX;\n      var srcY1 = rs.lastSrcCtlPtY;\n      var srcW1 = rs.lastSrcCtlPtW;\n      var srcH1 = rs.lastSrcCtlPtH;\n\n      var tgtX1 = rs.lastTgtCtlPtX;\n      var tgtY1 = rs.lastTgtCtlPtY;\n      var tgtW1 = rs.lastTgtCtlPtW;\n      var tgtH1 = rs.lastTgtCtlPtH;\n\n      var curveStyle1 = rs.lastCurveStyle;\n      var curveStyle2 = curveStyle;\n\n      var ctrlptDists1 = rs.lastCtrlptDists;\n      var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;\n\n      var ctrlptWs1 = rs.lastCtrlptWs;\n      var ctrlptWs2 = ctrlptWs.strValue;\n\n      var segmentWs1 = rs.lastSegmentWs;\n      var segmentWs2 = segmentWs.strValue;\n\n      var segmentDs1 = rs.lastSegmentDs;\n      var segmentDs2 = segmentDs.strValue;\n\n      var stepSize1 = rs.lastStepSize;\n      var stepSize2 = stepSize;\n\n      var loopDir1 = rs.lastLoopDir;\n      var loopDir2 = loopDir;\n\n      var loopSwp1 = rs.lastLoopSwp;\n      var loopSwp2 = loopSwp;\n\n      var edgeDistances1 = rs.lastEdgeDistances;\n      var edgeDistances2 = edgeDistances;\n\n      var srcEndpt1 = rs.lastSrcEndpt;\n      var srcEndpt2 = srcEndpt;\n\n      var tgtEndpt1 = rs.lastTgtEndpt;\n      var tgtEndpt2 = tgtEndpt;\n\n      var srcArr1 = rs.lastSrcArr;\n      var srcArr2 = srcArrShape;\n\n      var tgtArr1 = rs.lastTgtArr;\n      var tgtArr2 = tgtArrShape;\n\n      var lineW1 = rs.lastLineW;\n      var lineW2 = lineWidth;\n\n      var arrScl1 = rs.lastArrScl;\n      var arrScl2 = arrowScale;\n\n      if (badBezier) {\n        rs.badBezier = true;\n      } else {\n        rs.badBezier = false;\n      }\n\n      var ptCacheHit;\n\n      if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {\n        ptCacheHit = true; // then the control points haven't changed and we can skip calculating them\n      } else {\n        ptCacheHit = false;\n\n        rs.lastSrcCtlPtX = srcX2;\n        rs.lastSrcCtlPtY = srcY2;\n        rs.lastSrcCtlPtW = srcW2;\n        rs.lastSrcCtlPtH = srcH2;\n        rs.lastTgtCtlPtX = tgtX2;\n        rs.lastTgtCtlPtY = tgtY2;\n        rs.lastTgtCtlPtW = tgtW2;\n        rs.lastTgtCtlPtH = tgtH2;\n        rs.lastEdgeIndex = edgeIndex2;\n        rs.lastNumEdges = numEdges2;\n        rs.lastCurveStyle = curveStyle2;\n        rs.lastCtrlptDists = ctrlptDists2;\n        rs.lastCtrlptWs = ctrlptWs2;\n        rs.lastSegmentDs = segmentDs2;\n        rs.lastSegmentWs = segmentWs2;\n        rs.lastStepSize = stepSize2;\n        rs.lastLoopDir = loopDir2;\n        rs.lastLoopSwp = loopSwp2;\n        rs.lastEdgeDistances = edgeDistances2;\n        rs.lastSrcEndpt = srcEndpt2;\n        rs.lastTgtEndpt = tgtEndpt2;\n        rs.lastSrcArr = srcArr2;\n        rs.lastTgtArr = tgtArr2;\n        rs.lastLineW = lineW2;\n        rs.lastArrScl = arrScl2;\n      }\n\n      if (!ptCacheHit) {\n\n        if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {\n\n          pairEdges.calculatedIntersection = true;\n\n          // pt outside src shape to calc distance/displacement from src to tgt\n          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n\n          pairEdges.srcIntn = srcOutside;\n\n          // pt outside tgt shape to calc distance/displacement from src to tgt\n          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n\n          pairEdges.tgtIntn = tgtOutside;\n\n          var midptSrcPts = {\n            x1: srcOutside[0],\n            x2: tgtOutside[0],\n            y1: srcOutside[1],\n            y2: tgtOutside[1]\n          };\n\n          var posPts = {\n            x1: srcPos.x,\n            x2: tgtPos.x,\n            y1: srcPos.y,\n            y2: tgtPos.y\n          };\n\n          var dy = tgtOutside[1] - srcOutside[1];\n          var dx = tgtOutside[0] - srcOutside[0];\n          var l = Math.sqrt(dx * dx + dy * dy);\n\n          var vector = {\n            x: dx,\n            y: dy\n          };\n\n          var vectorNorm = {\n            x: vector.x / l,\n            y: vector.y / l\n          };\n          vectorNormInverse = {\n            x: -vectorNorm.y,\n            y: vectorNorm.x\n          };\n\n          // if node shapes overlap, then no ctrl pts to draw\n          if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {\n            vectorNormInverse = {};\n            badBezier = true;\n          }\n        }\n\n        if (!edgeIsSwapped) {\n          rs.srcIntn = pairEdges.srcIntn;\n          rs.tgtIntn = pairEdges.tgtIntn;\n        } else {\n          // ensure that the per-edge cached value for intersections are correct for swapped bundled edges\n          rs.srcIntn = pairEdges.tgtIntn;\n          rs.tgtIntn = pairEdges.srcIntn;\n        }\n\n        if (src === tgt) {\n          // Self-edge\n\n          rs.edgeType = 'self';\n\n          var j = i;\n          var loopDist = stepSize;\n\n          if (edgeIsUnbundled) {\n            j = 0;\n            loopDist = ctrlptDist;\n          }\n\n          var loopAngle = loopDir - Math.PI / 2;\n          var outAngle = loopAngle - loopSwp / 2;\n          var inAngle = loopAngle + loopSwp / 2;\n\n          // increase by step size for overlapping loops, keyed on direction and sweep values\n          var dc = String(loopDir + '_' + loopSwp);\n          j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n\n          rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n        } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {\n          // Compound edge\n\n          rs.edgeType = 'compound';\n\n          // because the line approximation doesn't apply for compound beziers\n          // (loop/self edges are already elided b/c of cheap src==tgt check)\n          rs.badBezier = false;\n\n          var j = i;\n          var loopDist = stepSize;\n\n          if (edgeIsUnbundled) {\n            j = 0;\n            loopDist = ctrlptDist;\n          }\n\n          var loopW = 50;\n\n          var loopaPos = {\n            x: srcPos.x - srcW / 2,\n            y: srcPos.y - srcH / 2\n          };\n\n          var loopbPos = {\n            x: tgtPos.x - tgtW / 2,\n            y: tgtPos.y - tgtH / 2\n          };\n\n          var loopPos = {\n            x: Math.min(loopaPos.x, loopbPos.x),\n            y: Math.min(loopaPos.y, loopbPos.y)\n          };\n\n          // avoids cases with impossible beziers\n          var minCompoundStretch = 0.5;\n          var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n          var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n\n          rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n        } else if (curveStyle === 'segments') {\n          // Segments (multiple straight lines)\n\n          rs.edgeType = 'segments';\n          rs.segpts = [];\n\n          for (var s = 0; s < segmentsN; s++) {\n            var w = segmentWs.pfValue[s];\n            var d = segmentDs.pfValue[s];\n\n            var w1 = 1 - w;\n            var w2 = w;\n\n            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\n            var adjustedMidpt = {\n              x: midptPts.x1 * w1 + midptPts.x2 * w2,\n              y: midptPts.y1 * w1 + midptPts.y2 * w2\n            };\n\n            rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n          }\n\n          // Straight edge\n        } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {\n\n          rs.edgeType = 'straight';\n        } else {\n          // (Multi)bezier\n\n          var multi = edgeIsUnbundled;\n\n          rs.edgeType = multi ? 'multibezier' : 'bezier';\n          rs.ctrlpts = [];\n\n          for (var b = 0; b < bezierN; b++) {\n            var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n            var manctrlptDist;\n            var sign = math.signum(normctrlptDist);\n\n            if (multi) {\n              ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n              ctrlptWeight = ctrlptWs.value[b];\n            }\n\n            if (edgeIsUnbundled) {\n              // multi or single unbundled\n              manctrlptDist = ctrlptDist;\n            } else {\n              manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n            }\n\n            var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n\n            var w1 = 1 - ctrlptWeight;\n            var w2 = ctrlptWeight;\n\n            if (edgeIsSwapped) {\n              var temp = w1;\n              w1 = w2;\n              w2 = temp;\n            }\n\n            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\n            var adjustedMidpt = {\n              x: midptPts.x1 * w1 + midptPts.x2 * w2,\n              y: midptPts.y1 * w1 + midptPts.y2 * w2\n            };\n\n            rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n          }\n        }\n\n        // find endpts for edge\n        this.findEndpoints(edge);\n\n        var badStart = !is.number(rs.startX) || !is.number(rs.startY);\n        var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);\n        var badEnd = !is.number(rs.endX) || !is.number(rs.endY);\n        var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);\n\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n        var minCpADist = minCpADistFactor * arrowW;\n\n        if (rs.edgeType === 'bezier') {\n          var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });\n          var closeStartACp = startACpDist < minCpADist;\n          var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });\n          var closeEndACp = endACpDist < minCpADist;\n\n          var overlapping = false;\n\n          if (badStart || badAStart || closeStartACp) {\n            overlapping = true;\n\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.ctrlpts[0] - srcPos.x,\n              y: rs.ctrlpts[1] - srcPos.y\n            };\n            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n              y: rs.ctrlpts[1] + cpM.y * 2 * radius\n            };\n\n            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n\n            if (closeStartACp) {\n              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n            } else {\n              rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n              rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n          }\n\n          if (badEnd || badAEnd || closeEndACp) {\n            overlapping = true;\n\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.ctrlpts[0] - tgtPos.x,\n              y: rs.ctrlpts[1] - tgtPos.y\n            };\n            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n              y: rs.ctrlpts[1] + cpM.y * 2 * radius\n            };\n\n            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);\n\n            if (closeEndACp) {\n              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);\n              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);\n            } else {\n              rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;\n              rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n          }\n\n          if (overlapping) {\n            // recalc endpts\n            this.findEndpoints(edge);\n          }\n        }\n\n        if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n          rs.allpts = [];\n\n          rs.allpts.push(rs.startX, rs.startY);\n\n          for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n            // ctrl pt itself\n            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n\n            // the midpt between ctrlpts as intermediate destination pts\n            if (b + 3 < rs.ctrlpts.length) {\n              rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n            }\n          }\n\n          rs.allpts.push(rs.endX, rs.endY);\n\n          var m, mt;\n          if (rs.ctrlpts.length / 2 % 2 === 0) {\n            m = rs.allpts.length / 2 - 1;\n\n            rs.midX = rs.allpts[m];\n            rs.midY = rs.allpts[m + 1];\n          } else {\n            m = rs.allpts.length / 2 - 3;\n            mt = 0.5;\n\n            rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n            rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n          }\n        } else if (rs.edgeType === 'straight') {\n          // need to calc these after endpts\n          rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];\n\n          // default midpt for labels etc\n          rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n          rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n        } else if (rs.edgeType === 'segments') {\n          rs.allpts = [];\n          rs.allpts.push(rs.startX, rs.startY);\n          rs.allpts.push.apply(rs.allpts, rs.segpts);\n          rs.allpts.push(rs.endX, rs.endY);\n\n          if (rs.segpts.length % 4 === 0) {\n            var i2 = rs.segpts.length / 2;\n            var i1 = i2 - 2;\n\n            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n          } else {\n            var i1 = rs.segpts.length / 2 - 1;\n\n            rs.midX = rs.segpts[i1];\n            rs.midY = rs.segpts[i1 + 1];\n          }\n        }\n\n        this.storeEdgeProjections(edge);\n        this.calculateArrowAngles(edge);\n      } // if point cache miss\n\n      this.recalculateEdgeLabelProjections(edge);\n      this.calculateLabelAngles(edge);\n    } // for pair edges\n  } // for pair ids\n\n  for (var i = 0; i < haystackEdges.length; i++) {\n    var edge = haystackEdges[i];\n    var _p = edge._private;\n    var rscratch = _p.rscratch;\n    var rs = rscratch;\n\n    if (!rscratch.haystack) {\n      var angle = Math.random() * 2 * Math.PI;\n\n      rscratch.source = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n\n      var angle = Math.random() * 2 * Math.PI;\n\n      rscratch.target = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n    }\n\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcPos = src.position();\n    var tgtPos = tgt.position();\n    var srcW = src.width();\n    var tgtW = tgt.width();\n    var srcH = src.height();\n    var tgtH = tgt.height();\n    var radius = edge.pstyle('haystack-radius').value;\n    var halfRadius = radius / 2; // b/c have to half width/height\n\n    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n\n    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n\n    // always override as haystack in case set to different type previously\n    rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';\n    rscratch.haystack = true;\n\n    this.storeEdgeProjections(edge);\n    this.calculateArrowAngles(edge);\n    this.recalculateEdgeLabelProjections(edge);\n    this.calculateLabelAngles(edge);\n  }\n};\n\nfunction getPts(pts) {\n  var retPts = [];\n\n  if (pts == null) {\n    return;\n  }\n\n  for (var i = 0; i < pts.length; i += 2) {\n    var x = pts[i];\n    var y = pts[i + 1];\n\n    retPts.push({ x: x, y: y });\n  }\n\n  return retPts;\n}\n\nBRp.getSegmentPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  var type = rs.edgeType;\n\n  if (type === 'segments') {\n    return getPts(rs.segpts);\n  }\n};\n\nBRp.getControlPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  var type = rs.edgeType;\n\n  if (type === 'bezier' || type === 'multibezier') {\n    return getPts(rs.ctrlpts);\n  }\n};\n\nBRp.getEdgeMidpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n\n  return {\n    x: rs.midX,\n    y: rs.midY\n  };\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\n\nvar BRp = {};\n\nBRp.manualEndptToPx = function (node, prop) {\n  var r = this;\n  var npos = node.position();\n  var w = node.outerWidth();\n  var h = node.outerHeight();\n\n  if (prop.value.length === 2) {\n    var p = [prop.pfValue[0], prop.pfValue[1]];\n\n    if (prop.units[0] === '%') {\n      p[0] = p[0] * w;\n    }\n\n    if (prop.units[1] === '%') {\n      p[1] = p[1] * h;\n    }\n\n    p[0] += npos.x;\n    p[1] += npos.y;\n\n    return p;\n  } else {\n    var angle = prop.pfValue[0];\n\n    angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\n    var l = 2 * Math.max(w, h);\n\n    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n\n    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n  }\n};\n\nBRp.findEndpoints = function (edge) {\n  var r = this;\n  var intersect = void 0;\n\n  var source = edge.source()[0];\n  var target = edge.target()[0];\n\n  var srcPos = source.position();\n  var tgtPos = target.position();\n\n  var tgtArShape = edge.pstyle('target-arrow-shape').value;\n  var srcArShape = edge.pstyle('source-arrow-shape').value;\n\n  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n  var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n\n  var rs = edge._private.rscratch;\n\n  var et = rs.edgeType;\n  var self = et === 'self' || et === 'compound';\n  var bezier = et === 'bezier' || et === 'multibezier' || self;\n  var multi = et !== 'bezier';\n  var lines = et === 'straight' || et === 'segments';\n  var segments = et === 'segments';\n  var hasEndpts = bezier || multi || lines;\n  var srcManEndpt = edge.pstyle('source-endpoint');\n  var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;\n  var tgtManEndpt = edge.pstyle('target-endpoint');\n  var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;\n\n  rs.srcManEndpt = srcManEndpt;\n  rs.tgtManEndpt = tgtManEndpt;\n\n  var p1 = void 0; // last known point of edge on target side\n  var p2 = void 0; // last known point of edge on source side\n\n  var p1_i = void 0; // point to intersect with target shape\n  var p2_i = void 0; // point to intersect with source shape\n\n  if (bezier) {\n    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n\n    p1 = cpEnd;\n    p2 = cpStart;\n  } else if (lines) {\n    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n\n    p1 = tgtArrowFromPt;\n    p2 = srcArrowFromPt;\n  }\n\n  if (tgtManEndptVal === 'inside-to-node') {\n    intersect = [tgtPos.x, tgtPos.y];\n  } else if (tgtManEndpt.units) {\n    intersect = this.manualEndptToPx(target, tgtManEndpt);\n  } else if (tgtManEndptVal === 'outside-to-line') {\n    intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n  } else {\n    if (tgtManEndptVal === 'outside-to-node') {\n      p1_i = p1;\n    } else if (tgtManEndptVal === 'outside-to-line') {\n      p1_i = [srcPos.x, srcPos.y];\n    }\n\n    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n  }\n\n  var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n  var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n\n  rs.endX = edgeEnd[0];\n  rs.endY = edgeEnd[1];\n\n  rs.arrowEndX = arrowEnd[0];\n  rs.arrowEndY = arrowEnd[1];\n\n  if (srcManEndptVal === 'inside-to-node') {\n    intersect = [srcPos.x, srcPos.y];\n  } else if (srcManEndpt.units) {\n    intersect = this.manualEndptToPx(source, srcManEndpt);\n  } else if (srcManEndptVal === 'outside-to-line') {\n    intersect = rs.srcIntn; // use cached value from ctrlpt calc\n  } else {\n    if (srcManEndptVal === 'outside-to-node') {\n      p2_i = p2;\n    } else if (srcManEndptVal === 'outside-to-line') {\n      p2_i = [tgtPos.x, tgtPos.y];\n    }\n\n    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n  }\n\n  var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n  var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n\n  rs.startX = edgeStart[0];\n  rs.startY = edgeStart[1];\n\n  rs.arrowStartX = arrowStart[0];\n  rs.arrowStartY = arrowStart[1];\n\n  if (hasEndpts) {\n    if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {\n      rs.badLine = true;\n    } else {\n      rs.badLine = false;\n    }\n  }\n};\n\nBRp.getSourceEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[0],\n        y: rs.haystackPts[1]\n      };\n    default:\n      return {\n        x: rs.arrowStartX,\n        y: rs.arrowStartY\n      };\n  }\n};\n\nBRp.getTargetEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[2],\n        y: rs.haystackPts[3]\n      };\n    default:\n      return {\n        x: rs.arrowEndX,\n        y: rs.arrowEndY\n      };\n  }\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\n\nvar BRp = {};\n\nfunction pushBezierPts(r, edge, pts) {\n  var qbezierAt = function qbezierAt(p1, p2, p3, t) {\n    return math.qbezierAt(p1, p2, p3, t);\n  };\n  var _p = edge._private;\n  var bpts = _p.rstyle.bezierPts;\n\n  for (var i = 0; i < r.bezierProjPcts.length; i++) {\n    var p = r.bezierProjPcts[i];\n\n    bpts.push({\n      x: qbezierAt(pts[0], pts[2], pts[4], p),\n      y: qbezierAt(pts[1], pts[3], pts[5], p)\n    });\n  }\n}\n\nBRp.storeEdgeProjections = function (edge) {\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var et = rs.edgeType;\n\n  // clear the cached points state\n  _p.rstyle.bezierPts = null;\n  _p.rstyle.linePts = null;\n  _p.rstyle.haystackPts = null;\n\n  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line\n\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n    }\n  } else if (et === 'segments') {\n    var lpts = _p.rstyle.linePts = [];\n\n    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n      lpts.push({\n        x: rs.allpts[i],\n        y: rs.allpts[i + 1]\n      });\n    }\n  } else if (et === 'haystack') {\n    var hpts = rs.haystackPts;\n\n    _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];\n  }\n\n  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n};\n\nBRp.recalculateEdgeProjections = function (edges) {\n  this.findEdgeControlPoints(edges);\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar BRp = {};\n\n[__webpack_require__(86), __webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(92), __webpack_require__(93), __webpack_require__(94), __webpack_require__(95)].forEach(function (props) {\n  util.extend(BRp, props);\n});\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\n\nvar BRp = {};\n\nBRp.recalculateNodeLabelProjection = function (node) {\n  var content = node.pstyle('label').strValue;\n\n  if (is.emptyString(content)) {\n    return;\n  }\n\n  var textX, textY;\n  var _p = node._private;\n  var nodeWidth = node.width();\n  var nodeHeight = node.height();\n  var padding = node.padding();\n  var nodePos = node.position();\n  var textHalign = node.pstyle('text-halign').strValue;\n  var textValign = node.pstyle('text-valign').strValue;\n  var rs = _p.rscratch;\n  var rstyle = _p.rstyle;\n\n  switch (textHalign) {\n    case 'left':\n      textX = nodePos.x - nodeWidth / 2 - padding;\n      break;\n\n    case 'right':\n      textX = nodePos.x + nodeWidth / 2 + padding;\n      break;\n\n    default:\n      // e.g. center\n      textX = nodePos.x;\n  }\n\n  switch (textValign) {\n    case 'top':\n      textY = nodePos.y - nodeHeight / 2 - padding;\n      break;\n\n    case 'bottom':\n      textY = nodePos.y + nodeHeight / 2 + padding;\n      break;\n\n    default:\n      // e.g. middle\n      textY = nodePos.y;\n  }\n\n  rs.labelX = textX;\n  rs.labelY = textY;\n  rstyle.labelX = textX;\n  rstyle.labelY = textY;\n\n  this.applyLabelDimensions(node);\n};\n\nBRp.recalculateEdgeLabelProjections = function (edge) {\n  var p;\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var r = this;\n  var content = {\n    mid: edge.pstyle('label').strValue,\n    source: edge.pstyle('source-label').strValue,\n    target: edge.pstyle('target-label').strValue\n  };\n\n  if (content.mid || content.source || content.target) {\n    // then we have to calculate...\n  } else {\n      return; // no labels => no calcs\n    }\n\n  // add center point to style so bounding box calculations can use it\n  //\n  p = {\n    x: rs.midX,\n    y: rs.midY\n  };\n\n  var setRs = function setRs(propName, prefix, value) {\n    util.setPrefixedProperty(_p.rscratch, propName, prefix, value);\n    util.setPrefixedProperty(_p.rstyle, propName, prefix, value);\n  };\n\n  setRs('labelX', null, p.x);\n  setRs('labelY', null, p.y);\n\n  var createControlPointInfo = function createControlPointInfo() {\n    if (createControlPointInfo.cache) {\n      return createControlPointInfo.cache;\n    } // use cache so only 1x per edge\n\n    var ctrlpts = [];\n\n    // store each ctrlpt info init\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };\n      var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt\n      var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };\n\n      ctrlpts.push({\n        p0: p0,\n        p1: p1,\n        p2: p2,\n        startDist: 0,\n        length: 0,\n        segments: []\n      });\n    }\n\n    var bpts = _p.rstyle.bezierPts;\n    var nProjs = r.bezierProjPcts.length;\n\n    function addSegment(cp, p0, p1, t0, t1) {\n      var length = math.dist(p0, p1);\n      var prevSegment = cp.segments[cp.segments.length - 1];\n      var segment = {\n        p0: p0,\n        p1: p1,\n        t0: t0,\n        t1: t1,\n        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n        length: length\n      };\n\n      cp.segments.push(segment);\n\n      cp.length += length;\n    }\n\n    // update each ctrlpt with segment info\n    for (var i = 0; i < ctrlpts.length; i++) {\n      var cp = ctrlpts[i];\n      var prevCp = ctrlpts[i - 1];\n\n      if (prevCp) {\n        cp.startDist = prevCp.startDist + prevCp.length;\n      }\n\n      addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first\n\n      for (var j = 0; j < nProjs - 1; j++) {\n        addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n      }\n\n      addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n    }\n\n    return createControlPointInfo.cache = ctrlpts;\n  };\n\n  var calculateEndProjection = function calculateEndProjection(prefix) {\n    var angle;\n    var isSrc = prefix === 'source';\n\n    if (!content[prefix]) {\n      return;\n    }\n\n    var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n\n    var lineAngle = function lineAngle(p0, p1) {\n      var dx = p1.x - p0.x;\n      var dy = p1.y - p0.y;\n\n      return Math.atan(dy / dx);\n    };\n\n    var bezierAngle = function bezierAngle(p0, p1, p2, t) {\n      var t0 = math.bound(0, t - 0.001, 1);\n      var t1 = math.bound(0, t + 0.001, 1);\n\n      var lp0 = math.qbezierPtAt(p0, p1, p2, t0);\n      var lp1 = math.qbezierPtAt(p0, p1, p2, t1);\n\n      return lineAngle(lp0, lp1);\n    };\n\n    switch (rs.edgeType) {\n      case 'self':\n      case 'compound':\n      case 'bezier':\n      case 'multibezier':\n        var cps = createControlPointInfo();\n        var selected;\n        var startDist = 0;\n        var totalDist = 0;\n\n        // find the segment we're on\n        for (var i = 0; i < cps.length; i++) {\n          var cp = cps[isSrc ? i : cps.length - 1 - i];\n\n          for (var j = 0; j < cp.segments.length; j++) {\n            var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];\n            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;\n\n            startDist = totalDist;\n            totalDist += seg.length;\n\n            if (totalDist >= offset || lastSeg) {\n              selected = { cp: cp, segment: seg };\n              break;\n            }\n          }\n\n          if (selected) {\n            break;\n          }\n        }\n\n        var cp = selected.cp;\n        var seg = selected.segment;\n        var tSegment = (offset - startDist) / seg.length;\n        var segDt = seg.t1 - seg.t0;\n        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n\n        t = math.bound(0, t, 1);\n        p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n        angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);\n\n        break;\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        var d = 0,\n            di,\n            d0;\n        var p0, p1;\n        var l = rs.allpts.length;\n\n        for (var i = 0; i + 3 < l; i += 2) {\n          if (isSrc) {\n            p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };\n            p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };\n          } else {\n            p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };\n            p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };\n          }\n\n          di = math.dist(p0, p1);\n          d0 = d;\n          d += di;\n\n          if (d >= offset) {\n            break;\n          }\n        }\n\n        var pD = offset - d0;\n        var t = pD / di;\n\n        t = math.bound(0, t, 1);\n        p = math.lineAt(p0, p1, t);\n        angle = lineAngle(p0, p1);\n\n        break;\n    }\n\n    setRs('labelX', prefix, p.x);\n    setRs('labelY', prefix, p.y);\n    setRs('labelAutoAngle', prefix, angle);\n  };\n\n  calculateEndProjection('source');\n  calculateEndProjection('target');\n\n  this.applyLabelDimensions(edge);\n};\n\nBRp.applyLabelDimensions = function (ele) {\n  this.applyPrefixedLabelDimensions(ele);\n\n  if (ele.isEdge()) {\n    this.applyPrefixedLabelDimensions(ele, 'source');\n    this.applyPrefixedLabelDimensions(ele, 'target');\n  }\n};\n\nBRp.applyPrefixedLabelDimensions = function (ele, prefix) {\n  var _p = ele._private;\n\n  var text = this.getLabelText(ele, prefix);\n  var labelDims = this.calculateLabelDimensions(ele, text);\n\n  util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);\n  util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);\n\n  util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);\n  util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);\n};\n\nBRp.getLabelText = function (ele, prefix) {\n  var _p = ele._private;\n  var pfd = prefix ? prefix + '-' : '';\n  var text = ele.pstyle(pfd + 'label').strValue;\n  var textTransform = ele.pstyle('text-transform').value;\n  var rscratch = function rscratch(propName, value) {\n    if (value) {\n      util.setPrefixedProperty(_p.rscratch, propName, prefix, value);\n      return value;\n    } else {\n      return util.getPrefixedProperty(_p.rscratch, propName, prefix);\n    }\n  };\n\n  if (textTransform == 'none') {\n    // passthrough\n  } else if (textTransform == 'uppercase') {\n    text = text.toUpperCase();\n  } else if (textTransform == 'lowercase') {\n    text = text.toLowerCase();\n  }\n\n  var wrapStyle = ele.pstyle('text-wrap').value;\n\n  if (wrapStyle === 'wrap') {\n    //console.log('wrap');\n\n    var labelKey = rscratch('labelKey');\n\n    // save recalc if the label is the same as before\n    if (labelKey && rscratch('labelWrapKey') === labelKey) {\n      // console.log('wrap cache hit');\n      return rscratch('labelWrapCachedText');\n    }\n    // console.log('wrap cache miss');\n\n    var lines = text.split('\\n');\n    var maxW = ele.pstyle('text-max-width').pfValue;\n    var wrappedLines = [];\n\n    for (var l = 0; l < lines.length; l++) {\n      var line = lines[l];\n      var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);\n      var lineW = lineDims.width;\n\n      if (lineW > maxW) {\n        // line is too long\n        var words = line.split(/\\s+/); // NB: assume collapsed whitespace into single space\n        var subline = '';\n\n        for (var w = 0; w < words.length; w++) {\n          var word = words[w];\n          var testLine = subline.length === 0 ? word : subline + ' ' + word;\n          var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);\n          var testW = testDims.width;\n\n          if (testW <= maxW) {\n            // word fits on current line\n            subline += word + ' ';\n          } else {\n            // word starts new line\n            wrappedLines.push(subline);\n            subline = word + ' ';\n          }\n        }\n\n        // if there's remaining text, put it in a wrapped line\n        if (!subline.match(/^\\s+$/)) {\n          wrappedLines.push(subline);\n        }\n      } else {\n        // line is already short enough\n        wrappedLines.push(line);\n      }\n    } // for\n\n    rscratch('labelWrapCachedLines', wrappedLines);\n    text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n    rscratch('labelWrapKey', labelKey);\n\n    // console.log(text)\n  } else if (wrapStyle === 'ellipsis') {\n    var maxW = ele.pstyle('text-max-width').pfValue;\n    var ellipsized = '';\n    var ellipsis = '\\u2026';\n    var incLastCh = false;\n\n    for (var i = 0; i < text.length; i++) {\n      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n\n      if (widthWithNextCh > maxW) {\n        break;\n      }\n\n      ellipsized += text[i];\n\n      if (i === text.length - 1) {\n        incLastCh = true;\n      }\n    }\n\n    if (!incLastCh) {\n      ellipsized += ellipsis;\n    }\n\n    return ellipsized;\n  } // if ellipsize\n\n  return text;\n};\n\nBRp.calculateLabelDimensions = function (ele, text, extraKey) {\n  var r = this;\n\n  var cacheKey = ele._private.labelStyleKey + '$@$' + text;\n\n  if (extraKey) {\n    cacheKey += '$@$' + extraKey;\n  }\n\n  var cache = r.labelDimCache || (r.labelDimCache = {});\n\n  if (cache[cacheKey]) {\n    return cache[cacheKey];\n  }\n\n  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text\n  var fStyle = ele.pstyle('font-style').strValue;\n  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';\n  var family = ele.pstyle('font-family').strValue;\n  var weight = ele.pstyle('font-weight').strValue;\n\n  var div = this.labelCalcDiv;\n\n  if (!div) {\n    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef\n    document.body.appendChild(div); // eslint-disable-line no-undef\n  }\n\n  var ds = div.style;\n\n  // from ele style\n  ds.fontFamily = family;\n  ds.fontStyle = fStyle;\n  ds.fontSize = size;\n  ds.fontWeight = weight;\n\n  // forced style\n  ds.position = 'absolute';\n  ds.left = '-9999px';\n  ds.top = '-9999px';\n  ds.zIndex = '-1';\n  ds.visibility = 'hidden';\n  ds.pointerEvents = 'none';\n  ds.padding = '0';\n  ds.lineHeight = '1';\n\n  if (ele.pstyle('text-wrap').value === 'wrap') {\n    ds.whiteSpace = 'pre'; // so newlines are taken into account\n  } else {\n    ds.whiteSpace = 'normal';\n  }\n\n  // put label content in div\n  div.textContent = text;\n\n  cache[cacheKey] = {\n    width: Math.ceil(div.clientWidth / sizeMult),\n    height: Math.ceil(div.clientHeight / sizeMult)\n  };\n\n  return cache[cacheKey];\n};\n\nBRp.calculateLabelAngles = function (ele) {\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  var isEdge = ele.isEdge();\n  var rot = ele.pstyle('text-rotation');\n  var rotStr = rot.strValue;\n\n  if (rotStr === 'none') {\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n  } else if (isEdge && rotStr === 'autorotate') {\n    rs.labelAngle = Math.atan(rs.midDispY / rs.midDispX);\n    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;\n    rs.targetLabelAngle = rs.targetLabelAutoAngle;\n  } else if (rotStr === 'autorotate') {\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n  } else {\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;\n  }\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BRp = {};\n\nBRp.getNodeShape = function (node) {\n  var r = this;\n  var shape = node.pstyle('shape').value;\n\n  if (node.isParent()) {\n    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {\n      return shape;\n    } else {\n      return 'rectangle';\n    }\n  }\n\n  if (shape === 'polygon') {\n    var points = node.pstyle('shape-polygon-points').value;\n\n    return r.nodeShapes.makePolygon(points).name;\n  }\n\n  return shape;\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BRp = {};\n\nBRp.registerCalculationListeners = function () {\n  var cy = this.cy;\n  var elesToUpdate = cy.collection();\n  var r = this;\n\n  var enqueue = function enqueue(eles, e, dirtyStyleCaches) {\n    elesToUpdate.merge(eles);\n\n    if (dirtyStyleCaches === true || dirtyStyleCaches === undefined) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n\n        rstyle.clean = false;\n        _p.bbCache = null;\n\n        var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };\n\n        if (!evts[e.type]) {\n          evts[e.type] = true;\n          evts.length++;\n        }\n      }\n    }\n  };\n\n  r.binder(cy)\n  // nodes\n\n  .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {\n    var node = e.target;\n\n    enqueue(node, e);\n    enqueue(node.connectedEdges(), e);\n  }).on('add.*', 'node', function onDirtyAddNode(e) {\n    var ele = e.target;\n\n    enqueue(ele, e);\n  }).on('background.*', 'node', function onDirtyBgNode(e) {\n    var ele = e.target;\n\n    enqueue(ele, e, false);\n  })\n\n  // edges\n\n  .on('add.* style.*', 'edge', function onDirtyEdge(e) {\n    var edge = e.target;\n\n    enqueue(edge, e);\n    enqueue(edge.parallelEdges(), e);\n  }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {\n    var edge = e.target;\n    var pEdges = edge.parallelEdges();\n\n    for (var i = 0; i < pEdges.length; i++) {\n      var pEdge = pEdges[i];\n\n      if (!pEdge.removed()) {\n        enqueue(pEdge, e);\n      }\n    }\n  })\n\n  // manual dirtying\n\n  .on('dirty.*', 'node', function onDirtyEle(e) {\n    var ele = e.target;\n\n    enqueue(ele, e);\n  });\n\n  var updateEleCalcs = function updateEleCalcs(willDraw) {\n    if (willDraw) {\n      var fns = r.onUpdateEleCalcsFns;\n\n      if (fns) {\n        for (var i = 0; i < fns.length; i++) {\n          var fn = fns[i];\n\n          fn(willDraw, elesToUpdate);\n        }\n      }\n\n      r.recalculateRenderedStyle(elesToUpdate, false);\n\n      for (var i = 0; i < elesToUpdate.length; i++) {\n        elesToUpdate[i]._private.rstyle.dirtyEvents = null;\n      }\n\n      elesToUpdate = cy.collection();\n    }\n  };\n\n  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\n\nBRp.onUpdateEleCalcs = function (fn) {\n  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n\n  fns.push(fn);\n};\n\nBRp.recalculateRenderedStyle = function (eles, useCache) {\n  var edges = [];\n  var nodes = [];\n\n  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n  if (this.destroyed) {\n    return;\n  }\n\n  // use cache by default for perf\n  if (useCache === undefined) {\n    useCache = true;\n  }\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n\n    // only update if dirty and in graph\n    if (useCache && rstyle.clean || ele.removed()) {\n      continue;\n    }\n\n    // only update if not display: none\n    if (ele.pstyle('display').value === 'none') {\n      continue;\n    }\n\n    if (_p.group === 'nodes') {\n      nodes.push(ele);\n    } else {\n      // edges\n      edges.push(ele);\n    }\n\n    rstyle.clean = true;\n    // rstyle.dirtyEvents = null;\n  }\n\n  // update node data from projections\n  for (var i = 0; i < nodes.length; i++) {\n    var ele = nodes[i];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var pos = ele.position();\n\n    this.recalculateNodeLabelProjection(ele);\n\n    rstyle.nodeX = pos.x;\n    rstyle.nodeY = pos.y;\n    rstyle.nodeW = ele.pstyle('width').pfValue;\n    rstyle.nodeH = ele.pstyle('height').pfValue;\n  }\n\n  this.recalculateEdgeProjections(edges);\n\n  // update edge data from projections\n  for (var i = 0; i < edges.length; i++) {\n    var ele = edges[i];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var rs = _p.rscratch;\n\n    this.recalculateEdgeLabelProjections(ele);\n\n    // update rstyle positions\n    rstyle.srcX = rs.arrowStartX;\n    rstyle.srcY = rs.arrowStartY;\n    rstyle.tgtX = rs.arrowEndX;\n    rstyle.tgtY = rs.arrowEndY;\n    rstyle.midX = rs.midX;\n    rstyle.midY = rs.midY;\n    rstyle.labelAngle = rs.labelAngle;\n    rstyle.sourceLabelAngle = rs.sourceLabelAngle;\n    rstyle.targetLabelAngle = rs.targetLabelAngle;\n  }\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar zIndexSort = __webpack_require__(14);\n\nvar BRp = {};\n\nBRp.updateCachedGrabbedEles = function () {\n  var eles = this.cachedZSortedEles;\n\n  if (!eles) {\n    // just let this be recalculated on the next z sort tick\n    return;\n  }\n\n  eles.drag = [];\n  eles.nondrag = [];\n\n  var grabTargets = [];\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n\n    if (ele.grabbed() && !ele.isParent()) {\n      grabTargets.push(ele);\n    } else if (rs.inDragLayer) {\n      eles.drag.push(ele);\n    } else {\n      eles.nondrag.push(ele);\n    }\n  }\n\n  // put the grab target nodes last so it's on top of its neighbourhood\n  for (var i = 0; i < grabTargets.length; i++) {\n    var ele = grabTargets[i];\n\n    eles.drag.push(ele);\n  }\n};\n\nBRp.invalidateCachedZSortedEles = function () {\n  this.cachedZSortedEles = null;\n};\n\nBRp.getCachedZSortedEles = function (forceRecalc) {\n  if (forceRecalc || !this.cachedZSortedEles) {\n    //console.time('cachezorder')\n\n    var eles = this.cy.mutableElements().toArray();\n\n    eles.sort(zIndexSort);\n\n    eles.interactive = eles.filter(function (ele) {\n      return ele.interactive();\n    });\n\n    this.cachedZSortedEles = eles;\n\n    this.updateCachedGrabbedEles();\n  } else {\n    eles = this.cachedZSortedEles;\n  }\n\n  return eles;\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BRp = {};\n\nBRp.getCachedImage = function (url, crossOrigin, onLoad) {\n  var r = this;\n  var imageCache = r.imageCache = r.imageCache || {};\n  var cache = imageCache[url];\n\n  if (cache) {\n    if (!cache.image.complete) {\n      cache.image.addEventListener('load', onLoad);\n    }\n\n    return cache.image;\n  } else {\n    cache = imageCache[url] = imageCache[url] || {};\n\n    var image = cache.image = new Image(); // eslint-disable-line no-undef\n\n    image.addEventListener('load', onLoad);\n    image.addEventListener('error', function () {\n      image.error = true;\n    });\n\n    // #1582 safari doesn't load data uris with crossOrigin properly\n    // https://bugs.webkit.org/show_bug.cgi?id=123978\n    var dataUriPrefix = 'data:';\n    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n    if (!isDataUri) {\n      image.crossOrigin = crossOrigin; // prevent tainted canvas\n    }\n\n    image.src = url;\n\n    return image;\n  }\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar window = __webpack_require__(4);\n\nvar BaseRenderer = function BaseRenderer(options) {\n  this.init(options);\n};\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\n\nBRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\n\nBRp.init = function (options) {\n  var r = this;\n\n  r.options = options;\n\n  r.cy = options.cy;\n\n  var ctr = r.container = options.cy.container();\n\n  // prepend a stylesheet in the head such that\n  if (window) {\n    var document = window.document;\n    var head = document.head;\n    var stylesheetId = '__________cytoscape_stylesheet';\n    var className = '__________cytoscape_container';\n    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n\n    if (ctr.className.indexOf(className) < 0) {\n      ctr.className = (ctr.className || '') + ' ' + className;\n    }\n\n    if (!stylesheetAlreadyExists) {\n      var stylesheet = document.createElement('style');\n\n      stylesheet.id = stylesheetId;\n      stylesheet.innerHTML = '.' + className + ' { position: relative; }';\n\n      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n    }\n\n    var computedStyle = window.getComputedStyle(ctr);\n    var position = computedStyle.getPropertyValue('position');\n\n    if (position === 'static') {\n      util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');\n    }\n  }\n\n  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];\n\n  //--Pointer-related data\n  r.hoverData = { down: null, last: null,\n    downTime: null, triggerMode: null,\n    dragging: false,\n    initialPan: [null, null], capture: false };\n\n  r.dragData = { possibleDragElements: [] };\n\n  r.touchData = {\n    start: null, capture: false,\n\n    // These 3 fields related to tap, taphold events\n    startPosition: [null, null, null, null, null, null],\n    singleTouchStartTime: null,\n    singleTouchMoved: true,\n\n    now: [null, null, null, null, null, null],\n    earlier: [null, null, null, null, null, null]\n  };\n\n  r.redraws = 0;\n  r.showFps = options.showFps;\n  r.debug = options.debug;\n\n  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n  r.hideLabelsOnViewport = options.hideLabelsOnViewport;\n  r.textureOnViewport = options.textureOnViewport;\n  r.wheelSensitivity = options.wheelSensitivity;\n  r.motionBlurEnabled = options.motionBlur; // on by default\n  r.forcedPixelRatio = options.pixelRatio;\n  r.motionBlur = options.motionBlur; // for initial kick off\n  r.motionBlurOpacity = options.motionBlurOpacity;\n  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n  r.motionBlurPxRatio = 1;\n  r.mbPxRBlurry = 1; //0.8;\n  r.minMbLowQualFrames = 4;\n  r.fullQualityMb = false;\n  r.clearedForMotionBlur = [];\n  r.desktopTapThreshold = options.desktopTapThreshold;\n  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n  r.touchTapThreshold = options.touchTapThreshold;\n  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n  r.tapholdDuration = 500;\n\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.beforeRenderPriorities = { // higher priority execs before lower one\n    animations: 400,\n    eleCalcs: 300,\n    eleTxrDeq: 200,\n    lyrTxrDeq: 100\n  };\n\n  r.registerNodeShapes();\n  r.registerArrowShapes();\n  r.registerCalculationListeners();\n};\n\nBRp.notify = function (params) {\n  var types;\n  var r = this;\n\n  // the renderer can't be notified after it's destroyed\n  if (this.destroyed) {\n    return;\n  }\n\n  if (is.array(params.type)) {\n    types = params.type;\n  } else {\n    types = [params.type];\n  }\n\n  var has = {};\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n\n    has[type] = true;\n  } // for\n\n  if (has['init']) {\n    r.load();\n    return;\n  }\n\n  if (has['destroy']) {\n    r.destroy();\n    return;\n  }\n\n  if (has['add'] || has['remove'] || has['load'] || has['zorder']) {\n    r.invalidateCachedZSortedEles();\n  }\n\n  if (has['viewport']) {\n    r.redrawHint('select', true);\n  }\n\n  if (has['load'] || has['resize']) {\n    r.invalidateContainerClientCoordsCache();\n    r.matchCanvasSize(r.container);\n  }\n\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n\n  this.startRenderLoop();\n\n  this.redraw();\n};\n\nBRp.destroy = function () {\n  var r = this;\n\n  r.destroyed = true;\n\n  r.cy.stopAnimationLoop();\n\n  for (var i = 0; i < r.bindings.length; i++) {\n    var binding = r.bindings[i];\n    var b = binding;\n    var tgt = b.target;\n\n    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n  }\n\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.onUpdateEleCalcsFns = [];\n\n  if (r.removeObserver) {\n    r.removeObserver.disconnect();\n  }\n\n  if (r.styleObserver) {\n    r.styleObserver.disconnect();\n  }\n\n  if (r.labelCalcDiv) {\n    try {\n      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n    } catch (e) {\n      // ie10 issue #1014\n    }\n  }\n};\n\n[__webpack_require__(85), __webpack_require__(91), __webpack_require__(96), __webpack_require__(98), __webpack_require__(99), __webpack_require__(100)].forEach(function (props) {\n  util.extend(BRp, props);\n});\n\nmodule.exports = BR;\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar Event = __webpack_require__(15);\n\nvar BRp = {};\n\nBRp.registerBinding = function (target, event, handler, useCapture) {\n  var args = Array.prototype.slice.apply(arguments, [1]); // copy\n  var b = this.binder(target);\n\n  return b.on.apply(b, args);\n};\n\nBRp.binder = function (tgt) {\n  var r = this;\n\n  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);\n\n  if (r.supportsPassiveEvents == null) {\n\n    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          supportsPassive = true;\n        }\n      });\n\n      window.addEventListener('test', null, opts);\n    } catch (err) {}\n\n    r.supportsPassiveEvents = supportsPassive;\n  }\n\n  var on = function on(event, handler, useCapture) {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (tgtIsDom && r.supportsPassiveEvents) {\n      // replace useCapture w/ opts obj\n      args[2] = {\n        capture: useCapture != null ? useCapture : false,\n        passive: false,\n        once: false\n      };\n    }\n\n    r.bindings.push({\n      target: tgt,\n      args: args\n    });\n\n    (tgt.addEventListener || tgt.on).apply(tgt, args);\n\n    return this;\n  };\n\n  return {\n    on: on,\n    addEventListener: on,\n    addListener: on,\n    bind: on\n  };\n};\n\nBRp.nodeIsDraggable = function (node) {\n  return node && node.isNode() && !node.locked() && node.grabbable();\n};\n\nBRp.nodeIsGrabbable = function (node) {\n  return this.nodeIsDraggable(node) && node.interactive();\n};\n\nBRp.load = function () {\n  var r = this;\n\n  var triggerEvents = function triggerEvents(target, names, e, props) {\n    if (target == null) {\n      target = r.cy;\n    }\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n\n      target.emit(util.extend({ originalEvent: e, type: name }, props));\n    }\n  };\n\n  var isMultSelKeyDown = function isMultSelKeyDown(e) {\n    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n  };\n\n  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n    var allowPassthrough = true;\n\n    if (r.cy.hasCompoundNodes() && down && down.isEdge()) {\n      // a compound node below the edge => no passthrough panning\n      for (var i = 0; downs && i < downs.length; i++) {\n        var down = downs[i];\n\n        if (down.isNode() && down.isParent()) {\n          allowPassthrough = false;\n          break;\n        }\n      }\n    } else {\n      allowPassthrough = true;\n    }\n\n    return allowPassthrough;\n  };\n\n  var getDragListIds = function getDragListIds(opts) {\n    var listHasId;\n\n    if (opts.addToList && r.cy.hasCompoundNodes()) {\n      // only needed for compound graphs\n      if (!opts.addToList.hasId) {\n        // build ids lookup if doesn't already exist\n        opts.addToList.hasId = {};\n\n        for (var i = 0; i < opts.addToList.length; i++) {\n          var ele = opts.addToList[i];\n\n          opts.addToList.hasId[ele.id()] = true;\n        }\n      }\n\n      listHasId = opts.addToList.hasId;\n    }\n\n    return listHasId || {};\n  };\n\n  var setGrabbed = function setGrabbed(ele) {\n    ele[0]._private.grabbed = true;\n  };\n\n  var setFreed = function setFreed(ele) {\n    ele[0]._private.grabbed = false;\n  };\n\n  var setInDragLayer = function setInDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = true;\n  };\n\n  var setOutDragLayer = function setOutDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = false;\n  };\n\n  var setGrabTarget = function setGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = true;\n  };\n\n  var removeGrabTarget = function removeGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = false;\n  };\n\n  var addToDragList = function addToDragList(ele, opts) {\n    var listHasId = getDragListIds(opts);\n\n    if (!listHasId[ele.id()]) {\n      opts.addToList.push(ele);\n      listHasId[ele.id()] = true;\n\n      setGrabbed(ele);\n    }\n  };\n\n  // helper function to determine which child nodes and inner edges\n  // of a compound node to be dragged as well as the grabbed and selected nodes\n  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    }\n\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n    var innerNodes = node.descendants();\n\n    if (opts.inDragLayer) {\n      innerNodes.forEach(setInDragLayer);\n      innerNodes.connectedEdges().forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      innerNodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n  };\n\n  // adds the given nodes and its neighbourhood to the drag layer\n  var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n    opts = opts || {};\n\n    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\n    if (opts.inDragLayer) {\n      nodes.forEach(setInDragLayer);\n\n      nodes.neighborhood().stdFilter(function (ele) {\n        return !hasCompoundNodes || ele.isEdge();\n      }).forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n\n    addDescendantsToDrag(nodes, opts); // always add to drag\n\n    // also add nodes and edges related to the topmost ancestor\n    updateAncestorsInDragLayer(nodes, {\n      inDragLayer: opts.inDragLayer\n    });\n\n    r.updateCachedGrabbedEles();\n  };\n\n  var addNodeToDrag = addNodesToDrag;\n\n  var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n    if (!grabbedEles) {\n      return;\n    }\n\n    grabbedEles.hasId = {}; // clear the id list\n\n    // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n    r.getCachedZSortedEles().forEach(function (ele) {\n      setFreed(ele);\n      setOutDragLayer(ele);\n      removeGrabTarget(ele);\n    });\n\n    r.updateCachedGrabbedEles();\n  };\n\n  // helper function to determine which ancestor nodes and edges should go\n  // to the drag layer (or should be removed from drag layer).\n  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    }\n\n    // find top-level parent\n    var parent = node.ancestors().orphans();\n\n    // no parent node: no nodes to add to the drag layer\n    if (parent.same(node)) {\n      return;\n    }\n\n    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n\n    var edges = nodes.connectedEdges();\n\n    if (opts.inDragLayer) {\n      edges.forEach(setInDragLayer);\n      nodes.forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n  };\n\n  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n\n  // watch for when the cy container is removed from the dom\n  if (haveMutationsApi) {\n    r.removeObserver = new MutationObserver(function (mutns) {\n      // eslint-disable-line no-undef\n      for (var i = 0; i < mutns.length; i++) {\n        var mutn = mutns[i];\n        var rNodes = mutn.removedNodes;\n\n        if (rNodes) {\n          for (var j = 0; j < rNodes.length; j++) {\n            var rNode = rNodes[j];\n\n            if (rNode === r.container) {\n              r.destroy();\n              break;\n            }\n          }\n        }\n      }\n    });\n\n    if (r.container.parentNode) {\n      r.removeObserver.observe(r.container.parentNode, { childList: true });\n    }\n  } else {\n    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n      r.destroy();\n    });\n  }\n\n  var onResize = util.debounce(function () {\n    r.cy.resize();\n  }, 100);\n\n  if (haveMutationsApi) {\n    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\n    r.styleObserver.observe(r.container, { attributes: true });\n  }\n\n  // auto resize\n  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef\n\n  var forEachUp = function forEachUp(domEle, fn) {\n    while (domEle != null) {\n      fn(domEle);\n\n      domEle = domEle.parentNode;\n    }\n  };\n\n  var invalidateCoords = function invalidateCoords() {\n    r.invalidateContainerClientCoordsCache();\n  };\n\n  forEachUp(r.container, function (domEle) {\n    r.registerBinding(domEle, 'transitionend', invalidateCoords);\n    r.registerBinding(domEle, 'animationend', invalidateCoords);\n    r.registerBinding(domEle, 'scroll', invalidateCoords);\n  });\n\n  // stop right click menu from appearing on cy\n  r.registerBinding(r.container, 'contextmenu', function (e) {\n    e.preventDefault();\n  });\n\n  var inBoxSelection = function inBoxSelection() {\n    return r.selection[4] !== 0;\n  };\n\n  var eventInContainer = function eventInContainer(e) {\n    // save cycles if mouse events aren't to be captured\n    var containerPageCoords = r.findContainerClientCoords();\n    var x = containerPageCoords[0];\n    var y = containerPageCoords[1];\n    var width = containerPageCoords[2];\n    var height = containerPageCoords[3];\n\n    var positions = e.touches ? e.touches : [e];\n    var atLeastOnePosInside = false;\n\n    for (var i = 0; i < positions.length; i++) {\n      var p = positions[i];\n\n      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n        atLeastOnePosInside = true;\n        break;\n      }\n    }\n\n    if (!atLeastOnePosInside) {\n      return false;\n    }\n\n    var container = r.container;\n    var target = e.target;\n    var tParent = target.parentNode;\n    var containerIsTarget = false;\n\n    while (tParent) {\n      if (tParent === container) {\n        containerIsTarget = true;\n        break;\n      }\n\n      tParent = tParent.parentNode;\n    }\n\n    if (!containerIsTarget) {\n      return false;\n    } // if target is outisde cy container, then this event is not for us\n\n    return true;\n  };\n\n  // Primary key\n  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n    if (!eventInContainer(e)) {\n      return;\n    }\n\n    e.preventDefault();\n    r.hoverData.capture = true;\n    r.hoverData.which = e.which;\n\n    var cy = r.cy;\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var select = r.selection;\n    var nears = r.findNearestElements(pos[0], pos[1], true, false);\n    var near = nears[0];\n    var draggedElements = r.dragData.possibleDragElements;\n\n    r.hoverData.mdownPos = pos;\n    r.hoverData.mdownGPos = gpos;\n\n    var checkForTaphold = function checkForTaphold() {\n      r.hoverData.tapholdCancelled = false;\n\n      clearTimeout(r.hoverData.tapholdTimeout);\n\n      r.hoverData.tapholdTimeout = setTimeout(function () {\n\n        if (r.hoverData.tapholdCancelled) {\n          return;\n        } else {\n          var ele = r.hoverData.down;\n\n          if (ele) {\n            ele.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: { x: pos[0], y: pos[1] }\n            });\n          } else {\n            cy.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: { x: pos[0], y: pos[1] }\n            });\n          }\n        }\n      }, r.tapholdDuration);\n    };\n\n    // Right click button\n    if (e.which == 3) {\n\n      r.hoverData.cxtStarted = true;\n\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapstart',\n        position: { x: pos[0], y: pos[1] }\n      };\n\n      if (near) {\n        near.activate();\n        near.emit(cxtEvt);\n\n        r.hoverData.down = near;\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      r.hoverData.downTime = new Date().getTime();\n      r.hoverData.cxtDragged = false;\n\n      // Primary button\n    } else if (e.which == 1) {\n\n      if (near) {\n        near.activate();\n      }\n\n      // Element dragging\n      {\n        // If something is under the cursor and it is draggable, prepare to grab it\n        if (near != null) {\n\n          if (r.nodeIsGrabbable(near)) {\n\n            var makeEvent = function makeEvent(type) {\n              return {\n                originalEvent: e,\n                type: type,\n                position: { x: pos[0], y: pos[1] }\n              };\n            };\n\n            var triggerGrab = function triggerGrab(ele) {\n              ele.emit(makeEvent('grab'));\n            };\n\n            setGrabTarget(near);\n\n            if (!near.selected()) {\n\n              draggedElements = r.dragData.possibleDragElements = [];\n              addNodeToDrag(near, { addToList: draggedElements });\n\n              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n            } else {\n              draggedElements = r.dragData.possibleDragElements = [];\n\n              var selectedNodes = cy.$(function (ele) {\n                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n              });\n\n              addNodesToDrag(selectedNodes, { addToList: draggedElements });\n\n              near.emit(makeEvent('grabon'));\n\n              selectedNodes.forEach(triggerGrab);\n            }\n\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n          }\n        }\n\n        r.hoverData.down = near;\n        r.hoverData.downs = nears;\n        r.hoverData.downTime = new Date().getTime();\n      }\n\n      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n        position: { x: pos[0], y: pos[1] }\n      });\n\n      if (near == null) {\n        select[4] = 1;\n\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n\n        r.redrawHint('select', true);\n\n        r.redraw();\n      } else if (near.isEdge()) {\n        select[4] = 1; // for future pan\n      }\n\n      checkForTaphold();\n    }\n\n    // Initialize selection box coordinates\n    select[0] = select[2] = pos[0];\n    select[1] = select[3] = pos[1];\n  }, false);\n\n  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.hoverData.capture;\n\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n\n    var preventDefault = false;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var mdownPos = r.hoverData.mdownPos;\n    var mdownGPos = r.hoverData.mdownGPos;\n    var select = r.selection;\n\n    var near = null;\n    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n      near = r.findNearestElement(pos[0], pos[1], true, false);\n    }\n    var last = r.hoverData.last;\n    var down = r.hoverData.down;\n\n    var disp = [pos[0] - select[2], pos[1] - select[3]];\n\n    var draggedElements = r.dragData.possibleDragElements;\n\n    var isOverThresholdDrag;\n\n    if (mdownGPos) {\n      var dx = gpos[0] - mdownGPos[0];\n      var dx2 = dx * dx;\n      var dy = gpos[1] - mdownGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n\n      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n    }\n\n    var multSelKeyDown = isMultSelKeyDown(e);\n\n    if (isOverThresholdDrag) {\n      r.hoverData.tapholdCancelled = true;\n    }\n\n    var updateDragDelta = function updateDragDelta() {\n      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n      if (dragDelta.length === 0) {\n        dragDelta.push(disp[0]);\n        dragDelta.push(disp[1]);\n      } else {\n        dragDelta[0] += disp[0];\n        dragDelta[1] += disp[1];\n      }\n    };\n\n    preventDefault = true;\n\n    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n      position: { x: pos[0], y: pos[1] }\n    });\n\n    var goIntoBoxMode = function goIntoBoxMode() {\n      r.data.bgActivePosistion = undefined;\n\n      if (!r.hoverData.selecting) {\n        cy.emit('boxstart');\n      }\n\n      select[4] = 1;\n      r.hoverData.selecting = true;\n\n      r.redrawHint('select', true);\n      r.redraw();\n    };\n\n    // trigger context drag if rmouse down\n    if (r.hoverData.which === 3) {\n      // but only if over threshold\n      if (isOverThresholdDrag) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxtdrag',\n          position: { x: pos[0], y: pos[1] }\n        };\n\n        if (down) {\n          down.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        r.hoverData.cxtDragged = true;\n\n        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n\n          if (r.hoverData.cxtOver) {\n            r.hoverData.cxtOver.emit({\n              originalEvent: e,\n              type: 'cxtdragout',\n              position: { x: pos[0], y: pos[1] }\n            });\n          }\n\n          r.hoverData.cxtOver = near;\n\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'cxtdragover',\n              position: { x: pos[0], y: pos[1] }\n            });\n          }\n        }\n      }\n\n      // Check if we are drag panning the entire graph\n    } else if (r.hoverData.dragging) {\n      preventDefault = true;\n\n      if (cy.panningEnabled() && cy.userPanningEnabled()) {\n        var deltaP;\n\n        if (r.hoverData.justStartedPan) {\n          var mdPos = r.hoverData.mdownPos;\n\n          deltaP = {\n            x: (pos[0] - mdPos[0]) * zoom,\n            y: (pos[1] - mdPos[1]) * zoom\n          };\n\n          r.hoverData.justStartedPan = false;\n        } else {\n          deltaP = {\n            x: disp[0] * zoom,\n            y: disp[1] * zoom\n          };\n        }\n\n        cy.panBy(deltaP);\n\n        r.hoverData.dragged = true;\n      }\n\n      // Needs reproject due to pan changing viewport\n      pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      // Checks primary button down & out of time & mouse not moved much\n    } else if (select[4] == 1 && (down == null || down.isEdge())) {\n\n      if (isOverThresholdDrag) {\n\n        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n          goIntoBoxMode();\n        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n\n          if (allowPassthrough) {\n            r.hoverData.dragging = true;\n            r.hoverData.justStartedPan = true;\n            select[4] = 0;\n\n            r.data.bgActivePosistion = math.array2point(mdownPos);\n\n            r.redrawHint('select', true);\n            r.redraw();\n          }\n        }\n\n        if (down && down.isEdge() && down.active()) {\n          down.unactivate();\n        }\n      }\n    } else {\n      if (down && down.isEdge() && down.active()) {\n        down.unactivate();\n      }\n\n      if ((!down || !down.grabbed()) && near != last) {\n\n        if (last) {\n          triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n            position: { x: pos[0], y: pos[1] }\n          });\n        }\n\n        if (near) {\n          triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n            position: { x: pos[0], y: pos[1] }\n          });\n        }\n\n        r.hoverData.last = near;\n      }\n\n      if (down) {\n\n        if (isOverThresholdDrag) {\n          // then we can take action\n\n          if (cy.boxSelectionEnabled() && multSelKeyDown) {\n            // then selection overrides\n            if (down && down.grabbed()) {\n              freeDraggedElements(draggedElements);\n\n              down.emit('free');\n            }\n\n            goIntoBoxMode();\n          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n            // drag node\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if (justStartedDrag) {\n              r.redrawHint('eles', true);\n            }\n\n            r.dragData.didDrag = true; // indicate that we actually did drag the node\n\n            var toTrigger = [];\n\n            // now, add the elements to the drag layer if not done already\n            if (!r.hoverData.draggingEles) {\n              addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });\n            }\n\n            for (var i = 0; i < draggedElements.length; i++) {\n              var dEle = draggedElements[i];\n\n              // Locked nodes not draggable, as well as non-visible nodes\n              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {\n                var dPos = dEle.position();\n\n                toTrigger.push(dEle);\n\n                if (is.number(disp[0]) && is.number(disp[1])) {\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n\n                  if (justStartedDrag) {\n                    var dragDelta = r.hoverData.dragDelta;\n\n                    if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {\n                      dPos.x += dragDelta[0];\n                      dPos.y += dragDelta[1];\n                    }\n                  }\n                }\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n\n            var tcol = cy.collection(toTrigger);\n\n            tcol.dirtyCompoundBoundsCache();\n            tcol.emit('position drag');\n\n            r.redrawHint('drag', true);\n            r.redraw();\n          }\n        } else {\n          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n          updateDragDelta();\n        }\n      }\n\n      // prevent the dragging from triggering text selection on the page\n      preventDefault = true;\n    }\n\n    select[2] = pos[0];select[3] = pos[1];\n\n    if (preventDefault) {\n      if (e.stopPropagation) e.stopPropagation();\n      if (e.preventDefault) e.preventDefault();\n      return false;\n    }\n  }, false);\n\n  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.hoverData.capture;\n    if (!capture) {\n      return;\n    }\n    r.hoverData.capture = false;\n\n    var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;\n    var near = r.findNearestElement(pos[0], pos[1], true, false);\n    var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;\n    var multSelKeyDown = isMultSelKeyDown(e);\n\n    if (r.data.bgActivePosistion) {\n      r.redrawHint('select', true);\n      r.redraw();\n    }\n\n    r.hoverData.tapholdCancelled = true;\n\n    r.data.bgActivePosistion = undefined; // not active bg now\n\n    if (down) {\n      down.unactivate();\n    }\n\n    if (r.hoverData.which === 3) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: { x: pos[0], y: pos[1] }\n      };\n\n      if (down) {\n        down.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      if (!r.hoverData.cxtDragged) {\n        var cxtTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: { x: pos[0], y: pos[1] }\n        };\n\n        if (down) {\n          down.emit(cxtTap);\n        } else {\n          cy.emit(cxtTap);\n        }\n      }\n\n      r.hoverData.cxtDragged = false;\n      r.hoverData.which = null;\n    } else if (r.hoverData.which === 1) {\n\n      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n      if (down == null && // not mousedown on node\n      !r.dragData.didDrag // didn't move the node around\n      && !r.hoverData.selecting // not box selection\n      && !r.hoverData.dragged // didn't pan\n      && !isMultSelKeyDown(e)) {\n\n        cy.$(function (ele) {\n          return ele.selected();\n        }).unselect();\n\n        if (draggedElements.length > 0) {\n          r.redrawHint('eles', true);\n        }\n\n        r.dragData.possibleDragElements = draggedElements = [];\n      }\n\n      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n        position: { x: pos[0], y: pos[1] }\n      });\n\n      if (!r.dragData.didDrag // didn't move a node around\n      && !r.hoverData.dragged // didn't pan\n      && !r.hoverData.selecting // not box selection\n      && !r.hoverData.isOverThresholdDrag // didn't move too much\n      ) {\n          triggerEvents(down, ['click', 'tap', 'vclick'], e, {\n            position: { x: pos[0], y: pos[1] }\n          });\n        }\n\n      // Single selection\n      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n        if (near != null && near._private.selectable) {\n\n          if (r.hoverData.dragging) {\n            // if panning, don't change selection state\n          } else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n            if (near.selected()) {\n              near.unselect();\n            } else {\n              near.select();\n            }\n          } else {\n            if (!multSelKeyDown) {\n              cy.$(':selected').unmerge(near).unselect();\n              near.select();\n            }\n          }\n\n          r.redrawHint('eles', true);\n        }\n      }\n\n      if (r.hoverData.selecting) {\n        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n\n        r.redrawHint('select', true);\n\n        if (box.length > 0) {\n          r.redrawHint('eles', true);\n        }\n\n        cy.emit('boxend');\n\n        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n          return ele.selectable() && !ele.selected();\n        };\n\n        if (cy.selectionType() === 'additive') {\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        } else {\n          if (!multSelKeyDown) {\n            cy.$(':selected').unmerge(box).unselect();\n          }\n\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        }\n\n        // always need redraw in case eles unselectable\n        r.redraw();\n      }\n\n      // Cancel drag pan\n      if (r.hoverData.dragging) {\n        r.hoverData.dragging = false;\n\n        r.redrawHint('select', true);\n        r.redrawHint('eles', true);\n\n        r.redraw();\n      }\n\n      if (!select[4]) {\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n\n        var downWasGrabbed = down && down.grabbed();\n\n        freeDraggedElements(draggedElements);\n\n        if (downWasGrabbed) {\n          down.emit('free');\n        }\n      }\n    } // else not right mouse\n\n    select[4] = 0;r.hoverData.down = null;\n\n    r.hoverData.cxtStarted = false;\n    r.hoverData.draggingEles = false;\n    r.hoverData.selecting = false;\n    r.hoverData.isOverThresholdDrag = false;\n    r.dragData.didDrag = false;\n    r.hoverData.dragged = false;\n    r.hoverData.dragDelta = [];\n    r.hoverData.mdownPos = null;\n    r.hoverData.mdownGPos = null;\n  }, false);\n\n  var wheelHandler = function wheelHandler(e) {\n\n    if (r.scrollingPage) {\n      return;\n    } // while scrolling, ignore wheel-to-zoom\n\n    var cy = r.cy;\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];\n\n    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n      // if pan dragging or cxt dragging, wheel movements make no zoom\n      e.preventDefault();\n      return;\n    }\n\n    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n      e.preventDefault();\n\n      r.data.wheelZooming = true;\n      clearTimeout(r.data.wheelTimeout);\n      r.data.wheelTimeout = setTimeout(function () {\n        r.data.wheelZooming = false;\n\n        r.redrawHint('eles', true);\n        r.redraw();\n      }, 150);\n\n      var diff;\n\n      if (e.deltaY != null) {\n        diff = e.deltaY / -250;\n      } else if (e.wheelDeltaY != null) {\n        diff = e.wheelDeltaY / 1000;\n      } else {\n        diff = e.wheelDelta / 1000;\n      }\n\n      diff = diff * r.wheelSensitivity;\n\n      var needsWheelFix = e.deltaMode === 1;\n      if (needsWheelFix) {\n        // fixes slow wheel events on ff/linux and ff/windows\n        diff *= 33;\n      }\n\n      cy.zoom({\n        level: cy.zoom() * Math.pow(10, diff),\n        renderedPosition: { x: rpos[0], y: rpos[1] }\n      });\n    }\n  };\n\n  // Functions to help with whether mouse wheel should trigger zooming\n  // --\n  r.registerBinding(r.container, 'wheel', wheelHandler, true);\n\n  // disable nonstandard wheel events\n  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n  r.registerBinding(window, 'scroll', function scrollHandler(e) {\n    // eslint-disable-line no-undef\n    r.scrollingPage = true;\n\n    clearTimeout(r.scrollingPageTimeout);\n    r.scrollingPageTimeout = setTimeout(function () {\n      r.scrollingPage = false;\n    }, 250);\n  }, true);\n\n  // Functions to help with handling mouseout/mouseover on the Cytoscape container\n  // Handle mouseout on Cytoscape container\n  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseout',\n      position: { x: pos[0], y: pos[1] }\n    });\n  }, false);\n\n  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseover',\n      position: { x: pos[0], y: pos[1] }\n    });\n  }, false);\n\n  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n  var center1, modelCenter1; // center point on start pinch to zoom\n  var offsetLeft, offsetTop;\n  var containerWidth, containerHeight;\n  var twoFingersStartInside;\n\n  var distance = function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  };\n\n  var distanceSq = function distanceSq(x1, y1, x2, y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  };\n\n  var touchstartHandler;\n  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n    if (!eventInContainer(e)) {\n      return;\n    }\n\n    r.touchData.capture = true;\n    r.data.bgActivePosistion = undefined;\n\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n    }\n\n    // record starting points for pinch-to-zoom\n    if (e.touches[1]) {\n\n      freeDraggedElements(r.dragData.touchDragEles);\n\n      var offsets = r.findContainerClientCoords();\n      offsetLeft = offsets[0];\n      offsetTop = offsets[1];\n      containerWidth = offsets[2];\n      containerHeight = offsets[3];\n\n      f1x1 = e.touches[0].clientX - offsetLeft;\n      f1y1 = e.touches[0].clientY - offsetTop;\n\n      f2x1 = e.touches[1].clientX - offsetLeft;\n      f2y1 = e.touches[1].clientY - offsetTop;\n\n      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n\n      distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];\n\n      // consider context tap\n      var cxtDistThreshold = 200;\n      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n\n        var near1 = r.findNearestElement(now[0], now[1], true, true);\n        var near2 = r.findNearestElement(now[2], now[3], true, true);\n\n        if (near1 && near1.isNode()) {\n          near1.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: { x: now[0], y: now[1] }\n          });\n          r.touchData.start = near1;\n        } else if (near2 && near2.isNode()) {\n          near2.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: { x: now[0], y: now[1] }\n          });\n          r.touchData.start = near2;\n        } else {\n          cy.emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: { x: now[0], y: now[1] }\n          });\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n        r.touchData.cxt = true;\n        r.touchData.cxtDragged = false;\n        r.data.bgActivePosistion = undefined;\n\n        r.redraw();\n        return;\n      }\n    }\n\n    if (e.touches[2]) {\n      // ignore\n    } else if (e.touches[1]) {\n      // ignore\n    } else if (e.touches[0]) {\n      var nears = r.findNearestElements(now[0], now[1], true, true);\n      var near = nears[0];\n\n      if (near != null) {\n        near.activate();\n\n        r.touchData.start = near;\n        r.touchData.starts = nears;\n\n        if (r.nodeIsGrabbable(near)) {\n\n          var draggedEles = r.dragData.touchDragEles = [];\n          var selectedNodes = null;\n\n          r.redrawHint('eles', true);\n          r.redrawHint('drag', true);\n\n          if (near.selected()) {\n            // reset drag elements, since near will be added again\n\n            selectedNodes = cy.$(function (ele) {\n              return ele.selected() && r.nodeIsGrabbable(ele);\n            });\n\n            addNodesToDrag(selectedNodes, { addToList: draggedEles });\n          } else {\n            addNodeToDrag(near, { addToList: draggedEles });\n          }\n\n          setGrabTarget(near);\n\n          var makeEvent = function makeEvent(type) {\n            return {\n              originalEvent: e,\n              type: type,\n              position: { x: now[0], y: now[1] }\n            };\n          };\n\n          near.emit(makeEvent('grabon'));\n\n          if (selectedNodes) {\n            selectedNodes.forEach(function (n) {\n              n.emit(makeEvent('grab'));\n            });\n          } else {\n            near.emit(makeEvent('grab'));\n          }\n        }\n      }\n\n      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n        position: { x: now[0], y: now[1] }\n      });\n\n      if (near == null) {\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n\n      // Tap, taphold\n      // -----\n\n      r.touchData.singleTouchMoved = false;\n      r.touchData.singleTouchStartTime = +new Date();\n\n      clearTimeout(r.touchData.tapholdTimeout);\n      r.touchData.tapholdTimeout = setTimeout(function () {\n        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n        && !r.touchData.selecting // box selection shouldn't allow taphold through\n        ) {\n            triggerEvents(r.touchData.start, ['taphold'], e, {\n              position: { x: now[0], y: now[1] }\n            });\n\n            if (!r.touchData.start) {\n              cy.$(':selected').unselect();\n            }\n          }\n      }, r.tapholdDuration);\n    }\n\n    if (e.touches.length >= 1) {\n      var sPos = r.touchData.startPosition = [];\n\n      for (var i = 0; i < now.length; i++) {\n        sPos[i] = earlier[i] = now[i];\n      }\n\n      var touch0 = e.touches[0];\n\n      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n    }\n  }, false);\n\n  var touchmoveHandler;\n  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.touchData.capture;\n\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n\n    var select = r.selection;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    var zoom = cy.zoom();\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n    }\n\n    var startGPos = r.touchData.startGPosition;\n    var isOverThresholdDrag;\n\n    if (capture && e.touches[0] && startGPos) {\n      var disp = [];for (var j = 0; j < now.length; j++) {\n        disp[j] = now[j] - earlier[j];\n      }\n      var dx = e.touches[0].clientX - startGPos[0];\n      var dx2 = dx * dx;\n      var dy = e.touches[0].clientY - startGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n\n      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n    }\n\n    // context swipe cancelling\n    if (capture && r.touchData.cxt) {\n      e.preventDefault();\n\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n          f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n          f2y2 = e.touches[1].clientY - offsetTop;\n      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n      var factorSq = distance2Sq / distance1Sq;\n\n      var distThreshold = 150;\n      var distThresholdSq = distThreshold * distThreshold;\n      var factorThreshold = 1.5;\n      var factorThresholdSq = factorThreshold * factorThreshold;\n\n      // cancel ctx gestures if the distance b/t the fingers increases\n      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n        r.touchData.cxt = false;\n\n        r.data.bgActivePosistion = undefined;\n\n        r.redrawHint('select', true);\n\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: { x: now[0], y: now[1] }\n        };\n\n        if (r.touchData.start) {\n          r.touchData.start.unactivate().emit(cxtEvt);\n\n          r.touchData.start = null;\n        } else {\n          cy.emit(cxtEvt);\n        }\n      }\n    }\n\n    // context swipe\n    if (capture && r.touchData.cxt) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxtdrag',\n        position: { x: now[0], y: now[1] }\n      };\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n\n      if (r.touchData.start) {\n        r.touchData.start.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n      r.touchData.cxtDragged = true;\n\n      var near = r.findNearestElement(now[0], now[1], true, true);\n\n      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n\n        if (r.touchData.cxtOver) {\n          r.touchData.cxtOver.emit({\n            originalEvent: e,\n            type: 'cxtdragout',\n            position: { x: now[0], y: now[1] }\n          });\n        }\n\n        r.touchData.cxtOver = near;\n\n        if (near) {\n          near.emit({\n            originalEvent: e,\n            type: 'cxtdragover',\n            position: { x: now[0], y: now[1] }\n          });\n        }\n      }\n\n      // box selection\n    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n      e.preventDefault();\n\n      r.data.bgActivePosistion = undefined;\n\n      this.lastThreeTouch = +new Date();\n\n      if (!r.touchData.selecting) {\n        cy.emit('boxstart');\n      }\n\n      r.touchData.selecting = true;\n\n      r.redrawHint('select', true);\n\n      if (!select || select.length === 0 || select[0] === undefined) {\n        select[0] = (now[0] + now[2] + now[4]) / 3;\n        select[1] = (now[1] + now[3] + now[5]) / 3;\n        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n      } else {\n        select[2] = (now[0] + now[2] + now[4]) / 3;\n        select[3] = (now[1] + now[3] + now[5]) / 3;\n      }\n\n      select[4] = 1;\n      r.touchData.selecting = true;\n\n      r.redraw();\n\n      // pinch to zoom\n    } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n      // two fingers => pinch to zoom\n      e.preventDefault();\n\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n\n      var draggedEles = r.dragData.touchDragEles;\n      if (draggedEles) {\n        r.redrawHint('drag', true);\n\n        for (var i = 0; i < draggedEles.length; i++) {\n          var de_p = draggedEles[i]._private;\n\n          de_p.grabbed = false;\n          de_p.rscratch.inDragLayer = false;\n        }\n      }\n\n      // (x2, y2) for fingers 1 and 2\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n          f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n          f2y2 = e.touches[1].clientY - offsetTop;\n\n      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n      var factor = distance2 / distance1;\n\n      if (twoFingersStartInside) {\n        // delta finger1\n        var df1x = f1x2 - f1x1;\n        var df1y = f1y2 - f1y1;\n\n        // delta finger 2\n        var df2x = f2x2 - f2x1;\n        var df2y = f2y2 - f2y1;\n\n        // translation is the normalised vector of the two fingers movement\n        // i.e. so pinching cancels out and moving together pans\n        var tx = (df1x + df2x) / 2;\n        var ty = (df1y + df2y) / 2;\n\n        // adjust factor by the speed multiplier\n        // var speed = 1.5;\n        // if( factor > 1 ){\n        //   factor = (factor - 1) * speed + 1;\n        // } else {\n        //   factor = 1 - (1 - factor) * speed;\n        // }\n\n        // now calculate the zoom\n        var zoom1 = cy.zoom();\n        var zoom2 = zoom1 * factor;\n        var pan1 = cy.pan();\n\n        // the model center point converted to the current rendered pos\n        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\n        var pan2 = {\n          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n        };\n\n        // remove dragged eles\n        if (r.touchData.start && r.touchData.start.active()) {\n          var draggedEles = r.dragData.touchDragEles;\n\n          freeDraggedElements(draggedEles);\n\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n\n          r.touchData.start.unactivate().emit('free');\n        }\n\n        cy.viewport({\n          zoom: zoom2,\n          pan: pan2,\n          cancelOnFailedZoom: true\n        });\n\n        distance1 = distance2;\n        f1x1 = f1x2;\n        f1y1 = f1y2;\n        f2x1 = f2x2;\n        f2y1 = f2y2;\n\n        r.pinching = true;\n      }\n\n      // Re-project\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n      }\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n      }\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n      }\n    } else if (e.touches[0]) {\n      var start = r.touchData.start;\n      var last = r.touchData.last;\n      var near;\n\n      if (!r.hoverData.draggingEles && !r.swipePanning) {\n        near = r.findNearestElement(now[0], now[1], true, true);\n      }\n\n      if (capture && start != null) {\n        e.preventDefault();\n      }\n\n      // dragging nodes\n      if (capture && start != null && r.nodeIsDraggable(start)) {\n\n        if (isOverThresholdDrag) {\n          // then dragging can happen\n          var draggedEles = r.dragData.touchDragEles;\n          var justStartedDrag = !r.dragData.didDrag;\n\n          if (justStartedDrag) {\n            addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });\n          }\n\n          for (var k = 0; k < draggedEles.length; k++) {\n            var draggedEle = draggedEles[k];\n\n            if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {\n              r.dragData.didDrag = true;\n              var dPos = draggedEle.position();\n\n              if (is.number(disp[0]) && is.number(disp[1])) {\n                dPos.x += disp[0];\n                dPos.y += disp[1];\n              }\n\n              if (justStartedDrag) {\n                r.redrawHint('eles', true);\n\n                var dragDelta = r.touchData.dragDelta;\n\n                if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {\n                  dPos.x += dragDelta[0];\n                  dPos.y += dragDelta[1];\n                }\n              }\n            }\n          }\n\n          var tcol = cy.collection(draggedEles);\n\n          tcol.dirtyCompoundBoundsCache();\n          tcol.emit('position drag');\n\n          r.hoverData.draggingEles = true;\n\n          r.redrawHint('drag', true);\n\n          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n\n            r.redrawHint('eles', true);\n          }\n\n          r.redraw();\n        } else {\n          // otherise keep track of drag delta for later\n          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n          if (dragDelta.length === 0) {\n            dragDelta.push(disp[0]);\n            dragDelta.push(disp[1]);\n          } else {\n            dragDelta[0] += disp[0];\n            dragDelta[1] += disp[1];\n          }\n        }\n      }\n\n      // touchmove\n      {\n        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n          position: { x: now[0], y: now[1] }\n        });\n\n        if ((!start || !start.grabbed()) && near != last) {\n          if (last) {\n            last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });\n          }\n          if (near) {\n            near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });\n          }\n        }\n\n        r.touchData.last = near;\n      }\n\n      // check to cancel taphold\n      if (capture) {\n        for (var i = 0; i < now.length; i++) {\n          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n\n            r.touchData.singleTouchMoved = true;\n          }\n        }\n      }\n\n      // panning\n      if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n\n        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n\n        if (allowPassthrough) {\n          e.preventDefault();\n\n          if (r.swipePanning) {\n            cy.panBy({\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            });\n          } else if (isOverThresholdDrag) {\n            r.swipePanning = true;\n\n            cy.panBy({\n              x: dx * zoom,\n              y: dy * zoom\n            });\n\n            if (start) {\n              start.unactivate();\n\n              if (!r.data.bgActivePosistion) {\n                r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);\n              }\n\n              r.redrawHint('select', true);\n\n              r.touchData.start = null;\n            }\n          }\n        }\n\n        // Re-project\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];now[1] = pos[1];\n      }\n    }\n\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    }\n    //r.redraw();\n  }, false);\n\n  var touchcancelHandler;\n  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n    // eslint-disable-line no-undef\n    var start = r.touchData.start;\n\n    r.touchData.capture = false;\n\n    if (start) {\n      start.unactivate();\n    }\n  });\n\n  var touchendHandler;\n  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {\n    // eslint-disable-line no-undef\n    var start = r.touchData.start;\n\n    var capture = r.touchData.capture;\n\n    if (capture) {\n      r.touchData.capture = false;\n\n      e.preventDefault();\n    } else {\n      return;\n    }\n\n    var select = r.selection;\n\n    r.swipePanning = false;\n    r.hoverData.draggingEles = false;\n\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];\n    }\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];\n    }\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];\n    }\n\n    if (start) {\n      start.unactivate();\n    }\n\n    var ctxTapend;\n    if (r.touchData.cxt) {\n      ctxTapend = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: { x: now[0], y: now[1] }\n      };\n\n      if (start) {\n        start.emit(ctxTapend);\n      } else {\n        cy.emit(ctxTapend);\n      }\n\n      if (!r.touchData.cxtDragged) {\n        var ctxTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: { x: now[0], y: now[1] }\n        };\n\n        if (start) {\n          start.emit(ctxTap);\n        } else {\n          cy.emit(ctxTap);\n        }\n      }\n\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n      r.touchData.cxt = false;\n      r.touchData.start = null;\n\n      r.redraw();\n      return;\n    }\n\n    // no more box selection if we don't have three fingers\n    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n      r.touchData.selecting = false;\n\n      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n\n      select[0] = undefined;\n      select[1] = undefined;\n      select[2] = undefined;\n      select[3] = undefined;\n      select[4] = 0;\n\n      r.redrawHint('select', true);\n\n      cy.emit('boxend');\n\n      var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n        return ele.selectable() && !ele.selected();\n      };\n\n      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\n      if (box.nonempty()) {\n        r.redrawHint('eles', true);\n      }\n\n      r.redraw();\n    }\n\n    if (start != null) {\n      start.unactivate();\n    }\n\n    if (e.touches[2]) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n    } else if (e.touches[1]) {\n      // ignore\n    } else if (e.touches[0]) {\n      // ignore\n\n      // Last touch released\n    } else if (!e.touches[0]) {\n\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n\n      var draggedEles = r.dragData.touchDragEles;\n\n      if (start != null) {\n\n        var startWasGrabbed = start._private.grabbed;\n\n        freeDraggedElements(draggedEles);\n\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n\n        if (startWasGrabbed) {\n          start.emit('free');\n        }\n\n        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          position: { x: now[0], y: now[1] }\n        });\n\n        start.unactivate();\n\n        r.touchData.start = null;\n      } else {\n        var near = r.findNearestElement(now[0], now[1], true, true);\n\n        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          position: { x: now[0], y: now[1] }\n        });\n      }\n\n      var dx = r.touchData.startPosition[0] - now[0];\n      var dx2 = dx * dx;\n      var dy = r.touchData.startPosition[1] - now[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n      if (start != null && !r.dragData.didDrag // didn't drag nodes around\n      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n      ) {\n\n          if (cy.selectionType() === 'single') {\n            cy.$(':selected').unmerge(start).unselect();\n            start.select();\n          } else {\n            if (start.selected()) {\n              start.unselect();\n            } else {\n              start.select();\n            }\n          }\n\n          r.redrawHint('eles', true);\n        }\n\n      // Tap event, roughly same as mouse click event for touch\n      if (!r.touchData.singleTouchMoved) {\n        triggerEvents(start, ['tap', 'vclick'], e, {\n          position: { x: now[0], y: now[1] }\n        });\n      }\n\n      r.touchData.singleTouchMoved = true;\n    }\n\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    }\n\n    r.dragData.didDrag = false; // reset for next mousedown\n\n    if (e.touches.length === 0) {\n      r.touchData.dragDelta = [];\n      r.touchData.startPosition = null;\n      r.touchData.startGPosition = null;\n    }\n\n    if (e.touches.length < 2) {\n      r.pinching = false;\n      r.redrawHint('eles', true);\n      r.redraw();\n    }\n\n    //r.redraw();\n  }, false);\n\n  // fallback compatibility layer for ms pointer events\n  if (typeof TouchEvent === 'undefined') {\n\n    var pointers = [];\n\n    var makeTouch = function makeTouch(e) {\n      return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n        force: 1,\n        identifier: e.pointerId,\n        pageX: e.pageX,\n        pageY: e.pageY,\n        radiusX: e.width / 2,\n        radiusY: e.height / 2,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        target: e.target\n      };\n    };\n\n    var makePointer = function makePointer(e) {\n      return {\n        event: e,\n        touch: makeTouch(e)\n      };\n    };\n\n    var addPointer = function addPointer(e) {\n      pointers.push(makePointer(e));\n    };\n\n    var removePointer = function removePointer(e) {\n      for (var i = 0; i < pointers.length; i++) {\n        var p = pointers[i];\n\n        if (p.event.pointerId === e.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    var updatePointer = function updatePointer(e) {\n      var p = pointers.filter(function (p) {\n        return p.event.pointerId === e.pointerId;\n      })[0];\n\n      p.event = e;\n      p.touch = makeTouch(e);\n    };\n\n    var addTouchesToEvent = function addTouchesToEvent(e) {\n      e.touches = pointers.map(function (p) {\n        return p.touch;\n      });\n    };\n\n    var pointerIsMouse = function pointerIsMouse(e) {\n      return e.pointerType === 'mouse' || e.pointerType === 4;\n    };\n\n    r.registerBinding(r.container, 'pointerdown', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      e.preventDefault();\n\n      addPointer(e);\n\n      addTouchesToEvent(e);\n      touchstartHandler(e);\n    });\n\n    r.registerBinding(r.container, 'pointerup', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      removePointer(e);\n\n      addTouchesToEvent(e);\n      touchendHandler(e);\n    });\n\n    r.registerBinding(r.container, 'pointercancel', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      removePointer(e);\n\n      addTouchesToEvent(e);\n      touchcancelHandler(e);\n    });\n\n    r.registerBinding(r.container, 'pointermove', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n      e.preventDefault();\n\n      updatePointer(e);\n\n      addTouchesToEvent(e);\n      touchmoveHandler(e);\n    });\n  }\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\n\nvar BRp = {};\n\nBRp.generatePolygon = function (name, points) {\n  return this.nodeShapes[name] = {\n    renderer: this,\n\n    name: name,\n\n    points: points,\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n};\n\nBRp.generateEllipse = function () {\n  return this.nodeShapes['ellipse'] = {\n    renderer: this,\n\n    name: 'ellipse',\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);\n    }\n  };\n};\n\nBRp.generateRoundRectangle = function () {\n  return this.nodeShapes['roundrectangle'] = {\n    renderer: this,\n\n    name: 'roundrectangle',\n\n    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\n      var cornerRadius = math.getRoundRectangleRadius(width, height);\n      var diam = cornerRadius * 2;\n\n      // Check hBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check top left quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n\n        return true;\n      }\n\n      // Check top right quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n\n        return true;\n      }\n\n      // Check bottom right quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\n        return true;\n      }\n\n      // Check bottom left quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\n        return true;\n      }\n\n      return false;\n    }\n  };\n};\n\nBRp.generateCutRectangle = function () {\n  return this.nodeShapes['cutrectangle'] = {\n    renderer: this,\n\n    name: 'cutrectangle',\n\n    cornerLength: math.getCutRectangleCornerLength(),\n\n    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n\n    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n      var cl = this.cornerLength;\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh;\n\n      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n      return {\n        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n      };\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n\n      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      // Check hBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {\n        return true;\n      }\n      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n      return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n    }\n\n  };\n};\n\nBRp.generateBarrel = function () {\n  return this.nodeShapes['barrel'] = {\n    renderer: this,\n\n    name: 'barrel',\n\n    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\n      var pts = [].concat(bPts.topLeft, bPts.topRight, bPts.bottomRight, bPts.bottomLeft);\n\n      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n\n    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh;\n\n      var curveConstants = math.getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset;\n      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n\n      // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n      var pts = {\n        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n      };\n\n      pts.topLeft.isTop = true;\n      pts.topRight.isTop = true;\n      pts.bottomLeft.isBottom = true;\n      pts.bottomRight.isBottom = true;\n\n      return pts;\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\n      var curveConstants = math.getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset;\n\n      // Check hBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n        return true;\n      }\n\n      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n\n      var getCurveT = function getCurveT(x, y, curvePts) {\n        var x0 = curvePts[4];\n        var x1 = curvePts[2];\n        var x2 = curvePts[0];\n        var y0 = curvePts[5];\n        // var y1 = curvePts[ 3 ];\n        var y2 = curvePts[1];\n\n        var xMin = Math.min(x0, x2);\n        var xMax = Math.max(x0, x2);\n        var yMin = Math.min(y0, y2);\n        var yMax = Math.max(y0, y2);\n\n        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n          var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);\n          var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n\n          var validRoots = roots.filter(function (r) {\n            return 0 <= r && r <= 1;\n          });\n\n          if (validRoots.length > 0) {\n            return validRoots[0];\n          }\n        }\n        return null;\n      };\n\n      var curveRegions = Object.keys(barrelCurvePts);\n      for (var i = 0; i < curveRegions.length; i++) {\n        var corner = curveRegions[i];\n        var cornerPts = barrelCurvePts[corner];\n        var t = getCurveT(x, y, cornerPts);\n\n        if (t == null) {\n          continue;\n        }\n\n        var y0 = cornerPts[5];\n        var y1 = cornerPts[3];\n        var y2 = cornerPts[1];\n        var bezY = math.qbezierAt(y0, y1, y2, t);\n\n        if (cornerPts.isTop && bezY <= y) {\n          return true;\n        }\n        if (cornerPts.isBottom && y <= bezY) {\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n};\n\nBRp.generateBottomRoundrectangle = function () {\n  return this.nodeShapes['bottomroundrectangle'] = {\n    renderer: this,\n\n    name: 'bottomroundrectangle',\n\n    points: math.generateUnitNgonPointsFitToSquare(4, 0),\n\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      var topStartX = nodeX - (width / 2 + padding);\n      var topStartY = nodeY - (height / 2 + padding);\n      var topEndY = topStartY;\n      var topEndX = nodeX + (width / 2 + padding);\n\n      var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n      if (topIntersections.length > 0) {\n        return topIntersections;\n      }\n\n      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n    },\n\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n\n      var cornerRadius = math.getRoundRectangleRadius(width, height);\n      var diam = 2 * cornerRadius;\n\n      // Check hBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      }\n\n      // Check vBox\n      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      }\n\n      // check non-rounded top side\n      var outerWidth = width / 2 + 2 * padding;\n      var outerHeight = height / 2 + 2 * padding;\n      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n      if (math.pointInsidePolygonPoints(x, y, points)) {\n        return true;\n      }\n\n      // Check bottom right quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\n        return true;\n      }\n\n      // Check bottom left quarter circle\n      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n\n        return true;\n      }\n\n      return false;\n    }\n  };\n};\n\nBRp.registerNodeShapes = function () {\n  var nodeShapes = this.nodeShapes = {};\n  var renderer = this;\n\n  this.generateEllipse();\n\n  this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));\n\n  this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));\n  nodeShapes['square'] = nodeShapes['rectangle'];\n\n  this.generateRoundRectangle();\n\n  this.generateCutRectangle();\n\n  this.generateBarrel();\n\n  this.generateBottomRoundrectangle();\n\n  this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);\n\n  this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));\n\n  this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));\n\n  this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));\n\n  this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));\n\n  var star5Points = new Array(20);\n  {\n    var outerPoints = math.generateUnitNgonPoints(5, 0);\n    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);\n\n    // Outer radius is 1; inner radius of star is smaller\n    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n    innerRadius *= 1.57;\n\n    for (var i = 0; i < innerPoints.length / 2; i++) {\n      innerPoints[i * 2] *= innerRadius;\n      innerPoints[i * 2 + 1] *= innerRadius;\n    }\n\n    for (var i = 0; i < 20 / 4; i++) {\n      star5Points[i * 4] = outerPoints[i * 2];\n      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n\n      star5Points[i * 4 + 2] = innerPoints[i * 2];\n      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n    }\n  }\n\n  star5Points = math.fitPolygonToSquare(star5Points);\n\n  this.generatePolygon('star', star5Points);\n\n  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n\n  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n\n  this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n\n  this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);\n\n  nodeShapes.makePolygon = function (points) {\n\n    // use caching on user-specified polygons so they are as fast as native shapes\n\n    var key = points.join('$');\n    var name = 'polygon-' + key;\n    var shape;\n\n    if (shape = this[name]) {\n      // got cached shape\n      return shape;\n    }\n\n    // create and cache new shape\n    return renderer.generatePolygon(name, points);\n  };\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\nvar BRp = {};\n\nBRp.timeToRender = function () {\n  return this.redrawTotalTime / this.redrawCount;\n};\n\nBRp.redraw = function (options) {\n  options = options || util.staticEmptyObject();\n\n  var r = this;\n\n  if (r.averageRedrawTime === undefined) {\n    r.averageRedrawTime = 0;\n  }\n  if (r.lastRedrawTime === undefined) {\n    r.lastRedrawTime = 0;\n  }\n  if (r.lastDrawTime === undefined) {\n    r.lastDrawTime = 0;\n  }\n\n  r.requestedFrame = true;\n  r.renderOptions = options;\n};\n\nBRp.beforeRender = function (fn, priority) {\n  // the renderer can't add tick callbacks when destroyed\n  if (this.destroyed) {\n    return;\n  }\n\n  priority = priority || 0;\n\n  var cbs = this.beforeRenderCallbacks;\n\n  cbs.push({ fn: fn, priority: priority });\n\n  // higher priority callbacks executed first\n  cbs.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n};\n\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n  var cbs = r.beforeRenderCallbacks;\n\n  for (var i = 0; i < cbs.length; i++) {\n    cbs[i].fn(willDraw, startTime);\n  }\n};\n\nBRp.startRenderLoop = function () {\n  var r = this;\n\n  if (r.renderLoopStarted) {\n    return;\n  } else {\n    r.renderLoopStarted = true;\n  }\n\n  var renderFn = function renderFn(requestTime) {\n    if (r.destroyed) {\n      return;\n    }\n\n    if (r.requestedFrame && !r.skipFrame) {\n      beforeRenderCallbacks(r, true, requestTime);\n\n      var startTime = util.performanceNow();\n\n      r.render(r.renderOptions);\n\n      var endTime = r.lastDrawTime = util.performanceNow();\n\n      if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = endTime - startTime;\n      }\n\n      if (r.redrawCount === undefined) {\n        r.redrawCount = 0;\n      }\n\n      r.redrawCount++;\n\n      if (r.redrawTotalTime === undefined) {\n        r.redrawTotalTime = 0;\n      }\n\n      var duration = endTime - startTime;\n\n      r.redrawTotalTime += duration;\n      r.lastRedrawTime = duration;\n\n      // use a weighted average with a bias from the previous average so we don't spike so easily\n      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n\n      r.requestedFrame = false;\n    } else {\n      beforeRenderCallbacks(r, false, requestTime);\n    }\n\n    r.skipFrame = false;\n\n    util.requestAnimationFrame(renderFn);\n  };\n\n  util.requestAnimationFrame(renderFn);\n};\n\nmodule.exports = BRp;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar CRp = {};\n\nvar impl;\n\nCRp.arrowShapeImpl = function (name) {\n  return (impl || (impl = {\n    'polygon': function polygon(context, points) {\n      for (var i = 0; i < points.length; i++) {\n        var pt = points[i];\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n\n    'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {\n      var firstPt;\n\n      for (var i = 0; i < points.length; i++) {\n        var pt = points[i];\n\n        if (i === 0) {\n          firstPt = pt;\n        }\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n      context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n    },\n\n    'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      var triPts = trianglePoints;\n      for (var i = 0; i < triPts.length; i++) {\n        var pt = triPts[i];\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n      if (context.closePath) {\n        context.closePath();\n      }\n\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      var teePts = teePoints;\n      var firstTeePt = teePoints[0];\n      context.moveTo(firstTeePt.x, firstTeePt.y);\n\n      for (var i = 0; i < teePts.length; i++) {\n        var pt = teePts[i];\n\n        context.lineTo(pt.x, pt.y);\n      }\n      if (context.closePath) {\n        context.closePath();\n      }\n    },\n\n    'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      var triPts = trianglePoints;\n      for (var i = 0; i < triPts.length; i++) {\n        var pt = triPts[i];\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n      if (context.closePath) {\n        context.closePath();\n      }\n\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      var teePts = crossLinePoints;\n      var firstTeePt = crossLinePoints[0];\n      context.moveTo(firstTeePt.x, firstTeePt.y);\n\n      for (var i = 0; i < teePts.length; i++) {\n        var pt = teePts[i];\n\n        context.lineTo(pt.x, pt.y);\n      }\n      if (context.closePath) {\n        context.closePath();\n      }\n    },\n\n    'circle': function circle(context, rx, ry, r) {\n      context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    }\n  }))[name];\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar CRp = {};\n\nCRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {\n  var r = this;\n  var rs = edge._private.rscratch;\n  var usePaths = r.usePaths();\n\n  // if bezier ctrl pts can not be calculated, then die\n  if (rs.badLine || isNaN(rs.allpts[0])) {\n    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n    return;\n  }\n\n  if (!edge.visible()) {\n    return;\n  }\n\n  var bb = void 0;\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n\n    context.translate(-bb.x1, -bb.y1);\n  }\n\n  var overlayPadding = edge.pstyle('overlay-padding').pfValue;\n  var overlayWidth = 2 * overlayPadding;\n  var overlayOpacity = edge.pstyle('overlay-opacity').value;\n  var overlayColor = edge.pstyle('overlay-color').value;\n  var lineColor = edge.pstyle('line-color').value;\n  var opacity = edge.pstyle('opacity').value;\n  var lineStyle = edge.pstyle('line-style').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n\n  var drawLine = function drawLine() {\n    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;\n\n    context.lineWidth = edgeWidth;\n    context.lineCap = 'butt';\n\n    r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);\n\n    r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n  };\n\n  var drawOverlay = function drawOverlay() {\n    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;\n\n    context.lineWidth = overlayWidth;\n\n    if (rs.edgeType === 'self' && !usePaths) {\n      context.lineCap = 'butt';\n    } else {\n      context.lineCap = 'round';\n    }\n\n    r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);\n\n    r.drawEdgePath(edge, context, rs.allpts, 'solid');\n  };\n\n  var drawArrows = function drawArrows() {\n    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;\n\n    r.drawArrowheads(context, edge, arrowOpacity);\n  };\n\n  var drawText = function drawText() {\n    r.drawElementText(context, edge, drawLabel);\n  };\n\n  context.lineJoin = 'round';\n\n  var ghost = edge.pstyle('ghost').value === 'yes';\n\n  if (ghost) {\n    var gx = edge.pstyle('ghost-offset-x').pfValue;\n    var gy = edge.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = edge.pstyle('ghost-opacity').value;\n    var effectiveGhostOpacity = opacity * ghostOpacity;\n\n    context.translate(gx, gy);\n\n    drawLine(effectiveGhostOpacity);\n    drawArrows(effectiveGhostOpacity);\n\n    context.translate(-gx, -gy);\n  }\n\n  drawLine();\n  drawArrows();\n  drawOverlay();\n  drawText();\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\n\nCRp.drawEdgePath = function (edge, context, pts, type) {\n  var rs = edge._private.rscratch;\n  var canvasCxt = context;\n  var path = void 0;\n  var pathCacheHit = false;\n  var usePaths = this.usePaths();\n\n  if (usePaths) {\n    var pathCacheKey = pts.join('$');\n    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\n    if (keyMatches) {\n      path = context = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D(); // eslint-disable-line no-undef\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n\n  if (canvasCxt.setLineDash) {\n    // for very outofdate browsers\n    switch (type) {\n      case 'dotted':\n        canvasCxt.setLineDash([1, 1]);\n        break;\n\n      case 'dashed':\n        canvasCxt.setLineDash([6, 3]);\n        break;\n\n      case 'solid':\n        canvasCxt.setLineDash([]);\n        break;\n    }\n  }\n\n  if (!pathCacheHit && !rs.badLine) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n    context.moveTo(pts[0], pts[1]);\n\n    switch (rs.edgeType) {\n      case 'bezier':\n      case 'self':\n      case 'compound':\n      case 'multibezier':\n        for (var i = 2; i + 3 < pts.length; i += 4) {\n          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n        }\n        break;\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n          context.lineTo(pts[_i], pts[_i + 1]);\n        }\n        break;\n    }\n  }\n\n  context = canvasCxt;\n  if (usePaths) {\n    context.stroke(path);\n  } else {\n    context.stroke();\n  }\n\n  // reset any line dashes\n  if (context.setLineDash) {\n    // for very outofdate browsers\n    context.setLineDash([]);\n  }\n};\n\nCRp.drawArrowheads = function (context, edge, opacity) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n  }\n\n  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n\n  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n  }\n};\n\nCRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n    return;\n  }\n\n  var self = this;\n  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n  if (arrowShape === 'none') {\n    return;\n  }\n\n  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  var edgeOpacity = edge.pstyle('opacity').value;\n\n  if (opacity === undefined) {\n    opacity = edgeOpacity;\n  }\n\n  var gco = context.globalCompositeOperation;\n\n  if (opacity !== 1 || arrowFill === 'hollow') {\n    // then extra clear is needed\n    context.globalCompositeOperation = 'destination-out';\n\n    self.fillStyle(context, 255, 255, 255, 1);\n    self.strokeStyle(context, 255, 255, 255, 1);\n\n    self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n\n    context.globalCompositeOperation = gco;\n  } // otherwise, the opaque arrow clears it for free :)\n\n  var color = edge.pstyle(prefix + '-arrow-color').value;\n  self.fillStyle(context, color[0], color[1], color[2], opacity);\n  self.strokeStyle(context, color[0], color[1], color[2], opacity);\n\n  self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n};\n\nCRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {\n  var r = this;\n  var usePaths = this.usePaths();\n  var rs = edge._private.rscratch;\n  var pathCacheHit = false;\n  var path = void 0;\n  var canvasContext = context;\n  var translation = { x: x, y: y };\n  var scale = edge.pstyle('arrow-scale').value;\n  var size = this.getArrowWidth(edgeWidth, scale);\n  var shapeImpl = r.arrowShapes[shape];\n\n  if (usePaths) {\n    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n    rs.arrowPathCache = rs.arrowPathCache || {};\n\n    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;\n    if (alreadyCached) {\n      path = context = rs.arrowPathCache[arrowType];\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D(); // eslint-disable-line no-undef\n      rs.arrowPathCacheKey[arrowType] = pathCacheKey;\n      rs.arrowPathCache[arrowType] = path;\n    }\n  }\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  if (!pathCacheHit) {\n    shapeImpl.draw(context, size, angle, translation, edgeWidth);\n  }\n\n  if (!shapeImpl.leavePathOpen && context.closePath) {\n    context.closePath();\n  }\n\n  context = canvasContext;\n\n  if (fill === 'filled' || fill === 'both') {\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  }\n\n  if (fill === 'hollow' || fill === 'both') {\n    context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;\n    context.lineJoin = 'miter';\n\n    if (usePaths) {\n      context.stroke(path);\n    } else {\n      context.stroke();\n    }\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\n\nvar CRp = {};\n\nCRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {\n  var r = this;\n\n  if (ele.isNode()) {\n    r.drawNode(context, ele, shiftToOriginWithBb, showLabel);\n  } else {\n    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);\n  }\n};\n\nCRp.drawCachedElement = function (context, ele, pxRatio, extent) {\n  var r = this;\n  var bb = ele.boundingBox();\n\n  if (bb.w === 0 || bb.h === 0) {\n    return;\n  }\n\n  if (!extent || math.boundingBoxesIntersect(bb, extent)) {\n    var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);\n\n    if (cache != null) {\n      context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);\n    } else {\n      // if the element is not cacheable, then draw directly\n      r.drawElement(context, ele);\n    }\n  }\n};\n\nCRp.drawElements = function (context, eles) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    r.drawElement(context, ele);\n  }\n};\n\nCRp.drawCachedElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\n\nCRp.drawCachedNodes = function (context, eles, pxRatio, extent) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (!ele.isNode()) {\n      continue;\n    }\n\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\n\nCRp.drawLayeredElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n\n  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n\n  if (layers) {\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i];\n      var bb = layer.bb;\n\n      if (bb.w === 0 || bb.h === 0) {\n        continue;\n      }\n\n      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n    }\n  } else {\n    // fall back on plain caching if no layers\n    r.drawCachedElements(context, eles, pxRatio, extent);\n  }\n};\n\nCRp.drawDebugPoints = function (context, eles) {\n  var draw = function draw(x, y, color) {\n    context.fillStyle = color;\n    context.fillRect(x - 1, y - 1, 3, 3);\n  };\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n\n    if (ele.isNode()) {\n      var p = ele.position();\n\n      draw(p.x, p.y, 'magenta');\n    } else {\n      var pts = rs.allpts;\n\n      for (var j = 0; j + 1 < pts.length; j += 2) {\n        var x = pts[j];\n        var y = pts[j + 1];\n\n        draw(x, y, 'cyan');\n      }\n\n      draw(rs.midX, rs.midY, 'yellow');\n    }\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar CRp = {};\n\nCRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n  var r = this;\n\n  // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n    return;\n  }\n\n  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n};\n\nCRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n  var r = this;\n  var pos = node.position();\n  var nodeX = pos.x;\n  var nodeY = pos.y;\n  var styleObj = node.cy().style();\n  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n  var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var paddingX2 = node.padding() * 2;\n  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var rs = node._private.rscratch;\n  var clip = node.pstyle('background-clip').value;\n  var shouldClip = clip === 'node';\n  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n\n  var imgW = img.width || img.cachedW;\n  var imgH = img.height || img.cachedH;\n\n  // workaround for broken browsers like ie\n  if (null == imgW || null == imgH) {\n    document.body.appendChild(img); // eslint-disable-line no-undef\n\n    imgW = img.cachedW = img.width || img.offsetWidth;\n    imgH = img.cachedH = img.height || img.offsetHeight;\n\n    document.body.removeChild(img); // eslint-disable-line no-undef\n  }\n\n  var w = imgW;\n  var h = imgH;\n\n  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n    } else {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n    }\n  }\n\n  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n    } else {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n    }\n  }\n\n  if (w === 0 || h === 0) {\n    return; // no point in drawing empty image (and chrome is broken in this case)\n  }\n\n  if (fit === 'contain') {\n    var scale = Math.min(nodeTW / w, nodeTH / h);\n\n    w *= scale;\n    h *= scale;\n  } else if (fit === 'cover') {\n    var scale = Math.max(nodeTW / w, nodeTH / h);\n\n    w *= scale;\n    h *= scale;\n  }\n\n  var x = nodeX - nodeTW / 2; // left\n  if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {\n    x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n  } else {\n    x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n  }\n\n  var y = nodeY - nodeTH / 2; // top\n  if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {\n    y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n  } else {\n    y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n  }\n\n  if (rs.pathCache) {\n    x -= nodeX;\n    y -= nodeY;\n\n    nodeX = 0;\n    nodeY = 0;\n  }\n\n  var gAlpha = context.globalAlpha;\n\n  context.globalAlpha = imgOpacity;\n\n  if (repeat === 'no-repeat') {\n\n    if (shouldClip) {\n      context.save();\n\n      if (rs.pathCache) {\n        context.clip(rs.pathCache);\n      } else {\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n\n        context.clip();\n      }\n    }\n\n    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n\n    if (shouldClip) {\n      context.restore();\n    }\n  } else {\n    var pattern = context.createPattern(img, repeat);\n    context.fillStyle = pattern;\n\n    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n\n    context.translate(x, y);\n    context.fill();\n    context.translate(-x, -y);\n  }\n\n  context.globalAlpha = gAlpha;\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\n\nvar CRp = {};\n\nCRp.eleTextBiggerThanMin = function (ele, scale) {\n  if (!scale) {\n    var zoom = ele.cy().zoom();\n    var pxRatio = this.getPixelRatio();\n    var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level\n\n    scale = Math.pow(2, lvl);\n  }\n\n  var computedSize = ele.pstyle('font-size').pfValue * scale;\n  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n\n  if (computedSize < minSize) {\n    return false;\n  }\n\n  return true;\n};\n\nCRp.drawElementText = function (context, ele, force) {\n  var r = this;\n\n  if (force === undefined) {\n    if (!r.eleTextBiggerThanMin(ele)) {\n      return;\n    }\n  } else {\n    if (!force) {\n      return;\n    }\n  }\n\n  if (ele.isNode()) {\n    var label = ele.pstyle('label');\n\n    if (!label || !label.value) {\n      return;\n    }\n\n    var textHalign = ele.pstyle('text-halign').strValue;\n    var textValign = ele.pstyle('text-valign').strValue;\n\n    switch (textHalign) {\n      case 'left':\n        context.textAlign = 'right';\n        break;\n\n      case 'right':\n        context.textAlign = 'left';\n        break;\n\n      default:\n        // e.g. center\n        context.textAlign = 'center';\n    }\n\n    context.textBaseline = 'bottom';\n  } else {\n    var label = ele.pstyle('label');\n    var srcLabel = ele.pstyle('source-label');\n    var tgtLabel = ele.pstyle('target-label');\n\n    if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n      return;\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'bottom';\n  }\n\n  r.drawText(context, ele);\n\n  if (ele.isEdge()) {\n    r.drawText(context, ele, 'source');\n\n    r.drawText(context, ele, 'target');\n  }\n};\n\nCRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;\n\nCRp.getFontCache = function (context) {\n  var cache;\n\n  this.fontCaches = this.fontCaches || [];\n\n  for (var i = 0; i < this.fontCaches.length; i++) {\n    cache = this.fontCaches[i];\n\n    if (cache.context === context) {\n      return cache;\n    }\n  }\n\n  cache = {\n    context: context\n  };\n  this.fontCaches.push(cache);\n\n  return cache;\n};\n\n// set up canvas context with font\n// returns transformed text string\nCRp.setupTextStyle = function (context, ele) {\n  // Font style\n  var parentOpacity = ele.effectiveOpacity();\n  var labelStyle = ele.pstyle('font-style').strValue;\n  var labelSize = ele.pstyle('font-size').pfValue + 'px';\n  var labelFamily = ele.pstyle('font-family').strValue;\n  var labelWeight = ele.pstyle('font-weight').strValue;\n  var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;\n  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n  var color = ele.pstyle('color').value;\n  var outlineColor = ele.pstyle('text-outline-color').value;\n\n  var fontCacheKey = ele._private.fontKey;\n  var cache = this.getFontCache(context);\n\n  if (cache.key !== fontCacheKey) {\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\n    cache.key = fontCacheKey;\n  }\n\n  // Calculate text draw position based on text alignment\n\n  // so text outlines aren't jagged\n  context.lineJoin = 'round';\n\n  this.fillStyle(context, color[0], color[1], color[2], opacity);\n\n  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n};\n\nfunction roundRect(ctx, x, y, width, height, radius) {\n  var radius = radius || 5;\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n  ctx.fill();\n}\n\n// Draw text\nCRp.drawText = function (context, ele, prefix) {\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var parentOpacity = ele.effectiveOpacity();\n  if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {\n    return;\n  }\n\n  var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);\n  var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);\n  var text = this.getLabelText(ele, prefix);\n\n  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n    this.setupTextStyle(context, ele);\n\n    var pdash = prefix ? prefix + '-' : '';\n    var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);\n    var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);\n    var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);\n    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n\n    var isEdge = ele.isEdge();\n    var isNode = ele.isNode();\n\n    var halign = ele.pstyle('text-halign').value;\n    var valign = ele.pstyle('text-valign').value;\n\n    if (isEdge) {\n      halign = 'center';\n      valign = 'center';\n    }\n\n    textX += marginX;\n    textY += marginY;\n\n    var rotation = ele.pstyle('text-rotation');\n    var theta;\n\n    if (rotation.strValue === 'autorotate') {\n      theta = isEdge ? textAngle : 0;\n    } else if (rotation.strValue === 'none') {\n      theta = 0;\n    } else {\n      theta = rotation.pfValue;\n    }\n\n    if (theta !== 0) {\n      var orgTextX = textX;\n      var orgTextY = textY;\n\n      context.translate(orgTextX, orgTextY);\n      context.rotate(theta);\n\n      textX = 0;\n      textY = 0;\n    }\n\n    switch (valign) {\n      case 'top':\n        break;\n      case 'center':\n        textY += textH / 2;\n        break;\n      case 'bottom':\n        textY += textH;\n        break;\n    }\n\n    var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n    var borderOpacity = ele.pstyle('text-border-opacity').value;\n    var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n\n    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n      var bgX = textX - backgroundPadding;\n\n      switch (halign) {\n        case 'left':\n          bgX -= textW;\n          break;\n        case 'center':\n          bgX -= textW / 2;\n          break;\n        case 'right':\n          break;\n      }\n\n      var bgY = textY - textH - backgroundPadding;\n      var bgW = textW + 2 * backgroundPadding;\n      var bgH = textH + 2 * backgroundPadding;\n\n      if (backgroundOpacity > 0) {\n        var textFill = context.fillStyle;\n        var textBackgroundColor = ele.pstyle('text-background-color').value;\n\n        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n        var styleShape = ele.pstyle('text-background-shape').strValue;\n        if (styleShape == 'roundrectangle') {\n          roundRect(context, bgX, bgY, bgW, bgH, 2);\n        } else {\n          context.fillRect(bgX, bgY, bgW, bgH);\n        }\n        context.fillStyle = textFill;\n      }\n\n      if (textBorderWidth > 0 && borderOpacity > 0) {\n        var textStroke = context.strokeStyle;\n        var textLineWidth = context.lineWidth;\n        var textBorderColor = ele.pstyle('text-border-color').value;\n        var textBorderStyle = ele.pstyle('text-border-style').value;\n\n        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n        context.lineWidth = textBorderWidth;\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          switch (textBorderStyle) {\n            case 'dotted':\n              context.setLineDash([1, 1]);\n              break;\n            case 'dashed':\n              context.setLineDash([4, 2]);\n              break;\n            case 'double':\n              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n              context.setLineDash([]);\n              break;\n            case 'solid':\n              context.setLineDash([]);\n              break;\n          }\n        }\n\n        context.strokeRect(bgX, bgY, bgW, bgH);\n\n        if (textBorderStyle === 'double') {\n          var whiteWidth = textBorderWidth / 2;\n\n          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n        }\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          context.setLineDash([]);\n        }\n        context.lineWidth = textLineWidth;\n        context.strokeStyle = textStroke;\n      }\n    }\n\n    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n    if (lineWidth > 0) {\n      context.lineWidth = lineWidth;\n    }\n\n    if (ele.pstyle('text-wrap').value === 'wrap') {\n      var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n      var lineHeight = textH / lines.length;\n\n      switch (valign) {\n        case 'top':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n        case 'center':\n        case 'bottom':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n      }\n\n      for (var l = 0; l < lines.length; l++) {\n        if (lineWidth > 0) {\n          context.strokeText(lines[l], textX, textY);\n        }\n\n        context.fillText(lines[l], textX, textY);\n\n        textY += lineHeight;\n      }\n    } else {\n      if (lineWidth > 0) {\n        context.strokeText(text, textX, textY);\n      }\n\n      context.fillText(text, textX, textY);\n    }\n\n    if (theta !== 0) {\n      context.rotate(-theta);\n      context.translate(-orgTextX, -orgTextY);\n    }\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/* global Path2D */\n\nvar is = __webpack_require__(0);\n\nvar CRp = {};\n\nCRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {\n  var r = this;\n  var nodeWidth = void 0,\n      nodeHeight = void 0;\n  var _p = node._private;\n  var rs = _p.rscratch;\n  var pos = node.position();\n\n  if (!is.number(pos.x) || !is.number(pos.y)) {\n    return; // can't draw node with undefined position\n  }\n\n  if (!node.visible()) {\n    return;\n  }\n\n  var parentOpacity = node.effectiveOpacity();\n\n  var usePaths = r.usePaths();\n  var path = void 0;\n  var pathCacheHit = false;\n\n  var padding = node.padding();\n\n  nodeWidth = node.width() + 2 * padding;\n  nodeHeight = node.height() + 2 * padding;\n\n  context.lineWidth = node.pstyle('border-width').pfValue;\n\n  //\n  // setup shift\n\n  var bb = void 0;\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n\n    context.translate(-bb.x1, -bb.y1);\n  }\n\n  //\n  // load bg image\n\n  var bgImgProp = node.pstyle('background-image');\n  var urls = bgImgProp.value;\n  var url = void 0;\n  var urlDefined = [];\n  var image = [];\n  var numImages = urls.length;\n  for (var i = 0; i < numImages; i++) {\n    url = urls[i];\n    urlDefined[i] = url != null && url !== 'none';\n    if (urlDefined[i]) {\n      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n\n      // get image, and if not loaded then ask to redraw when later loaded\n      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n        node.emitAndNotify('background');\n      });\n    }\n  }\n\n  //\n  // setup styles\n\n  var darkness = node.pstyle('background-blacken').value;\n  var borderWidth = node.pstyle('border-width').pfValue;\n  var bgColor = node.pstyle('background-color').value;\n  var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;\n  var borderColor = node.pstyle('border-color').value;\n  var borderStyle = node.pstyle('border-style').value;\n  var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;\n\n  context.lineJoin = 'miter'; // so borders are square with the node shape\n\n  if (context.setLineDash) {\n    // for very outofdate browsers\n    switch (borderStyle) {\n      case 'dotted':\n        context.setLineDash([1, 1]);\n        break;\n\n      case 'dashed':\n        context.setLineDash([4, 2]);\n        break;\n\n      case 'solid':\n      case 'double':\n        context.setLineDash([]);\n        break;\n    }\n  }\n\n  var setupShapeColor = function setupShapeColor() {\n    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n\n    r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);\n  };\n\n  var setupBorderColor = function setupBorderColor() {\n    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n\n    r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n  };\n\n  //\n  // setup shape\n\n  var styleShape = node.pstyle('shape').strValue;\n  var shapePts = node.pstyle('shape-polygon-points').pfValue;\n\n  if (usePaths) {\n    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');\n\n    context.translate(pos.x, pos.y);\n\n    if (rs.pathCacheKey === pathCacheKey) {\n      path = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = new Path2D();\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n\n  var drawShape = function drawShape() {\n    if (!pathCacheHit) {\n\n      var npos = pos;\n\n      if (usePaths) {\n        npos = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n    }\n\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  };\n\n  var drawImages = function drawImages() {\n    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;\n\n    var prevBging = _p.backgrounding;\n    var totalCompleted = 0;\n\n    for (var _i = 0; _i < numImages; _i++) {\n      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n        totalCompleted++;\n        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n      }\n    }\n\n    _p.backgrounding = !(totalCompleted === numImages);\n    if (prevBging !== _p.backgrounding) {\n      // update style b/c :backgrounding state changed\n      node.updateStyle(false);\n    }\n  };\n\n  var drawPie = function drawPie() {\n    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;\n\n    if (r.hasPie(node)) {\n      r.drawPie(context, node, pieOpacity);\n\n      // redraw/restore path if steps after pie need it\n      if (redrawShape) {\n\n        if (!usePaths) {\n          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n        }\n      }\n    }\n  };\n\n  var darken = function darken() {\n    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;\n\n    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n    var c = darkness > 0 ? 0 : 255;\n\n    if (darkness !== 0) {\n      r.fillStyle(context, c, c, c, opacity);\n\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    }\n  };\n\n  var drawBorder = function drawBorder() {\n    if (borderWidth > 0) {\n\n      if (usePaths) {\n        context.stroke(path);\n      } else {\n        context.stroke();\n      }\n\n      if (borderStyle === 'double') {\n        context.lineWidth = borderWidth / 3;\n\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n\n        if (usePaths) {\n          context.stroke(path);\n        } else {\n          context.stroke();\n        }\n\n        context.globalCompositeOperation = gco;\n      }\n    }\n  };\n\n  var drawOverlay = function drawOverlay() {\n    var overlayPadding = node.pstyle('overlay-padding').pfValue;\n    var overlayOpacity = node.pstyle('overlay-opacity').value;\n    var overlayColor = node.pstyle('overlay-color').value;\n\n    if (overlayOpacity > 0) {\n      r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n\n      r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);\n\n      context.fill();\n    }\n  };\n\n  var drawText = function drawText() {\n    r.drawElementText(context, node, drawLabel);\n  };\n\n  var ghost = node.pstyle('ghost').value === 'yes';\n\n  if (ghost) {\n    var gx = node.pstyle('ghost-offset-x').pfValue;\n    var gy = node.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = node.pstyle('ghost-opacity').value;\n    var effGhostOpacity = ghostOpacity * parentOpacity;\n\n    context.translate(gx, gy);\n\n    setupShapeColor(ghostOpacity * bgOpacity);\n    drawShape();\n    drawImages(effGhostOpacity);\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    darken(effGhostOpacity);\n    setupBorderColor(ghostOpacity * borderOpacity);\n    drawBorder();\n\n    context.translate(-gx, -gy);\n  }\n\n  setupShapeColor();\n  drawShape();\n  drawImages();\n  drawPie(darkness !== 0 || borderWidth !== 0);\n  darken();\n  setupBorderColor();\n  drawBorder();\n\n  if (usePaths) {\n    context.translate(-pos.x, -pos.y);\n  }\n\n  drawText();\n  drawOverlay();\n\n  // reset in case we changed the border style\n  if (context.setLineDash) {\n    // for very outofdate browsers\n    context.setLineDash([]);\n  }\n\n  //\n  // clean up shift\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\n\n// does the node have at least one pie piece?\nCRp.hasPie = function (node) {\n  node = node[0]; // ensure ele ref\n\n  return node._private.hasPie;\n};\n\nCRp.drawPie = function (context, node, nodeOpacity, pos) {\n  node = node[0]; // ensure ele ref\n  pos = pos || node.position();\n\n  var cyStyle = node.cy().style();\n  var pieSize = node.pstyle('pie-size');\n  var x = pos.x;\n  var y = pos.y;\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n  var usePaths = this.usePaths();\n\n  if (usePaths) {\n    x = 0;\n    y = 0;\n  }\n\n  if (pieSize.units === '%') {\n    radius = radius * pieSize.pfValue;\n  } else if (pieSize.pfValue !== undefined) {\n    radius = pieSize.pfValue / 2;\n  }\n\n  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n    // 1..N\n    var size = node.pstyle('pie-' + i + '-background-size').value;\n    var color = node.pstyle('pie-' + i + '-background-color').value;\n    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n\n    // percent can't push beyond 1\n    if (percent + lastPercent > 1) {\n      percent = 1 - lastPercent;\n    }\n\n    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n    var angleDelta = 2 * Math.PI * percent;\n    var angleEnd = angleStart + angleDelta;\n\n    // ignore if\n    // - zero size\n    // - we're already beyond the full circle\n    // - adding the current slice would go beyond the full circle\n    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n      continue;\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.arc(x, y, radius, angleStart, angleEnd);\n    context.closePath();\n\n    this.fillStyle(context, color[0], color[1], color[2], opacity);\n\n    context.fill();\n\n    lastPercent += percent;\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar CRp = {};\n\nvar util = __webpack_require__(1);\n\nvar motionBlurDelay = 100;\n\n// var isFirefox = typeof InstallTrigger !== 'undefined';\n\nCRp.getPixelRatio = function () {\n  var context = this.data.contexts[0];\n\n  if (this.forcedPixelRatio != null) {\n    return this.forcedPixelRatio;\n  }\n\n  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n\n  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\n\nCRp.paintCache = function (context) {\n  var caches = this.paintCaches = this.paintCaches || [];\n  var needToCreateCache = true;\n  var cache;\n\n  for (var i = 0; i < caches.length; i++) {\n    cache = caches[i];\n\n    if (cache.context === context) {\n      needToCreateCache = false;\n      break;\n    }\n  }\n\n  if (needToCreateCache) {\n    cache = {\n      context: context\n    };\n    caches.push(cache);\n  }\n\n  return cache;\n};\n\nCRp.fillStyle = function (context, r, g, b, a) {\n  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.fillStyle !== fillStyle ){\n  //   context.fillStyle = cache.fillStyle = fillStyle;\n  // }\n};\n\nCRp.strokeStyle = function (context, r, g, b, a) {\n  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.strokeStyle !== strokeStyle ){\n  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n  // }\n};\n\n// Resize canvas\nCRp.matchCanvasSize = function (container) {\n  var r = this;\n  var data = r.data;\n  var bb = r.findContainerClientCoords();\n  var width = bb[2];\n  var height = bb[3];\n  var pixelRatio = r.getPixelRatio();\n  var mbPxRatio = r.motionBlurPxRatio;\n\n  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n    pixelRatio = mbPxRatio;\n  }\n\n  var canvasWidth = width * pixelRatio;\n  var canvasHeight = height * pixelRatio;\n  var canvas;\n\n  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n    return; // save cycles if same\n  }\n\n  r.fontCaches = null; // resizing resets the style\n\n  var canvasContainer = data.canvasContainer;\n  canvasContainer.style.width = width + 'px';\n  canvasContainer.style.height = height + 'px';\n\n  for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n    canvas = data.canvases[i];\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  for (var i = 0; i < r.BUFFER_COUNT; i++) {\n    canvas = data.bufferCanvases[i];\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  r.textureMult = 1;\n  if (pixelRatio <= 1) {\n    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n\n    r.textureMult = 2;\n    canvas.width = canvasWidth * r.textureMult;\n    canvas.height = canvasHeight * r.textureMult;\n  }\n\n  r.canvasWidth = canvasWidth;\n  r.canvasHeight = canvasHeight;\n};\n\nCRp.renderTo = function (cxt, zoom, pan, pxRatio) {\n  this.render({\n    forcedContext: cxt,\n    forcedZoom: zoom,\n    forcedPan: pan,\n    drawAllLayers: true,\n    forcedPxRatio: pxRatio\n  });\n};\n\nCRp.render = function (options) {\n  options = options || util.staticEmptyObject();\n\n  var forcedContext = options.forcedContext;\n  var drawAllLayers = options.drawAllLayers;\n  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n  var forcedZoom = options.forcedZoom;\n  var forcedPan = options.forcedPan;\n  var r = this;\n  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n  var cy = r.cy;var data = r.data;\n  var needDraw = data.canvasNeedsRedraw;\n  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n  var mbPxRatio = r.motionBlurPxRatio;\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var inNodeDragGesture = r.hoverData.draggingEles;\n  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n  var motionBlurFadeEffect = motionBlur;\n\n  if (!forcedContext) {\n    if (r.prevPxRatio !== pixelRatio) {\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize(r.container);\n\n      r.redrawHint('eles', true);\n      r.redrawHint('drag', true);\n    }\n\n    r.prevPxRatio = pixelRatio;\n  }\n\n  if (!forcedContext && r.motionBlurTimeout) {\n    clearTimeout(r.motionBlurTimeout);\n  }\n\n  if (motionBlur) {\n    if (r.mbFrames == null) {\n      r.mbFrames = 0;\n    }\n\n    r.mbFrames++;\n\n    if (r.mbFrames < 3) {\n      // need several frames before even high quality motionblur\n      motionBlurFadeEffect = false;\n    }\n\n    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n    if (r.mbFrames > r.minMbLowQualFrames) {\n      //r.fullQualityMb = false;\n      r.motionBlurPxRatio = r.mbPxRBlurry;\n    }\n  }\n\n  if (r.clearingMotionBlur) {\n    r.motionBlurPxRatio = 1;\n  }\n\n  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n  // because a rogue async texture frame would clear needDraw\n  if (r.textureDrawLastFrame && !textureDraw) {\n    needDraw[r.NODE] = true;\n    needDraw[r.SELECT_BOX] = true;\n  }\n\n  var coreStyle = cy.style()._private.coreStyle;\n\n  var zoom = cy.zoom();\n  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n  var pan = cy.pan();\n  var effectivePan = {\n    x: pan.x,\n    y: pan.y\n  };\n\n  var vp = {\n    zoom: zoom,\n    pan: {\n      x: pan.x,\n      y: pan.y\n    }\n  };\n  var prevVp = r.prevViewport;\n  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n\n  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n    r.motionBlurPxRatio = 1;\n  }\n\n  if (forcedPan) {\n    effectivePan = forcedPan;\n  }\n\n  // apply pixel ratio\n\n  effectiveZoom *= pixelRatio;\n  effectivePan.x *= pixelRatio;\n  effectivePan.y *= pixelRatio;\n\n  var eles = r.getCachedZSortedEles();\n\n  function mbclear(context, x, y, w, h) {\n    var gco = context.globalCompositeOperation;\n\n    context.globalCompositeOperation = 'destination-out';\n    r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n    context.fillRect(x, y, w, h);\n\n    context.globalCompositeOperation = gco;\n  }\n\n  function setContextTransform(context, clear) {\n    var ePan, eZoom, w, h;\n\n    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n      ePan = {\n        x: pan.x * mbPxRatio,\n        y: pan.y * mbPxRatio\n      };\n\n      eZoom = zoom * mbPxRatio;\n\n      w = r.canvasWidth * mbPxRatio;\n      h = r.canvasHeight * mbPxRatio;\n    } else {\n      ePan = effectivePan;\n      eZoom = effectiveZoom;\n\n      w = r.canvasWidth;\n      h = r.canvasHeight;\n    }\n\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (clear === 'motionBlur') {\n      mbclear(context, 0, 0, w, h);\n    } else if (!forcedContext && (clear === undefined || clear)) {\n      context.clearRect(0, 0, w, h);\n    }\n\n    if (!drawAllLayers) {\n      context.translate(ePan.x, ePan.y);\n      context.scale(eZoom, eZoom);\n    }\n    if (forcedPan) {\n      context.translate(forcedPan.x, forcedPan.y);\n    }\n    if (forcedZoom) {\n      context.scale(forcedZoom, forcedZoom);\n    }\n  }\n\n  if (!textureDraw) {\n    r.textureDrawLastFrame = false;\n  }\n\n  if (textureDraw) {\n    r.textureDrawLastFrame = true;\n\n    var bb;\n\n    if (!r.textureCache) {\n      r.textureCache = {};\n\n      bb = r.textureCache.bb = cy.mutableElements().boundingBox();\n\n      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n\n      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n\n      r.render({\n        forcedContext: cxt,\n        drawOnlyNodeLayer: true,\n        forcedPxRatio: pixelRatio * r.textureMult\n      });\n\n      var vp = r.textureCache.viewport = {\n        zoom: cy.zoom(),\n        pan: cy.pan(),\n        width: r.canvasWidth,\n        height: r.canvasHeight\n      };\n\n      vp.mpan = {\n        x: (0 - vp.pan.x) / vp.zoom,\n        y: (0 - vp.pan.y) / vp.zoom\n      };\n    }\n\n    needDraw[r.DRAG] = false;\n    needDraw[r.NODE] = false;\n\n    var context = data.contexts[r.NODE];\n\n    var texture = r.textureCache.texture;\n    var vp = r.textureCache.viewport;\n    bb = r.textureCache.bb;\n\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (motionBlur) {\n      mbclear(context, 0, 0, vp.width, vp.height);\n    } else {\n      context.clearRect(0, 0, vp.width, vp.height);\n    }\n\n    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;\n    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;\n    r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n    context.fillRect(0, 0, vp.width, vp.height);\n\n    var zoom = cy.zoom();\n\n    setContextTransform(context, false);\n\n    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n  } else if (r.textureOnViewport && !forcedContext) {\n    // clear the cache since we don't need it\n    r.textureCache = null;\n  }\n\n  var extent = cy.extent();\n  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;\n  var hideEdges = r.hideEdgesOnViewport && vpManip;\n\n  var needMbClear = [];\n\n  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n  if (needMbClear[r.NODE]) {\n    r.clearedForMotionBlur[r.NODE] = true;\n  }\n\n  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n  if (needMbClear[r.DRAG]) {\n    r.clearedForMotionBlur[r.DRAG] = true;\n  }\n\n  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n\n    setContextTransform(context, clear);\n\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n    } else {\n      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n    }\n\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.nondrag);\n    }\n\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.NODE] = false;\n    }\n  }\n\n  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n\n    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n    } else {\n      r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n    }\n\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.drag);\n    }\n\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.DRAG] = false;\n    }\n  }\n\n  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n    var context = forcedContext || data.contexts[r.SELECT_BOX];\n\n    setContextTransform(context);\n\n    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n      var zoom = r.cy.zoom();\n      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;\n\n      context.lineWidth = borderWidth;\n      context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';\n\n      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\n      if (borderWidth > 0) {\n        context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';\n\n        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n      }\n    }\n\n    if (data.bgActivePosistion && !r.hoverData.selecting) {\n      var zoom = r.cy.zoom();\n      var pos = data.bgActivePosistion;\n\n      context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';\n\n      context.beginPath();\n      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);\n      context.fill();\n    }\n\n    var timeToRender = r.lastRedrawTime;\n    if (r.showFps && timeToRender) {\n      timeToRender = Math.round(timeToRender);\n      var fps = Math.round(1000 / timeToRender);\n\n      context.setTransform(1, 0, 0, 1, 0, 0);\n\n      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n      context.lineWidth = 1;\n      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n\n      var maxFps = 60;\n      context.strokeRect(0, 30, 250, 20);\n      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n    }\n\n    if (!drawAllLayers) {\n      needDraw[r.SELECT_BOX] = false;\n    }\n  }\n\n  // motionblur: blit rendered blurry frames\n  if (motionBlur && mbPxRatio !== 1) {\n    var cxtNode = data.contexts[r.NODE];\n    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n\n    var cxtDrag = data.contexts[r.DRAG];\n    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n\n    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (needClear || !motionBlurFadeEffect) {\n        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n      } else {\n        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n      }\n\n      var pxr = mbPxRatio;\n\n      cxt.drawImage(txt, // img\n      0, 0, // sx, sy\n      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n      0, 0, // x, y\n      r.canvasWidth, r.canvasHeight // w, h\n      );\n    };\n\n    if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n      needDraw[r.NODE] = false;\n    }\n\n    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n      needDraw[r.DRAG] = false;\n    }\n  }\n\n  r.prevViewport = vp;\n\n  if (r.clearingMotionBlur) {\n    r.clearingMotionBlur = false;\n    r.motionBlurCleared = true;\n    r.motionBlur = true;\n  }\n\n  if (motionBlur) {\n    r.motionBlurTimeout = setTimeout(function () {\n      r.motionBlurTimeout = null;\n\n      r.clearedForMotionBlur[r.NODE] = false;\n      r.clearedForMotionBlur[r.DRAG] = false;\n      r.motionBlur = false;\n      r.clearingMotionBlur = !textureDraw;\n      r.mbFrames = 0;\n\n      needDraw[r.NODE] = true;\n      needDraw[r.DRAG] = true;\n\n      r.redraw();\n    }, motionBlurDelay);\n  }\n\n  if (!forcedContext) {\n    cy.emit('render');\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\n\nvar CRp = {};\n\n// @O Polygon drawing\nCRp.drawPolygonPath = function (context, x, y, width, height, points) {\n\n  var halfW = width / 2;\n  var halfH = height / 2;\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n\n  for (var i = 1; i < points.length / 2; i++) {\n    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n  }\n\n  context.closePath();\n};\n\n// Round rectangle drawing\nCRp.drawRoundRectanglePath = function (context, x, y, width, height) {\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = math.getRoundRectangleRadius(width, height);\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  // Start at top middle\n  context.moveTo(x, y - halfHeight);\n  // Arc from middle top to right side\n  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n  // Arc from right side to bottom\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n  // Arc from bottom to left side\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n  // Arc from left side to topBorder\n  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n  // Join line\n  context.lineTo(x, y - halfHeight);\n\n  context.closePath();\n};\n\nCRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = math.getRoundRectangleRadius(width, height);\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  // Start at top middle\n  context.moveTo(x, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight);\n  context.lineTo(x + halfWidth, y);\n\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n\n  context.lineTo(x - halfWidth, y - halfHeight);\n  context.lineTo(x, y - halfHeight);\n\n  context.closePath();\n};\n\nCRp.drawCutRectanglePath = function (context, x, y, width, height) {\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerLength = math.getCutRectangleCornerLength();\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n\n  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n\n  context.closePath();\n};\n\nCRp.drawBarrelPath = function (context, x, y, width, height) {\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n\n  var xBegin = x - halfWidth;\n  var xEnd = x + halfWidth;\n  var yBegin = y - halfHeight;\n  var yEnd = y + halfHeight;\n\n  var barrelCurveConstants = math.getBarrelCurveConstants(width, height);\n  var wOffset = barrelCurveConstants.widthOffset;\n  var hOffset = barrelCurveConstants.heightOffset;\n  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(xBegin, yBegin + hOffset);\n\n  context.lineTo(xBegin, yEnd - hOffset);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n\n  context.lineTo(xEnd - wOffset, yEnd);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n\n  context.lineTo(xEnd, yBegin + hOffset);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n\n  context.lineTo(xBegin + wOffset, yBegin);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n\n  context.closePath();\n};\n\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\n\nvar sin = {};\nvar cos = {};\n\nvar ellipseStepSize = Math.PI / 40;\n\nfor (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n  sin[i] = Math.sin(i);\n  cos[i] = Math.cos(i);\n}\n\nCRp.drawEllipsePath = function (context, centerX, centerY, width, height) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  if (context.ellipse) {\n    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n  } else {\n    var xPos, yPos;\n    var rw = width / 2;\n    var rh = height / 2;\n    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n\n      if (i === 0) {\n        context.moveTo(xPos, yPos);\n      } else {\n        context.lineTo(xPos, yPos);\n      }\n    }\n  }\n\n  context.closePath();\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar math = __webpack_require__(2);\nvar util = __webpack_require__(1);\nvar Heap = __webpack_require__(8);\nvar defs = __webpack_require__(16);\n\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024; // the maximum height of a texture\nvar minUtility = 0.5; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)\nvar allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\nvar getTxrReasons = {\n  dequeue: 'dequeue',\n  downscale: 'downscale',\n  highQuality: 'highQuality'\n};\n\nvar ElementTextureCache = function ElementTextureCache(renderer) {\n  var self = this;\n\n  self.renderer = renderer;\n  self.onDequeues = [];\n\n  self.setupDequeueing();\n};\n\nvar ETCp = ElementTextureCache.prototype;\n\nETCp.reasons = getTxrReasons;\n\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function (txrH) {\n  var self = this;\n  self.eleImgCaches = self.eleImgCaches || {};\n\n  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n};\n\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function (txrH) {\n  var self = this;\n\n  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n\n  return rtxtrQ;\n};\n\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function () {\n  var self = this;\n\n  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {\n    return b.reqs - a.reqs;\n  });\n\n  return q;\n};\n\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementIdToQueue = function () {\n  var self = this;\n\n  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};\n\n  return id2q;\n};\n\nETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n  var self = this;\n  var r = this.renderer;\n  var rs = ele._private.rscratch;\n  var zoom = r.cy.zoom();\n\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return null;\n  }\n\n  if (lvl == null) {\n    lvl = Math.ceil(math.log2(zoom * pxRatio));\n  }\n\n  if (lvl < minLvl) {\n    lvl = minLvl;\n  } else if (zoom >= maxZoom || lvl > maxLvl) {\n    return null;\n  }\n\n  var scale = Math.pow(2, lvl);\n  var eleScaledH = bb.h * scale;\n  var eleScaledW = bb.w * scale;\n  var caches = rs.imgCaches = rs.imgCaches || {};\n  var eleCache = caches[lvl];\n\n  if (eleCache) {\n    return eleCache;\n  }\n\n  var txrH; // which texture height this ele belongs to\n\n  if (eleScaledH <= minTxrH) {\n    txrH = minTxrH;\n  } else if (eleScaledH <= txrStepH) {\n    txrH = txrStepH;\n  } else {\n    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n  }\n\n  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {\n    return null; // caching large elements is not efficient\n  }\n\n  var txrQ = self.getTextureQueue(txrH);\n\n  // first try the second last one in case it has space at the end\n  var txr = txrQ[txrQ.length - 2];\n\n  var addNewTxr = function addNewTxr() {\n    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n  };\n\n  // try the last one if there is no second last one\n  if (!txr) {\n    txr = txrQ[txrQ.length - 1];\n  }\n\n  // if the last one doesn't exist, we need a first one\n  if (!txr) {\n    txr = addNewTxr();\n  }\n\n  // if there's no room in the current texture, we need a new one\n  if (txr.width - txr.usedWidth < eleScaledW) {\n    txr = addNewTxr();\n  }\n\n  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n  var scalableFrom = function scalableFrom(otherCache) {\n    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n  };\n\n  var deqing = reason && reason === getTxrReasons.dequeue;\n  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n  var downscaleReq = reason && reason === getTxrReasons.downscale;\n\n  var higherCache; // the nearest cache with a higher level\n  for (var l = lvl + 1; l <= maxLvl; l++) {\n    var c = caches[l];\n\n    if (c) {\n      higherCache = c;break;\n    }\n  }\n\n  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\n  var downscale = function downscale() {\n    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n  };\n\n  // reset ele area in texture\n  txr.context.setTransform(1, 0, 0, 1, 0, 0);\n  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n\n  if (scalableFrom(oneUpCache)) {\n    // then we can relatively cheaply rescale the existing image w/o rerendering\n    downscale();\n  } else if (scalableFrom(higherCache)) {\n    // then use the higher cache for now and queue the next level down\n    // to cheaply scale towards the smaller level\n\n    if (highQualityReq) {\n      for (var l = higherCache.level; l > lvl; l--) {\n        oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);\n      }\n\n      downscale();\n    } else {\n      self.queueElement(ele, bb, higherCache.level - 1);\n\n      return higherCache;\n    }\n  } else {\n\n    var lowerCache; // the nearest cache with a lower level\n    if (!deqing && !highQualityReq && !downscaleReq) {\n      for (var l = lvl - 1; l >= minLvl; l--) {\n        var c = caches[l];\n\n        if (c) {\n          lowerCache = c;break;\n        }\n      }\n    }\n\n    if (scalableFrom(lowerCache)) {\n      // then use the lower quality cache for now and queue the better one for later\n\n      self.queueElement(ele, bb, lvl);\n\n      return lowerCache;\n    }\n\n    txr.context.translate(txr.usedWidth, 0);\n    txr.context.scale(scale, scale);\n\n    r.drawElement(txr.context, ele, bb, scaledLabelShown);\n\n    txr.context.scale(1 / scale, 1 / scale);\n    txr.context.translate(-txr.usedWidth, 0);\n  }\n\n  eleCache = caches[lvl] = {\n    ele: ele,\n    x: txr.usedWidth,\n    texture: txr,\n    level: lvl,\n    scale: scale,\n    width: eleScaledW,\n    height: eleScaledH,\n    scaledLabelShown: scaledLabelShown\n  };\n\n  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n\n  txr.eleCaches.push(eleCache);\n\n  self.checkTextureFullness(txr);\n\n  return eleCache;\n};\n\nETCp.invalidateElement = function (ele) {\n  var self = this;\n  var caches = ele._private.rscratch.imgCaches;\n\n  if (caches) {\n    for (var lvl = minLvl; lvl <= maxLvl; lvl++) {\n      var cache = caches[lvl];\n\n      if (cache) {\n        var txr = cache.texture;\n\n        // remove space from the texture it belongs to\n        txr.invalidatedWidth += cache.width;\n\n        // remove refs with the element\n        caches[lvl] = null;\n        util.removeFromArray(txr.eleCaches, cache);\n\n        // might have to remove the entire texture if it's not efficiently using its space\n        self.checkTextureUtility(txr);\n      }\n    }\n  }\n};\n\nETCp.checkTextureUtility = function (txr) {\n  // invalidate all entries in the cache if the cache size is small\n  if (txr.invalidatedWidth >= minUtility * txr.width) {\n    this.retireTexture(txr);\n  }\n};\n\nETCp.checkTextureFullness = function (txr) {\n  // if texture has been mostly filled and passed over several times, remove\n  // it from the queue so we don't need to waste time looking at it to put new things\n\n  var self = this;\n  var txrQ = self.getTextureQueue(txr.height);\n\n  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n    util.removeFromArray(txrQ, txr);\n  } else {\n    txr.fullnessChecks++;\n  }\n};\n\nETCp.retireTexture = function (txr) {\n  var self = this;\n  var txrH = txr.height;\n  var txrQ = self.getTextureQueue(txrH);\n\n  // retire the texture from the active / searchable queue:\n\n  util.removeFromArray(txrQ, txr);\n\n  txr.retired = true;\n\n  // remove the refs from the eles to the caches:\n\n  var eleCaches = txr.eleCaches;\n\n  for (var i = 0; i < eleCaches.length; i++) {\n    var eleCache = eleCaches[i];\n    var ele = eleCache.ele;\n    var lvl = eleCache.level;\n    var imgCaches = ele._private.rscratch.imgCaches;\n\n    if (imgCaches) {\n      imgCaches[lvl] = null;\n    }\n  }\n\n  util.clearArray(eleCaches);\n\n  // add the texture to a retired queue so it can be recycled in future:\n\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\n  rtxtrQ.push(txr);\n};\n\nETCp.addTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var txr = {};\n\n  txrQ.push(txr);\n\n  txr.eleCaches = [];\n\n  txr.height = txrH;\n  txr.width = Math.max(defTxrWidth, minW);\n  txr.usedWidth = 0;\n  txr.invalidatedWidth = 0;\n  txr.fullnessChecks = 0;\n\n  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n  txr.canvas.width = txr.width;\n  txr.canvas.height = txr.height;\n\n  txr.context = txr.canvas.getContext('2d');\n\n  return txr;\n};\n\nETCp.recycleTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\n  for (var i = 0; i < rtxtrQ.length; i++) {\n    var txr = rtxtrQ[i];\n\n    if (txr.width >= minW) {\n      txr.retired = false;\n\n      txr.usedWidth = 0;\n      txr.invalidatedWidth = 0;\n      txr.fullnessChecks = 0;\n\n      util.clearArray(txr.eleCaches);\n\n      txr.context.setTransform(1, 0, 0, 1, 0, 0);\n      txr.context.clearRect(0, 0, txr.width, txr.height);\n\n      util.removeFromArray(rtxtrQ, txr);\n      txrQ.push(txr);\n\n      return txr;\n    }\n  }\n};\n\nETCp.queueElement = function (ele, bb, lvl) {\n  var self = this;\n  var q = self.getElementQueue();\n  var id2q = self.getElementIdToQueue();\n  var id = ele.id();\n  var existingReq = id2q[id];\n\n  if (existingReq) {\n    // use the max lvl b/c in between lvls are cheap to make\n    existingReq.level = Math.max(existingReq.level, lvl);\n    existingReq.reqs++;\n\n    q.updateItem(existingReq);\n  } else {\n    var req = {\n      ele: ele,\n      bb: bb,\n      position: math.copyPosition(ele.position()),\n      level: lvl,\n      reqs: 1\n    };\n\n    if (ele.isEdge()) {\n      req.positions = {\n        source: math.copyPosition(ele.source().position()),\n        target: math.copyPosition(ele.target().position())\n      };\n    }\n\n    q.push(req);\n\n    id2q[id] = req;\n  }\n};\n\nETCp.dequeue = function (pxRatio /*, extent*/) {\n  var self = this;\n  var q = self.getElementQueue();\n  var id2q = self.getElementIdToQueue();\n  var dequeued = [];\n\n  for (var i = 0; i < maxDeqSize; i++) {\n    if (q.size() > 0) {\n      var req = q.pop();\n\n      id2q[req.ele.id()] = null;\n\n      dequeued.push(req);\n\n      var ele = req.ele;\n      var bb;\n\n      if (ele.isEdge() && (!math.arePositionsSame(ele.source().position(), req.positions.source) || !math.arePositionsSame(ele.target().position(), req.positions.target)) || !math.arePositionsSame(ele.position(), req.position)) {\n        bb = ele.boundingBox();\n      } else {\n        bb = req.bb;\n      }\n\n      self.getElement(req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n    } else {\n      break;\n    }\n  }\n\n  return dequeued;\n};\n\nETCp.onDequeue = function (fn) {\n  this.onDequeues.push(fn);\n};\nETCp.offDequeue = function (fn) {\n  util.removeFromArray(this.onDequeues, fn);\n};\n\nETCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function deq(self, pxRatio, extent) {\n    return self.dequeue(pxRatio, extent);\n  },\n  onDeqd: function onDeqd(self, deqd) {\n    for (var i = 0; i < self.onDequeues.length; i++) {\n      var fn = self.onDequeues[i];\n\n      fn(deqd);\n    }\n  },\n  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n    for (var i = 0; i < deqd.length; i++) {\n      var bb = deqd[i].bb;\n\n      if (math.boundingBoxesIntersect(bb, extent)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n  }\n});\n\nmodule.exports = ElementTextureCache;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nvar CRp = {};\n\nCRp.createBuffer = function (w, h) {\n  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n  buffer.width = w;\n  buffer.height = h;\n\n  return [buffer, buffer.getContext('2d')];\n};\n\nCRp.bufferCanvasImage = function (options) {\n  var cy = this.cy;\n  var eles = cy.mutableElements();\n  var bb = eles.boundingBox();\n  var ctrRect = this.findContainerClientCoords();\n  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n  var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);\n  var pxRatio = this.getPixelRatio();\n  var scale = 1;\n\n  if (options.scale !== undefined) {\n    width *= options.scale;\n    height *= options.scale;\n\n    scale = options.scale;\n  } else if (specdMaxDims) {\n    var maxScaleW = Infinity;\n    var maxScaleH = Infinity;\n\n    if (is.number(options.maxWidth)) {\n      maxScaleW = scale * options.maxWidth / width;\n    }\n\n    if (is.number(options.maxHeight)) {\n      maxScaleH = scale * options.maxHeight / height;\n    }\n\n    scale = Math.min(maxScaleW, maxScaleH);\n\n    width *= scale;\n    height *= scale;\n  }\n\n  if (!specdMaxDims) {\n    width *= pxRatio;\n    height *= pxRatio;\n    scale *= pxRatio;\n  }\n\n  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n  buffCanvas.width = width;\n  buffCanvas.height = height;\n\n  buffCanvas.style.width = width + 'px';\n  buffCanvas.style.height = height + 'px';\n\n  var buffCxt = buffCanvas.getContext('2d');\n\n  // Rasterize the layers, but only if container has nonzero size\n  if (width > 0 && height > 0) {\n\n    buffCxt.clearRect(0, 0, width, height);\n\n    buffCxt.globalCompositeOperation = 'source-over';\n\n    var zsortedEles = this.getCachedZSortedEles();\n\n    if (options.full) {\n      // draw the full bounds of the graph\n      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n      buffCxt.scale(scale, scale);\n\n      this.drawElements(buffCxt, zsortedEles);\n\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n    } else {\n      // draw the current view\n      var pan = cy.pan();\n\n      var translation = {\n        x: pan.x * scale,\n        y: pan.y * scale\n      };\n\n      scale *= cy.zoom();\n\n      buffCxt.translate(translation.x, translation.y);\n      buffCxt.scale(scale, scale);\n\n      this.drawElements(buffCxt, zsortedEles);\n\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(-translation.x, -translation.y);\n    }\n\n    // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n    if (options.bg) {\n      buffCxt.globalCompositeOperation = 'destination-over';\n\n      buffCxt.fillStyle = options.bg;\n      buffCxt.rect(0, 0, width, height);\n      buffCxt.fill();\n    }\n  }\n\n  return buffCanvas;\n};\n\nfunction b64ToBlob(b64, mimeType) {\n  var bytes = atob(b64);\n  var buff = new ArrayBuffer(bytes.length);\n  var buffUint8 = new Uint8Array(buff);\n\n  for (var i = 0; i < bytes.length; i++) {\n    buffUint8[i] = bytes.charCodeAt(i);\n  }\n\n  return new Blob([buff], { type: mimeType });\n}\n\nfunction b64UriToB64(b64uri) {\n  var i = b64uri.indexOf(',');\n\n  return b64uri.substr(i + 1);\n};\n\nfunction output(options, canvas, mimeType) {\n  var b64Uri = canvas.toDataURL(mimeType, options.quality);\n\n  switch (options.output) {\n    case 'blob':\n      return b64ToBlob(b64UriToB64(b64Uri), mimeType);\n\n    case 'base64':\n      return b64UriToB64(b64Uri);\n\n    case 'base64uri':\n    default:\n      return b64Uri;\n  }\n}\n\nCRp.png = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/png');\n};\n\nCRp.jpg = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\nThe canvas renderer was written by Yue Dong.\n\nModifications tracked on Github.\n*/\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar ElementTextureCache = __webpack_require__(109);\nvar LayeredTextureCache = __webpack_require__(112);\n\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\n\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\n\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\nfunction CanvasRenderer(options) {\n  var r = this;\n\n  r.data = {\n    canvases: new Array(CRp.CANVAS_LAYERS),\n    contexts: new Array(CRp.CANVAS_LAYERS),\n    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n\n    bufferCanvases: new Array(CRp.BUFFER_COUNT),\n    bufferContexts: new Array(CRp.CANVAS_LAYERS)\n  };\n\n  var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';\n\n  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n  var containerStyle = r.data.canvasContainer.style;\n  r.data.canvasContainer.setAttribute('style', tapHlOff);\n  containerStyle.position = 'relative';\n  containerStyle.zIndex = '0';\n  containerStyle.overflow = 'hidden';\n\n  var container = options.cy.container();\n  container.appendChild(r.data.canvasContainer);\n\n  if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {\n    container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);\n  }\n\n  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n    r.data.contexts[i] = canvas.getContext('2d');\n    canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));\n    canvas.style.position = 'absolute';\n    canvas.setAttribute('data-id', 'layer' + i);\n    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n    r.data.canvasContainer.appendChild(canvas);\n\n    r.data.canvasNeedsRedraw[i] = false;\n  }\n  r.data.topCanvas = r.data.canvases[0];\n\n  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n\n  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n    r.data.bufferCanvases[i].style.position = 'absolute';\n    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n    r.data.bufferCanvases[i].style.visibility = 'hidden';\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n  }\n\n  r.pathsEnabled = true;\n\n  r.data.eleTxrCache = new ElementTextureCache(r);\n  r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);\n\n  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var rs = ele._private.rstyle;\n      var de = rs.dirtyEvents;\n\n      if (ele.isNode() && de && de.length === 1 && de['position']) {\n        // then keep cached ele texture\n      } else {\n        r.data.eleTxrCache.invalidateElement(ele);\n      }\n    }\n\n    if (eles.length > 0) {\n      r.data.lyrTxrCache.invalidateElements(eles);\n    }\n  });\n}\n\nCRp.redrawHint = function (group, bool) {\n  var r = this;\n\n  switch (group) {\n    case 'eles':\n      r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n      break;\n    case 'drag':\n      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n      break;\n    case 'select':\n      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n      break;\n  }\n};\n\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== 'undefined';\n\nCRp.path2dEnabled = function (on) {\n  if (on === undefined) {\n    return this.pathsEnabled;\n  }\n\n  this.pathsEnabled = on ? true : false;\n};\n\nCRp.usePaths = function () {\n  return pathsImpld && this.pathsEnabled;\n};\n\n[__webpack_require__(101), __webpack_require__(103), __webpack_require__(102), __webpack_require__(104), __webpack_require__(105), __webpack_require__(106), __webpack_require__(107), __webpack_require__(108), __webpack_require__(110), __webpack_require__(113)].forEach(function (props) {\n  util.extend(CRp, props);\n});\n\nmodule.exports = CR;\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar math = __webpack_require__(2);\nvar Heap = __webpack_require__(8);\nvar is = __webpack_require__(0);\nvar defs = __webpack_require__(16);\n\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n\nvar useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache\n\n// var log = function(){ console.log.apply( console, arguments ); };\n\nvar LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {\n  var self = this;\n\n  var r = self.renderer = renderer;\n\n  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n  self.firstGet = true;\n\n  self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;\n\n  self.skipping = false;\n\n  r.beforeRender(function (willDraw, now) {\n    if (now - self.lastInvalidationTime <= invalidThreshold) {\n      self.skipping = true;\n    } else {\n      self.skipping = false;\n    }\n  });\n\n  var qSort = function qSort(a, b) {\n    return b.reqs - a.reqs;\n  };\n\n  self.layersQueue = new Heap(qSort);\n\n  self.eleTxrCache = eleTxrCache;\n\n  self.setupEleCacheInvalidation();\n\n  self.setupDequeueing();\n};\n\nvar LTCp = LayeredTextureCache.prototype;\n\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\n\nLTCp.makeLayer = function (bb, lvl) {\n  var scale = Math.pow(2, lvl);\n\n  var w = Math.ceil(bb.w * scale);\n  var h = Math.ceil(bb.h * scale);\n\n  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n  canvas.width = w;\n  canvas.height = h;\n\n  var layer = {\n    id: layerIdPool = ++layerIdPool % MAX_INT,\n    bb: bb,\n    level: lvl,\n    width: w,\n    height: h,\n    canvas: canvas,\n    context: canvas.getContext('2d'),\n    eles: [],\n    elesQueue: [],\n    reqs: 0\n  };\n\n  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n  var cxt = layer.context;\n  var dx = -layer.bb.x1;\n  var dy = -layer.bb.y1;\n\n  // do the transform on creation to save cycles (it's the same for all eles)\n  cxt.scale(scale, scale);\n  cxt.translate(dx, dy);\n\n  return layer;\n};\n\nLTCp.getLayers = function (eles, pxRatio, lvl) {\n  var self = this;\n  var r = self.renderer;\n  var cy = r.cy;\n  var zoom = cy.zoom();\n  var firstGet = self.firstGet;\n\n  self.firstGet = false;\n\n  // log('--\\nget layers with %s eles', eles.length);\n  //log eles.map(function(ele){ return ele.id() }) );\n\n  if (lvl == null) {\n    lvl = Math.ceil(math.log2(zoom * pxRatio));\n\n    if (lvl < minLvl) {\n      lvl = minLvl;\n    } else if (zoom >= maxZoom || lvl > maxLvl) {\n      return null;\n    }\n  }\n\n  self.validateLayersElesOrdering(lvl, eles);\n\n  var layersByLvl = self.layersByLevel;\n  var scale = Math.pow(2, lvl);\n  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n  var bb;\n\n  var lvlComplete = self.levelIsComplete(lvl, eles);\n  var tmpLayers;\n\n  var checkTempLevels = function checkTempLevels() {\n    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n      self.validateLayersElesOrdering(l, eles);\n\n      if (self.levelIsComplete(l, eles)) {\n        tmpLayers = layersByLvl[l];\n        return true;\n      }\n    };\n\n    var checkLvls = function checkLvls(dir) {\n      if (tmpLayers) {\n        return;\n      }\n\n      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n        if (canUseAsTmpLvl(l)) {\n          break;\n        }\n      }\n    };\n\n    checkLvls(+1);\n    checkLvls(-1);\n\n    // remove the invalid layers; they will be replaced as needed later in this function\n    for (var i = layers.length - 1; i >= 0; i--) {\n      var layer = layers[i];\n\n      if (layer.invalid) {\n        util.removeFromArray(layers, layer);\n      }\n    }\n  };\n\n  if (!lvlComplete) {\n    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n    // and later queue the current layerset so we can get the proper quality level soon\n\n    checkTempLevels();\n  } else {\n    // log('level complete, using existing layers\\n--');\n    return layers;\n  }\n\n  var getBb = function getBb() {\n    if (!bb) {\n      bb = math.makeBoundingBox();\n\n      for (var i = 0; i < eles.length; i++) {\n        math.updateBoundingBox(bb, eles[i].boundingBox());\n      }\n    }\n\n    return bb;\n  };\n\n  var makeLayer = function makeLayer(opts) {\n    opts = opts || {};\n\n    var after = opts.after;\n\n    getBb();\n\n    var area = bb.w * scale * (bb.h * scale);\n\n    if (area > maxLayerArea) {\n      return null;\n    }\n\n    var layer = self.makeLayer(bb, lvl);\n\n    if (after != null) {\n      var index = layers.indexOf(after) + 1;\n\n      layers.splice(index, 0, layer);\n    } else if (opts.insert === undefined || opts.insert) {\n      // no after specified => first layer made so put at start\n      layers.unshift(layer);\n    }\n\n    // if( tmpLayers ){\n    //self.queueLayer( layer );\n    // }\n\n    return layer;\n  };\n\n  if (self.skipping && !firstGet) {\n    // log('skip layers');\n    return null;\n  }\n\n  // log('do layers');\n\n  var layer = null;\n  var maxElesPerLayer = eles.length / defNumLayers;\n  var allowLazyQueueing = alwaysQueue && !firstGet;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    // log('look at ele', ele.id());\n\n    var existingLayer = caches[lvl];\n\n    if (existingLayer) {\n      // reuse layer for later eles\n      // log('reuse layer for', ele.id());\n      layer = existingLayer;\n      continue;\n    }\n\n    if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n      // log('make new layer for ele %s', ele.id());\n\n      layer = makeLayer({ insert: true, after: layer });\n\n      // if now layer can be built then we can't use layers at this level\n      if (!layer) {\n        return null;\n      }\n\n      // log('new layer with id %s', layer.id);\n    }\n\n    if (tmpLayers || allowLazyQueueing) {\n      // log('queue ele %s in layer %s', ele.id(), layer.id);\n      self.queueLayer(layer, ele);\n    } else {\n      // log('draw ele %s in layer %s', ele.id(), layer.id);\n      self.drawEleInLayer(layer, ele, lvl, pxRatio);\n    }\n\n    layer.eles.push(ele);\n\n    caches[lvl] = layer;\n  }\n\n  // log('--');\n\n  if (tmpLayers) {\n    // then we only queued the current layerset and can't draw it yet\n    return tmpLayers;\n  }\n\n  if (allowLazyQueueing) {\n    // log('lazy queue level', lvl);\n    return null;\n  }\n\n  return layers;\n};\n\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n  return lvl;\n};\n\nfunction imgSmoothing(context, bool) {\n  if (context.imageSmoothingEnabled != null) {\n    context.imageSmoothingEnabled = bool;\n  } else {\n    context.webkitImageSmoothingEnabled = bool;\n    context.mozImageSmoothingEnabled = bool;\n    context.msImageSmoothingEnabled = bool;\n  }\n}\n\nLTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n  var self = this;\n  var r = this.renderer;\n  var context = layer.context;\n  var bb = ele.boundingBox();\n\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return;\n  }\n\n  var eleCache = self.eleTxrCache;\n  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;\n\n  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n\n  var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;\n\n  if (cache) {\n    if (disableEleImgSmoothing) {\n      imgSmoothing(context, false);\n    }\n\n    context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);\n\n    if (disableEleImgSmoothing) {\n      imgSmoothing(context, true);\n    }\n  } else {\n    // if the element is not cacheable, then draw directly\n    r.drawElement(context, ele);\n  }\n};\n\nLTCp.levelIsComplete = function (lvl, eles) {\n  var self = this;\n  var layers = self.layersByLevel[lvl];\n\n  if (!layers || layers.length === 0) {\n    return false;\n  }\n\n  var numElesInLayers = 0;\n\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n\n    // if there are any eles needed to be drawn yet, the level is not complete\n    if (layer.reqs > 0) {\n      return false;\n    }\n\n    // if the layer is invalid, the level is not complete\n    if (layer.invalid) {\n      return false;\n    }\n\n    numElesInLayers += layer.eles.length;\n  }\n\n  // we should have exactly the number of eles passed in to be complete\n  if (numElesInLayers !== eles.length) {\n    return false;\n  }\n\n  return true;\n};\n\nLTCp.validateLayersElesOrdering = function (lvl, eles) {\n  var layers = this.layersByLevel[lvl];\n\n  if (!layers) {\n    return;\n  }\n\n  // if in a layer the eles are not in the same order, then the layer is invalid\n  // (i.e. there is an ele in between the eles in the layer)\n\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n    var offset = -1;\n\n    // find the offset\n    for (var j = 0; j < eles.length; j++) {\n      if (layer.eles[0] === eles[j]) {\n        offset = j;\n        break;\n      }\n    }\n\n    if (offset < 0) {\n      // then the layer has nonexistant elements and is invalid\n      this.invalidateLayer(layer);\n      continue;\n    }\n\n    // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n    var o = offset;\n\n    for (var j = 0; j < layer.eles.length; j++) {\n      if (layer.eles[j] !== eles[o + j]) {\n        // log('invalidate based on ordering', layer.id);\n\n        this.invalidateLayer(layer);\n        break;\n      }\n    }\n  }\n};\n\nLTCp.updateElementsInLayers = function (eles, update) {\n  var self = this;\n  var isEles = is.element(eles[0]);\n\n  // collect udpated elements (cascaded from the layers) and update each\n  // layer itself along the way\n  for (var i = 0; i < eles.length; i++) {\n    var req = isEles ? null : eles[i];\n    var ele = isEles ? eles[i] : eles[i].ele;\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    for (var l = minLvl; l <= maxLvl; l++) {\n      var layer = caches[l];\n\n      if (!layer) {\n        continue;\n      }\n\n      // if update is a request from the ele cache, then it affects only\n      // the matching level\n      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n        continue;\n      }\n\n      update(layer, ele, req);\n    }\n  }\n};\n\nLTCp.haveLayers = function () {\n  var self = this;\n  var haveLayers = false;\n\n  for (var l = minLvl; l <= maxLvl; l++) {\n    var layers = self.layersByLevel[l];\n\n    if (layers && layers.length > 0) {\n      haveLayers = true;\n      break;\n    }\n  }\n\n  return haveLayers;\n};\n\nLTCp.invalidateElements = function (eles) {\n  var self = this;\n\n  self.lastInvalidationTime = util.performanceNow();\n\n  // log('update invalidate layer time from eles');\n\n  if (eles.length === 0 || !self.haveLayers()) {\n    return;\n  }\n\n  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n    self.invalidateLayer(layer);\n  });\n};\n\nLTCp.invalidateLayer = function (layer) {\n  // log('update invalidate layer time');\n\n  this.lastInvalidationTime = util.performanceNow();\n\n  if (layer.invalid) {\n    return;\n  } // save cycles\n\n  var lvl = layer.level;\n  var eles = layer.eles;\n  var layers = this.layersByLevel[lvl];\n\n  // log('invalidate layer', layer.id );\n\n  util.removeFromArray(layers, layer);\n  // layer.eles = [];\n\n  layer.elesQueue = [];\n\n  layer.invalid = true;\n\n  if (layer.replacement) {\n    layer.replacement.invalid = true;\n  }\n\n  for (var i = 0; i < eles.length; i++) {\n    var caches = eles[i]._private.rscratch.imgLayerCaches;\n\n    if (caches) {\n      caches[lvl] = null;\n    }\n  }\n};\n\nLTCp.refineElementTextures = function (eles) {\n  var self = this;\n\n  // log('refine', eles.length);\n\n  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n    var rLyr = layer.replacement;\n\n    if (!rLyr) {\n      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n      rLyr.replaces = layer;\n      rLyr.eles = layer.eles;\n\n      // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n    }\n\n    if (!rLyr.reqs) {\n      for (var i = 0; i < rLyr.eles.length; i++) {\n        self.queueLayer(rLyr, rLyr.eles[i]);\n      }\n\n      // log('queue replacement layer refinement', rLyr.id);\n    }\n  });\n};\n\nLTCp.setupEleCacheInvalidation = function () {\n  var self = this;\n  var eleDeqs = [];\n\n  if (!useEleTxrCaching) {\n    return;\n  }\n\n  var updatedElesInLayers = util.debounce(function () {\n    self.refineElementTextures(eleDeqs);\n\n    eleDeqs = [];\n  }, refineEleDebounceTime);\n\n  self.eleTxrCache.onDequeue(function (reqs) {\n    for (var i = 0; i < reqs.length; i++) {\n      eleDeqs.push(reqs[i]);\n    }\n\n    updatedElesInLayers();\n  });\n};\n\nLTCp.queueLayer = function (layer, ele) {\n  var self = this;\n  var q = self.layersQueue;\n  var elesQ = layer.elesQueue;\n  var hasId = elesQ.hasId = elesQ.hasId || {};\n\n  // if a layer is going to be replaced, queuing is a waste of time\n  if (layer.replacement) {\n    return;\n  }\n\n  if (ele) {\n    if (hasId[ele.id()]) {\n      return;\n    }\n\n    elesQ.push(ele);\n    hasId[ele.id()] = true;\n  }\n\n  if (layer.reqs) {\n    layer.reqs++;\n\n    q.updateItem(layer);\n  } else {\n    layer.reqs = 1;\n\n    q.push(layer);\n  }\n};\n\nLTCp.dequeue = function (pxRatio) {\n  var self = this;\n  var q = self.layersQueue;\n  var deqd = [];\n  var eleDeqs = 0;\n\n  while (eleDeqs < maxDeqSize) {\n    if (q.size() === 0) {\n      break;\n    }\n\n    var layer = q.peek();\n\n    // if a layer has been or will be replaced, then don't waste time with it\n    if (layer.replacement) {\n      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n      q.pop();\n      continue;\n    }\n\n    // if this is a replacement layer that has been superceded, then forget it\n    if (layer.replaces && layer !== layer.replaces.replacement) {\n      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n      q.pop();\n      continue;\n    }\n\n    if (layer.invalid) {\n      // log('replacement layer %s is invalid; dequeued', layer.id);\n      q.pop();\n      continue;\n    }\n\n    var ele = layer.elesQueue.shift();\n\n    if (ele) {\n      // log('dequeue layer %s', layer.id);\n\n      self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n\n      eleDeqs++;\n    }\n\n    if (deqd.length === 0) {\n      // we need only one entry in deqd to queue redrawing etc\n      deqd.push(true);\n    }\n\n    // if the layer has all its eles done, then remove from the queue\n    if (layer.elesQueue.length === 0) {\n      q.pop();\n\n      layer.reqs = 0;\n\n      // log('dequeue of layer %s complete', layer.id);\n\n      // when a replacement layer is dequeued, it replaces the old layer in the level\n      if (layer.replaces) {\n        self.applyLayerReplacement(layer);\n      }\n\n      self.requestRedraw();\n    }\n  }\n\n  return deqd;\n};\n\nLTCp.applyLayerReplacement = function (layer) {\n  var self = this;\n  var layersInLevel = self.layersByLevel[layer.level];\n  var replaced = layer.replaces;\n  var index = layersInLevel.indexOf(replaced);\n\n  // if the replaced layer is not in the active list for the level, then replacing\n  // refs would be a mistake (i.e. overwriting the true active layer)\n  if (index < 0 || replaced.invalid) {\n    // log('replacement layer would have no effect', layer.id);\n    return;\n  }\n\n  layersInLevel[index] = layer; // replace level ref\n\n  // replace refs in eles\n  for (var i = 0; i < layer.eles.length; i++) {\n    var _p = layer.eles[i]._private;\n    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\n    if (cache) {\n      cache[layer.level] = layer;\n    }\n  }\n\n  // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n  self.requestRedraw();\n};\n\nLTCp.requestRedraw = util.debounce(function () {\n  var r = this.renderer;\n\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n  r.redraw();\n}, 100);\n\nLTCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function deq(self, pxRatio) {\n    return self.dequeue(pxRatio);\n  },\n  onDeqd: util.noop,\n  shouldRedraw: util.trueify,\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n  }\n});\n\nmodule.exports = LayeredTextureCache;\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar CRp = {};\n\nCRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {\n  switch (name) {\n    case 'ellipse':\n      return this.drawEllipsePath(context, centerX, centerY, width, height);\n    case 'polygon':\n      return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n    case 'roundrectangle':\n      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n    case 'cutrectangle':\n      return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n    case 'bottomroundrectangle':\n      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n    case 'barrel':\n      return this.drawBarrelPath(context, centerX, centerY, width, height);\n  }\n};\n\nmodule.exports = CRp;\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = [{ name: 'null', impl: __webpack_require__(115) }, { name: 'base', impl: __webpack_require__(97) }, { name: 'canvas', impl: __webpack_require__(111) }];\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction NullRenderer(options) {\n  this.options = options;\n  this.notifications = 0; // for testing\n}\n\nvar noop = function noop() {};\n\nNullRenderer.prototype = {\n  recalculateRenderedStyle: noop,\n  notify: function notify() {\n    this.notifications++;\n  },\n  init: noop\n};\n\nmodule.exports = NullRenderer;\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar Core = __webpack_require__(12);\nvar extension = __webpack_require__(20);\nvar Stylesheet = __webpack_require__(21);\n\nvar cytoscape = function cytoscape(options) {\n  // jshint ignore:line\n  // if no options specified, use default\n  if (options === undefined) {\n    options = {};\n  }\n\n  // create instance\n  if (is.plainObject(options)) {\n    return new Core(options);\n  }\n\n  // allow for registration of extensions\n  else if (is.string(options)) {\n      return extension.apply(extension, arguments);\n    }\n};\n\n// e.g. cytoscape.use( require('cytoscape-foo'), bar )\ncytoscape.use = function (ext) {\n  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\n  args.unshift(cytoscape); // cytoscape is first arg to ext\n\n  ext.apply(null, args);\n\n  return this;\n};\n\n// replaced by build system\ncytoscape.version = __webpack_require__(22);\n\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\nmodule.exports = cytoscape;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction ObjectMap() {\n  this._obj = {};\n}\n\nvar p = ObjectMap.prototype;\n\np.set = function (key, val) {\n  this._obj[key] = val;\n};\n\np.delete = function (key) {\n  this._obj[key] = null;\n};\n\np.has = function (key) {\n  return this._obj[key] != null;\n};\n\np.get = function (key) {\n  return this._obj[key];\n};\n\n// TODO use the stdlib Map in future...\n// module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;\nmodule.exports = ObjectMap;\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _require = __webpack_require__(17),\n    stateSelectorRegex = _require.stateSelectorRegex;\n\nvar tokens = __webpack_require__(121);\nvar util = __webpack_require__(1);\nvar newQuery = __webpack_require__(11);\n\n// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n// so that values get compared properly in Selector.filter()\nvar cleanMetaChars = function cleanMetaChars(str) {\n  return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n    return $1;\n  });\n};\n\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n  if (examiningQuery === selector[selector.length - 1]) {\n    selector[selector.length - 1] = replacementQuery;\n  }\n};\n\n// NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;\n// - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n// - when you add something here, also add to Selector.toString()\nvar exprs = [{\n  name: 'group',\n  query: true,\n  regex: '(' + tokens.group + ')',\n  populate: function populate(selector, query, _ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        group = _ref2[0];\n\n    query.group = group === '*' ? group : group + 's';\n  }\n}, {\n  name: 'state',\n  query: true,\n  regex: stateSelectorRegex,\n  populate: function populate(selector, query, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        state = _ref4[0];\n\n    query.colonSelectors.push(state);\n  }\n}, {\n  name: 'id',\n  query: true,\n  regex: '\\\\#(' + tokens.id + ')',\n  populate: function populate(selector, query, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        id = _ref6[0];\n\n    query.ids.push(cleanMetaChars(id));\n  }\n}, {\n  name: 'className',\n  query: true,\n  regex: '\\\\.(' + tokens.className + ')',\n  populate: function populate(selector, query, _ref7) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n        className = _ref8[0];\n\n    query.classes.push(cleanMetaChars(className));\n  }\n}, {\n  name: 'dataExists',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 1),\n        variable = _ref10[0];\n\n    query.data.push({\n      field: cleanMetaChars(variable)\n    });\n  }\n}, {\n  name: 'dataCompare',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref11) {\n    var _ref12 = _slicedToArray(_ref11, 3),\n        variable = _ref12[0],\n        comparatorOp = _ref12[1],\n        value = _ref12[2];\n\n    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n    if (valueIsString) {\n      value = value.substring(1, value.length - 1);\n    } else {\n      value = parseFloat(value);\n    }\n\n    query.data.push({\n      field: cleanMetaChars(variable),\n      operator: comparatorOp,\n      value: value\n    });\n  }\n}, {\n  name: 'dataBool',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        boolOp = _ref14[0],\n        variable = _ref14[1];\n\n    query.data.push({\n      field: cleanMetaChars(variable),\n      operator: boolOp\n    });\n  }\n}, {\n  name: 'metaCompare',\n  query: true,\n  regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n  populate: function populate(selector, query, _ref15) {\n    var _ref16 = _slicedToArray(_ref15, 3),\n        meta = _ref16[0],\n        comparatorOp = _ref16[1],\n        number = _ref16[2];\n\n    query.meta.push({\n      field: cleanMetaChars(meta),\n      operator: comparatorOp,\n      value: parseFloat(number)\n    });\n  }\n}, {\n  name: 'nextQuery',\n  separator: true,\n  regex: tokens.separator,\n  populate: function populate(selector) {\n    // go on to next query\n    var nextQuery = selector[selector.length++] = newQuery();\n    selector.currentSubject = null;\n\n    return nextQuery;\n  }\n}, {\n  name: 'directedEdge',\n  separator: true,\n  regex: tokens.directedEdge,\n  populate: function populate(selector, query) {\n    var edgeQuery = newQuery();\n    var source = query;\n    var target = newQuery();\n\n    edgeQuery.group = 'edges';\n    edgeQuery.target = target;\n    edgeQuery.source = source;\n    edgeQuery.subject = selector.currentSubject;\n\n    // the query in the selector should be the edge rather than the source\n    replaceLastQuery(selector, query, edgeQuery);\n\n    // we're now populating the target query with expressions that follow\n    return target;\n  }\n}, {\n  name: 'undirectedEdge',\n  separator: true,\n  regex: tokens.undirectedEdge,\n  populate: function populate(selector, query) {\n    var edgeQuery = newQuery();\n    var source = query;\n    var target = newQuery();\n\n    edgeQuery.group = 'edges';\n    edgeQuery.connectedNodes = [source, target];\n    edgeQuery.subject = selector.currentSubject;\n\n    // the query in the selector should be the edge rather than the source\n    replaceLastQuery(selector, query, edgeQuery);\n\n    // we're now populating the target query with expressions that follow\n    return target;\n  }\n}, {\n  name: 'child',\n  separator: true,\n  regex: tokens.child,\n  populate: function populate(selector, query) {\n    // this query is the parent of the following query\n    var childQuery = newQuery();\n    childQuery.parent = query;\n    childQuery.subject = selector.currentSubject;\n\n    // it's cheaper to compare children first and go up so replace the parent\n    replaceLastQuery(selector, query, childQuery);\n\n    // we're now populating the child query with expressions that follow\n    return childQuery;\n  }\n}, {\n  name: 'descendant',\n  separator: true,\n  regex: tokens.descendant,\n  populate: function populate(selector, query) {\n    // this query is the ancestor of the following query\n    var descendantQuery = newQuery();\n    descendantQuery.ancestor = query;\n    descendantQuery.subject = selector.currentSubject;\n\n    // it's cheaper to compare descendants first and go up so replace the ancestor\n    replaceLastQuery(selector, query, descendantQuery);\n\n    // we're now populating the descendant query with expressions that follow\n    return descendantQuery;\n  }\n}, {\n  name: 'subject',\n  modifier: true,\n  regex: tokens.subject,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject != null && query.subject != query) {\n      util.error('Redefinition of subject in selector `' + selector.toString() + '`');\n      return false;\n    }\n\n    selector.currentSubject = query;\n    query.subject = query;\n    selector[selector.length - 1].subject = query;\n  }\n}];\n\nexprs.forEach(function (e) {\n  return e.regexObj = new RegExp('^' + e.regex);\n});\n\nmodule.exports = exprs;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _require = __webpack_require__(17),\n    stateSelectorMatches = _require.stateSelectorMatches;\n\nvar is = __webpack_require__(0);\n\n// generic checking for data/metadata\nvar operandsMatch = function operandsMatch(query, params) {\n  var allDataMatches = true;\n  for (var k = 0; k < query[params.name].length; k++) {\n    var data = query[params.name][k];\n    var operator = data.operator;\n    var value = data.value;\n    var field = data.field;\n    var _matches = void 0;\n    var fieldVal = params.fieldValue(field);\n\n    if (operator != null && value != null) {\n      var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;\n      var valStr = '' + value;\n\n      var caseInsensitive = false;\n      if (operator.indexOf('@') >= 0) {\n        fieldStr = fieldStr.toLowerCase();\n        valStr = valStr.toLowerCase();\n\n        operator = operator.replace('@', '');\n        caseInsensitive = true;\n      }\n\n      var notExpr = false;\n      if (operator.indexOf('!') >= 0) {\n        operator = operator.replace('!', '');\n        notExpr = true;\n      }\n\n      // if we're doing a case insensitive comparison, then we're using a STRING comparison\n      // even if we're comparing numbers\n      if (caseInsensitive) {\n        value = valStr.toLowerCase();\n        fieldVal = fieldStr.toLowerCase();\n      }\n\n      var isIneqCmp = false;\n\n      switch (operator) {\n        case '*=':\n          _matches = fieldStr.indexOf(valStr) >= 0;\n          break;\n        case '$=':\n          _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n          break;\n        case '^=':\n          _matches = fieldStr.indexOf(valStr) === 0;\n          break;\n        case '=':\n          _matches = fieldVal === value;\n          break;\n        case '>':\n          isIneqCmp = true;\n          _matches = fieldVal > value;\n          break;\n        case '>=':\n          isIneqCmp = true;\n          _matches = fieldVal >= value;\n          break;\n        case '<':\n          isIneqCmp = true;\n          _matches = fieldVal < value;\n          break;\n        case '<=':\n          isIneqCmp = true;\n          _matches = fieldVal <= value;\n          break;\n        default:\n          _matches = false;\n          break;\n      }\n\n      // apply the not op, but null vals for inequalities should always stay non-matching\n      if (notExpr && (fieldVal != null || !isIneqCmp)) {\n        _matches = !_matches;\n      }\n    } else if (operator != null) {\n      switch (operator) {\n        case '?':\n          _matches = fieldVal ? true : false;\n          break;\n        case '!':\n          _matches = fieldVal ? false : true;\n          break;\n        case '^':\n          _matches = fieldVal === undefined;\n          break;\n      }\n    } else {\n      _matches = fieldVal !== undefined;\n    }\n\n    if (!_matches) {\n      allDataMatches = false;\n      break;\n    }\n  } // for\n\n  return allDataMatches;\n}; // operandsMatch\n\n// check parent/child relations\nvar confirmRelations = function confirmRelations(query, isNecessary, eles) {\n  if (query != null) {\n    var _matches2 = false;\n\n    if (!isNecessary) {\n      return false;\n    }\n\n    eles = eles(); // save cycles if query == null\n\n    // query must match for at least one element (may be recursive)\n    for (var i = 0; i < eles.length; i++) {\n      if (queryMatches(query, eles[i])) {\n        _matches2 = true;\n        break;\n      }\n    }\n\n    return _matches2;\n  } else {\n    return true;\n  }\n};\n\nvar queryMatches = function queryMatches(query, ele) {\n  // make single group-only selectors really cheap to check since they're the most common ones\n  if (query.groupOnly) {\n    return query.group === '*' || query.group === ele.group();\n  }\n\n  // check group\n  if (query.group != null && query.group != '*' && query.group != ele.group()) {\n    return false;\n  }\n\n  var cy = ele.cy();\n  var k = void 0;\n\n  // check colon selectors\n  var allColonSelectorsMatch = true;\n  for (k = 0; k < query.colonSelectors.length; k++) {\n    var sel = query.colonSelectors[k];\n\n    allColonSelectorsMatch = stateSelectorMatches(sel, ele);\n\n    if (!allColonSelectorsMatch) break;\n  }\n  if (!allColonSelectorsMatch) return false;\n\n  // check id\n  var allIdsMatch = true;\n  for (k = 0; k < query.ids.length; k++) {\n    var id = query.ids[k];\n    var actualId = ele.id();\n\n    allIdsMatch = allIdsMatch && id == actualId;\n\n    if (!allIdsMatch) break;\n  }\n  if (!allIdsMatch) return false;\n\n  // check classes\n  var allClassesMatch = true;\n  for (k = 0; k < query.classes.length; k++) {\n    var cls = query.classes[k];\n\n    allClassesMatch = allClassesMatch && ele.hasClass(cls);\n\n    if (!allClassesMatch) break;\n  }\n  if (!allClassesMatch) return false;\n\n  // check data matches\n  var allDataMatches = operandsMatch(query, {\n    name: 'data',\n    fieldValue: function fieldValue(field) {\n      return ele.data(field);\n    }\n  });\n\n  if (!allDataMatches) {\n    return false;\n  }\n\n  // check metadata matches\n  var allMetaMatches = operandsMatch(query, {\n    name: 'meta',\n    fieldValue: function fieldValue(field) {\n      return ele[field]();\n    }\n  });\n\n  if (!allMetaMatches) {\n    return false;\n  }\n\n  // check collection\n  if (query.collection != null) {\n    var matchesAny = query.collection.hasElementWithId(ele.id());\n\n    if (!matchesAny) {\n      return false;\n    }\n  }\n\n  // check filter function\n  if (query.filter != null && ele.collection().some(query.filter)) {\n    return false;\n  }\n\n  var isCompound = cy.hasCompoundNodes();\n  var getSource = function getSource() {\n    return ele.source();\n  };\n  var getTarget = function getTarget() {\n    return ele.target();\n  };\n\n  if (!confirmRelations(query.parent, isCompound, function () {\n    return ele.parent();\n  })) {\n    return false;\n  }\n\n  if (!confirmRelations(query.ancestor, isCompound, function () {\n    return ele.parents();\n  })) {\n    return false;\n  }\n\n  if (!confirmRelations(query.child, isCompound, function () {\n    return ele.children();\n  })) {\n    return false;\n  }\n\n  if (!confirmRelations(query.descendant, isCompound, function () {\n    return ele.descendants();\n  })) {\n    return false;\n  }\n\n  if (!confirmRelations(query.source, true, getSource)) {\n    return false;\n  }\n\n  if (!confirmRelations(query.target, true, getTarget)) {\n    return false;\n  }\n\n  if (query.connectedNodes) {\n    var q0 = query.connectedNodes[0];\n    var q1 = query.connectedNodes[1];\n\n    if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {\n      // match\n    } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {\n      // match\n    } else {\n      return false;\n    }\n  }\n\n  // we've reached the end, so we've matched everything for this query\n  return true;\n}; // queryMatches\n\n// filter an existing collection\nvar filter = function filter(collection) {\n  var self = this;\n  var cy = collection.cy();\n\n  // don't bother trying if it's invalid\n  if (self.invalid()) {\n    return cy.collection();\n  }\n\n  // for 1 id #foo queries, just get the element\n  if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {\n    return collection.getElementById(self[0].ids[0]).collection();\n  }\n\n  var selectorFunction = function selectorFunction(element) {\n    for (var j = 0; j < self.length; j++) {\n      var query = self[j];\n\n      if (queryMatches(query, element)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  if (self.text() == null) {\n    selectorFunction = function selectorFunction() {\n      return true;\n    };\n  }\n\n  var filteredCollection = collection.filter(selectorFunction);\n\n  return filteredCollection;\n}; // filter\n\n// does selector match a single element?\nvar matches = function matches(ele) {\n  var self = this;\n\n  // don't bother trying if it's invalid\n  if (self.invalid()) {\n    return false;\n  }\n\n  for (var j = 0; j < self.length; j++) {\n    var query = self[j];\n\n    if (queryMatches(query, ele)) {\n      return true;\n    }\n  }\n\n  return false;\n}; // filter\n\nmodule.exports = { matches: matches, filter: filter };\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar exprs = __webpack_require__(118);\nvar newQuery = __webpack_require__(11);\n\n// of all the expressions, find the first match in the remaining text\nvar consumeExpr = function consumeExpr(remaining) {\n  var expr = void 0;\n  var match = void 0;\n  var name = void 0;\n\n  for (var j = 0; j < exprs.length; j++) {\n    var e = exprs[j];\n    var n = e.name;\n\n    var m = remaining.match(e.regexObj);\n\n    if (m != null) {\n      match = m;\n      expr = e;\n      name = n;\n\n      var consumed = m[0];\n      remaining = remaining.substring(consumed.length);\n\n      break; // we've consumed one expr, so we can return now\n    }\n  }\n\n  return {\n    expr: expr,\n    match: match,\n    name: name,\n    remaining: remaining\n  };\n};\n\n// consume all leading whitespace\nvar consumeWhitespace = function consumeWhitespace(remaining) {\n  var match = remaining.match(/^\\s+/);\n\n  if (match) {\n    var consumed = match[0];\n    remaining = remaining.substring(consumed.length);\n  }\n\n  return remaining;\n};\n\nvar parse = function parse(selector) {\n  var self = this;\n\n  var remaining = self._private.selectorText = selector;\n\n  var currentQuery = self[0] = newQuery();\n  self.length = 1;\n\n  remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\n  for (;;) {\n    var check = consumeExpr(remaining);\n\n    if (check.expr == null) {\n      util.error('The selector `' + selector + '`is invalid');\n      return false;\n    } else {\n      var args = check.match.slice(1);\n\n      // let the token populate the selector object in currentQuery\n      var ret = check.expr.populate(self, currentQuery, args);\n\n      if (ret === false) {\n        return false; // exit if population failed\n      } else if (ret != null) {\n        currentQuery = ret; // change the current query to be filled if the expr specifies\n      }\n    }\n\n    remaining = check.remaining;\n\n    // we're done when there's nothing left to parse\n    if (remaining.match(/^\\s*$/)) {\n      break;\n    }\n  }\n\n  // adjust references for subject\n  for (var j = 0; j < self.length; j++) {\n    var query = self[j];\n\n    if (query.subject != null) {\n      // go up the tree until we reach the subject\n      for (;;) {\n        if (query.subject === query) {\n          break;\n        } // done if subject is self\n\n        if (query.parent != null) {\n          // swap parent/child reference\n          var parent = query.parent;\n          var child = query;\n\n          child.parent = null;\n          parent.child = child;\n\n          query = parent; // go up the tree\n        } else if (query.ancestor != null) {\n          // swap ancestor/descendant\n          var ancestor = query.ancestor;\n          var descendant = query;\n\n          descendant.ancestor = null;\n          ancestor.descendant = descendant;\n\n          query = ancestor; // go up the tree\n        } else if (query.source || query.target || query.connectedNodes) {\n          util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');\n          return false;\n        } else {\n          util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');\n          return false;\n        }\n      } // for\n\n      self[j] = query.subject; // subject should be the root query\n    } // if\n  } // for\n\n  return true; // success\n};\n\nmodule.exports = { parse: parse };\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\n\n// tokens in the query language\nvar tokens = {\n  metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in let names, etc\n  comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n  boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n  string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n  number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n  meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)\n  separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n  descendant: '\\\\s+',\n  child: '\\\\s+>\\\\s+',\n  subject: '\\\\$',\n  group: 'node|edge|\\\\*',\n  directedEdge: '\\\\s+->\\\\s+',\n  undirectedEdge: '\\\\s+<->\\\\s+'\n};\ntokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name\ntokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\ntokens.className = tokens.variable; // a class name (follows variable conventions)\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n\n(function () {\n  var ops = void 0,\n      op = void 0,\n      i = void 0;\n\n  // add @ variants to comparatorOp\n  ops = tokens.comparatorOp.split('|');\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n    tokens.comparatorOp += '|@' + op;\n  }\n\n  // add ! variants to comparatorOp\n  ops = tokens.comparatorOp.split('|');\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n\n    if (op.indexOf('!') >= 0) {\n      continue;\n    } // skip ops that explicitly contain !\n    if (op === '=') {\n      continue;\n    } // skip = b/c != is explicitly defined\n\n    tokens.comparatorOp += '|\\\\!' + op;\n  }\n})();\n\nmodule.exports = tokens;\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar Promise = __webpack_require__(5);\n\nvar styfn = {};\n\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn.apply = function (eles) {\n  var self = this;\n  var _p = self._private;\n  var cy = _p.cy;\n  var updatedEles = cy.collection();\n\n  if (_p.newStyle) {\n    // clear style caches\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n\n    self.cleanElements(eles, true);\n  }\n\n  for (var ie = 0; ie < eles.length; ie++) {\n    var ele = eles[ie];\n\n    var cxtMeta = self.getContextMeta(ele);\n\n    if (cxtMeta.empty) {\n      continue;\n    } else {\n      updatedEles.merge(ele);\n    }\n\n    var cxtStyle = self.getContextStyle(cxtMeta);\n    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\n    if (!_p.newStyle) {\n      self.updateTransitions(ele, app.diffProps);\n    }\n\n    self.updateStyleHints(ele);\n  } // for elements\n\n  _p.newStyle = false;\n\n  return updatedEles;\n};\n\nstyfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n  var self = this;\n  var cache = self._private.propDiffs = self._private.propDiffs || {};\n  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n  var cachedVal = cache[dualCxtKey];\n\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  var diffProps = [];\n  var addedProp = {};\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var oldHasCxt = oldCxtKey[i] === 't';\n    var newHasCxt = newCxtKey[i] === 't';\n    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n    if (cxtHasDiffed || cxtHasMappedProps) {\n      var props = void 0;\n\n      if (cxtHasDiffed && cxtHasMappedProps) {\n        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n      } else if (cxtHasDiffed) {\n        props = cxt.properties; // need to check them all\n      } else if (cxtHasMappedProps) {\n        props = cxt.mappedProperties; // only need to check mapped\n      }\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        var name = prop.name;\n\n        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n        // is cached)\n        var laterCxtOverrides = false;\n        for (var k = i + 1; k < self.length; k++) {\n          var laterCxt = self[k];\n          var hasLaterCxt = newCxtKey[k] === 't';\n\n          if (!hasLaterCxt) {\n            continue;\n          } // can't override unless the context is active\n\n          laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\n          if (laterCxtOverrides) {\n            break;\n          } // exit early as long as one later context overrides\n        }\n\n        if (!addedProp[name] && !laterCxtOverrides) {\n          addedProp[name] = true;\n          diffProps.push(name);\n        }\n      } // for props\n    } // if\n  } // for contexts\n\n  cache[dualCxtKey] = diffProps;\n  return diffProps;\n};\n\nstyfn.getContextMeta = function (ele) {\n  var self = this;\n  var cxtKey = '';\n  var diffProps = void 0;\n  var prevKey = ele._private.styleCxtKey || '';\n\n  if (self._private.newStyle) {\n    prevKey = ''; // since we need to apply all style if a fresh stylesheet\n  }\n\n  // get the cxt key\n  for (var i = 0; i < self.length; i++) {\n    var context = self[i];\n    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n    if (contextSelectorMatches) {\n      cxtKey += 't';\n    } else {\n      cxtKey += 'f';\n    }\n  } // for context\n\n  diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n\n  ele._private.styleCxtKey = cxtKey;\n\n  return {\n    key: cxtKey,\n    diffPropNames: diffProps,\n    empty: diffProps.length === 0\n  };\n};\n\n// gets a computed ele style object based on matched contexts\nstyfn.getContextStyle = function (cxtMeta) {\n  var cxtKey = cxtMeta.key;\n  var self = this;\n  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\n  // if already computed style, returned cached copy\n  if (cxtStyles[cxtKey]) {\n    return cxtStyles[cxtKey];\n  }\n\n  var style = {\n    _private: {\n      key: cxtKey\n    }\n  };\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var hasCxt = cxtKey[i] === 't';\n\n    if (!hasCxt) {\n      continue;\n    }\n\n    for (var j = 0; j < cxt.properties.length; j++) {\n      var prop = cxt.properties[j];\n\n      style[prop.name] = prop;\n    }\n  }\n\n  cxtStyles[cxtKey] = style;\n  return style;\n};\n\nstyfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n  var self = this;\n  var diffProps = cxtMeta.diffPropNames;\n  var retDiffProps = {};\n\n  for (var i = 0; i < diffProps.length; i++) {\n    var diffPropName = diffProps[i];\n    var cxtProp = cxtStyle[diffPropName];\n    var eleProp = ele.pstyle(diffPropName);\n\n    if (!cxtProp) {\n      // no context prop means delete\n      if (!eleProp) {\n        continue; // no existing prop means nothing needs to be removed\n        // nb affects initial application on mapped values like control-point-distances\n      } else if (eleProp.bypass) {\n        cxtProp = { name: diffPropName, deleteBypassed: true };\n      } else {\n        cxtProp = { name: diffPropName, delete: true };\n      }\n    }\n\n    // save cycles when the context prop doesn't need to be applied\n    if (eleProp === cxtProp) {\n      continue;\n    }\n\n    var retDiffProp = retDiffProps[diffPropName] = {\n      prev: eleProp\n    };\n\n    self.applyParsedProperty(ele, cxtProp);\n\n    retDiffProp.next = ele.pstyle(diffPropName);\n\n    if (retDiffProp.next && retDiffProp.next.bypass) {\n      retDiffProp.next = retDiffProp.next.bypassed;\n    }\n  }\n\n  return {\n    diffProps: retDiffProps\n  };\n};\n\nstyfn.updateStyleHints = function (ele) {\n  var _p = ele._private;\n  var self = this;\n\n  if (ele.removed()) {\n    return;\n  }\n\n  // set whether has pie or not; for greater efficiency\n  var hasPie = false;\n  if (_p.group === 'nodes') {\n    for (var i = 1; i <= self.pieBackgroundN; i++) {\n      // 1..N\n      var _size = ele.pstyle('pie-' + i + '-background-size').value;\n\n      if (_size > 0) {\n        hasPie = true;\n        break;\n      }\n    }\n  }\n\n  _p.hasPie = hasPie;\n\n  var transform = ele.pstyle('text-transform').strValue;\n  var content = ele.pstyle('label').strValue;\n  var srcContent = ele.pstyle('source-label').strValue;\n  var tgtContent = ele.pstyle('target-label').strValue;\n  var fStyle = ele.pstyle('font-style').strValue;\n  var size = ele.pstyle('font-size').pfValue + 'px';\n  var family = ele.pstyle('font-family').strValue;\n  // let letiant = style['font-letiant'].strValue;\n  var weight = ele.pstyle('font-weight').strValue;\n  var valign = ele.pstyle('text-valign').strValue;\n  var halign = ele.pstyle('text-valign').strValue;\n  var oWidth = ele.pstyle('text-outline-width').pfValue;\n  var wrap = ele.pstyle('text-wrap').strValue;\n  var wrapW = ele.pstyle('text-max-width').pfValue;\n  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;\n  _p.labelStyleKey = labelStyleKey;\n  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;\n  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;\n  _p.labelKey = labelStyleKey + '$' + content;\n  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;\n\n  _p.styleKey = Date.now();\n};\n\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn.applyParsedProperty = function (ele, parsedProp) {\n  var self = this;\n  var prop = parsedProp;\n  var style = ele._private.style;\n  var fieldVal = void 0,\n      flatProp = void 0;\n  var types = self.types;\n  var type = self.properties[prop.name].type;\n  var propIsBypass = prop.bypass;\n  var origProp = style[prop.name];\n  var origPropIsBypass = origProp && origProp.bypass;\n  var _p = ele._private;\n  var flatPropMapping = 'mapping';\n\n  var checkZOrder = function checkZOrder() {\n    self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);\n  };\n\n  // edges connected to compound nodes can not be haystacks\n  if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {\n    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n  }\n\n  if (prop.delete) {\n    // delete the property and use the default value on falsey value\n    style[prop.name] = undefined;\n\n    checkZOrder();\n\n    return true;\n  }\n\n  if (prop.deleteBypassed) {\n    // delete the property that the\n    if (!origProp) {\n      checkZOrder();\n\n      return true; // can't delete if no prop\n    } else if (origProp.bypass) {\n      // delete bypassed\n      origProp.bypassed = undefined;\n\n      checkZOrder();\n\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypassed\n    }\n  }\n\n  // check if we need to delete the current bypass\n  if (prop.deleteBypass) {\n    // then this property is just here to indicate we need to delete\n    if (!origProp) {\n      checkZOrder();\n\n      return true; // property is already not defined\n    } else if (origProp.bypass) {\n      // then replace the bypass property with the original\n      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n      style[prop.name] = origProp.bypassed;\n\n      checkZOrder();\n\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypass\n    }\n  }\n\n  var printMappingErr = function printMappingErr() {\n    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n  };\n\n  // put the property in the style objects\n  switch (prop.mapped) {// flatten the property if mapped\n    case types.mapData:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var fields = prop.field.split('.');\n        var _fieldVal = _p.data;\n\n        for (var i = 0; i < fields.length && _fieldVal; i++) {\n          var field = fields[i];\n          _fieldVal = _fieldVal[field];\n        }\n\n        var percent = void 0;\n        if (!is.number(_fieldVal)) {\n          // then keep the mapping but assume 0% for now\n          percent = 0;\n        } else {\n          percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n        }\n\n        // make sure to bound percent value\n        if (percent < 0) {\n          percent = 0;\n        } else if (percent > 1) {\n          percent = 1;\n        }\n\n        if (type.color) {\n          var r1 = prop.valueMin[0];\n          var r2 = prop.valueMax[0];\n          var g1 = prop.valueMin[1];\n          var g2 = prop.valueMax[1];\n          var b1 = prop.valueMin[2];\n          var b2 = prop.valueMax[2];\n          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\n          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n\n          flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n            bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n            name: prop.name,\n            value: clr,\n            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n          };\n        } else if (type.number) {\n          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n        } else {\n          return false; // can only map to colours and numbers\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n          flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);\n        }\n\n        if (!flatProp) {\n          printMappingErr();\n        }\n        flatProp.mapping = prop; // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    // direct mapping\n    case types.data:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var _fields = prop.field.split('.');\n        var _fieldVal2 = _p.data;\n\n        if (_fieldVal2) {\n          for (var _i = 0; _i < _fields.length; _i++) {\n            var _field = _fields[_i];\n            _fieldVal2 = _fieldVal2[_field];\n          }\n        }\n\n        flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);\n\n        if (!flatProp) {\n          // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n          var flatPropVal = origProp ? origProp.strValue : '';\n\n          flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);\n        }\n\n        if (!flatProp) {\n          printMappingErr();\n        }\n        flatProp.mapping = prop; // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case types.fn:\n      {\n        var fn = prop.value;\n        var fnRetVal = fn(ele);\n\n        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n        flatProp.mapping = prop; // keep a reference to the mapping\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case undefined:\n      break; // just set the property\n\n    default:\n      return false; // not a valid mapping\n  }\n\n  // if the property is a bypass property, then link the resultant property to the original one\n  if (propIsBypass) {\n    if (origPropIsBypass) {\n      // then this bypass overrides the existing one\n      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n    } else {\n      // then link the orig prop to the new bypass\n      prop.bypassed = origProp;\n    }\n\n    style[prop.name] = prop; // and set\n  } else {\n    // prop is not bypass\n    if (origPropIsBypass) {\n      // then keep the orig prop (since it's a bypass) and link to the new prop\n      origProp.bypassed = prop;\n    } else {\n      // then just replace the old prop with the new one\n      style[prop.name] = prop;\n    }\n  }\n\n  checkZOrder();\n\n  return true;\n};\n\nstyfn.cleanElements = function (eles, keepBypasses) {\n  var self = this;\n  var props = self.properties;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (!keepBypasses) {\n      ele._private.style = {};\n    } else {\n      var style = ele._private.style;\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        var eleProp = style[prop.name];\n\n        if (eleProp) {\n          if (eleProp.bypass) {\n            eleProp.bypassed = null;\n          } else {\n            style[prop.name] = null;\n          }\n        }\n      }\n    }\n  }\n};\n\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn.update = function () {\n  var cy = this._private.cy;\n  var eles = cy.mutableElements();\n\n  eles.updateStyle();\n};\n\n// just update the functional properties (i.e. mappings) in the elements'\n// styles (less expensive than recalculation)\nstyfn.updateMappers = function (eles) {\n  var self = this;\n  var cy = this._private.cy;\n  var updatedEles = cy.collection();\n\n  for (var i = 0; i < eles.length; i++) {\n    // for each ele\n    var ele = eles[i];\n    var style = ele._private.style;\n    var updatedEle = false;\n\n    for (var j = 0; j < self.properties.length; j++) {\n      // for each prop\n      var prop = self.properties[j];\n      var propInStyle = style[prop.name];\n\n      if (propInStyle && propInStyle.mapping) {\n        var mapping = propInStyle.mapping;\n\n        this.applyParsedProperty(ele, mapping); // reapply the mapping property\n\n        updatedEle = true;\n      }\n    }\n\n    if (updatedEle) {\n      this.updateStyleHints(ele);\n\n      updatedEles.merge(ele);\n    }\n  }\n\n  return updatedEles;\n};\n\n// diffProps : { name => { prev, next } }\nstyfn.updateTransitions = function (ele, diffProps, isBypass) {\n  var self = this;\n  var _p = ele._private;\n  var props = ele.pstyle('transition-property').value;\n  var duration = ele.pstyle('transition-duration').pfValue;\n  var delay = ele.pstyle('transition-delay').pfValue;\n\n  if (props.length > 0 && duration > 0) {\n\n    var style = {};\n\n    // build up the style to animate towards\n    var anyPrev = false;\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var styProp = ele.pstyle(prop);\n      var diffProp = diffProps[prop];\n\n      if (!diffProp) {\n        continue;\n      }\n\n      var prevProp = diffProp.prev;\n      var fromProp = prevProp;\n      var toProp = diffProp.next != null ? diffProp.next : styProp;\n      var diff = false;\n      var initVal = void 0;\n      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n      if (!fromProp) {\n        continue;\n      }\n\n      // consider px values\n      if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {\n        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n        initVal = fromProp.pfValue + initDt * diff;\n\n        // consider numerical values\n      } else if (is.number(fromProp.value) && is.number(toProp.value)) {\n        diff = toProp.value - fromProp.value; // nonzero is truthy\n        initVal = fromProp.value + initDt * diff;\n\n        // consider colour values\n      } else if (is.array(fromProp.value) && is.array(toProp.value)) {\n        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n\n        initVal = fromProp.strValue;\n      }\n\n      // the previous value is good for an animation only if it's different\n      if (diff) {\n        style[prop] = toProp.strValue; // to val\n        this.applyBypass(ele, prop, initVal); // from val\n        anyPrev = true;\n      }\n    } // end if props allow ani\n\n    // can't transition if there's nothing previous to transition from\n    if (!anyPrev) {\n      return;\n    }\n\n    _p.transitioning = true;\n\n    new Promise(function (resolve) {\n      if (delay > 0) {\n        ele.delayAnimation(delay).play().promise().then(resolve);\n      } else {\n        resolve();\n      }\n    }).then(function () {\n      return ele.animation({\n        style: style,\n        duration: duration,\n        easing: ele.pstyle('transition-timing-function').value,\n        queue: false\n      }).play().promise();\n    }).then(function () {\n      // if( !isBypass ){\n      self.removeBypasses(ele, props);\n      ele.emitAndNotify('style');\n      // }\n\n      _p.transitioning = false;\n    });\n  } else if (_p.transitioning) {\n    this.removeBypasses(ele, props);\n    ele.emitAndNotify('style');\n\n    _p.transitioning = false;\n  }\n};\n\nstyfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n  var prop = this.properties[name];\n\n  if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {\n    this._private.cy.notify({\n      type: 'zorder',\n      eles: ele\n    });\n  }\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\nvar util = __webpack_require__(1);\n\nvar styfn = {};\n\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn.applyBypass = function (eles, name, value, updateTransitions) {\n  var self = this;\n  var props = [];\n  var isBypass = true;\n\n  // put all the properties (can specify one or many) in an array after parsing them\n  if (name === '*' || name === '**') {\n    // apply to all property names\n\n    if (value !== undefined) {\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var _name = prop.name;\n\n        var parsedProp = this.parse(_name, value, true);\n\n        if (parsedProp) {\n          props.push(parsedProp);\n        }\n      }\n    }\n  } else if (is.string(name)) {\n    // then parse the single property\n    var _parsedProp = this.parse(name, value, true);\n\n    if (_parsedProp) {\n      props.push(_parsedProp);\n    }\n  } else if (is.plainObject(name)) {\n    // then parse each property\n    var specifiedProps = name;\n    updateTransitions = value;\n\n    var names = Object.keys(specifiedProps);\n\n    for (var _i = 0; _i < names.length; _i++) {\n      var _name2 = names[_i];\n      var _prop = self.properties[_name2];\n      var _value = specifiedProps[_name2];\n\n      if (_value === undefined) {\n        // try camel case name too\n        _value = specifiedProps[util.dash2camel(_name2)];\n      }\n\n      if (_value !== undefined) {\n        var _parsedProp2 = this.parse(_name2, _value, true);\n\n        if (_parsedProp2) {\n          props.push(_parsedProp2);\n        }\n      }\n    }\n  } else {\n    // can't do anything without well defined properties\n    return false;\n  }\n\n  // we've failed if there are no valid properties\n  if (props.length === 0) {\n    return false;\n  }\n\n  // now, apply the bypass properties on the elements\n  var ret = false; // return true if at least one succesful bypass applied\n  for (var _i2 = 0; _i2 < eles.length; _i2++) {\n    // for each ele\n    var ele = eles[_i2];\n    var diffProps = {};\n    var diffProp = void 0;\n\n    for (var j = 0; j < props.length; j++) {\n      // for each prop\n      var _prop2 = props[j];\n\n      if (updateTransitions) {\n        var prevProp = ele.pstyle(_prop2.name);\n        diffProp = diffProps[_prop2.name] = { prev: prevProp };\n      }\n\n      ret = this.applyParsedProperty(ele, _prop2) || ret;\n\n      if (updateTransitions) {\n        diffProp.next = ele.pstyle(_prop2.name);\n      }\n    } // for props\n\n    if (ret) {\n      this.updateStyleHints(ele);\n    }\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n  return ret;\n};\n\n// only useful in specific cases like animation\nstyfn.overrideBypass = function (eles, name, value) {\n  name = util.camel2dash(name);\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var prop = ele._private.style[name];\n    var type = this.properties[name].type;\n    var isColor = type.color;\n    var isMulti = type.mutiple;\n\n    if (!prop || !prop.bypass) {\n      // need a bypass if one doesn't exist\n      this.applyBypass(ele, name, value);\n      continue;\n    }\n\n    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;\n\n    prop.value = value;\n\n    if (prop.pfValue != null) {\n      prop.pfValue = value;\n    }\n\n    if (isColor) {\n      prop.strValue = 'rgb(' + value.join(',') + ')';\n    } else if (isMulti) {\n      prop.strValue = value.join(' ');\n    } else {\n      prop.strValue = '' + value;\n    }\n\n    this.checkZOrderTrigger(ele, name, oldValue, value);\n  }\n};\n\nstyfn.removeAllBypasses = function (eles, updateTransitions) {\n  return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\n\nstyfn.removeBypasses = function (eles, props, updateTransitions) {\n  var isBypass = true;\n\n  for (var j = 0; j < eles.length; j++) {\n    var ele = eles[j];\n    var diffProps = {};\n\n    for (var i = 0; i < props.length; i++) {\n      var name = props[i];\n      var prop = this.properties[name];\n      var prevProp = ele.pstyle(prop.name);\n\n      if (!prevProp || !prevProp.bypass) {\n        // if a bypass doesn't exist for the prop, nothing needs to be removed\n        continue;\n      }\n\n      var value = ''; // empty => remove bypass\n      var parsedProp = this.parse(name, value, true);\n      var diffProp = diffProps[prop.name] = { prev: prevProp };\n\n      this.applyParsedProperty(ele, parsedProp);\n\n      diffProp.next = ele.pstyle(prop.name);\n    } // for props\n\n    this.updateStyleHints(ele);\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar window = __webpack_require__(4);\n\nvar styfn = {};\n\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn.getEmSizeInPixels = function () {\n  var px = this.containerCss('font-size');\n\n  if (px != null) {\n    return parseFloat(px);\n  } else {\n    return 1; // for headless\n  }\n};\n\n// gets css property from the core container\nstyfn.containerCss = function (propName) {\n  var cy = this._private.cy;\n  var domElement = cy.container();\n\n  if (window && domElement && window.getComputedStyle) {\n    return window.getComputedStyle(domElement).getPropertyValue(propName);\n  }\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar styfn = {};\n\n// gets the rendered style for an element\nstyfn.getRenderedStyle = function (ele, prop) {\n  if (prop) {\n    return this.getStylePropertyValue(ele, prop, true);\n  } else {\n    return this.getRawStyle(ele, true);\n  }\n};\n\n// gets the raw style for an element\nstyfn.getRawStyle = function (ele, isRenderedVal) {\n  var self = this;\n\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var rstyle = {};\n\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\n      if (val != null) {\n        rstyle[prop.name] = val;\n        rstyle[util.dash2camel(prop.name)] = val;\n      }\n    }\n\n    return rstyle;\n  }\n};\n\nstyfn.getIndexedStyle = function (ele, property, subproperty, index) {\n  var pstyle = ele.pstyle(property)[subproperty][index];\n  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\n\nstyfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n  var self = this;\n\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var prop = self.properties[propName];\n\n    if (prop.alias) {\n      prop = prop.pointsTo;\n    }\n\n    var type = prop.type;\n    var styleProp = ele.pstyle(prop.name);\n    var zoom = ele.cy().zoom();\n\n    if (styleProp) {\n      var units = styleProp.units ? type.implicitUnits || 'px' : null;\n      var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {\n        return pfValue * (isRenderedVal ? zoom : 1) + units;\n      }).join(' ') : styleProp.strValue;\n\n      return val;\n    }\n  }\n};\n\nstyfn.getAnimationStartStyle = function (ele, aniProps) {\n  var rstyle = {};\n\n  for (var i = 0; i < aniProps.length; i++) {\n    var aniProp = aniProps[i];\n    var name = aniProp.name;\n\n    var styleProp = ele.pstyle(name);\n\n    if (styleProp !== undefined) {\n      // then make a prop of it\n      if (is.plainObject(styleProp)) {\n        styleProp = this.parse(name, styleProp.strValue);\n      } else {\n        styleProp = this.parse(name, styleProp);\n      }\n    }\n\n    if (styleProp) {\n      rstyle[name] = styleProp;\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn.getPropsList = function (propsObj) {\n  var self = this;\n  var rstyle = [];\n  var style = propsObj;\n  var props = self.properties;\n\n  if (style) {\n    var names = Object.keys(style);\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var val = style[name];\n      var prop = props[name] || props[util.camel2dash(name)];\n      var styleProp = this.parse(prop.name, val);\n\n      if (styleProp) {\n        rstyle.push(styleProp);\n      }\n    }\n  }\n\n  return rstyle;\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar styfn = {};\n\nstyfn.appendFromJson = function (json) {\n  var style = this;\n\n  for (var i = 0; i < json.length; i++) {\n    var context = json[i];\n    var selector = context.selector;\n    var props = context.style || context.css;\n    var names = Object.keys(props);\n\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < names.length; j++) {\n      var name = names[j];\n      var value = props[name];\n\n      style.css(name, value); // apply property\n    }\n  }\n\n  return style;\n};\n\n// accessible cy.style() function\nstyfn.fromJson = function (json) {\n  var style = this;\n\n  style.resetToDefault();\n  style.appendFromJson(json);\n\n  return style;\n};\n\n// get json from cy.style() api\nstyfn.json = function () {\n  var json = [];\n\n  for (var i = this.defaultLength; i < this.length; i++) {\n    var cxt = this[i];\n    var selector = cxt.selector;\n    var props = cxt.properties;\n    var css = {};\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      css[prop.name] = prop.strValue;\n    }\n\n    json.push({\n      selector: !selector ? 'core' : selector.toString(),\n      style: css\n    });\n  }\n\n  return json;\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\nvar math = __webpack_require__(2);\n\nvar styfn = {};\n\n// a caching layer for property parsing\nstyfn.parse = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n\n  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n  if (is.fn(value)) {\n    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n\n  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n  var argHash = [name, value, propIsBypass, flatKey].join('$');\n  var propCache = self.propCache = self.propCache || {};\n  var ret = void 0;\n\n  if (!(ret = propCache[argHash])) {\n    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n\n  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n  // - mappings can't be shared b/c mappings are per-element\n  if (propIsBypass || propIsFlat === 'mapping') {\n    // need a copy since props are mutated later in their lifecycles\n    ret = util.copy(ret);\n\n    if (ret) {\n      ret.value = util.copy(ret.value); // because it could be an array, e.g. colour\n    }\n  }\n\n  return ret;\n};\n\nstyfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\n  if (!prop && value != null) {\n    util.error('The style property `%s: %s` is invalid', name, value);\n  }\n\n  return prop;\n};\n\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nstyfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n\n  name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n  var property = self.properties[name];\n  var passedValue = value;\n  var types = self.types;\n\n  if (!property) {\n    return null;\n  } // return null on property of unknown name\n  if (value === undefined || value === null) {\n    return null;\n  } // can't assign null\n\n  // the property may be an alias\n  if (property.alias) {\n    property = property.pointsTo;\n    name = property.name;\n  }\n\n  var valueIsString = is.string(value);\n  if (valueIsString) {\n    // trim the value to make parsing easier\n    value = value.trim();\n  }\n\n  var type = property.type;\n  if (!type) {\n    return null;\n  } // no type, no luck\n\n  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n  if (propIsBypass && (value === '' || value === null)) {\n    return {\n      name: name,\n      value: value,\n      bypass: true,\n      deleteBypass: true\n    };\n  }\n\n  // check if value is a function used as a mapper\n  if (is.fn(value)) {\n    return {\n      name: name,\n      value: value,\n      strValue: 'fn',\n      mapped: types.fn,\n      bypass: propIsBypass\n    };\n  }\n\n  // check if value is mapped\n  var data = void 0,\n      mapData = void 0;\n  if (!valueIsString || propIsFlat) {\n    // then don't bother to do the expensive regex checks\n\n  } else if (data = new RegExp(types.data.regex).exec(value)) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n    var mapped = types.data;\n\n    return {\n      name: name,\n      value: data,\n      strValue: '' + value,\n      mapped: mapped,\n      field: data[1],\n      bypass: propIsBypass\n    };\n  } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n    if (type.multiple) {\n      return false;\n    } // impossible to map to num\n\n    var _mapped = types.mapData;\n\n    // we can map only if the type is a colour or a number\n    if (!(type.color || type.number)) {\n      return false;\n    }\n\n    var valueMin = this.parse(name, mapData[4]); // parse to validate\n    if (!valueMin || valueMin.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n    var valueMax = this.parse(name, mapData[5]); // parse to validate\n    if (!valueMax || valueMax.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n    // check if valueMin and valueMax are the same\n    if (valueMin.value === valueMax.value) {\n      return false; // can't make much of a mapper without a range\n    } else if (type.color) {\n      var c1 = valueMin.value;\n      var c2 = valueMax.value;\n\n      var same = c1[0] === c2[0] // red\n      && c1[1] === c2[1] // green\n      && c1[2] === c2[2] // blue\n      && ( // optional alpha\n      c1[3] === c2[3] // same alpha outright\n      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?\n      c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n      );\n\n      if (same) {\n        return false;\n      } // can't make a mapper without a range\n    }\n\n    return {\n      name: name,\n      value: mapData,\n      strValue: '' + value,\n      mapped: _mapped,\n      field: mapData[1],\n      fieldMin: parseFloat(mapData[2]), // min & max are numeric\n      fieldMax: parseFloat(mapData[3]),\n      valueMin: valueMin.value,\n      valueMax: valueMax.value,\n      bypass: propIsBypass\n    };\n  }\n\n  if (type.multiple && propIsFlat !== 'multiple') {\n    var vals = void 0;\n\n    if (valueIsString) {\n      vals = value.split(/\\s+/);\n    } else if (is.array(value)) {\n      vals = value;\n    } else {\n      vals = [value];\n    }\n\n    if (type.evenMultiple && vals.length % 2 !== 0) {\n      return null;\n    }\n\n    var valArr = [];\n    var unitsArr = [];\n    var pfValArr = [];\n    var hasEnum = false;\n\n    for (var i = 0; i < vals.length; i++) {\n      var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n\n      hasEnum = hasEnum || is.string(p.value);\n\n      valArr.push(p.value);\n      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n      unitsArr.push(p.units);\n    }\n\n    if (type.validate && !type.validate(valArr, unitsArr)) {\n      return null;\n    }\n\n    if (type.singleEnum && hasEnum) {\n      if (valArr.length === 1 && is.string(valArr[0])) {\n        return {\n          name: name,\n          value: valArr[0],\n          strValue: valArr[0],\n          bypass: propIsBypass\n        };\n      } else {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: valArr,\n      pfValue: pfValArr,\n      strValue: valArr.join(' '),\n      bypass: propIsBypass,\n      units: unitsArr\n    };\n  }\n\n  // several types also allow enums\n  var checkEnums = function checkEnums() {\n    for (var _i = 0; _i < type.enums.length; _i++) {\n      var en = type.enums[_i];\n\n      if (en === value) {\n        return {\n          name: name,\n          value: value,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null;\n  };\n\n  // check the type and return the appropriate object\n  if (type.number) {\n    var units = void 0;\n    var implicitUnits = 'px'; // not set => px\n\n    if (type.units) {\n      // use specified units if set\n      units = type.units;\n    }\n\n    if (type.implicitUnits) {\n      implicitUnits = type.implicitUnits;\n    }\n\n    if (!type.unitless) {\n      if (valueIsString) {\n        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n        if (units) {\n          unitsRegex = units;\n        } // only allow explicit units if so set\n        var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');\n\n        if (match) {\n          value = match[1];\n          units = match[2] || implicitUnits;\n        }\n      } else if (!units || type.implicitUnits) {\n        units = implicitUnits; // implicitly px if unspecified\n      }\n    }\n\n    value = parseFloat(value);\n\n    // if not a number and enums not allowed, then the value is invalid\n    if (isNaN(value) && type.enums === undefined) {\n      return null;\n    }\n\n    // check if this number type also accepts special keywords in place of numbers\n    // (i.e. `left`, `auto`, etc)\n    if (isNaN(value) && type.enums !== undefined) {\n      value = passedValue;\n\n      return checkEnums();\n    }\n\n    // check if value must be an integer\n    if (type.integer && !is.integer(value)) {\n      return null;\n    }\n\n    // check value is within range\n    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n      return null;\n    }\n\n    var ret = {\n      name: name,\n      value: value,\n      strValue: '' + value + (units ? units : ''),\n      units: units,\n      bypass: propIsBypass\n    };\n\n    // normalise value in pixels\n    if (type.unitless || units !== 'px' && units !== 'em') {\n      ret.pfValue = value;\n    } else {\n      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n    }\n\n    // normalise value in ms\n    if (units === 'ms' || units === 's') {\n      ret.pfValue = units === 'ms' ? value : 1000 * value;\n    }\n\n    // normalise value in rad\n    if (units === 'deg' || units === 'rad') {\n      ret.pfValue = units === 'rad' ? value : math.deg2rad(value);\n    }\n\n    // normalize value in %\n    if (units === '%') {\n      ret.pfValue = value / 100;\n    }\n\n    return ret;\n  } else if (type.propList) {\n\n    var props = [];\n    var propsStr = '' + value;\n\n    if (propsStr === 'none') {\n      // leave empty\n\n    } else {\n      // go over each prop\n\n      var propsSplit = propsStr.split(',');\n      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n        var propName = propsSplit[_i2].trim();\n\n        if (self.properties[propName]) {\n          props.push(propName);\n        }\n      }\n\n      if (props.length === 0) {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: props,\n      strValue: props.length === 0 ? 'none' : props.join(', '),\n      bypass: propIsBypass\n    };\n  } else if (type.color) {\n    var tuple = util.color2tuple(value);\n\n    if (!tuple) {\n      return null;\n    }\n\n    return {\n      name: name,\n      value: tuple,\n      pfValue: tuple,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n  } else if (type.regex || type.regexes) {\n\n    // first check enums\n    if (type.enums) {\n      var enumProp = checkEnums();\n\n      if (enumProp) {\n        return enumProp;\n      }\n    }\n\n    var regexes = type.regexes ? type.regexes : [type.regex];\n\n    for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n      var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n      var m = regex.exec(value);\n\n      if (m) {\n        // regex matches\n        return {\n          name: name,\n          value: type.singleRegexMatchValue ? m[1] : m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null; // didn't match any\n  } else if (type.string) {\n    // just return\n    return {\n      name: name,\n      value: '' + value,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n  } else if (type.enums) {\n    // check enums last because it's a combo type in others\n    return checkEnums();\n  } else {\n    return null; // not a type we can handle\n  }\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar is = __webpack_require__(0);\n\nvar styfn = {};\n\n(function () {\n  var number = util.regex.number;\n  var rgba = util.regex.rgbaNoBackRefs;\n  var hsla = util.regex.hslaNoBackRefs;\n  var hex3 = util.regex.hex3;\n  var hex6 = util.regex.hex6;\n  var data = function data(prefix) {\n    return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n  };\n  var mapData = function mapData(prefix) {\n    var mapArg = number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;\n    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n  };\n  var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$'];\n\n  // each visual style property has a type and needs to be validated according to it\n  styfn.types = {\n    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },\n    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n    zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },\n    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n    position: { enums: ['parent', 'origin'] },\n    nodeSize: { number: true, min: 0, enums: ['label'] },\n    number: { number: true, unitless: true },\n    numbers: { number: true, unitless: true, multiple: true },\n    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },\n    size: { number: true, min: 0 },\n    bidirectionalSize: { number: true }, // allows negative\n    bidirectionalSizes: { number: true, multiple: true }, // allows negative\n    sizeMaybePercent: { number: true, min: 0, allowPercent: true },\n    paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },\n    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },\n    bgPos: { number: true, allowPercent: true, multiple: true },\n    bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },\n    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },\n    bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },\n    bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },\n    bgClip: { enums: ['none', 'node'] },\n    color: { color: true },\n    bool: { enums: ['yes', 'no'] },\n    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },\n    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },\n    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },\n    fontFamily: { regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$' },\n    fontletiant: { enums: ['small-caps', 'normal'] },\n    fontStyle: { enums: ['italic', 'normal', 'oblique'] },\n    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },\n    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },\n    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },\n    textWrap: { enums: ['none', 'wrap', 'ellipsis'] },\n    textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },\n    nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },\n    compoundIncludeLabels: { enums: ['include', 'exclude'] },\n    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },\n    arrowFill: { enums: ['filled', 'hollow'] },\n    display: { enums: ['element', 'none'] },\n    visibility: { enums: ['hidden', 'visible'] },\n    zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },\n    zIndexCompare: { enums: ['auto', 'manual'] },\n    valign: { enums: ['top', 'center', 'bottom'] },\n    halign: { enums: ['left', 'center', 'right'] },\n    text: { string: true },\n    data: { mapping: true, regex: data('data') },\n    layoutData: { mapping: true, regex: data('layoutData') },\n    scratch: { mapping: true, regex: data('scratch') },\n    mapData: { mapping: true, regex: mapData('mapData') },\n    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },\n    mapScratch: { mapping: true, regex: mapData('mapScratch') },\n    fn: { mapping: true, fn: true },\n    url: { regexes: urlRegexes, singleRegexMatchValue: true },\n    urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },\n    propList: { propList: true },\n    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },\n    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },\n    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },\n    edgeDistances: { enums: ['intersection', 'node-position'] },\n    edgeEndpoint: {\n      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',\n      enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,\n      validate: function validate(valArr, unitsArr) {\n        switch (valArr.length) {\n          case 2:\n            // can be % or px only\n            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n          case 1:\n            // can be enum, deg, or rad only\n            return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n          default:\n            return false;\n        }\n      }\n    },\n    easing: {\n      regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$'],\n      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n    }\n  };\n\n  var zOrderDiff = {\n    zeroNonZero: function zeroNonZero(val1, val2) {\n      if (val1 === 0 && val2 !== 0) {\n        return true;\n      } else if (val1 !== 0 && val2 === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    anyDiff: function anyDiff(val1, val2) {\n      return val1 !== val2;\n    }\n  };\n\n  var zd = zOrderDiff;\n\n  // define visual style properties\n  var t = styfn.types;\n  var props = styfn.properties = [\n  // main label\n  { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },\n\n  // source label\n  { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },\n\n  // target label\n  { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },\n\n  // common label style\n  { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },\n  // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n  { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },\n  // { name: 'font-letiant', type: t.fontletiant }, // not useful\n  { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },\n\n  // behaviour\n  { name: 'events', type: t.bool },\n\n  // visibility\n  { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },\n\n  // overlays\n  { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },\n\n  // transition anis\n  { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },\n\n  // node body\n  { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },\n\n  // node border\n  { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },\n\n  // node background images\n  { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },\n\n  // compound props\n  { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },\n\n  // edge line\n  { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },\n\n  // ghost properties\n  { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },\n\n  // these are just for the core\n  { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];\n\n  // define aliases\n  var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];\n\n  // pie backgrounds for nodes\n  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n  props.push({ name: 'pie-size', type: t.sizeMaybePercent });\n  for (var i = 1; i <= styfn.pieBackgroundN; i++) {\n    props.push({ name: 'pie-' + i + '-background-color', type: t.color });\n    props.push({ name: 'pie-' + i + '-background-size', type: t.percent });\n    props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });\n  }\n\n  // edge arrows\n  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n  [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {\n    arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var type = prop.type;\n\n      props.push({ name: name, type: type });\n    });\n  }, {});\n\n  // list of property names\n  styfn.propertyNames = props.map(function (p) {\n    return p.name;\n  });\n\n  // allow access of properties by name ( e.g. style.properties.height )\n  for (var _i = 0; _i < props.length; _i++) {\n    var prop = props[_i];\n\n    props[prop.name] = prop; // allow lookup by name\n  }\n\n  // map aliases\n  for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n    var alias = aliases[_i2];\n    var pointsToProp = props[alias.pointsTo];\n    var aliasProp = {\n      name: alias.name,\n      alias: true,\n      pointsTo: pointsToProp\n    };\n\n    // add alias prop for parsing\n    props.push(aliasProp);\n\n    props[alias.name] = aliasProp; // allow lookup by name\n  }\n})();\n\nstyfn.getDefaultProperty = function (name) {\n  return this.getDefaultProperties()[name];\n};\n\nstyfn.getDefaultProperties = util.memoize(function () {\n  var rawProps = util.extend({\n    // common node/edge props\n    'events': 'yes',\n    'text-events': 'no',\n    'text-valign': 'top',\n    'text-halign': 'center',\n    'color': '#000',\n    'text-outline-color': '#000',\n    'text-outline-width': 0,\n    'text-outline-opacity': 1,\n    'text-opacity': 1,\n    'text-decoration': 'none',\n    'text-transform': 'none',\n    'text-wrap': 'none',\n    'text-max-width': 9999,\n    'text-background-color': '#000',\n    'text-background-opacity': 0,\n    'text-background-shape': 'rectangle',\n    'text-background-padding': 0,\n    'text-border-opacity': 0,\n    'text-border-width': 0,\n    'text-border-style': 'solid',\n    'text-border-color': '#000',\n    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n    'font-style': 'normal',\n    // 'font-letiant': fontletiant,\n    'font-weight': 'normal',\n    'font-size': 16,\n    'min-zoomed-font-size': 0,\n    'text-rotation': 'none',\n    'source-text-rotation': 'none',\n    'target-text-rotation': 'none',\n    'visibility': 'visible',\n    'display': 'element',\n    'opacity': 1,\n    'z-compound-depth': 'auto',\n    'z-index-compare': 'auto',\n    'z-index': 0,\n    'label': '',\n    'text-margin-x': 0,\n    'text-margin-y': 0,\n    'source-label': '',\n    'source-text-offset': 0,\n    'source-text-margin-x': 0,\n    'source-text-margin-y': 0,\n    'target-label': '',\n    'target-text-offset': 0,\n    'target-text-margin-x': 0,\n    'target-text-margin-y': 0,\n    'overlay-opacity': 0,\n    'overlay-color': '#000',\n    'overlay-padding': 10,\n    'transition-property': 'none',\n    'transition-duration': 0,\n    'transition-delay': 0,\n    'transition-timing-function': 'linear',\n\n    // node props\n    'background-blacken': 0,\n    'background-color': '#999',\n    'background-opacity': 1,\n    'background-image': 'none',\n    'background-image-crossorigin': 'anonymous',\n    'background-image-opacity': 1,\n    'background-position-x': '50%',\n    'background-position-y': '50%',\n    'background-width-relative-to': 'include-padding',\n    'background-height-relative-to': 'include-padding',\n    'background-repeat': 'no-repeat',\n    'background-fit': 'none',\n    'background-clip': 'node',\n    'background-width': 'auto',\n    'background-height': 'auto',\n    'border-color': '#000',\n    'border-opacity': 1,\n    'border-width': 0,\n    'border-style': 'solid',\n    'height': 30,\n    'width': 30,\n    'shape': 'ellipse',\n    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n\n    // ghost props\n    'ghost': 'no',\n    'ghost-offset-y': 0,\n    'ghost-offset-x': 0,\n    'ghost-opacity': 0,\n\n    // compound props\n    'padding': 0,\n    'padding-relative-to': 'width',\n    'position': 'origin',\n    'compound-sizing-wrt-labels': 'include',\n    'min-width': 0,\n    'min-width-bias-left': 0,\n    'min-width-bias-right': 0,\n    'min-height': 0,\n    'min-height-bias-top': 0,\n    'min-height-bias-bottom': 0\n  }, {\n    // node pie bg\n    'pie-size': '100%'\n  }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {\n    for (var i = 1; i <= styfn.pieBackgroundN; i++) {\n      var name = prop.name.replace('{{i}}', i);\n      var val = prop.value;\n\n      css[name] = val;\n    }\n\n    return css;\n  }, {}), {\n    // edge props\n    'line-style': 'solid',\n    'line-color': '#999',\n    'control-point-step-size': 40,\n    'control-point-weights': 0.5,\n    'segment-weights': 0.5,\n    'segment-distances': 20,\n    'edge-distances': 'intersection',\n    'curve-style': 'bezier',\n    'haystack-radius': 0,\n    'arrow-scale': 1,\n    'loop-direction': '-45deg',\n    'loop-sweep': '-90deg',\n    'source-distance-from-node': 0,\n    'target-distance-from-node': 0,\n    'source-endpoint': 'outside-to-node',\n    'target-endpoint': 'outside-to-node'\n  }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {\n    styfn.arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var val = prop.value;\n\n      css[name] = val;\n    });\n\n    return css;\n  }, {}));\n\n  var parsedProps = {};\n\n  for (var i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n\n    if (prop.pointsTo) {\n      continue;\n    }\n\n    var name = prop.name;\n    var val = rawProps[name];\n    var parsedProp = this.parse(name, val);\n\n    parsedProps[name] = parsedProp;\n  }\n\n  return parsedProps;\n});\n\nstyfn.addDefaultStylesheet = function () {\n  this.selector('$node > node') // compound (parent) node properties\n  .css({\n    'shape': 'rectangle',\n    'padding': 10,\n    'background-color': '#eee',\n    'border-color': '#ccc',\n    'border-width': 1\n  }).selector('edge') // just edge properties\n  .css({\n    'width': 3,\n    'curve-style': 'haystack'\n  }).selector(':parent <-> node').css({\n    'curve-style': 'bezier',\n    'source-endpoint': 'outside-to-line',\n    'target-endpoint': 'outside-to-line'\n  }).selector(':selected').css({\n    'background-color': '#0169D9',\n    'line-color': '#0169D9',\n    'source-arrow-color': '#0169D9',\n    'target-arrow-color': '#0169D9',\n    'mid-source-arrow-color': '#0169D9',\n    'mid-target-arrow-color': '#0169D9'\n  }).selector('node:parent:selected').css({\n    'background-color': '#CCE1F9',\n    'border-color': '#aec8e5'\n  }).selector(':active').css({\n    'overlay-color': 'black',\n    'overlay-padding': 10,\n    'overlay-opacity': 0.25\n  }).selector('core') // just core properties\n  .css({\n    'selection-box-color': '#ddd',\n    'selection-box-opacity': 0.65,\n    'selection-box-border-color': '#aaa',\n    'selection-box-border-width': 1,\n    'active-bg-color': 'black',\n    'active-bg-opacity': 0.15,\n    'active-bg-size': 30,\n    'outside-texture-bg-color': '#000',\n    'outside-texture-bg-opacity': 0.125\n  });\n\n  this.defaultLength = this.length;\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar util = __webpack_require__(1);\nvar Selector = __webpack_require__(6);\n\nvar styfn = {};\n\nstyfn.appendFromString = function (string) {\n  var self = this;\n  var style = this;\n  var remaining = '' + string;\n  var selAndBlockStr = void 0;\n  var blockRem = void 0;\n  var propAndValStr = void 0;\n\n  // remove comments from the style string\n  remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n  function removeSelAndBlockFromRemaining() {\n    // remove the parsed selector and block from the remaining text to parse\n    if (remaining.length > selAndBlockStr.length) {\n      remaining = remaining.substr(selAndBlockStr.length);\n    } else {\n      remaining = '';\n    }\n  }\n\n  function removePropAndValFromRem() {\n    // remove the parsed property and value from the remaining block text to parse\n    if (blockRem.length > propAndValStr.length) {\n      blockRem = blockRem.substr(propAndValStr.length);\n    } else {\n      blockRem = '';\n    }\n  }\n\n  while (true) {\n    var nothingLeftToParse = remaining.match(/^\\s*$/);\n    if (nothingLeftToParse) {\n      break;\n    }\n\n    var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n    if (!selAndBlock) {\n      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n      break;\n    }\n\n    selAndBlockStr = selAndBlock[0];\n\n    // parse the selector\n    var selectorStr = selAndBlock[1];\n    if (selectorStr !== 'core') {\n      var selector = new Selector(selectorStr);\n      if (selector._private.invalid) {\n        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n\n        // skip this selector and block\n        removeSelAndBlockFromRemaining();\n        continue;\n      }\n    }\n\n    // parse the block of properties and values\n    var blockStr = selAndBlock[2];\n    var invalidBlock = false;\n    blockRem = blockStr;\n    var props = [];\n\n    while (true) {\n      var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n      if (_nothingLeftToParse) {\n        break;\n      }\n\n      var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);\n\n      if (!propAndVal) {\n        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n        invalidBlock = true;\n        break;\n      }\n\n      propAndValStr = propAndVal[0];\n      var propStr = propAndVal[1];\n      var valStr = propAndVal[2];\n\n      var prop = self.properties[propStr];\n      if (!prop) {\n        util.error('Skipping property: Invalid property name in: ' + propAndValStr);\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n\n      var parsedProp = style.parse(propStr, valStr);\n\n      if (!parsedProp) {\n        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n\n      props.push({\n        name: propStr,\n        val: valStr\n      });\n      removePropAndValFromRem();\n    }\n\n    if (invalidBlock) {\n      removeSelAndBlockFromRemaining();\n      break;\n    }\n\n    // put the parsed block in the style\n    style.selector(selectorStr);\n    for (var i = 0; i < props.length; i++) {\n      var _prop = props[i];\n      style.css(_prop.name, _prop.val);\n    }\n\n    removeSelAndBlockFromRemaining();\n  }\n\n  return style;\n};\n\nstyfn.fromString = function (string) {\n  var style = this;\n\n  style.resetToDefault();\n  style.appendFromString(string);\n\n  return style;\n};\n\nmodule.exports = styfn;\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nmodule.exports = {\n  // get [r, g, b] from #abc or #aabbcc\n  hex2tuple: function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n      return;\n    }\n\n    var shortHex = hex.length === 4;\n    var r = void 0,\n        g = void 0,\n        b = void 0;\n    var base = 16;\n\n    if (shortHex) {\n      r = parseInt(hex[1] + hex[1], base);\n      g = parseInt(hex[2] + hex[2], base);\n      b = parseInt(hex[3] + hex[3], base);\n    } else {\n      r = parseInt(hex[1] + hex[2], base);\n      g = parseInt(hex[3] + hex[4], base);\n      b = parseInt(hex[5] + hex[6], base);\n    }\n\n    return [r, g, b];\n  },\n\n  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n  hsl2tuple: function hsl2tuple(hsl) {\n    var ret = void 0;\n    var h = void 0,\n        s = void 0,\n        l = void 0,\n        a = void 0,\n        r = void 0,\n        g = void 0,\n        b = void 0;\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);\n    if (m) {\n\n      // get hue\n      h = parseInt(m[1]);\n      if (h < 0) {\n        h = (360 - -1 * h % 360) % 360;\n      } else if (h > 360) {\n        h = h % 360;\n      }\n      h /= 360; // normalise on [0, 1]\n\n      s = parseFloat(m[2]);\n      if (s < 0 || s > 100) {\n        return;\n      } // saturation is [0, 100]\n      s = s / 100; // normalise on [0, 1]\n\n      l = parseFloat(m[3]);\n      if (l < 0 || l > 100) {\n        return;\n      } // lightness is [0, 100]\n      l = l / 100; // normalise on [0, 1]\n\n      a = m[4];\n      if (a !== undefined) {\n        a = parseFloat(a);\n\n        if (a < 0 || a > 1) {\n          return;\n        } // alpha is [0, 1]\n      }\n\n      // now, convert to rgb\n      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n      if (s === 0) {\n        r = g = b = Math.round(l * 255); // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n        g = Math.round(255 * hue2rgb(p, q, h));\n        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n      }\n\n      ret = [r, g, b, a];\n    }\n\n    return ret;\n  },\n\n  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n  rgb2tuple: function rgb2tuple(rgb) {\n    var ret = void 0;\n\n    var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);\n    if (m) {\n      ret = [];\n\n      var isPct = [];\n      for (var i = 1; i <= 3; i++) {\n        var channel = m[i];\n\n        if (channel[channel.length - 1] === '%') {\n          isPct[i] = true;\n        }\n        channel = parseFloat(channel);\n\n        if (isPct[i]) {\n          channel = channel / 100 * 255; // normalise to [0, 255]\n        }\n\n        if (channel < 0 || channel > 255) {\n          return;\n        } // invalid channel value\n\n        ret.push(Math.floor(channel));\n      }\n\n      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n      var allArePct = isPct[1] && isPct[2] && isPct[3];\n      if (atLeastOneIsPct && !allArePct) {\n        return;\n      } // must all be percent values if one is\n\n      var alpha = m[4];\n      if (alpha !== undefined) {\n        alpha = parseFloat(alpha);\n\n        if (alpha < 0 || alpha > 1) {\n          return;\n        } // invalid alpha value\n\n        ret.push(alpha);\n      }\n    }\n\n    return ret;\n  },\n\n  colorname2tuple: function colorname2tuple(color) {\n    return this.colors[color.toLowerCase()];\n  },\n\n  color2tuple: function color2tuple(color) {\n    return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);\n  },\n\n  colors: {\n    // special colour names\n    transparent: [0, 0, 0, 0], // NB alpha === 0\n\n    // regular colours\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    grey: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  }\n};\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar is = __webpack_require__(0);\n\nmodule.exports = {\n  // has anything been set in the map\n  mapEmpty: function mapEmpty(map) {\n    var empty = true;\n\n    if (map != null) {\n      return Object.keys(map).length === 0;\n    }\n\n    return empty;\n  },\n\n  // pushes to the array at the end of a map (map may not be built)\n  pushMap: function pushMap(options) {\n    var array = this.getMap(options);\n\n    if (array == null) {\n      // if empty, put initial array\n      this.setMap(this.extend({}, options, {\n        value: [options.value]\n      }));\n    } else {\n      array.push(options.value);\n    }\n  },\n\n  // sets the value in a map (map may not be built)\n  setMap: function setMap(options) {\n    var obj = options.map;\n    var key = void 0;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var _key = keys[i];\n\n      if (is.plainObject(_key)) {\n        this.error('Tried to set map with object key');\n      }\n\n      if (i < keys.length - 1) {\n\n        // extend the map if necessary\n        if (obj[_key] == null) {\n          obj[_key] = {};\n        }\n\n        obj = obj[_key];\n      } else {\n        // set the value\n        obj[_key] = options.value;\n      }\n    }\n  },\n\n  // gets the value in a map even if it's not built in places\n  getMap: function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (is.plainObject(key)) {\n        this.error('Tried to get map with object key');\n      }\n\n      obj = obj[key];\n\n      if (obj == null) {\n        return obj;\n      }\n    }\n\n    return obj;\n  },\n\n  // deletes the entry in the map\n  deleteMap: function deleteMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    var keepChildren = options.keepChildren;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (is.plainObject(key)) {\n        this.error('Tried to delete map with object key');\n      }\n\n      var lastKey = i === options.keys.length - 1;\n      if (lastKey) {\n\n        if (keepChildren) {\n          // then only delete child fields not in keepChildren\n          var children = Object.keys(obj);\n\n          for (var j = 0; j < children.length; j++) {\n            var child = children[j];\n\n            if (!keepChildren[child]) {\n              obj[child] = undefined;\n            }\n          }\n        } else {\n          obj[key] = undefined;\n        }\n      } else {\n        obj = obj[key];\n      }\n    }\n  }\n};\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\nmodule.exports = {\n  regex: {\n    number: number,\n    rgba: rgba,\n    rgbaNoBackRefs: rgbaNoBackRefs,\n    hsla: hsla,\n    hslaNoBackRefs: hslaNoBackRefs,\n    hex3: hex3,\n    hex6: hex6\n  }\n};\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction ascending(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction descending(a, b) {\n  return -1 * ascending(a, b);\n}\n\nmodule.exports = {\n  sort: {\n    ascending: ascending,\n    descending: descending\n  }\n};\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar memoize = __webpack_require__(19);\nvar is = __webpack_require__(0);\n\nmodule.exports = {\n\n  camel2dash: memoize(function (str) {\n    return str.replace(/([A-Z])/g, function (v) {\n      return '-' + v.toLowerCase();\n    });\n  }),\n\n  dash2camel: memoize(function (str) {\n    return str.replace(/(-\\w)/g, function (v) {\n      return v[1].toUpperCase();\n    });\n  }),\n\n  prependCamel: memoize(function (prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n  }, function (prefix, str) {\n    return prefix + '$' + str;\n  }),\n\n  capitalize: function capitalize(str) {\n    if (is.emptyString(str)) {\n      return str;\n    }\n\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n};\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar window = __webpack_require__(4);\nvar performance = window ? window.performance : null;\n\nvar util = {};\n\nvar pnow = performance && performance.now ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\n\nvar raf = function () {\n  if (window) {\n    if (window.requestAnimationFrame) {\n      return function (fn) {\n        window.requestAnimationFrame(fn);\n      };\n    } else if (window.mozRequestAnimationFrame) {\n      return function (fn) {\n        window.mozRequestAnimationFrame(fn);\n      };\n    } else if (window.webkitRequestAnimationFrame) {\n      return function (fn) {\n        window.webkitRequestAnimationFrame(fn);\n      };\n    } else if (window.msRequestAnimationFrame) {\n      return function (fn) {\n        window.msRequestAnimationFrame(fn);\n      };\n    }\n  }\n\n  return function (fn) {\n    if (fn) {\n      setTimeout(function () {\n        fn(pnow());\n      }, 1000 / 60);\n    }\n  };\n}();\n\nutil.requestAnimationFrame = function (fn) {\n  raf(fn);\n};\n\nutil.performanceNow = pnow;\n\nutil.debounce = __webpack_require__(141);\n\nutil.now = function () {\n  return Date.now();\n};\n\nmodule.exports = util;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(139), __webpack_require__(136)))\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(137);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_140__;\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_141__;\n\n/***/ })\n/******/ ]);\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/cytoscape/dist/cytoscape.cjs.js\n// module id = 743\n// module chunks = 174189240362290","module.exports = require('./lib/heap');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/heap/index.js\n// module id = 961\n// module chunks = 174189240362290","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/heap/lib/heap.js\n// module id = 962\n// module chunks = 174189240362290","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash.debounce/index.js\n// module id = 1060\n// module chunks = 174189240362290","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 1477\n// module chunks = 174189240362290","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 557\n// module chunks = 174189240362290","import React, { Component } from 'react';\n\nimport cytoscape from 'cytoscape';\n\nimport './route.scss';\n\nconst nodes = [\n  { data: { id: 'Front-End' } },\n  { data: { id: 'HTML' } },\n  { data: { id: 'JavaScript' } },\n  { data: { id: 'CSS' } },\n];\nconst edges = [\n  {\n    data: {\n      source: 'Front-End',\n      target: 'HTML',\n    },\n  },\n  {\n    data: {\n      source: 'Front-End',\n      target: 'JavaScript',\n    },\n  },\n  {\n    data: {\n      source: 'Front-End',\n      target: 'CSS',\n    },\n  },\n];\n\nconst elements = [...nodes, ...edges];\n\nclass Cytoscape extends Component {\n  componentDidMount() {\n    cytoscape({\n      container: document.getElementById('cy'),\n      elements,\n\n      pan: { x: 0, y: 0 },\n\n      style: [ // the stylesheet for the graph\n        {\n          selector: 'node',\n          style: {\n            'background-color': '#ededed',\n            label: 'data(id)',\n          },\n        },\n\n        {\n          selector: 'edge',\n          style: {\n            width: 3,\n            'line-color': '#6cf',\n          },\n        },\n      ],\n\n      // TODO: Change layout name by location or other config\n      layout: {\n        name: 'circle',\n      },\n\n    });\n  }\n\n  render() {\n    return (\n      <div id=\"cy\" />\n    );\n  }\n}\n\nexport default Cytoscape;\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/demo/route/index.js"],"sourceRoot":""}