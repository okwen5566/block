webpackJsonp([0x7e1a24416c9b],{1001:function(e,n){e.exports={data:{content:{content:'<h2 id=組件>組件</h2>\n<p><code>React</code>提供<code>React.Component</code>，我們可以透過使用組件，拆分UI為可以重複使用的獨立部分。<code>React.Component</code>是一個抽象的base class。我們甚少直接運用<code>React.Component</code>，通常是透過創建一個子類，並使用<code>render()</code>方法。</p>\n<p>例子：</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-keyword">return</span> &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}\n</code></pre></code></pre>\n<p>如果你不選擇使用ES6，你可以使用模組<code>create-react-class</code>。你可以參考<a href="https://facebook.github.io/react/docs/react-without-es6.html">React Without ES6</a>。\n下面這一段和ES6的寫法效果一樣：</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> createReactClass = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'create-react-class\'</span>);\n<span class="hljs-keyword">var</span> Greeting = createReactClass({\n  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n});\n</code></pre></code></pre>\n<h2 id=組件生命週期>組件生命週期</h2>\n<p>每一個組件都會有幾個生命週期的方法，你可以在程序運行的指定時間，透過覆蓋他們來運行特定代碼。對於這些方法，我們會用<code>will-</code>來表示它會在某些事情發生之前的一刻被調用，而<code>did-</code>則是表示它會在某些事情發生之後的一刻被調用。本文會細說加載組件中發生了什麼事情。</p>\n<h3 id=加載(Mounting)>加載 (Mounting)</h3>\n<ol>\n<li><code>constructor()</code></li>\n<li><code>componentWillMount()</code></li>\n<li><code>render()</code></li>\n<li><code>componentDidMount()</code></li>\n</ol>\n<h3 id=更新(Updating)>更新 (Updating)</h3>\n<p>當 props 或者 state 更新的時候，下面這些方法會被調用：</p>\n<ol>\n<li>componentWillReceiveProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>componentWillUpdate()</li>\n<li>render()</li>\n<li>componentDidUpdate()</li>\n</ol>\n<h3 id=斷開連接(Unmounting)>斷開連接 (Unmounting)</h3>\n<p>當組件脫離DOM的時候，下面這個方法回被調用：</p>\n<ol>\n<li>componentWillUnmount()</li>\n</ol>\n<h3 id=其他內置方法>其他內置方法</h3>\n<ol>\n<li>setState()</li>\n<li>forceUpdate()</li>\n</ol>\n<p>我們會在下文討論一下React是如何加載組件。</p>\n<p>{% img /img/react-mount.svg 300 auto React LifeCycle Mount %}</p>\n<h4 id=constructor()>constructor()</h4>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">constructor</span>(props)\n</code></pre></code></pre>\n<p>在React加載組件之前，它會調用<code>constructor</code>。你可以在<code>constructor</code>中去賦予組件的初始<code>state</code>。如果你使用<code>props</code>創造初始<code>state</code>的話，這也是可以接受的。這會很有效地<code>fork</code>組件的<code>props</code>，然後賦予初始<code>state</code>的值。</p>\n<p>有效的<code>constructor</code>例子：</p>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-keyword">constructor</span>(props) {\n  <span class="hljs-keyword">super</span>(props);\n  <span class="hljs-keyword">this</span>.state = {\n    <span class="hljs-attr">color</span>: props.initialColor\n  };\n}\n</code></pre></code></pre>\n<h5 id=注意事項>注意事項</h5>\n<ol>\n<li>如果你不需要賦予初始<code>state</code>，你不需要在 React 的組件中植入<code>constructor</code>。</li>\n<li>當你使用在<code>React.Component</code>的子類中加載<code>constructor()</code>方法時，你應該第一時間調用<code>super(props)</code>，而不是在任何statement之後。不然，我們獲取<code>this.props</code>值的時候，它會是<code>undefined</code>。</li>\n<li>在一些類似上面的例子，<code>state</code>未必會及時與任何的<code>props</code>更新。如果你需要同步<code>state</code>的話，你其實是想要<a href="https://facebook.github.io/react/docs/lifting-state-up.html">lift the state up</a>。</li>\n</ol>\n<h4 id=componentWillMount()>componentWillMount()</h4>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript">componentWillMount()\n</code></pre></code></pre>\n<p>它會在組件<code>render()</code>之前執行一次，然後不能再執行。如果在這裡定義了<code>setState</code>方法，頁面只會在加載之前更新一次，不會重複渲染。React 官方推薦使用<code>constructor()</code>代替這個方法。</p>\n<h4 id=render()>render()</h4>\n<p><code>React.Component</code>必須有這個方法，即使你返回<code>null</code>，或者<code>false</code>。當你返回<code>null</code>，或者<code>false</code>的時候，<code>ReactDOM.findDOMNode(this)</code> 會返回<code>null</code>。</p>\n<p>當它被調用的時候，它會檢查<code>this.props</code>和<code>this.state</code>，然後返回一個單獨的 React 元素。這個元素會是一個純正的<code>DOM</code>組件，例如&lt;div /&gt;，或者自定義的 composite 組件。</p>\n<h5 id=注意事項>注意事項</h5>\n<ol>\n<li><code>render()</code>方法應該是<code>pure</code>：它不會改寫任何組件的<code>state</code>。每一次調用它都會返回同樣的結果。它不會直接接觸到瀏覽器層面。</li>\n<li>如果你需要接觸到瀏覽器層面，你應該在<code>componentDidMount()</code>或者其他生命週期方法中接觸瀏覽器。</li>\n<li>保持<code>render()</code>方法 pure 來讓組件更加容易被人理解。</li>\n</ol>\n<h4 id=componentDidMount()>componentDidMount()</h4>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript">componentDidMount()\n</code></pre></code></pre>\n<p>它會在組件加載之後執行一次。如果你的初始程序需要DOM nodes，你應該在這裡寫。如果你需要從其他地方加載資料，這裡也是一個不錯的地方去執行網絡請求。如果在這裡定義了<code>setState</code>方法，會觸發重複渲染。</p>\n<h4 id=測試代碼>測試代碼</h4>\n<pre><code class="language-JavaScript"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  _log(method, args) {\n    <span class="hljs-built_in">console</span>.log(method, args);\n  }\n\n  <span class="hljs-keyword">constructor</span>(props) {\n    <span class="hljs-keyword">super</span>(props);\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'constructor\'</span>, props);\n  }\n\n  render() {\n    <span class="hljs-keyword">this</span>._log(<span class="hljs-string">\'render\'</span>, <span class="hljs-keyword">this</span>.props.name);\n    <span class="hljs-keyword">return</span> &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n\n  componentWillMount() {\n    <span class="hljs-keyword">this</span>._log(<span class="hljs-string">\'componentWillMount\'</span>);\n  }\n\n  componentDidMount() {\n    <span class="hljs-keyword">this</span>._log(<span class="hljs-string">\'componentDidMount\'</span>);\n  }\n}\n\nReactDOM.render(\n  &lt;Greeting name="Calpa" /&gt;,\n  document.getElementById(\'app\')\n);\n</code></pre></code></pre>\n<p>Console Output:</p>\n<pre><code><pre><code class="hljs javascript"><span class="hljs-string">"constructor"</span> <span class="hljs-built_in">Object</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Calpa"</span>\n}\n<span class="hljs-string">"componentWillMount"</span> <span class="hljs-literal">undefined</span>\n<span class="hljs-string">"render"</span> <span class="hljs-string">"Calpa"</span>\n<span class="hljs-string">"componentDidMount"</span> <span class="hljs-literal">undefined</span>\n</code></pre></code></pre>\n<p>你可以在<a href="https://codepen.io/calpa/full/xdJrQm/">CodePen</a>中獲取，並測試這段代碼。</p>\n<p>不知道拿哪一張當封面好。。。</p>\n',title:"React 組件生命週期 - 加載組件",createdDate:"2017-05-16T22:40+08:00",headerImgur:"IYhTVXU.png",id:"36jJTjyZwIYGmqucM2iu6S",toc:["組件","組件生命週期","加載(Mounting)","更新(Updating)","斷開連接(Unmounting)","其他內置方法","constructor()","注意事項","componentWillMount()","render()","注意事項","componentDidMount()","測試代碼"],tags:"React"},latestPosts:{totalCount:60,edges:[{node:{title:"【網易考拉校招】部門總監面對面-直播答疑邀約（附網易內推碼B222E54）",url:"netease-kaola-live",createdDate:"2018-08-01T20:00+08:00"}},{node:{title:"Uncaught ReferenceError: regeneratorRuntime is not defined 解決方法",url:"regenerator-runtime-is-not-defined",createdDate:"2018-07-29T20:00+08:00"}},{node:{title:"關於作者",url:"about-calpa-liu",createdDate:"2018-05-01T20:00+08:00"}},{node:{title:"【方法】在直接複製貼上內容的時候，可能已經不知不覺注入了一段不可視的「空白」",url:"insert-zero-width-characters",createdDate:"2018-04-06T23:00+08:00"}},{node:{title:"知乎無限 live 數據流網站",url:"zhihu-unlimited-lives-website",createdDate:"2018-03-28T20:49+08:00"}},{node:{title:"Gatsbyjs async/await 更新報錯解決方法",url:"gatsybjs-async-await-upgrade-bug-solution",createdDate:"2018-03-21T20:00+08:00"}}]}},pathContext:{id:"36jJTjyZwIYGmqucM2iu6S"}}}});
//# sourceMappingURL=path---2017-05-16-react-component-lifecycle-1a9e2cbab8306f6b3134.js.map